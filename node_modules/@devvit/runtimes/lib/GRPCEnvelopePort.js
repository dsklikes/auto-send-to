var _GRPCEnvelopePort_instances, _GRPCEnvelopePort_remoteUrl, _GRPCEnvelopePort_client, _GRPCEnvelopePort_providesByServiceName, _GRPCEnvelopePort_extraOutgoingMetadata, _GRPCEnvelopePort_postMessageAsync, _GRPCEnvelopePort_onMessage, _GRPCEnvelopePort_newMethodDescriptor;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { Envelope, } from '@devvit/protos';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import * as grpcWeb from 'grpc-web';
import { v4 as UUIDv4 } from 'uuid';
import { envelopeMethodToName, envelopeMethodToServiceName, } from '../common/envelope/EnvelopeUtil.js';
import { Header } from './Header.js';
import { Log } from './loggers/Log.js';
export class GRPCEnvelopePort {
    constructor(remoteUrl, definitions, extraOutgoingMetadata, client) {
        _GRPCEnvelopePort_instances.add(this);
        _GRPCEnvelopePort_remoteUrl.set(this, void 0);
        _GRPCEnvelopePort_client.set(this, void 0);
        _GRPCEnvelopePort_providesByServiceName.set(this, void 0);
        _GRPCEnvelopePort_extraOutgoingMetadata.set(this, void 0);
        this.onmessage = null;
        __classPrivateFieldSet(this, _GRPCEnvelopePort_remoteUrl, remoteUrl, "f");
        __classPrivateFieldSet(this, _GRPCEnvelopePort_client, client ?? new grpcWeb.GrpcWebClientBase({ format: 'binary', withCredentials: true }), "f");
        // TODO: see if there is a way we can look up this def by name in postMessage
        // NOTE: we won't always have the full list if/when we allow devs to provide their own
        //       service definitions
        __classPrivateFieldSet(this, _GRPCEnvelopePort_providesByServiceName, definitions.reduce((obj, def) => Object.assign(obj, { [def.fullName]: def }), {}), "f");
        __classPrivateFieldSet(this, _GRPCEnvelopePort_extraOutgoingMetadata, extraOutgoingMetadata, "f");
    }
    postMessage(envelope) {
        // Can't await and don't want to. We post to the GRPC "port" but there's no
        // addEventListener for it. Instead, the port later responds and that's the
        // port message event.
        __classPrivateFieldGet(this, _GRPCEnvelopePort_instances, "m", _GRPCEnvelopePort_postMessageAsync).call(this, envelope).catch((err) => Log.error(StringUtil.caughtToString(err)));
    }
    terminate() {
        this.onmessage = null;
    }
}
_GRPCEnvelopePort_remoteUrl = new WeakMap(), _GRPCEnvelopePort_client = new WeakMap(), _GRPCEnvelopePort_providesByServiceName = new WeakMap(), _GRPCEnvelopePort_extraOutgoingMetadata = new WeakMap(), _GRPCEnvelopePort_instances = new WeakSet(), _GRPCEnvelopePort_postMessageAsync = async function _GRPCEnvelopePort_postMessageAsync(envelope) {
    const metadata = metadataToObject(envelope.metadata);
    if (__classPrivateFieldGet(this, _GRPCEnvelopePort_extraOutgoingMetadata, "f")) {
        const extraMetadata = metadataToObject(__classPrivateFieldGet(this, _GRPCEnvelopePort_extraOutgoingMetadata, "f"));
        Object.assign(metadata, extraMetadata);
    }
    const descriptor = __classPrivateFieldGet(this, _GRPCEnvelopePort_instances, "m", _GRPCEnvelopePort_newMethodDescriptor).call(this, envelope);
    // Every request must have a response.
    const message = await __classPrivateFieldGet(this, _GRPCEnvelopePort_client, "f").thenableCall(`${__classPrivateFieldGet(this, _GRPCEnvelopePort_remoteUrl, "f")}${envelope.method}`, envelope.message, metadata, descriptor);
    __classPrivateFieldGet(this, _GRPCEnvelopePort_instances, "m", _GRPCEnvelopePort_onMessage).call(this, envelope, message);
}, _GRPCEnvelopePort_onMessage = function _GRPCEnvelopePort_onMessage(envelope, message) {
    const response = Envelope.fromPartial({
        id: UUIDv4(),
        method: envelope.method,
        request: false,
        message,
        metadata: envelope.metadata,
        src: envelope.dst,
        dst: envelope.src,
        streamId: envelope.streamId,
        traceId: envelope.traceId,
        complete: true,
        success: true, // to-do: allow failure.
    });
    this.onmessage?.(new MessageEvent('message', { data: response }));
}, _GRPCEnvelopePort_newMethodDescriptor = function _GRPCEnvelopePort_newMethodDescriptor(envelope) {
    const serviceName = envelopeMethodToServiceName(envelope);
    const methodName = envelopeMethodToName(envelope);
    const method = __classPrivateFieldGet(this, _GRPCEnvelopePort_providesByServiceName, "f")[serviceName].methods[methodName];
    if (method == null)
        throw Error(`Unknown method: ${methodName}.`);
    if (method.requestType == null || method.responseType == null) {
        throw new Error('Envelope must contain a valid `requestType` and `responseType`.');
    }
    // Best guess: https://github.com/grpc/grpc-web/blob/f1fe57473f15aa995bdf7935ebe714ed8c3bf05b/javascript/net/grpc/web/grpcwebclientbase_test.js#L204
    class Request {
        constructor(message) {
            Object.assign(this, method.requestType.fromPartial(message));
        }
    }
    class Response {
        constructor(message) {
            Object.assign(this, method.responseType.fromPartial(message));
        }
    }
    return new grpcWeb.MethodDescriptor(envelope.method, method.requestStream ? grpcWeb.MethodType.SERVER_STREAMING : grpcWeb.MethodType.UNARY, Request, Response, (request) => method.requestType.encode(request).finish(), method.responseType.decode.bind(method.responseType));
};
function metadataToObject(metadata) {
    // These are the only dev platform headers allowed by CORS:
    const allowedKeys = [
        Header.Installation,
        Header.Version,
        Header.App,
        Header.Actor,
        Header.Canary,
    ];
    return Object.entries(metadata)
        .filter(([key]) => allowedKeys.includes(key))
        .reduce((out, [key, { values }]) => ({ ...out, [key]: values.join(',') }), {});
}
