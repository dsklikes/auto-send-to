var _HTTP_fetch, _HTTP_namespace;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { FetchResponse } from '@devvit/protos';
import { getFromMetadata } from '../../common/envelope/EnvelopeUtil.js';
import { Header } from '../../lib/Header.js';
import { Hostname } from '../../lib/HostnameUtil.js';
// @ts-expect-error
import httpConfig from './http_config.json' assert { type: 'json' };
export class HTTP {
    constructor(aFetchImpl, namespace) {
        _HTTP_fetch.set(this, void 0);
        _HTTP_namespace.set(this, void 0);
        this.assertEnvironment();
        __classPrivateFieldSet(this, _HTTP_fetch, aFetchImpl, "f");
        __classPrivateFieldSet(this, _HTTP_namespace, namespace, "f");
    }
    async Fetch(request, metadata) {
        const data = { ...request.data };
        if (['get', 'head'].includes(data.method?.toLowerCase())) {
            delete data.body;
        }
        // Allowed HTTP domains and method validation for User Actors
        const allowedHTTPDomains = httpConfig['allowed_domains'];
        const allowedHTTPMethods = ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'];
        const domain = new URL(request.url).hostname;
        const caller = getFromMetadata(Header.Caller, metadata);
        if (!caller) {
            throw Error('Caller header not found in Metadata during HTTP Fetch');
        }
        if (!Hostname.isSystem(caller, __classPrivateFieldGet(this, _HTTP_namespace, "f"))) {
            if (!allowedHTTPDomains.includes(domain)) {
                throw Error(`HTTP Fetch request to ${domain} is not allowed`);
            }
            if (!allowedHTTPMethods.includes(data.method?.toUpperCase())) {
                throw Error(`HTTP Fetch request with method:${data.method} is not allowed`);
            }
        }
        const response = await __classPrivateFieldGet(this, _HTTP_fetch, "f").call(globalThis, request.url, data);
        return FetchResponse.fromPartial({
            url: response.url,
            body: new Uint8Array(await response.arrayBuffer()),
            status: response.status,
            headers: Object.fromEntries(response.headers.entries()),
        });
    }
}
_HTTP_fetch = new WeakMap(), _HTTP_namespace = new WeakMap();
