var _RedditAPI_instances, _RedditAPI_httpClient, _RedditAPI_mapArgsToUrl, _RedditAPI_getBaseUrl, _RedditAPI_getHeaders, _RedditAPI_getBodyParams, _RedditAPI_getFetchRequest;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { FetchRequest } from '@devvit/protos';
import { Header } from '../../lib/Header.js';
import { RedditAPIMappings } from './apiMappings.js';
import { getFromMetadata } from '../../common/envelope/EnvelopeUtil.js';
import { isObject } from '@devvit/shared-types/isObject.js';
import { findAndThrowRedditAPIError } from './errors.js';
import { deepSnakeToCamel } from './snakeToCamel.js';
const camelToSnake = (str) => str.replace(/[A-Z]|(?<=[a-zA-Z])[\d]/g, (l) => `_${l.toLocaleLowerCase()}`);
export class RedditAPI {
    constructor(httpClient) {
        _RedditAPI_instances.add(this);
        _RedditAPI_httpClient.set(this, void 0);
        __classPrivateFieldSet(this, _RedditAPI_httpClient, httpClient, "f");
    }
    _decodeAndValidateResponseJSON(response, ignoreKeys = []) {
        if (response.status == 204) {
            // some endpoints return a 204 No Content for a non-op, but valid request,
            // so return an empty object to avoid a JSON parse error
            return {};
        }
        const body = JSON.parse(new TextDecoder().decode(response.body));
        // Throws on known error patterns.
        findAndThrowRedditAPIError(response.status, body);
        return deepSnakeToCamel(body, ignoreKeys);
    }
    _fetch(methodName, obj, metadata) {
        return __classPrivateFieldGet(this, _RedditAPI_httpClient, "f").Fetch(__classPrivateFieldGet(this, _RedditAPI_instances, "m", _RedditAPI_getFetchRequest).call(this, methodName, obj, metadata), metadata);
    }
}
_RedditAPI_httpClient = new WeakMap(), _RedditAPI_instances = new WeakSet(), _RedditAPI_mapArgsToUrl = function _RedditAPI_mapArgsToUrl(url, obj) {
    return `${Object.entries(obj).reduce((p, c) => {
        const pattern = RegExp(`{([^}]+)?${c[0]}([^{]+)?}`);
        const value = (c[1] ?? null) !== null ? `$1${c[1]}$2` : '';
        return p.replace(pattern, value);
    }, url)}${url.indexOf('?') > 0 ? '&' : '?'}raw_json=1`;
}, _RedditAPI_getBaseUrl = function _RedditAPI_getBaseUrl(metadata) {
    const r2Host = getFromMetadata(Header.R2Host, metadata);
    if (r2Host) {
        return `https://${r2Host}`;
    }
    throw new Error('unable to locate base url for reddit api');
}, _RedditAPI_getHeaders = function _RedditAPI_getHeaders(mapping, metadata) {
    const authToken = getFromMetadata(Header.R2Auth, metadata);
    if (!authToken) {
        throw new Error('Must include auth header when calling the reddit api');
    }
    const headers = {};
    if (authToken) {
        headers['Authorization'] = `Bearer ${authToken}`;
    }
    switch (mapping.body) {
        case '*':
        case '*.snake':
            headers['Content-Type'] = 'application/json';
            break;
        case '*form':
        case '*form.snake':
            headers['Content-Type'] = 'application/x-www-form-urlencoded';
    }
    return headers;
}, _RedditAPI_getBodyParams = function _RedditAPI_getBodyParams(mapping, obj) {
    const { body: bodyType, enforceJson } = mapping;
    let body = '';
    const bodyObj = enforceJson ? enforceJsonOnBody(obj) : obj;
    switch (bodyType) {
        case '*': {
            body = JSON.stringify(bodyObj);
            break;
        }
        case '*.snake': {
            const tempBody = {};
            for (const key in bodyObj) {
                if (bodyObj[key] !== undefined) {
                    tempBody[camelToSnake(key)] = bodyObj[key];
                }
            }
            body = JSON.stringify(tempBody);
            break;
        }
        case '*form': {
            body = bodyToFormData(bodyObj);
            break;
        }
        case '*form.snake': {
            const tempBody = {};
            for (const key in bodyObj) {
                if (bodyObj[key] !== undefined) {
                    tempBody[camelToSnake(key)] = bodyObj[key];
                }
            }
            body = bodyToFormData(tempBody);
            break;
        }
    }
    return new TextEncoder().encode(body);
}, _RedditAPI_getFetchRequest = function _RedditAPI_getFetchRequest(methodName, obj, metadata) {
    const mapping = RedditAPIMappings[methodName];
    const url = __classPrivateFieldGet(this, _RedditAPI_instances, "m", _RedditAPI_mapArgsToUrl).call(this, `${__classPrivateFieldGet(this, _RedditAPI_instances, "m", _RedditAPI_getBaseUrl).call(this, metadata)}${mapping.path}`, obj);
    return FetchRequest.fromPartial({
        url,
        data: {
            body: __classPrivateFieldGet(this, _RedditAPI_instances, "m", _RedditAPI_getBodyParams).call(this, mapping, obj),
            headers: __classPrivateFieldGet(this, _RedditAPI_instances, "m", _RedditAPI_getHeaders).call(this, mapping, metadata),
            method: mapping.method,
        },
    });
};
// URLSearchParams isn't available in v8go,
// so this creates the formdata body
function bodyToFormData(obj) {
    // TODO: escape '&' and '=' in keys/values
    return Object.entries(obj)
        .map(([k, v]) => {
        return isObject(v)
            ? `${k}=${encodeURIComponent(JSON.stringify(v))}`
            : `${k}=${encodeURIComponent(v)}`;
    })
        .join('&');
}
// Adds the api_type=json property to a body object
function enforceJsonOnBody(obj) {
    return {
        ...obj,
        api_type: 'json',
    };
}
