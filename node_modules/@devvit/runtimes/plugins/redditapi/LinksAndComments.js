import { RedditAPI } from './RedditAPI.js';
import { Empty, JsonStatus, JsonWrappedComment, Listing, SubmitResponse, LinkedBundle, Definition, CustomPostDefinition, } from '@devvit/protos';
import { isCommentId } from '@devvit/shared-types/tid.js';
import { findAndThrowRedditAPIError } from './errors.js';
import { deepSnakeToCamel } from './snakeToCamel.js';
import { getFromMetadata } from '../../common/envelope/EnvelopeUtil.js';
import { Header } from '../../lib/Header.js';
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { fromByteArray } from 'base64-js';
const customPostTemplate = (encodedBundle, encodedCached) => `# DX_Bundle:

    ${encodedBundle}

# DX_Config:

    EhYKB3ZlcnNpb24SCwgCGQAAAAAAAPA/

# DX_Cached:

    ${encodedCached}

`;
export class LinksAndComments extends RedditAPI {
    async Comment(request, metadata) {
        const response = await this._fetch('Comment', request, metadata);
        let body = JSON.parse(new TextDecoder().decode(response.body));
        findAndThrowRedditAPIError(response.status, body);
        // When richtextJson is provided the response comes back unwrapped.
        if (!body.json && request.richtextJson && isCommentId(body.name)) {
            body = {
                json: {
                    errors: [],
                    data: {
                        things: [
                            {
                                kind: 't1',
                                data: body,
                            },
                        ],
                    },
                },
            };
        }
        return JsonWrappedComment.fromJSON(deepSnakeToCamel(body));
    }
    async Del(request, metadata) {
        await this._fetch('Del', request, metadata);
        return Empty.fromPartial({});
    }
    async EditUserText(request, metadata) {
        const response = await this._fetch('EditUserText', request, metadata);
        return JsonWrappedComment.fromJSON(this._decodeAndValidateResponseJSON(response));
    }
    async FollowPost(request, metadata) {
        await this._fetch('FollowPost', request, metadata);
        return Empty.fromPartial({});
    }
    async Hide(request, metadata) {
        await this._fetch('Hide', request, metadata);
        return Empty.fromPartial({});
    }
    async Info(request, metadata) {
        const response = await this._fetch('Info', request, metadata);
        return Listing.fromJSON(this._decodeAndValidateResponseJSON(response));
    }
    async Lock(request, metadata) {
        await this._fetch('Lock', request, metadata);
        return Empty.fromPartial({});
    }
    async MarkNSFW(request, metadata) {
        await this._fetch('MarkNSFW', request, metadata);
        return Empty.fromPartial({});
    }
    async MoreChildren(request, metadata) {
        const response = await this._fetch('MoreChildren', request, metadata);
        return JsonWrappedComment.fromJSON(this._decodeAndValidateResponseJSON(response));
    }
    async Report(request, metadata) {
        const response = await this._fetch('Report', request, metadata);
        return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
    }
    async ReportAward(request, metadata) {
        await this._fetch('ReportAward', request, metadata);
        return Empty.fromPartial({});
    }
    async Save(request, metadata) {
        await this._fetch('Save', request, metadata);
        return Empty.fromPartial({});
    }
    async SendReplies(request, metadata) {
        await this._fetch('SendReplies', request, metadata);
        return Empty.fromPartial({});
    }
    async SetContestMode(request, metadata) {
        const response = await this._fetch('SetContestMode', request, metadata);
        return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
    }
    async SetSubredditSticky(request, metadata) {
        const response = await this._fetch('SetSubredditSticky', request, metadata);
        return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
    }
    async SetSuggestedSort(request, metadata) {
        const response = await this._fetch('SetSuggestedSort', request, metadata);
        return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
    }
    async Spoiler(request, metadata) {
        await this._fetch('Spoiler', request, metadata);
        return Empty.fromPartial({});
    }
    async Submit(request, metadata) {
        if (request.kind === 'custom') {
            return this.SubmitCustomPost(request, metadata);
        }
        const response = await this._fetch('Submit', request, metadata);
        return SubmitResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
    }
    async SubmitCustomPost(request, metadata) {
        const hostname = getFromMetadata(Header.RemoteHostname, metadata);
        assertNonNull(hostname, 'Remote hostname is missing');
        const bundle = LinkedBundle.fromPartial({
            hostname,
            provides: [Definition.toSerializable(CustomPostDefinition)],
        });
        assertNonNull(request.text, 'Custom post blocks is missing');
        const encodedBundle = fromByteArray(LinkedBundle.encode(bundle).finish());
        const encodedCached = request.text;
        request.text = customPostTemplate(encodedBundle, encodedCached);
        request.kind = 'self';
        const response = await this._fetch('Submit', request, metadata);
        return SubmitResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
    }
    async Unhide(request, metadata) {
        await this._fetch('Unhide', request, metadata);
        return Empty.fromPartial({});
    }
    async Unlock(request, metadata) {
        await this._fetch('Unlock', request, metadata);
        return Empty.fromPartial({});
    }
    async UnmarkNSFW(request, metadata) {
        await this._fetch('UnmarkNSFW', request, metadata);
        return Empty.fromPartial({});
    }
    async Unsave(request, metadata) {
        await this._fetch('Unsave', request, metadata);
        return Empty.fromPartial({});
    }
    async Unspoiler(request, metadata) {
        await this._fetch('Unspoiler', request, metadata);
        return Empty.fromPartial({});
    }
    async Vote(request, metadata) {
        await this._fetch('Vote', request, metadata);
        return Empty.fromPartial({});
    }
}
