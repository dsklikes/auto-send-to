"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray2;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer2[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset + i - d] |= s * 128;
    };
  }
});

// ../../node_modules/buffer/index.js
var require_buffer = __commonJS({
  "../../node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike2(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike2(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike2(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike2(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// ../../node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// ../../node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "../../node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer2, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// ../../node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// ../../node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../../node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// ../../node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// ../../node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../../node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer2[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer2[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// ../../node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// ../../node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject27(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet112(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// ../../node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../../node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// ../../node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// ../../node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../../node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// ../../node_modules/long/src/long.js
var require_long = __commonJS({
  "../../node_modules/long/src/long.js"(exports2, module2) {
    module2.exports = Long12;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long12(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long12.prototype.__isLong__;
    Object.defineProperty(Long12.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long12.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long12.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long12.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long12(lowBits, highBits, unsigned);
    }
    Long12.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long12.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long12.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long12.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long12.UZERO = UZERO;
    var ONE = fromInt(1);
    Long12.ONE = ONE;
    var UONE = fromInt(1, true);
    Long12.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long12.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long12.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long12.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long12.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long12.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long12.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long12.fromBytesLE(bytes, unsigned) : Long12.fromBytesBE(bytes, unsigned);
    };
    Long12.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long12(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long12.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long12(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
  }
});

// ../../node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/lru-cache/index.js"(exports2, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort() {
        this.signal.dispatchEvent("abort");
      }
    };
    var AS = hasAbortController ? AbortSignal : class AbortSignal {
      constructor() {
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(type) {
        if (type === "abort") {
          this.aborted = true;
          const e = { type, target: this };
          this.onabort(e);
          this._listeners.forEach((f) => f(e), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code)) {
        warn(code, `${opt} option`, `options.${instead}`, LRUCache);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code, `${method} method`, `cache.${instead}()`, get);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code, `${field} property`, `cache.${instead}`, get);
      }
    };
    var emitWarning = (...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    };
    var shouldWarn = (code) => !warned.has(code);
    var warn = (code, what, instead, fn) => {
      warned.add(code);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class {
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          sizeCalculation,
          fetchMethod,
          noDeleteOnFetchRejection
        } = options;
        const { length, maxAge, stale } = options instanceof LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
          if (!this.maxSize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        if (this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) {
            throw new TypeError(
              "maxSize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl) => {
          this.starts[index] = ttl !== 0 ? perf.now() : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(index) {
      }
      setItemTTL(index, ttl) {
      }
      isStale(index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => this.calculatedSize -= this.sizes[index];
        this.requireSize = (k, v, size, sizeCalculation) => {
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer)"
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, v, k, size) => {
          this.sizes[index] = size;
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict(true);
          }
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(index) {
      }
      addItemSize(index, v, k, size) {
      }
      requireSize(k, v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.tail; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.head) {
              break;
            } else {
              i = this.prev[i];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.head; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.tail) {
              break;
            } else {
              i = this.next[i];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i of this.indexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *rentries() {
        for (const i of this.rindexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *keys() {
        for (const i of this.indexes()) {
          yield this.keyList[i];
        }
      }
      *rkeys() {
        for (const i of this.rindexes()) {
          yield this.keyList[i];
        }
      }
      *values() {
        for (const i of this.indexes()) {
          yield this.valList[i];
        }
      }
      *rvalues() {
        for (const i of this.rindexes()) {
          yield this.valList[i];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i of this.indexes()) {
          if (fn(this.valList[i], this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of this.indexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of this.rindexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({ allowStale: true })) {
          if (this.isStale(i)) {
            this.delete(this.keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of this.indexes()) {
          const key = this.keyList[i];
          const value = this.valList[i];
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
          }
          if (this.sizes) {
            entry.size = this.sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          this.set(key, entry.value, entry);
        }
      }
      dispose(v, k, reason) {
      }
      set(k, v, {
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, v, k, size);
          noUpdateTTL = false;
        } else {
          const oldVal = this.valList[index];
          if (v !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort();
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v;
            this.addItemSize(index, v, k, size);
          }
          this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort();
        } else {
          this.dispose(v, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            return true;
          }
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          return this.valList[index];
        }
      }
      backgroundFetch(k, index, options) {
        const v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const fetchOpts = {
          signal: ac.signal,
          options
        };
        const cb = (v2) => {
          if (!ac.signal.aborted) {
            this.set(k, v2, fetchOpts.options);
          }
          return v2;
        };
        const eb = (er) => {
          if (this.valList[index] === p) {
            const del = !options.noDeleteOnFetchRejection || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (p.__returned === p) {
            throw er;
          }
        };
        const pcall = (res) => res(this.fetchMethod(k, v, fetchOpts));
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, fetchOpts.options);
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection
      } = {}) {
        if (!this.fetchMethod) {
          return this.get(k, { allowStale, updateAgeOnGet });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          const p = this.backgroundFetch(k, index, options);
          return p.__returned = p;
        } else {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            return allowStale && v.__staleWhileFetching !== void 0 ? v.__staleWhileFetching : v.__returned = v;
          }
          if (!this.isStale(index)) {
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return v;
          }
          const p = this.backgroundFetch(k, index, options);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              this.delete(k);
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v = this.valList[index];
              if (this.isBackgroundFetch(v)) {
                v.__abortController.abort();
              } else {
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort();
          } else {
            const k = this.keyList[index];
            this.dispose(v, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module2.exports = LRUCache;
  }
});

// src/lib/getRandomValues.polyfill.ts
if (globalThis.crypto?.getRandomValues == null) {
  let getRandomValues2;
  if (typeof require === "function") {
    const nodeCrypto = require("crypto");
    getRandomValues2 = (array) => {
      if (!isTypedArray(array) || array instanceof BigInt64Array || array instanceof BigUint64Array)
        throw Error("Expected number TypedArray.");
      array.set(nodeCrypto.pseudoRandomBytes(array.length));
      return array;
    };
  } else {
    getRandomValues2 = (array) => {
      if (!isTypedArray(array) || array instanceof BigInt64Array || array instanceof BigUint64Array)
        throw Error("Expected number TypedArray.");
      array.set(array.map(() => Math.floor(Math.random() * 256)));
      return array;
    };
  }
  if (globalThis.crypto == null) {
    globalThis.crypto = {};
  }
  globalThis.crypto.getRandomValues = getRandomValues2;
}
function isTypedArray(val) {
  return ArrayBuffer.isView(val) && !(val instanceof DataView);
}

// src/lib/Buffer.polyfill.ts
var import_buffer = __toESM(require_buffer(), 1);
globalThis.Buffer ?? (globalThis.Buffer = import_buffer.Buffer);

// ../protos/dist/types/devvit/actor/automation/v1alpha/automation_builder.js
var import_minimal13 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/google/protobuf/empty.js
var import_minimal = __toESM(require_minimal2(), 1);

// ../protos/dist/types/typeRegistry.js
var messageTypeRegistry = /* @__PURE__ */ new Map();

// ../protos/dist/types/google/protobuf/empty.js
function createBaseEmpty() {
  return {};
}
var Empty = {
  $type: "google.protobuf.Empty",
  encode(_, writer = import_minimal.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal.default.Reader ? input : new import_minimal.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseEmpty();
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.Empty", Empty);

// ../protos/dist/types/devvit/actor/user_configurable/user_configurable.js
var import_minimal2 = __toESM(require_minimal2(), 1);
var ConfigFieldType;
(function(ConfigFieldType2) {
  ConfigFieldType2[ConfigFieldType2["STRING"] = 0] = "STRING";
  ConfigFieldType2[ConfigFieldType2["PARAGRAPH"] = 1] = "PARAGRAPH";
  ConfigFieldType2[ConfigFieldType2["NUMBER"] = 2] = "NUMBER";
  ConfigFieldType2[ConfigFieldType2["BOOLEAN"] = 3] = "BOOLEAN";
  ConfigFieldType2[ConfigFieldType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigFieldType || (ConfigFieldType = {}));
function configFieldTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "STRING":
      return ConfigFieldType.STRING;
    case 1:
    case "PARAGRAPH":
      return ConfigFieldType.PARAGRAPH;
    case 2:
    case "NUMBER":
      return ConfigFieldType.NUMBER;
    case 3:
    case "BOOLEAN":
      return ConfigFieldType.BOOLEAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConfigFieldType.UNRECOGNIZED;
  }
}
function configFieldTypeToJSON(object) {
  switch (object) {
    case ConfigFieldType.STRING:
      return 0;
    case ConfigFieldType.PARAGRAPH:
      return 1;
    case ConfigFieldType.NUMBER:
      return 2;
    case ConfigFieldType.BOOLEAN:
      return 3;
    case ConfigFieldType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseConfigForm() {
  return { fields: [] };
}
var ConfigForm = {
  $type: "devvit.actor.user_configurable.ConfigForm",
  encode(message, writer = import_minimal2.default.Writer.create()) {
    for (const v of message.fields) {
      ConfigField.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigForm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fields.push(ConfigField.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { fields: Array.isArray(object?.fields) ? object.fields.map((e) => ConfigField.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.fields) {
      obj.fields = message.fields.map((e) => e ? ConfigField.toJSON(e) : void 0);
    } else {
      obj.fields = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConfigForm();
    message.fields = object.fields?.map((e) => ConfigField.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.user_configurable.ConfigForm", ConfigForm);
function createBaseConfigField() {
  return { fieldType: 0, key: "", prompt: "", response: "" };
}
var ConfigField = {
  $type: "devvit.actor.user_configurable.ConfigField",
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.fieldType !== 0) {
      writer.uint32(8).int32(message.fieldType);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.prompt !== "") {
      writer.uint32(26).string(message.prompt);
    }
    if (message.response !== "") {
      writer.uint32(34).string(message.response);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fieldType = reader.int32();
          break;
        case 2:
          message.key = reader.string();
          break;
        case 3:
          message.prompt = reader.string();
          break;
        case 4:
          message.response = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fieldType: isSet(object.fieldType) ? configFieldTypeFromJSON(object.fieldType) : 0,
      key: isSet(object.key) ? String(object.key) : "",
      prompt: isSet(object.prompt) ? String(object.prompt) : "",
      response: isSet(object.response) ? String(object.response) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.fieldType !== void 0 && (obj.fieldType = configFieldTypeToJSON(message.fieldType));
    message.key !== void 0 && (obj.key = message.key);
    message.prompt !== void 0 && (obj.prompt = message.prompt);
    message.response !== void 0 && (obj.response = message.response);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConfigField();
    message.fieldType = object.fieldType ?? 0;
    message.key = object.key ?? "";
    message.prompt = object.prompt ?? "";
    message.response = object.response ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.user_configurable.ConfigField", ConfigField);
function createBaseFormResponse() {
  return { success: false, messages: [] };
}
var FormResponse = {
  $type: "devvit.actor.user_configurable.FormResponse",
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.messages) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.success = reader.bool();
          break;
        case 2:
          message.messages.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet(object.success) ? Boolean(object.success) : false,
      messages: Array.isArray(object?.messages) ? object.messages.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.success !== void 0 && (obj.success = message.success);
    if (message.messages) {
      obj.messages = message.messages.map((e) => e);
    } else {
      obj.messages = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFormResponse();
    message.success = object.success ?? false;
    message.messages = object.messages?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.user_configurable.FormResponse", FormResponse);
function isSet(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/automation/v1alpha/automation.js
var import_minimal12 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/reddit/comment.js
var import_minimal6 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/google/protobuf/struct.js
var import_minimal3 = __toESM(require_minimal2(), 1);
var NullValue;
(function(NullValue2) {
  NullValue2[NullValue2["NULL_VALUE"] = 0] = "NULL_VALUE";
  NullValue2[NullValue2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(NullValue || (NullValue = {}));
function nullValueFromJSON(object) {
  switch (object) {
    case 0:
    case "NULL_VALUE":
      return NullValue.NULL_VALUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NullValue.UNRECOGNIZED;
  }
}
function nullValueToJSON(object) {
  switch (object) {
    case NullValue.NULL_VALUE:
      return 0;
    case NullValue.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseStruct() {
  return { fields: {} };
}
var Struct = {
  $type: "google.protobuf.Struct",
  encode(message, writer = import_minimal3.default.Writer.create()) {
    Object.entries(message.fields).forEach(([key, value]) => {
      if (value !== void 0) {
        Struct_FieldsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
      }
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : new import_minimal3.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = Struct_FieldsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.fields[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fields: isObject(object.fields) ? Object.entries(object.fields).reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    obj.fields = {};
    if (message.fields) {
      Object.entries(message.fields).forEach(([k, v]) => {
        obj.fields[k] = v;
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStruct();
    message.fields = Object.entries(object.fields ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, {});
    return message;
  },
  wrap(object) {
    const struct = createBaseStruct();
    if (object !== void 0) {
      Object.keys(object).forEach((key) => {
        struct.fields[key] = object[key];
      });
    }
    return struct;
  },
  unwrap(message) {
    const object = {};
    Object.keys(message.fields).forEach((key) => {
      object[key] = message.fields[key];
    });
    return object;
  }
};
messageTypeRegistry.set("google.protobuf.Struct", Struct);
function createBaseStruct_FieldsEntry() {
  return { key: "", value: void 0 };
}
var Struct_FieldsEntry = {
  $type: "google.protobuf.Struct.FieldsEntry",
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : new import_minimal3.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStruct_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet2(object.key) ? String(object.key) : "", value: isSet2(object?.value) ? object.value : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStruct_FieldsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.Struct.FieldsEntry", Struct_FieldsEntry);
function createBaseValue() {
  return {
    nullValue: void 0,
    numberValue: void 0,
    stringValue: void 0,
    boolValue: void 0,
    structValue: void 0,
    listValue: void 0
  };
}
var Value = {
  $type: "google.protobuf.Value",
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.nullValue !== void 0) {
      writer.uint32(8).int32(message.nullValue);
    }
    if (message.numberValue !== void 0) {
      writer.uint32(17).double(message.numberValue);
    }
    if (message.stringValue !== void 0) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.structValue !== void 0) {
      Struct.encode(Struct.wrap(message.structValue), writer.uint32(42).fork()).ldelim();
    }
    if (message.listValue !== void 0) {
      ListValue.encode(ListValue.wrap(message.listValue), writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : new import_minimal3.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nullValue = reader.int32();
          break;
        case 2:
          message.numberValue = reader.double();
          break;
        case 3:
          message.stringValue = reader.string();
          break;
        case 4:
          message.boolValue = reader.bool();
          break;
        case 5:
          message.structValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        case 6:
          message.listValue = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      nullValue: isSet2(object.nullValue) ? nullValueFromJSON(object.nullValue) : void 0,
      numberValue: isSet2(object.numberValue) ? Number(object.numberValue) : void 0,
      stringValue: isSet2(object.stringValue) ? String(object.stringValue) : void 0,
      boolValue: isSet2(object.boolValue) ? Boolean(object.boolValue) : void 0,
      structValue: isObject(object.structValue) ? object.structValue : void 0,
      listValue: Array.isArray(object.listValue) ? [...object.listValue] : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.nullValue !== void 0 && (obj.nullValue = message.nullValue !== void 0 ? nullValueToJSON(message.nullValue) : void 0);
    message.numberValue !== void 0 && (obj.numberValue = message.numberValue);
    message.stringValue !== void 0 && (obj.stringValue = message.stringValue);
    message.boolValue !== void 0 && (obj.boolValue = message.boolValue);
    message.structValue !== void 0 && (obj.structValue = message.structValue);
    message.listValue !== void 0 && (obj.listValue = message.listValue);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseValue();
    message.nullValue = object.nullValue ?? void 0;
    message.numberValue = object.numberValue ?? void 0;
    message.stringValue = object.stringValue ?? void 0;
    message.boolValue = object.boolValue ?? void 0;
    message.structValue = object.structValue ?? void 0;
    message.listValue = object.listValue ?? void 0;
    return message;
  },
  wrap(value) {
    const result = createBaseValue();
    if (value === null) {
      result.nullValue = NullValue.NULL_VALUE;
    } else if (typeof value === "boolean") {
      result.boolValue = value;
    } else if (typeof value === "number") {
      result.numberValue = value;
    } else if (typeof value === "string") {
      result.stringValue = value;
    } else if (Array.isArray(value)) {
      result.listValue = value;
    } else if (typeof value === "object") {
      result.structValue = value;
    } else if (typeof value !== "undefined") {
      throw new Error("Unsupported any value type: " + typeof value);
    }
    return result;
  },
  unwrap(message) {
    if (message?.stringValue !== void 0) {
      return message.stringValue;
    } else if (message?.numberValue !== void 0) {
      return message.numberValue;
    } else if (message?.boolValue !== void 0) {
      return message.boolValue;
    } else if (message?.structValue !== void 0) {
      return message.structValue;
    } else if (message?.listValue !== void 0) {
      return message.listValue;
    } else if (message?.nullValue !== void 0) {
      return null;
    }
    return void 0;
  }
};
messageTypeRegistry.set("google.protobuf.Value", Value);
function createBaseListValue() {
  return { values: [] };
}
var ListValue = {
  $type: "google.protobuf.ListValue",
  encode(message, writer = import_minimal3.default.Writer.create()) {
    for (const v of message.values) {
      Value.encode(Value.wrap(v), writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : new import_minimal3.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.values.push(Value.unwrap(Value.decode(reader, reader.uint32())));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { values: Array.isArray(object?.values) ? [...object.values] : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.values) {
      obj.values = message.values.map((e) => e);
    } else {
      obj.values = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseListValue();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
  wrap(value) {
    const result = createBaseListValue();
    result.values = value ?? [];
    return result;
  },
  unwrap(message) {
    return message.values;
  }
};
messageTypeRegistry.set("google.protobuf.ListValue", ListValue);
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function isSet2(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/google/protobuf/wrappers.js
var import_long = __toESM(require_long(), 1);
var import_minimal4 = __toESM(require_minimal2(), 1);
function createBaseDoubleValue() {
  return { value: 0 };
}
var DoubleValue = {
  $type: "google.protobuf.DoubleValue",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDoubleValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet3(object.value) ? Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDoubleValue();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.DoubleValue", DoubleValue);
function createBaseFloatValue() {
  return { value: 0 };
}
var FloatValue = {
  $type: "google.protobuf.FloatValue",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(13).float(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFloatValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet3(object.value) ? Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFloatValue();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.FloatValue", FloatValue);
function createBaseInt64Value() {
  return { value: 0 };
}
var Int64Value = {
  $type: "google.protobuf.Int64Value",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(8).int64(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInt64Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = longToNumber(reader.int64());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet3(object.value) ? Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.value !== void 0 && (obj.value = Math.round(message.value));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInt64Value();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.Int64Value", Int64Value);
function createBaseUInt64Value() {
  return { value: 0 };
}
var UInt64Value = {
  $type: "google.protobuf.UInt64Value",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUInt64Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = longToNumber(reader.uint64());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet3(object.value) ? Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.value !== void 0 && (obj.value = Math.round(message.value));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUInt64Value();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.UInt64Value", UInt64Value);
function createBaseInt32Value() {
  return { value: 0 };
}
var Int32Value = {
  $type: "google.protobuf.Int32Value",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInt32Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet3(object.value) ? Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.value !== void 0 && (obj.value = Math.round(message.value));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInt32Value();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.Int32Value", Int32Value);
function createBaseUInt32Value() {
  return { value: 0 };
}
var UInt32Value = {
  $type: "google.protobuf.UInt32Value",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUInt32Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet3(object.value) ? Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.value !== void 0 && (obj.value = Math.round(message.value));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUInt32Value();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.UInt32Value", UInt32Value);
function createBaseBoolValue() {
  return { value: false };
}
var BoolValue = {
  $type: "google.protobuf.BoolValue",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value === true) {
      writer.uint32(8).bool(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBoolValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet3(object.value) ? Boolean(object.value) : false };
  },
  toJSON(message) {
    const obj = {};
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBoolValue();
    message.value = object.value ?? false;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.BoolValue", BoolValue);
function createBaseStringValue() {
  return { value: "" };
}
var StringValue = {
  $type: "google.protobuf.StringValue",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStringValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet3(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStringValue();
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.StringValue", StringValue);
function createBaseBytesValue() {
  return { value: new Uint8Array() };
}
var BytesValue = {
  $type: "google.protobuf.BytesValue",
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBytesValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet3(object.value) ? bytesFromBase64(object.value) : new Uint8Array() };
  },
  toJSON(message) {
    const obj = {};
    message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBytesValue();
    message.value = object.value ?? new Uint8Array();
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.BytesValue", BytesValue);
var globalThis2 = (() => {
  if (typeof globalThis2 !== "undefined") {
    return globalThis2;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
  if (globalThis2.Buffer) {
    return Uint8Array.from(globalThis2.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis2.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes(arr) {
  if (globalThis2.Buffer) {
    return globalThis2.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return globalThis2.btoa(bin.join(""));
  }
}
function longToNumber(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal4.default.util.Long !== import_long.default) {
  import_minimal4.default.util.Long = import_long.default;
  import_minimal4.default.configure();
}
function isSet3(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/common.js
var import_minimal5 = __toESM(require_minimal2(), 1);
var BanInfo_BanInfoAction;
(function(BanInfo_BanInfoAction2) {
  BanInfo_BanInfoAction2[BanInfo_BanInfoAction2["UNKNOWN"] = 0] = "UNKNOWN";
  BanInfo_BanInfoAction2[BanInfo_BanInfoAction2["SPAM"] = 1] = "SPAM";
  BanInfo_BanInfoAction2[BanInfo_BanInfoAction2["FILTER"] = 2] = "FILTER";
  BanInfo_BanInfoAction2[BanInfo_BanInfoAction2["REMOVE"] = 3] = "REMOVE";
  BanInfo_BanInfoAction2[BanInfo_BanInfoAction2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BanInfo_BanInfoAction || (BanInfo_BanInfoAction = {}));
function banInfo_BanInfoActionFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return BanInfo_BanInfoAction.UNKNOWN;
    case 1:
    case "SPAM":
      return BanInfo_BanInfoAction.SPAM;
    case 2:
    case "FILTER":
      return BanInfo_BanInfoAction.FILTER;
    case 3:
    case "REMOVE":
      return BanInfo_BanInfoAction.REMOVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BanInfo_BanInfoAction.UNRECOGNIZED;
  }
}
function banInfo_BanInfoActionToJSON(object) {
  switch (object) {
    case BanInfo_BanInfoAction.UNKNOWN:
      return 0;
    case BanInfo_BanInfoAction.SPAM:
      return 1;
    case BanInfo_BanInfoAction.FILTER:
      return 2;
    case BanInfo_BanInfoAction.REMOVE:
      return 3;
    case BanInfo_BanInfoAction.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseAuthorFlairRichText() {
  return { e: void 0, t: void 0 };
}
var AuthorFlairRichText = {
  $type: "devvit.reddit.AuthorFlairRichText",
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.e !== void 0) {
      StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
    }
    if (message.t !== void 0) {
      StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : new import_minimal5.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAuthorFlairRichText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.e = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.t = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { e: isSet4(object.e) ? String(object.e) : void 0, t: isSet4(object.t) ? String(object.t) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.e !== void 0 && (obj.e = message.e);
    message.t !== void 0 && (obj.t = message.t);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAuthorFlairRichText();
    message.e = object.e ?? void 0;
    message.t = object.t ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.AuthorFlairRichText", AuthorFlairRichText);
function createBaseAwarding() {
  return {
    awardSubType: void 0,
    awardType: void 0,
    awardingsRequiredToGrantBenefits: void 0,
    coinPrice: void 0,
    coinReward: void 0,
    count: void 0,
    daysOfDripExtension: void 0,
    daysOfPremium: void 0,
    description: void 0,
    endDate: void 0,
    giverCoinReward: void 0,
    iconFormat: void 0,
    iconHeight: void 0,
    iconUrl: void 0,
    iconWidth: void 0,
    id: void 0,
    isEnabled: void 0,
    isNew: void 0,
    name: void 0,
    pennyDonate: void 0,
    pennyPrice: void 0,
    resizedIcons: [],
    resizedStaticIcons: [],
    startDate: void 0,
    staticIconHeight: void 0,
    staticIconUrl: void 0,
    staticIconWidth: void 0,
    stickyDurationSeconds: void 0,
    subredditCoinReward: void 0,
    subredditId: void 0,
    tiersByRequiredAwardings: void 0
  };
}
var Awarding = {
  $type: "devvit.reddit.Awarding",
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.awardSubType !== void 0) {
      StringValue.encode({ value: message.awardSubType }, writer.uint32(10).fork()).ldelim();
    }
    if (message.awardType !== void 0) {
      StringValue.encode({ value: message.awardType }, writer.uint32(18).fork()).ldelim();
    }
    if (message.awardingsRequiredToGrantBenefits !== void 0) {
      Int32Value.encode({ value: message.awardingsRequiredToGrantBenefits }, writer.uint32(26).fork()).ldelim();
    }
    if (message.coinPrice !== void 0) {
      Int64Value.encode({ value: message.coinPrice }, writer.uint32(34).fork()).ldelim();
    }
    if (message.coinReward !== void 0) {
      Int64Value.encode({ value: message.coinReward }, writer.uint32(42).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int32Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
    }
    if (message.daysOfDripExtension !== void 0) {
      Int32Value.encode({ value: message.daysOfDripExtension }, writer.uint32(58).fork()).ldelim();
    }
    if (message.daysOfPremium !== void 0) {
      Int32Value.encode({ value: message.daysOfPremium }, writer.uint32(66).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(74).fork()).ldelim();
    }
    if (message.endDate !== void 0) {
      StringValue.encode({ value: message.endDate }, writer.uint32(82).fork()).ldelim();
    }
    if (message.giverCoinReward !== void 0) {
      Int32Value.encode({ value: message.giverCoinReward }, writer.uint32(90).fork()).ldelim();
    }
    if (message.iconFormat !== void 0) {
      StringValue.encode({ value: message.iconFormat }, writer.uint32(98).fork()).ldelim();
    }
    if (message.iconHeight !== void 0) {
      Int32Value.encode({ value: message.iconHeight }, writer.uint32(106).fork()).ldelim();
    }
    if (message.iconUrl !== void 0) {
      StringValue.encode({ value: message.iconUrl }, writer.uint32(114).fork()).ldelim();
    }
    if (message.iconWidth !== void 0) {
      Int32Value.encode({ value: message.iconWidth }, writer.uint32(122).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(130).fork()).ldelim();
    }
    if (message.isEnabled !== void 0) {
      BoolValue.encode({ value: message.isEnabled }, writer.uint32(138).fork()).ldelim();
    }
    if (message.isNew !== void 0) {
      BoolValue.encode({ value: message.isNew }, writer.uint32(146).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(154).fork()).ldelim();
    }
    if (message.pennyDonate !== void 0) {
      Int32Value.encode({ value: message.pennyDonate }, writer.uint32(162).fork()).ldelim();
    }
    if (message.pennyPrice !== void 0) {
      Int32Value.encode({ value: message.pennyPrice }, writer.uint32(170).fork()).ldelim();
    }
    for (const v of message.resizedIcons) {
      Awarding_Icon.encode(v, writer.uint32(178).fork()).ldelim();
    }
    for (const v of message.resizedStaticIcons) {
      Awarding_Icon.encode(v, writer.uint32(186).fork()).ldelim();
    }
    if (message.startDate !== void 0) {
      StringValue.encode({ value: message.startDate }, writer.uint32(194).fork()).ldelim();
    }
    if (message.staticIconHeight !== void 0) {
      Int32Value.encode({ value: message.staticIconHeight }, writer.uint32(202).fork()).ldelim();
    }
    if (message.staticIconUrl !== void 0) {
      StringValue.encode({ value: message.staticIconUrl }, writer.uint32(210).fork()).ldelim();
    }
    if (message.staticIconWidth !== void 0) {
      Int32Value.encode({ value: message.staticIconWidth }, writer.uint32(218).fork()).ldelim();
    }
    if (message.stickyDurationSeconds !== void 0) {
      Int64Value.encode({ value: message.stickyDurationSeconds }, writer.uint32(226).fork()).ldelim();
    }
    if (message.subredditCoinReward !== void 0) {
      Int64Value.encode({ value: message.subredditCoinReward }, writer.uint32(234).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(242).fork()).ldelim();
    }
    if (message.tiersByRequiredAwardings !== void 0) {
      StringValue.encode({ value: message.tiersByRequiredAwardings }, writer.uint32(250).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : new import_minimal5.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAwarding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.awardSubType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.awardType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.awardingsRequiredToGrantBenefits = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.coinPrice = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.coinReward = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.count = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.daysOfDripExtension = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.daysOfPremium = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.endDate = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.giverCoinReward = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.iconFormat = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.iconHeight = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.iconUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.iconWidth = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.isEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.isNew = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.pennyDonate = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.pennyPrice = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.resizedIcons.push(Awarding_Icon.decode(reader, reader.uint32()));
          break;
        case 23:
          message.resizedStaticIcons.push(Awarding_Icon.decode(reader, reader.uint32()));
          break;
        case 24:
          message.startDate = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.staticIconHeight = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.staticIconUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 27:
          message.staticIconWidth = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.stickyDurationSeconds = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.subredditCoinReward = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.tiersByRequiredAwardings = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      awardSubType: isSet4(object.awardSubType) ? String(object.awardSubType) : void 0,
      awardType: isSet4(object.awardType) ? String(object.awardType) : void 0,
      awardingsRequiredToGrantBenefits: isSet4(object.awardingsRequiredToGrantBenefits) ? Number(object.awardingsRequiredToGrantBenefits) : void 0,
      coinPrice: isSet4(object.coinPrice) ? Number(object.coinPrice) : void 0,
      coinReward: isSet4(object.coinReward) ? Number(object.coinReward) : void 0,
      count: isSet4(object.count) ? Number(object.count) : void 0,
      daysOfDripExtension: isSet4(object.daysOfDripExtension) ? Number(object.daysOfDripExtension) : void 0,
      daysOfPremium: isSet4(object.daysOfPremium) ? Number(object.daysOfPremium) : void 0,
      description: isSet4(object.description) ? String(object.description) : void 0,
      endDate: isSet4(object.endDate) ? String(object.endDate) : void 0,
      giverCoinReward: isSet4(object.giverCoinReward) ? Number(object.giverCoinReward) : void 0,
      iconFormat: isSet4(object.iconFormat) ? String(object.iconFormat) : void 0,
      iconHeight: isSet4(object.iconHeight) ? Number(object.iconHeight) : void 0,
      iconUrl: isSet4(object.iconUrl) ? String(object.iconUrl) : void 0,
      iconWidth: isSet4(object.iconWidth) ? Number(object.iconWidth) : void 0,
      id: isSet4(object.id) ? String(object.id) : void 0,
      isEnabled: isSet4(object.isEnabled) ? Boolean(object.isEnabled) : void 0,
      isNew: isSet4(object.isNew) ? Boolean(object.isNew) : void 0,
      name: isSet4(object.name) ? String(object.name) : void 0,
      pennyDonate: isSet4(object.pennyDonate) ? Number(object.pennyDonate) : void 0,
      pennyPrice: isSet4(object.pennyPrice) ? Number(object.pennyPrice) : void 0,
      resizedIcons: Array.isArray(object?.resizedIcons) ? object.resizedIcons.map((e) => Awarding_Icon.fromJSON(e)) : [],
      resizedStaticIcons: Array.isArray(object?.resizedStaticIcons) ? object.resizedStaticIcons.map((e) => Awarding_Icon.fromJSON(e)) : [],
      startDate: isSet4(object.startDate) ? String(object.startDate) : void 0,
      staticIconHeight: isSet4(object.staticIconHeight) ? Number(object.staticIconHeight) : void 0,
      staticIconUrl: isSet4(object.staticIconUrl) ? String(object.staticIconUrl) : void 0,
      staticIconWidth: isSet4(object.staticIconWidth) ? Number(object.staticIconWidth) : void 0,
      stickyDurationSeconds: isSet4(object.stickyDurationSeconds) ? Number(object.stickyDurationSeconds) : void 0,
      subredditCoinReward: isSet4(object.subredditCoinReward) ? Number(object.subredditCoinReward) : void 0,
      subredditId: isSet4(object.subredditId) ? String(object.subredditId) : void 0,
      tiersByRequiredAwardings: isSet4(object.tiersByRequiredAwardings) ? String(object.tiersByRequiredAwardings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.awardSubType !== void 0 && (obj.awardSubType = message.awardSubType);
    message.awardType !== void 0 && (obj.awardType = message.awardType);
    message.awardingsRequiredToGrantBenefits !== void 0 && (obj.awardingsRequiredToGrantBenefits = message.awardingsRequiredToGrantBenefits);
    message.coinPrice !== void 0 && (obj.coinPrice = message.coinPrice);
    message.coinReward !== void 0 && (obj.coinReward = message.coinReward);
    message.count !== void 0 && (obj.count = message.count);
    message.daysOfDripExtension !== void 0 && (obj.daysOfDripExtension = message.daysOfDripExtension);
    message.daysOfPremium !== void 0 && (obj.daysOfPremium = message.daysOfPremium);
    message.description !== void 0 && (obj.description = message.description);
    message.endDate !== void 0 && (obj.endDate = message.endDate);
    message.giverCoinReward !== void 0 && (obj.giverCoinReward = message.giverCoinReward);
    message.iconFormat !== void 0 && (obj.iconFormat = message.iconFormat);
    message.iconHeight !== void 0 && (obj.iconHeight = message.iconHeight);
    message.iconUrl !== void 0 && (obj.iconUrl = message.iconUrl);
    message.iconWidth !== void 0 && (obj.iconWidth = message.iconWidth);
    message.id !== void 0 && (obj.id = message.id);
    message.isEnabled !== void 0 && (obj.isEnabled = message.isEnabled);
    message.isNew !== void 0 && (obj.isNew = message.isNew);
    message.name !== void 0 && (obj.name = message.name);
    message.pennyDonate !== void 0 && (obj.pennyDonate = message.pennyDonate);
    message.pennyPrice !== void 0 && (obj.pennyPrice = message.pennyPrice);
    if (message.resizedIcons) {
      obj.resizedIcons = message.resizedIcons.map((e) => e ? Awarding_Icon.toJSON(e) : void 0);
    } else {
      obj.resizedIcons = [];
    }
    if (message.resizedStaticIcons) {
      obj.resizedStaticIcons = message.resizedStaticIcons.map((e) => e ? Awarding_Icon.toJSON(e) : void 0);
    } else {
      obj.resizedStaticIcons = [];
    }
    message.startDate !== void 0 && (obj.startDate = message.startDate);
    message.staticIconHeight !== void 0 && (obj.staticIconHeight = message.staticIconHeight);
    message.staticIconUrl !== void 0 && (obj.staticIconUrl = message.staticIconUrl);
    message.staticIconWidth !== void 0 && (obj.staticIconWidth = message.staticIconWidth);
    message.stickyDurationSeconds !== void 0 && (obj.stickyDurationSeconds = message.stickyDurationSeconds);
    message.subredditCoinReward !== void 0 && (obj.subredditCoinReward = message.subredditCoinReward);
    message.subredditId !== void 0 && (obj.subredditId = message.subredditId);
    message.tiersByRequiredAwardings !== void 0 && (obj.tiersByRequiredAwardings = message.tiersByRequiredAwardings);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAwarding();
    message.awardSubType = object.awardSubType ?? void 0;
    message.awardType = object.awardType ?? void 0;
    message.awardingsRequiredToGrantBenefits = object.awardingsRequiredToGrantBenefits ?? void 0;
    message.coinPrice = object.coinPrice ?? void 0;
    message.coinReward = object.coinReward ?? void 0;
    message.count = object.count ?? void 0;
    message.daysOfDripExtension = object.daysOfDripExtension ?? void 0;
    message.daysOfPremium = object.daysOfPremium ?? void 0;
    message.description = object.description ?? void 0;
    message.endDate = object.endDate ?? void 0;
    message.giverCoinReward = object.giverCoinReward ?? void 0;
    message.iconFormat = object.iconFormat ?? void 0;
    message.iconHeight = object.iconHeight ?? void 0;
    message.iconUrl = object.iconUrl ?? void 0;
    message.iconWidth = object.iconWidth ?? void 0;
    message.id = object.id ?? void 0;
    message.isEnabled = object.isEnabled ?? void 0;
    message.isNew = object.isNew ?? void 0;
    message.name = object.name ?? void 0;
    message.pennyDonate = object.pennyDonate ?? void 0;
    message.pennyPrice = object.pennyPrice ?? void 0;
    message.resizedIcons = object.resizedIcons?.map((e) => Awarding_Icon.fromPartial(e)) || [];
    message.resizedStaticIcons = object.resizedStaticIcons?.map((e) => Awarding_Icon.fromPartial(e)) || [];
    message.startDate = object.startDate ?? void 0;
    message.staticIconHeight = object.staticIconHeight ?? void 0;
    message.staticIconUrl = object.staticIconUrl ?? void 0;
    message.staticIconWidth = object.staticIconWidth ?? void 0;
    message.stickyDurationSeconds = object.stickyDurationSeconds ?? void 0;
    message.subredditCoinReward = object.subredditCoinReward ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.tiersByRequiredAwardings = object.tiersByRequiredAwardings ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.Awarding", Awarding);
function createBaseAwarding_Icon() {
  return { height: void 0, url: void 0, width: void 0 };
}
var Awarding_Icon = {
  $type: "devvit.reddit.Awarding.Icon",
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(10).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(18).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : new import_minimal5.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAwarding_Icon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet4(object.height) ? Number(object.height) : void 0,
      url: isSet4(object.url) ? String(object.url) : void 0,
      width: isSet4(object.width) ? Number(object.width) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.height !== void 0 && (obj.height = message.height);
    message.url !== void 0 && (obj.url = message.url);
    message.width !== void 0 && (obj.width = message.width);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAwarding_Icon();
    message.height = object.height ?? void 0;
    message.url = object.url ?? void 0;
    message.width = object.width ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.Awarding.Icon", Awarding_Icon);
function createBaseCommentContributionSettings() {
  return { allowedMediaTypes: [] };
}
var CommentContributionSettings = {
  $type: "devvit.reddit.CommentContributionSettings",
  encode(message, writer = import_minimal5.default.Writer.create()) {
    for (const v of message.allowedMediaTypes) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : new import_minimal5.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentContributionSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.allowedMediaTypes.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      allowedMediaTypes: Array.isArray(object?.allowedMediaTypes) ? object.allowedMediaTypes.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allowedMediaTypes) {
      obj.allowedMediaTypes = message.allowedMediaTypes.map((e) => e);
    } else {
      obj.allowedMediaTypes = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommentContributionSettings();
    message.allowedMediaTypes = object.allowedMediaTypes?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.CommentContributionSettings", CommentContributionSettings);
function createBaseGildings() {
  return { gid1: void 0, gid2: void 0, gid3: void 0 };
}
var Gildings = {
  $type: "devvit.reddit.Gildings",
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.gid1 !== void 0) {
      Int32Value.encode({ value: message.gid1 }, writer.uint32(10).fork()).ldelim();
    }
    if (message.gid2 !== void 0) {
      Int32Value.encode({ value: message.gid2 }, writer.uint32(18).fork()).ldelim();
    }
    if (message.gid3 !== void 0) {
      Int32Value.encode({ value: message.gid3 }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : new import_minimal5.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGildings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gid1 = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.gid2 = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.gid3 = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      gid1: isSet4(object.gid1) ? Number(object.gid1) : void 0,
      gid2: isSet4(object.gid2) ? Number(object.gid2) : void 0,
      gid3: isSet4(object.gid3) ? Number(object.gid3) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.gid1 !== void 0 && (obj.gid1 = message.gid1);
    message.gid2 !== void 0 && (obj.gid2 = message.gid2);
    message.gid3 !== void 0 && (obj.gid3 = message.gid3);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGildings();
    message.gid1 = object.gid1 ?? void 0;
    message.gid2 = object.gid2 ?? void 0;
    message.gid3 = object.gid3 ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.Gildings", Gildings);
function createBaseMediaEmbed() {
  return {
    content: void 0,
    width: void 0,
    height: void 0,
    sandbox: void 0,
    scrolling: void 0,
    publicThumbnailUrl: void 0
  };
}
var MediaEmbed = {
  $type: "devvit.reddit.MediaEmbed",
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.content !== void 0) {
      StringValue.encode({ value: message.content }, writer.uint32(10).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(18).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(26).fork()).ldelim();
    }
    if (message.sandbox !== void 0) {
      BoolValue.encode({ value: message.sandbox }, writer.uint32(34).fork()).ldelim();
    }
    if (message.scrolling !== void 0) {
      BoolValue.encode({ value: message.scrolling }, writer.uint32(42).fork()).ldelim();
    }
    if (message.publicThumbnailUrl !== void 0) {
      StringValue.encode({ value: message.publicThumbnailUrl }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : new import_minimal5.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaEmbed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.content = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.sandbox = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.scrolling = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.publicThumbnailUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      content: isSet4(object.content) ? String(object.content) : void 0,
      width: isSet4(object.width) ? Number(object.width) : void 0,
      height: isSet4(object.height) ? Number(object.height) : void 0,
      sandbox: isSet4(object.sandbox) ? Boolean(object.sandbox) : void 0,
      scrolling: isSet4(object.scrolling) ? Boolean(object.scrolling) : void 0,
      publicThumbnailUrl: isSet4(object.publicThumbnailUrl) ? String(object.publicThumbnailUrl) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.content !== void 0 && (obj.content = message.content);
    message.width !== void 0 && (obj.width = message.width);
    message.height !== void 0 && (obj.height = message.height);
    message.sandbox !== void 0 && (obj.sandbox = message.sandbox);
    message.scrolling !== void 0 && (obj.scrolling = message.scrolling);
    message.publicThumbnailUrl !== void 0 && (obj.publicThumbnailUrl = message.publicThumbnailUrl);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMediaEmbed();
    message.content = object.content ?? void 0;
    message.width = object.width ?? void 0;
    message.height = object.height ?? void 0;
    message.sandbox = object.sandbox ?? void 0;
    message.scrolling = object.scrolling ?? void 0;
    message.publicThumbnailUrl = object.publicThumbnailUrl ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.MediaEmbed", MediaEmbed);
function createBaseUserFlairRichtext() {
  return { e: void 0, t: void 0 };
}
var UserFlairRichtext = {
  $type: "devvit.reddit.UserFlairRichtext",
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.e !== void 0) {
      StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
    }
    if (message.t !== void 0) {
      StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : new import_minimal5.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserFlairRichtext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.e = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.t = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { e: isSet4(object.e) ? String(object.e) : void 0, t: isSet4(object.t) ? String(object.t) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.e !== void 0 && (obj.e = message.e);
    message.t !== void 0 && (obj.t = message.t);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserFlairRichtext();
    message.e = object.e ?? void 0;
    message.t = object.t ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.UserFlairRichtext", UserFlairRichtext);
function createBaseBanInfo() {
  return {
    auto: void 0,
    bannedAt: void 0,
    banner: void 0,
    moderatorBanned: void 0,
    note: void 0,
    unbanner: void 0,
    unbannedAt: void 0,
    resetUsed: void 0,
    reasonId: void 0,
    reasonTitle: void 0,
    reasonMessage: void 0,
    reasonBy: void 0,
    modNote: void 0,
    banAllTriggered: void 0,
    subredditMessage: void 0,
    removeAction: 0
  };
}
var BanInfo = {
  $type: "devvit.reddit.BanInfo",
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.auto !== void 0) {
      BoolValue.encode({ value: message.auto }, writer.uint32(10).fork()).ldelim();
    }
    if (message.bannedAt !== void 0) {
      Int32Value.encode({ value: message.bannedAt }, writer.uint32(18).fork()).ldelim();
    }
    if (message.banner !== void 0) {
      StringValue.encode({ value: message.banner }, writer.uint32(26).fork()).ldelim();
    }
    if (message.moderatorBanned !== void 0) {
      BoolValue.encode({ value: message.moderatorBanned }, writer.uint32(34).fork()).ldelim();
    }
    if (message.note !== void 0) {
      StringValue.encode({ value: message.note }, writer.uint32(42).fork()).ldelim();
    }
    if (message.unbanner !== void 0) {
      StringValue.encode({ value: message.unbanner }, writer.uint32(50).fork()).ldelim();
    }
    if (message.unbannedAt !== void 0) {
      Int32Value.encode({ value: message.unbannedAt }, writer.uint32(58).fork()).ldelim();
    }
    if (message.resetUsed !== void 0) {
      BoolValue.encode({ value: message.resetUsed }, writer.uint32(66).fork()).ldelim();
    }
    if (message.reasonId !== void 0) {
      StringValue.encode({ value: message.reasonId }, writer.uint32(74).fork()).ldelim();
    }
    if (message.reasonTitle !== void 0) {
      StringValue.encode({ value: message.reasonTitle }, writer.uint32(82).fork()).ldelim();
    }
    if (message.reasonMessage !== void 0) {
      StringValue.encode({ value: message.reasonMessage }, writer.uint32(90).fork()).ldelim();
    }
    if (message.reasonBy !== void 0) {
      StringValue.encode({ value: message.reasonBy }, writer.uint32(98).fork()).ldelim();
    }
    if (message.modNote !== void 0) {
      StringValue.encode({ value: message.modNote }, writer.uint32(106).fork()).ldelim();
    }
    if (message.banAllTriggered !== void 0) {
      BoolValue.encode({ value: message.banAllTriggered }, writer.uint32(114).fork()).ldelim();
    }
    if (message.subredditMessage !== void 0) {
      StringValue.encode({ value: message.subredditMessage }, writer.uint32(122).fork()).ldelim();
    }
    if (message.removeAction !== 0) {
      writer.uint32(128).int32(message.removeAction);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : new import_minimal5.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBanInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.auto = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.bannedAt = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.banner = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.moderatorBanned = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.note = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.unbanner = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.unbannedAt = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.resetUsed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.reasonId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.reasonTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.reasonMessage = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.reasonBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.modNote = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.banAllTriggered = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.subredditMessage = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.removeAction = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      auto: isSet4(object.auto) ? Boolean(object.auto) : void 0,
      bannedAt: isSet4(object.bannedAt) ? Number(object.bannedAt) : void 0,
      banner: isSet4(object.banner) ? String(object.banner) : void 0,
      moderatorBanned: isSet4(object.moderatorBanned) ? Boolean(object.moderatorBanned) : void 0,
      note: isSet4(object.note) ? String(object.note) : void 0,
      unbanner: isSet4(object.unbanner) ? String(object.unbanner) : void 0,
      unbannedAt: isSet4(object.unbannedAt) ? Number(object.unbannedAt) : void 0,
      resetUsed: isSet4(object.resetUsed) ? Boolean(object.resetUsed) : void 0,
      reasonId: isSet4(object.reasonId) ? String(object.reasonId) : void 0,
      reasonTitle: isSet4(object.reasonTitle) ? String(object.reasonTitle) : void 0,
      reasonMessage: isSet4(object.reasonMessage) ? String(object.reasonMessage) : void 0,
      reasonBy: isSet4(object.reasonBy) ? String(object.reasonBy) : void 0,
      modNote: isSet4(object.modNote) ? String(object.modNote) : void 0,
      banAllTriggered: isSet4(object.banAllTriggered) ? Boolean(object.banAllTriggered) : void 0,
      subredditMessage: isSet4(object.subredditMessage) ? String(object.subredditMessage) : void 0,
      removeAction: isSet4(object.removeAction) ? banInfo_BanInfoActionFromJSON(object.removeAction) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.auto !== void 0 && (obj.auto = message.auto);
    message.bannedAt !== void 0 && (obj.bannedAt = message.bannedAt);
    message.banner !== void 0 && (obj.banner = message.banner);
    message.moderatorBanned !== void 0 && (obj.moderatorBanned = message.moderatorBanned);
    message.note !== void 0 && (obj.note = message.note);
    message.unbanner !== void 0 && (obj.unbanner = message.unbanner);
    message.unbannedAt !== void 0 && (obj.unbannedAt = message.unbannedAt);
    message.resetUsed !== void 0 && (obj.resetUsed = message.resetUsed);
    message.reasonId !== void 0 && (obj.reasonId = message.reasonId);
    message.reasonTitle !== void 0 && (obj.reasonTitle = message.reasonTitle);
    message.reasonMessage !== void 0 && (obj.reasonMessage = message.reasonMessage);
    message.reasonBy !== void 0 && (obj.reasonBy = message.reasonBy);
    message.modNote !== void 0 && (obj.modNote = message.modNote);
    message.banAllTriggered !== void 0 && (obj.banAllTriggered = message.banAllTriggered);
    message.subredditMessage !== void 0 && (obj.subredditMessage = message.subredditMessage);
    message.removeAction !== void 0 && (obj.removeAction = banInfo_BanInfoActionToJSON(message.removeAction));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBanInfo();
    message.auto = object.auto ?? void 0;
    message.bannedAt = object.bannedAt ?? void 0;
    message.banner = object.banner ?? void 0;
    message.moderatorBanned = object.moderatorBanned ?? void 0;
    message.note = object.note ?? void 0;
    message.unbanner = object.unbanner ?? void 0;
    message.unbannedAt = object.unbannedAt ?? void 0;
    message.resetUsed = object.resetUsed ?? void 0;
    message.reasonId = object.reasonId ?? void 0;
    message.reasonTitle = object.reasonTitle ?? void 0;
    message.reasonMessage = object.reasonMessage ?? void 0;
    message.reasonBy = object.reasonBy ?? void 0;
    message.modNote = object.modNote ?? void 0;
    message.banAllTriggered = object.banAllTriggered ?? void 0;
    message.subredditMessage = object.subredditMessage ?? void 0;
    message.removeAction = object.removeAction ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.BanInfo", BanInfo);
function isSet4(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/comment.js
function createBaseComment() {
  return {
    allAwardings: [],
    approved: void 0,
    approvedAtUtc: void 0,
    approvedBy: void 0,
    archived: void 0,
    associatedAward: void 0,
    author: void 0,
    authorFlairBackgroundColor: void 0,
    authorFlairCssClass: void 0,
    authorFlairRichtext: [],
    authorFlairTemplateId: void 0,
    authorFlairText: void 0,
    authorFlairTextColor: void 0,
    authorFlairType: void 0,
    authorFullname: void 0,
    authorIsBlocked: void 0,
    authorPatreonFlair: void 0,
    authorPremium: void 0,
    awarders: [],
    bannedAtUtc: void 0,
    bannedBy: void 0,
    body: void 0,
    bodyHtml: void 0,
    canGild: void 0,
    canModPost: void 0,
    collapsed: void 0,
    collapsedBecauseCrowdControl: void 0,
    collapsedReason: void 0,
    collapsedReasonCode: void 0,
    commentType: void 0,
    controversiality: void 0,
    created: void 0,
    createdUtc: void 0,
    depth: void 0,
    distinguished: void 0,
    downs: void 0,
    edited: void 0,
    gilded: void 0,
    gildings: void 0,
    id: void 0,
    ignoreReports: void 0,
    isSubmitter: void 0,
    likes: void 0,
    linkId: void 0,
    locked: void 0,
    modNote: void 0,
    modReasonBy: void 0,
    modReasonTitle: void 0,
    modReports: [],
    name: void 0,
    noFollow: void 0,
    numReports: void 0,
    parentId: void 0,
    permalink: void 0,
    removalReason: void 0,
    removed: void 0,
    replies: void 0,
    reportReasons: [],
    rteMode: void 0,
    saved: void 0,
    score: void 0,
    scoreHidden: void 0,
    sendReplies: void 0,
    spam: void 0,
    stickied: void 0,
    subreddit: void 0,
    subredditId: void 0,
    subredditNamePrefixed: void 0,
    subredditType: void 0,
    topAwardedType: void 0,
    totalAwardsReceived: void 0,
    treatmentTags: [],
    unrepliableReason: void 0,
    ups: void 0,
    userReports: [],
    count: void 0,
    children: [],
    banInfo: void 0,
    markedSpam: void 0,
    verdict: void 0
  };
}
var Comment = {
  $type: "devvit.reddit.Comment",
  encode(message, writer = import_minimal6.default.Writer.create()) {
    for (const v of message.allAwardings) {
      Awarding.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.approved !== void 0) {
      BoolValue.encode({ value: message.approved }, writer.uint32(18).fork()).ldelim();
    }
    if (message.approvedAtUtc !== void 0) {
      Int32Value.encode({ value: message.approvedAtUtc }, writer.uint32(26).fork()).ldelim();
    }
    if (message.approvedBy !== void 0) {
      StringValue.encode({ value: message.approvedBy }, writer.uint32(34).fork()).ldelim();
    }
    if (message.archived !== void 0) {
      BoolValue.encode({ value: message.archived }, writer.uint32(42).fork()).ldelim();
    }
    if (message.associatedAward !== void 0) {
      StringValue.encode({ value: message.associatedAward }, writer.uint32(50).fork()).ldelim();
    }
    if (message.author !== void 0) {
      StringValue.encode({ value: message.author }, writer.uint32(58).fork()).ldelim();
    }
    if (message.authorFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.authorFlairBackgroundColor }, writer.uint32(66).fork()).ldelim();
    }
    if (message.authorFlairCssClass !== void 0) {
      StringValue.encode({ value: message.authorFlairCssClass }, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.authorFlairRichtext) {
      AuthorFlairRichText.encode(v, writer.uint32(82).fork()).ldelim();
    }
    if (message.authorFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.authorFlairTemplateId }, writer.uint32(90).fork()).ldelim();
    }
    if (message.authorFlairText !== void 0) {
      StringValue.encode({ value: message.authorFlairText }, writer.uint32(98).fork()).ldelim();
    }
    if (message.authorFlairTextColor !== void 0) {
      StringValue.encode({ value: message.authorFlairTextColor }, writer.uint32(106).fork()).ldelim();
    }
    if (message.authorFlairType !== void 0) {
      StringValue.encode({ value: message.authorFlairType }, writer.uint32(114).fork()).ldelim();
    }
    if (message.authorFullname !== void 0) {
      StringValue.encode({ value: message.authorFullname }, writer.uint32(122).fork()).ldelim();
    }
    if (message.authorIsBlocked !== void 0) {
      BoolValue.encode({ value: message.authorIsBlocked }, writer.uint32(130).fork()).ldelim();
    }
    if (message.authorPatreonFlair !== void 0) {
      BoolValue.encode({ value: message.authorPatreonFlair }, writer.uint32(138).fork()).ldelim();
    }
    if (message.authorPremium !== void 0) {
      BoolValue.encode({ value: message.authorPremium }, writer.uint32(146).fork()).ldelim();
    }
    for (const v of message.awarders) {
      StringValue.encode({ value: v }, writer.uint32(154).fork()).ldelim();
    }
    if (message.bannedAtUtc !== void 0) {
      Int32Value.encode({ value: message.bannedAtUtc }, writer.uint32(162).fork()).ldelim();
    }
    if (message.bannedBy !== void 0) {
      StringValue.encode({ value: message.bannedBy }, writer.uint32(170).fork()).ldelim();
    }
    if (message.body !== void 0) {
      StringValue.encode({ value: message.body }, writer.uint32(178).fork()).ldelim();
    }
    if (message.bodyHtml !== void 0) {
      StringValue.encode({ value: message.bodyHtml }, writer.uint32(186).fork()).ldelim();
    }
    if (message.canGild !== void 0) {
      BoolValue.encode({ value: message.canGild }, writer.uint32(194).fork()).ldelim();
    }
    if (message.canModPost !== void 0) {
      BoolValue.encode({ value: message.canModPost }, writer.uint32(202).fork()).ldelim();
    }
    if (message.collapsed !== void 0) {
      BoolValue.encode({ value: message.collapsed }, writer.uint32(210).fork()).ldelim();
    }
    if (message.collapsedBecauseCrowdControl !== void 0) {
      BoolValue.encode({ value: message.collapsedBecauseCrowdControl }, writer.uint32(218).fork()).ldelim();
    }
    if (message.collapsedReason !== void 0) {
      StringValue.encode({ value: message.collapsedReason }, writer.uint32(226).fork()).ldelim();
    }
    if (message.collapsedReasonCode !== void 0) {
      StringValue.encode({ value: message.collapsedReasonCode }, writer.uint32(234).fork()).ldelim();
    }
    if (message.commentType !== void 0) {
      StringValue.encode({ value: message.commentType }, writer.uint32(242).fork()).ldelim();
    }
    if (message.controversiality !== void 0) {
      Int32Value.encode({ value: message.controversiality }, writer.uint32(250).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int32Value.encode({ value: message.created }, writer.uint32(258).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int32Value.encode({ value: message.createdUtc }, writer.uint32(266).fork()).ldelim();
    }
    if (message.depth !== void 0) {
      Int32Value.encode({ value: message.depth }, writer.uint32(274).fork()).ldelim();
    }
    if (message.distinguished !== void 0) {
      StringValue.encode({ value: message.distinguished }, writer.uint32(282).fork()).ldelim();
    }
    if (message.downs !== void 0) {
      Int32Value.encode({ value: message.downs }, writer.uint32(290).fork()).ldelim();
    }
    if (message.edited !== void 0) {
      BoolValue.encode({ value: message.edited }, writer.uint32(298).fork()).ldelim();
    }
    if (message.gilded !== void 0) {
      Int32Value.encode({ value: message.gilded }, writer.uint32(306).fork()).ldelim();
    }
    if (message.gildings !== void 0) {
      Gildings.encode(message.gildings, writer.uint32(314).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(322).fork()).ldelim();
    }
    if (message.ignoreReports !== void 0) {
      BoolValue.encode({ value: message.ignoreReports }, writer.uint32(330).fork()).ldelim();
    }
    if (message.isSubmitter !== void 0) {
      BoolValue.encode({ value: message.isSubmitter }, writer.uint32(338).fork()).ldelim();
    }
    if (message.likes !== void 0) {
      BoolValue.encode({ value: message.likes }, writer.uint32(346).fork()).ldelim();
    }
    if (message.linkId !== void 0) {
      StringValue.encode({ value: message.linkId }, writer.uint32(354).fork()).ldelim();
    }
    if (message.locked !== void 0) {
      BoolValue.encode({ value: message.locked }, writer.uint32(362).fork()).ldelim();
    }
    if (message.modNote !== void 0) {
      StringValue.encode({ value: message.modNote }, writer.uint32(370).fork()).ldelim();
    }
    if (message.modReasonBy !== void 0) {
      StringValue.encode({ value: message.modReasonBy }, writer.uint32(378).fork()).ldelim();
    }
    if (message.modReasonTitle !== void 0) {
      StringValue.encode({ value: message.modReasonTitle }, writer.uint32(386).fork()).ldelim();
    }
    for (const v of message.modReports) {
      ListValue.encode(ListValue.wrap(v), writer.uint32(394).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(402).fork()).ldelim();
    }
    if (message.noFollow !== void 0) {
      BoolValue.encode({ value: message.noFollow }, writer.uint32(410).fork()).ldelim();
    }
    if (message.numReports !== void 0) {
      Int32Value.encode({ value: message.numReports }, writer.uint32(418).fork()).ldelim();
    }
    if (message.parentId !== void 0) {
      StringValue.encode({ value: message.parentId }, writer.uint32(426).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(434).fork()).ldelim();
    }
    if (message.removalReason !== void 0) {
      StringValue.encode({ value: message.removalReason }, writer.uint32(442).fork()).ldelim();
    }
    if (message.removed !== void 0) {
      BoolValue.encode({ value: message.removed }, writer.uint32(450).fork()).ldelim();
    }
    if (message.replies !== void 0) {
      StringValue.encode({ value: message.replies }, writer.uint32(458).fork()).ldelim();
    }
    for (const v of message.reportReasons) {
      StringValue.encode({ value: v }, writer.uint32(466).fork()).ldelim();
    }
    if (message.rteMode !== void 0) {
      StringValue.encode({ value: message.rteMode }, writer.uint32(474).fork()).ldelim();
    }
    if (message.saved !== void 0) {
      BoolValue.encode({ value: message.saved }, writer.uint32(482).fork()).ldelim();
    }
    if (message.score !== void 0) {
      Int32Value.encode({ value: message.score }, writer.uint32(490).fork()).ldelim();
    }
    if (message.scoreHidden !== void 0) {
      BoolValue.encode({ value: message.scoreHidden }, writer.uint32(498).fork()).ldelim();
    }
    if (message.sendReplies !== void 0) {
      BoolValue.encode({ value: message.sendReplies }, writer.uint32(506).fork()).ldelim();
    }
    if (message.spam !== void 0) {
      BoolValue.encode({ value: message.spam }, writer.uint32(514).fork()).ldelim();
    }
    if (message.stickied !== void 0) {
      BoolValue.encode({ value: message.stickied }, writer.uint32(522).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(530).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(538).fork()).ldelim();
    }
    if (message.subredditNamePrefixed !== void 0) {
      StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(546).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(554).fork()).ldelim();
    }
    if (message.topAwardedType !== void 0) {
      StringValue.encode({ value: message.topAwardedType }, writer.uint32(562).fork()).ldelim();
    }
    if (message.totalAwardsReceived !== void 0) {
      Int32Value.encode({ value: message.totalAwardsReceived }, writer.uint32(570).fork()).ldelim();
    }
    for (const v of message.treatmentTags) {
      StringValue.encode({ value: v }, writer.uint32(578).fork()).ldelim();
    }
    if (message.unrepliableReason !== void 0) {
      StringValue.encode({ value: message.unrepliableReason }, writer.uint32(586).fork()).ldelim();
    }
    if (message.ups !== void 0) {
      Int32Value.encode({ value: message.ups }, writer.uint32(594).fork()).ldelim();
    }
    for (const v of message.userReports) {
      ListValue.encode(ListValue.wrap(v), writer.uint32(602).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int32Value.encode({ value: message.count }, writer.uint32(610).fork()).ldelim();
    }
    for (const v of message.children) {
      StringValue.encode({ value: v }, writer.uint32(618).fork()).ldelim();
    }
    if (message.banInfo !== void 0) {
      BanInfo.encode(message.banInfo, writer.uint32(626).fork()).ldelim();
    }
    if (message.markedSpam !== void 0) {
      BoolValue.encode({ value: message.markedSpam }, writer.uint32(634).fork()).ldelim();
    }
    if (message.verdict !== void 0) {
      StringValue.encode({ value: message.verdict }, writer.uint32(642).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : new import_minimal6.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.allAwardings.push(Awarding.decode(reader, reader.uint32()));
          break;
        case 2:
          message.approved = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.approvedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.approvedBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.archived = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.associatedAward = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.author = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.authorFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.authorFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.authorFlairRichtext.push(AuthorFlairRichText.decode(reader, reader.uint32()));
          break;
        case 11:
          message.authorFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.authorFlairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.authorFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.authorFlairType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.authorFullname = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.authorIsBlocked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.authorPatreonFlair = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.authorPremium = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.awarders.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 20:
          message.bannedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.bannedBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.body = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.bodyHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.canGild = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.canModPost = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.collapsed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 27:
          message.collapsedBecauseCrowdControl = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.collapsedReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.collapsedReasonCode = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.commentType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.controversiality = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.created = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.createdUtc = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.depth = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 35:
          message.distinguished = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.downs = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 37:
          message.edited = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 38:
          message.gilded = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 39:
          message.gildings = Gildings.decode(reader, reader.uint32());
          break;
        case 40:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 41:
          message.ignoreReports = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 42:
          message.isSubmitter = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 43:
          message.likes = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 44:
          message.linkId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 45:
          message.locked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 46:
          message.modNote = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 47:
          message.modReasonBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 48:
          message.modReasonTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 49:
          message.modReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          break;
        case 50:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 51:
          message.noFollow = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 52:
          message.numReports = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 53:
          message.parentId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 54:
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 55:
          message.removalReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 56:
          message.removed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 57:
          message.replies = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 58:
          message.reportReasons.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 59:
          message.rteMode = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 60:
          message.saved = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 61:
          message.score = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 62:
          message.scoreHidden = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 63:
          message.sendReplies = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 64:
          message.spam = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 65:
          message.stickied = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 66:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 67:
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 68:
          message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 69:
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 70:
          message.topAwardedType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 71:
          message.totalAwardsReceived = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 72:
          message.treatmentTags.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 73:
          message.unrepliableReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 74:
          message.ups = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 75:
          message.userReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          break;
        case 76:
          message.count = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 77:
          message.children.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 78:
          message.banInfo = BanInfo.decode(reader, reader.uint32());
          break;
        case 79:
          message.markedSpam = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 80:
          message.verdict = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      allAwardings: Array.isArray(object?.allAwardings) ? object.allAwardings.map((e) => Awarding.fromJSON(e)) : [],
      approved: isSet5(object.approved) ? Boolean(object.approved) : void 0,
      approvedAtUtc: isSet5(object.approvedAtUtc) ? Number(object.approvedAtUtc) : void 0,
      approvedBy: isSet5(object.approvedBy) ? String(object.approvedBy) : void 0,
      archived: isSet5(object.archived) ? Boolean(object.archived) : void 0,
      associatedAward: isSet5(object.associatedAward) ? String(object.associatedAward) : void 0,
      author: isSet5(object.author) ? String(object.author) : void 0,
      authorFlairBackgroundColor: isSet5(object.authorFlairBackgroundColor) ? String(object.authorFlairBackgroundColor) : void 0,
      authorFlairCssClass: isSet5(object.authorFlairCssClass) ? String(object.authorFlairCssClass) : void 0,
      authorFlairRichtext: Array.isArray(object?.authorFlairRichtext) ? object.authorFlairRichtext.map((e) => AuthorFlairRichText.fromJSON(e)) : [],
      authorFlairTemplateId: isSet5(object.authorFlairTemplateId) ? String(object.authorFlairTemplateId) : void 0,
      authorFlairText: isSet5(object.authorFlairText) ? String(object.authorFlairText) : void 0,
      authorFlairTextColor: isSet5(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : void 0,
      authorFlairType: isSet5(object.authorFlairType) ? String(object.authorFlairType) : void 0,
      authorFullname: isSet5(object.authorFullname) ? String(object.authorFullname) : void 0,
      authorIsBlocked: isSet5(object.authorIsBlocked) ? Boolean(object.authorIsBlocked) : void 0,
      authorPatreonFlair: isSet5(object.authorPatreonFlair) ? Boolean(object.authorPatreonFlair) : void 0,
      authorPremium: isSet5(object.authorPremium) ? Boolean(object.authorPremium) : void 0,
      awarders: Array.isArray(object?.awarders) ? object.awarders.map((e) => String(e)) : [],
      bannedAtUtc: isSet5(object.bannedAtUtc) ? Number(object.bannedAtUtc) : void 0,
      bannedBy: isSet5(object.bannedBy) ? String(object.bannedBy) : void 0,
      body: isSet5(object.body) ? String(object.body) : void 0,
      bodyHtml: isSet5(object.bodyHtml) ? String(object.bodyHtml) : void 0,
      canGild: isSet5(object.canGild) ? Boolean(object.canGild) : void 0,
      canModPost: isSet5(object.canModPost) ? Boolean(object.canModPost) : void 0,
      collapsed: isSet5(object.collapsed) ? Boolean(object.collapsed) : void 0,
      collapsedBecauseCrowdControl: isSet5(object.collapsedBecauseCrowdControl) ? Boolean(object.collapsedBecauseCrowdControl) : void 0,
      collapsedReason: isSet5(object.collapsedReason) ? String(object.collapsedReason) : void 0,
      collapsedReasonCode: isSet5(object.collapsedReasonCode) ? String(object.collapsedReasonCode) : void 0,
      commentType: isSet5(object.commentType) ? String(object.commentType) : void 0,
      controversiality: isSet5(object.controversiality) ? Number(object.controversiality) : void 0,
      created: isSet5(object.created) ? Number(object.created) : void 0,
      createdUtc: isSet5(object.createdUtc) ? Number(object.createdUtc) : void 0,
      depth: isSet5(object.depth) ? Number(object.depth) : void 0,
      distinguished: isSet5(object.distinguished) ? String(object.distinguished) : void 0,
      downs: isSet5(object.downs) ? Number(object.downs) : void 0,
      edited: isSet5(object.edited) ? Boolean(object.edited) : void 0,
      gilded: isSet5(object.gilded) ? Number(object.gilded) : void 0,
      gildings: isSet5(object.gildings) ? Gildings.fromJSON(object.gildings) : void 0,
      id: isSet5(object.id) ? String(object.id) : void 0,
      ignoreReports: isSet5(object.ignoreReports) ? Boolean(object.ignoreReports) : void 0,
      isSubmitter: isSet5(object.isSubmitter) ? Boolean(object.isSubmitter) : void 0,
      likes: isSet5(object.likes) ? Boolean(object.likes) : void 0,
      linkId: isSet5(object.linkId) ? String(object.linkId) : void 0,
      locked: isSet5(object.locked) ? Boolean(object.locked) : void 0,
      modNote: isSet5(object.modNote) ? String(object.modNote) : void 0,
      modReasonBy: isSet5(object.modReasonBy) ? String(object.modReasonBy) : void 0,
      modReasonTitle: isSet5(object.modReasonTitle) ? String(object.modReasonTitle) : void 0,
      modReports: Array.isArray(object?.modReports) ? object.modReports.map((e) => [...e]) : [],
      name: isSet5(object.name) ? String(object.name) : void 0,
      noFollow: isSet5(object.noFollow) ? Boolean(object.noFollow) : void 0,
      numReports: isSet5(object.numReports) ? Number(object.numReports) : void 0,
      parentId: isSet5(object.parentId) ? String(object.parentId) : void 0,
      permalink: isSet5(object.permalink) ? String(object.permalink) : void 0,
      removalReason: isSet5(object.removalReason) ? String(object.removalReason) : void 0,
      removed: isSet5(object.removed) ? Boolean(object.removed) : void 0,
      replies: isSet5(object.replies) ? String(object.replies) : void 0,
      reportReasons: Array.isArray(object?.reportReasons) ? object.reportReasons.map((e) => String(e)) : [],
      rteMode: isSet5(object.rteMode) ? String(object.rteMode) : void 0,
      saved: isSet5(object.saved) ? Boolean(object.saved) : void 0,
      score: isSet5(object.score) ? Number(object.score) : void 0,
      scoreHidden: isSet5(object.scoreHidden) ? Boolean(object.scoreHidden) : void 0,
      sendReplies: isSet5(object.sendReplies) ? Boolean(object.sendReplies) : void 0,
      spam: isSet5(object.spam) ? Boolean(object.spam) : void 0,
      stickied: isSet5(object.stickied) ? Boolean(object.stickied) : void 0,
      subreddit: isSet5(object.subreddit) ? String(object.subreddit) : void 0,
      subredditId: isSet5(object.subredditId) ? String(object.subredditId) : void 0,
      subredditNamePrefixed: isSet5(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : void 0,
      subredditType: isSet5(object.subredditType) ? String(object.subredditType) : void 0,
      topAwardedType: isSet5(object.topAwardedType) ? String(object.topAwardedType) : void 0,
      totalAwardsReceived: isSet5(object.totalAwardsReceived) ? Number(object.totalAwardsReceived) : void 0,
      treatmentTags: Array.isArray(object?.treatmentTags) ? object.treatmentTags.map((e) => String(e)) : [],
      unrepliableReason: isSet5(object.unrepliableReason) ? String(object.unrepliableReason) : void 0,
      ups: isSet5(object.ups) ? Number(object.ups) : void 0,
      userReports: Array.isArray(object?.userReports) ? object.userReports.map((e) => [...e]) : [],
      count: isSet5(object.count) ? Number(object.count) : void 0,
      children: Array.isArray(object?.children) ? object.children.map((e) => String(e)) : [],
      banInfo: isSet5(object.banInfo) ? BanInfo.fromJSON(object.banInfo) : void 0,
      markedSpam: isSet5(object.markedSpam) ? Boolean(object.markedSpam) : void 0,
      verdict: isSet5(object.verdict) ? String(object.verdict) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allAwardings) {
      obj.allAwardings = message.allAwardings.map((e) => e ? Awarding.toJSON(e) : void 0);
    } else {
      obj.allAwardings = [];
    }
    message.approved !== void 0 && (obj.approved = message.approved);
    message.approvedAtUtc !== void 0 && (obj.approvedAtUtc = message.approvedAtUtc);
    message.approvedBy !== void 0 && (obj.approvedBy = message.approvedBy);
    message.archived !== void 0 && (obj.archived = message.archived);
    message.associatedAward !== void 0 && (obj.associatedAward = message.associatedAward);
    message.author !== void 0 && (obj.author = message.author);
    message.authorFlairBackgroundColor !== void 0 && (obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor);
    message.authorFlairCssClass !== void 0 && (obj.authorFlairCssClass = message.authorFlairCssClass);
    if (message.authorFlairRichtext) {
      obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => e ? AuthorFlairRichText.toJSON(e) : void 0);
    } else {
      obj.authorFlairRichtext = [];
    }
    message.authorFlairTemplateId !== void 0 && (obj.authorFlairTemplateId = message.authorFlairTemplateId);
    message.authorFlairText !== void 0 && (obj.authorFlairText = message.authorFlairText);
    message.authorFlairTextColor !== void 0 && (obj.authorFlairTextColor = message.authorFlairTextColor);
    message.authorFlairType !== void 0 && (obj.authorFlairType = message.authorFlairType);
    message.authorFullname !== void 0 && (obj.authorFullname = message.authorFullname);
    message.authorIsBlocked !== void 0 && (obj.authorIsBlocked = message.authorIsBlocked);
    message.authorPatreonFlair !== void 0 && (obj.authorPatreonFlair = message.authorPatreonFlair);
    message.authorPremium !== void 0 && (obj.authorPremium = message.authorPremium);
    if (message.awarders) {
      obj.awarders = message.awarders.map((e) => e);
    } else {
      obj.awarders = [];
    }
    message.bannedAtUtc !== void 0 && (obj.bannedAtUtc = message.bannedAtUtc);
    message.bannedBy !== void 0 && (obj.bannedBy = message.bannedBy);
    message.body !== void 0 && (obj.body = message.body);
    message.bodyHtml !== void 0 && (obj.bodyHtml = message.bodyHtml);
    message.canGild !== void 0 && (obj.canGild = message.canGild);
    message.canModPost !== void 0 && (obj.canModPost = message.canModPost);
    message.collapsed !== void 0 && (obj.collapsed = message.collapsed);
    message.collapsedBecauseCrowdControl !== void 0 && (obj.collapsedBecauseCrowdControl = message.collapsedBecauseCrowdControl);
    message.collapsedReason !== void 0 && (obj.collapsedReason = message.collapsedReason);
    message.collapsedReasonCode !== void 0 && (obj.collapsedReasonCode = message.collapsedReasonCode);
    message.commentType !== void 0 && (obj.commentType = message.commentType);
    message.controversiality !== void 0 && (obj.controversiality = message.controversiality);
    message.created !== void 0 && (obj.created = message.created);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    message.depth !== void 0 && (obj.depth = message.depth);
    message.distinguished !== void 0 && (obj.distinguished = message.distinguished);
    message.downs !== void 0 && (obj.downs = message.downs);
    message.edited !== void 0 && (obj.edited = message.edited);
    message.gilded !== void 0 && (obj.gilded = message.gilded);
    message.gildings !== void 0 && (obj.gildings = message.gildings ? Gildings.toJSON(message.gildings) : void 0);
    message.id !== void 0 && (obj.id = message.id);
    message.ignoreReports !== void 0 && (obj.ignoreReports = message.ignoreReports);
    message.isSubmitter !== void 0 && (obj.isSubmitter = message.isSubmitter);
    message.likes !== void 0 && (obj.likes = message.likes);
    message.linkId !== void 0 && (obj.linkId = message.linkId);
    message.locked !== void 0 && (obj.locked = message.locked);
    message.modNote !== void 0 && (obj.modNote = message.modNote);
    message.modReasonBy !== void 0 && (obj.modReasonBy = message.modReasonBy);
    message.modReasonTitle !== void 0 && (obj.modReasonTitle = message.modReasonTitle);
    if (message.modReports) {
      obj.modReports = message.modReports.map((e) => e);
    } else {
      obj.modReports = [];
    }
    message.name !== void 0 && (obj.name = message.name);
    message.noFollow !== void 0 && (obj.noFollow = message.noFollow);
    message.numReports !== void 0 && (obj.numReports = message.numReports);
    message.parentId !== void 0 && (obj.parentId = message.parentId);
    message.permalink !== void 0 && (obj.permalink = message.permalink);
    message.removalReason !== void 0 && (obj.removalReason = message.removalReason);
    message.removed !== void 0 && (obj.removed = message.removed);
    message.replies !== void 0 && (obj.replies = message.replies);
    if (message.reportReasons) {
      obj.reportReasons = message.reportReasons.map((e) => e);
    } else {
      obj.reportReasons = [];
    }
    message.rteMode !== void 0 && (obj.rteMode = message.rteMode);
    message.saved !== void 0 && (obj.saved = message.saved);
    message.score !== void 0 && (obj.score = message.score);
    message.scoreHidden !== void 0 && (obj.scoreHidden = message.scoreHidden);
    message.sendReplies !== void 0 && (obj.sendReplies = message.sendReplies);
    message.spam !== void 0 && (obj.spam = message.spam);
    message.stickied !== void 0 && (obj.stickied = message.stickied);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.subredditId !== void 0 && (obj.subredditId = message.subredditId);
    message.subredditNamePrefixed !== void 0 && (obj.subredditNamePrefixed = message.subredditNamePrefixed);
    message.subredditType !== void 0 && (obj.subredditType = message.subredditType);
    message.topAwardedType !== void 0 && (obj.topAwardedType = message.topAwardedType);
    message.totalAwardsReceived !== void 0 && (obj.totalAwardsReceived = message.totalAwardsReceived);
    if (message.treatmentTags) {
      obj.treatmentTags = message.treatmentTags.map((e) => e);
    } else {
      obj.treatmentTags = [];
    }
    message.unrepliableReason !== void 0 && (obj.unrepliableReason = message.unrepliableReason);
    message.ups !== void 0 && (obj.ups = message.ups);
    if (message.userReports) {
      obj.userReports = message.userReports.map((e) => e);
    } else {
      obj.userReports = [];
    }
    message.count !== void 0 && (obj.count = message.count);
    if (message.children) {
      obj.children = message.children.map((e) => e);
    } else {
      obj.children = [];
    }
    message.banInfo !== void 0 && (obj.banInfo = message.banInfo ? BanInfo.toJSON(message.banInfo) : void 0);
    message.markedSpam !== void 0 && (obj.markedSpam = message.markedSpam);
    message.verdict !== void 0 && (obj.verdict = message.verdict);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseComment();
    message.allAwardings = object.allAwardings?.map((e) => Awarding.fromPartial(e)) || [];
    message.approved = object.approved ?? void 0;
    message.approvedAtUtc = object.approvedAtUtc ?? void 0;
    message.approvedBy = object.approvedBy ?? void 0;
    message.archived = object.archived ?? void 0;
    message.associatedAward = object.associatedAward ?? void 0;
    message.author = object.author ?? void 0;
    message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? void 0;
    message.authorFlairCssClass = object.authorFlairCssClass ?? void 0;
    message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => AuthorFlairRichText.fromPartial(e)) || [];
    message.authorFlairTemplateId = object.authorFlairTemplateId ?? void 0;
    message.authorFlairText = object.authorFlairText ?? void 0;
    message.authorFlairTextColor = object.authorFlairTextColor ?? void 0;
    message.authorFlairType = object.authorFlairType ?? void 0;
    message.authorFullname = object.authorFullname ?? void 0;
    message.authorIsBlocked = object.authorIsBlocked ?? void 0;
    message.authorPatreonFlair = object.authorPatreonFlair ?? void 0;
    message.authorPremium = object.authorPremium ?? void 0;
    message.awarders = object.awarders?.map((e) => e) || [];
    message.bannedAtUtc = object.bannedAtUtc ?? void 0;
    message.bannedBy = object.bannedBy ?? void 0;
    message.body = object.body ?? void 0;
    message.bodyHtml = object.bodyHtml ?? void 0;
    message.canGild = object.canGild ?? void 0;
    message.canModPost = object.canModPost ?? void 0;
    message.collapsed = object.collapsed ?? void 0;
    message.collapsedBecauseCrowdControl = object.collapsedBecauseCrowdControl ?? void 0;
    message.collapsedReason = object.collapsedReason ?? void 0;
    message.collapsedReasonCode = object.collapsedReasonCode ?? void 0;
    message.commentType = object.commentType ?? void 0;
    message.controversiality = object.controversiality ?? void 0;
    message.created = object.created ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.depth = object.depth ?? void 0;
    message.distinguished = object.distinguished ?? void 0;
    message.downs = object.downs ?? void 0;
    message.edited = object.edited ?? void 0;
    message.gilded = object.gilded ?? void 0;
    message.gildings = object.gildings !== void 0 && object.gildings !== null ? Gildings.fromPartial(object.gildings) : void 0;
    message.id = object.id ?? void 0;
    message.ignoreReports = object.ignoreReports ?? void 0;
    message.isSubmitter = object.isSubmitter ?? void 0;
    message.likes = object.likes ?? void 0;
    message.linkId = object.linkId ?? void 0;
    message.locked = object.locked ?? void 0;
    message.modNote = object.modNote ?? void 0;
    message.modReasonBy = object.modReasonBy ?? void 0;
    message.modReasonTitle = object.modReasonTitle ?? void 0;
    message.modReports = object.modReports?.map((e) => e) || [];
    message.name = object.name ?? void 0;
    message.noFollow = object.noFollow ?? void 0;
    message.numReports = object.numReports ?? void 0;
    message.parentId = object.parentId ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.removalReason = object.removalReason ?? void 0;
    message.removed = object.removed ?? void 0;
    message.replies = object.replies ?? void 0;
    message.reportReasons = object.reportReasons?.map((e) => e) || [];
    message.rteMode = object.rteMode ?? void 0;
    message.saved = object.saved ?? void 0;
    message.score = object.score ?? void 0;
    message.scoreHidden = object.scoreHidden ?? void 0;
    message.sendReplies = object.sendReplies ?? void 0;
    message.spam = object.spam ?? void 0;
    message.stickied = object.stickied ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.subredditNamePrefixed = object.subredditNamePrefixed ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.topAwardedType = object.topAwardedType ?? void 0;
    message.totalAwardsReceived = object.totalAwardsReceived ?? void 0;
    message.treatmentTags = object.treatmentTags?.map((e) => e) || [];
    message.unrepliableReason = object.unrepliableReason ?? void 0;
    message.ups = object.ups ?? void 0;
    message.userReports = object.userReports?.map((e) => e) || [];
    message.count = object.count ?? void 0;
    message.children = object.children?.map((e) => e) || [];
    message.banInfo = object.banInfo !== void 0 && object.banInfo !== null ? BanInfo.fromPartial(object.banInfo) : void 0;
    message.markedSpam = object.markedSpam ?? void 0;
    message.verdict = object.verdict ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.Comment", Comment);
function isSet5(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/post.js
var import_minimal7 = __toESM(require_minimal2(), 1);
function createBasePost() {
  return {
    allAwardings: [],
    allowLiveComments: void 0,
    approved: void 0,
    approvedAtUtc: void 0,
    approvedBy: void 0,
    archived: void 0,
    author: void 0,
    authorFlairBackgroundColor: void 0,
    authorFlairCssClass: void 0,
    authorFlairRichtext: [],
    authorFlairTemplateId: void 0,
    authorFlairText: void 0,
    authorFlairTextColor: void 0,
    authorFlairType: void 0,
    authorFullname: void 0,
    authorIsBlocked: void 0,
    authorPatreonFlair: void 0,
    authorPremium: void 0,
    awarders: [],
    bannedAtUtc: void 0,
    bannedBy: void 0,
    canGild: void 0,
    canModPost: void 0,
    category: void 0,
    clicked: void 0,
    contentCategories: [],
    contestMode: void 0,
    created: void 0,
    createdUtc: void 0,
    discussionType: void 0,
    distinguished: void 0,
    domain: void 0,
    downs: void 0,
    edited: void 0,
    gilded: void 0,
    gildings: void 0,
    hidden: void 0,
    hideScore: void 0,
    id: void 0,
    ignoreReports: void 0,
    isCreatedFromAdsUi: void 0,
    isCrosspostable: void 0,
    isMeta: void 0,
    isOriginalContent: void 0,
    isRedditMediaDomain: void 0,
    isRobotIndexable: void 0,
    isSelf: void 0,
    isVideo: void 0,
    likes: void 0,
    linkFlairBackgroundColor: void 0,
    linkFlairCssClass: void 0,
    linkFlairRichtext: [],
    linkFlairTextColor: void 0,
    linkFlairText: void 0,
    linkFlairType: void 0,
    locked: void 0,
    mediaEmbed: void 0,
    mediaOnly: void 0,
    media: void 0,
    modNote: void 0,
    modReasonBy: void 0,
    modReasonTitle: void 0,
    modReports: [],
    name: void 0,
    noFollow: void 0,
    numComments: void 0,
    numCrossposts: void 0,
    numDuplicates: void 0,
    numReports: void 0,
    over18: void 0,
    parentWhitelistStatus: void 0,
    permalink: void 0,
    pinned: void 0,
    postHint: void 0,
    preview: void 0,
    pwls: void 0,
    quarantine: void 0,
    removalReason: void 0,
    removedByCategory: void 0,
    removedBy: void 0,
    removed: void 0,
    reportReasons: [],
    rteMode: void 0,
    saved: void 0,
    score: void 0,
    secureMediaEmbed: void 0,
    secureMedia: void 0,
    selftextHtml: void 0,
    selftext: void 0,
    sendReplies: void 0,
    spam: void 0,
    spoiler: void 0,
    stickied: void 0,
    subredditId: void 0,
    subredditNamePrefixed: void 0,
    subredditSubscribers: void 0,
    subredditType: void 0,
    subreddit: void 0,
    suggestedSort: void 0,
    thumbnailHeight: void 0,
    thumbnailWidth: void 0,
    thumbnail: void 0,
    title: void 0,
    topAwardedType: void 0,
    totalAwardsReceived: void 0,
    treatmentTags: [],
    ups: void 0,
    upvoteRatio: void 0,
    urlOverriddenByDest: void 0,
    url: void 0,
    userReports: [],
    viewCount: void 0,
    visited: void 0,
    whitelistStatus: void 0,
    wls: void 0,
    linkFlairTemplateId: void 0,
    crowdControlLevel: void 0,
    isGallery: void 0,
    isLiveStream: void 0,
    isMetaDiscussion: void 0,
    oembed: void 0,
    banInfo: void 0,
    markedSpam: void 0,
    verdict: void 0,
    gallery: void 0
  };
}
var Post = {
  $type: "devvit.reddit.Post",
  encode(message, writer = import_minimal7.default.Writer.create()) {
    for (const v of message.allAwardings) {
      Awarding.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.allowLiveComments !== void 0) {
      BoolValue.encode({ value: message.allowLiveComments }, writer.uint32(18).fork()).ldelim();
    }
    if (message.approved !== void 0) {
      BoolValue.encode({ value: message.approved }, writer.uint32(26).fork()).ldelim();
    }
    if (message.approvedAtUtc !== void 0) {
      Int32Value.encode({ value: message.approvedAtUtc }, writer.uint32(34).fork()).ldelim();
    }
    if (message.approvedBy !== void 0) {
      StringValue.encode({ value: message.approvedBy }, writer.uint32(42).fork()).ldelim();
    }
    if (message.archived !== void 0) {
      BoolValue.encode({ value: message.archived }, writer.uint32(50).fork()).ldelim();
    }
    if (message.author !== void 0) {
      StringValue.encode({ value: message.author }, writer.uint32(58).fork()).ldelim();
    }
    if (message.authorFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.authorFlairBackgroundColor }, writer.uint32(66).fork()).ldelim();
    }
    if (message.authorFlairCssClass !== void 0) {
      StringValue.encode({ value: message.authorFlairCssClass }, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.authorFlairRichtext) {
      AuthorFlairRichText.encode(v, writer.uint32(82).fork()).ldelim();
    }
    if (message.authorFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.authorFlairTemplateId }, writer.uint32(90).fork()).ldelim();
    }
    if (message.authorFlairText !== void 0) {
      StringValue.encode({ value: message.authorFlairText }, writer.uint32(98).fork()).ldelim();
    }
    if (message.authorFlairTextColor !== void 0) {
      StringValue.encode({ value: message.authorFlairTextColor }, writer.uint32(106).fork()).ldelim();
    }
    if (message.authorFlairType !== void 0) {
      StringValue.encode({ value: message.authorFlairType }, writer.uint32(114).fork()).ldelim();
    }
    if (message.authorFullname !== void 0) {
      StringValue.encode({ value: message.authorFullname }, writer.uint32(122).fork()).ldelim();
    }
    if (message.authorIsBlocked !== void 0) {
      BoolValue.encode({ value: message.authorIsBlocked }, writer.uint32(130).fork()).ldelim();
    }
    if (message.authorPatreonFlair !== void 0) {
      BoolValue.encode({ value: message.authorPatreonFlair }, writer.uint32(138).fork()).ldelim();
    }
    if (message.authorPremium !== void 0) {
      BoolValue.encode({ value: message.authorPremium }, writer.uint32(146).fork()).ldelim();
    }
    for (const v of message.awarders) {
      StringValue.encode({ value: v }, writer.uint32(154).fork()).ldelim();
    }
    if (message.bannedAtUtc !== void 0) {
      Int32Value.encode({ value: message.bannedAtUtc }, writer.uint32(162).fork()).ldelim();
    }
    if (message.bannedBy !== void 0) {
      StringValue.encode({ value: message.bannedBy }, writer.uint32(170).fork()).ldelim();
    }
    if (message.canGild !== void 0) {
      BoolValue.encode({ value: message.canGild }, writer.uint32(178).fork()).ldelim();
    }
    if (message.canModPost !== void 0) {
      BoolValue.encode({ value: message.canModPost }, writer.uint32(186).fork()).ldelim();
    }
    if (message.category !== void 0) {
      StringValue.encode({ value: message.category }, writer.uint32(194).fork()).ldelim();
    }
    if (message.clicked !== void 0) {
      BoolValue.encode({ value: message.clicked }, writer.uint32(202).fork()).ldelim();
    }
    for (const v of message.contentCategories) {
      StringValue.encode({ value: v }, writer.uint32(210).fork()).ldelim();
    }
    if (message.contestMode !== void 0) {
      BoolValue.encode({ value: message.contestMode }, writer.uint32(218).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int32Value.encode({ value: message.created }, writer.uint32(226).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int32Value.encode({ value: message.createdUtc }, writer.uint32(234).fork()).ldelim();
    }
    if (message.discussionType !== void 0) {
      StringValue.encode({ value: message.discussionType }, writer.uint32(242).fork()).ldelim();
    }
    if (message.distinguished !== void 0) {
      StringValue.encode({ value: message.distinguished }, writer.uint32(250).fork()).ldelim();
    }
    if (message.domain !== void 0) {
      StringValue.encode({ value: message.domain }, writer.uint32(258).fork()).ldelim();
    }
    if (message.downs !== void 0) {
      Int32Value.encode({ value: message.downs }, writer.uint32(266).fork()).ldelim();
    }
    if (message.edited !== void 0) {
      BoolValue.encode({ value: message.edited }, writer.uint32(274).fork()).ldelim();
    }
    if (message.gilded !== void 0) {
      Int32Value.encode({ value: message.gilded }, writer.uint32(282).fork()).ldelim();
    }
    if (message.gildings !== void 0) {
      Gildings.encode(message.gildings, writer.uint32(290).fork()).ldelim();
    }
    if (message.hidden !== void 0) {
      BoolValue.encode({ value: message.hidden }, writer.uint32(298).fork()).ldelim();
    }
    if (message.hideScore !== void 0) {
      BoolValue.encode({ value: message.hideScore }, writer.uint32(306).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(314).fork()).ldelim();
    }
    if (message.ignoreReports !== void 0) {
      BoolValue.encode({ value: message.ignoreReports }, writer.uint32(322).fork()).ldelim();
    }
    if (message.isCreatedFromAdsUi !== void 0) {
      BoolValue.encode({ value: message.isCreatedFromAdsUi }, writer.uint32(330).fork()).ldelim();
    }
    if (message.isCrosspostable !== void 0) {
      BoolValue.encode({ value: message.isCrosspostable }, writer.uint32(338).fork()).ldelim();
    }
    if (message.isMeta !== void 0) {
      BoolValue.encode({ value: message.isMeta }, writer.uint32(346).fork()).ldelim();
    }
    if (message.isOriginalContent !== void 0) {
      BoolValue.encode({ value: message.isOriginalContent }, writer.uint32(354).fork()).ldelim();
    }
    if (message.isRedditMediaDomain !== void 0) {
      BoolValue.encode({ value: message.isRedditMediaDomain }, writer.uint32(362).fork()).ldelim();
    }
    if (message.isRobotIndexable !== void 0) {
      BoolValue.encode({ value: message.isRobotIndexable }, writer.uint32(370).fork()).ldelim();
    }
    if (message.isSelf !== void 0) {
      BoolValue.encode({ value: message.isSelf }, writer.uint32(378).fork()).ldelim();
    }
    if (message.isVideo !== void 0) {
      BoolValue.encode({ value: message.isVideo }, writer.uint32(386).fork()).ldelim();
    }
    if (message.likes !== void 0) {
      BoolValue.encode({ value: message.likes }, writer.uint32(394).fork()).ldelim();
    }
    if (message.linkFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.linkFlairBackgroundColor }, writer.uint32(402).fork()).ldelim();
    }
    if (message.linkFlairCssClass !== void 0) {
      StringValue.encode({ value: message.linkFlairCssClass }, writer.uint32(410).fork()).ldelim();
    }
    for (const v of message.linkFlairRichtext) {
      StringValue.encode({ value: v }, writer.uint32(418).fork()).ldelim();
    }
    if (message.linkFlairTextColor !== void 0) {
      StringValue.encode({ value: message.linkFlairTextColor }, writer.uint32(426).fork()).ldelim();
    }
    if (message.linkFlairText !== void 0) {
      StringValue.encode({ value: message.linkFlairText }, writer.uint32(434).fork()).ldelim();
    }
    if (message.linkFlairType !== void 0) {
      StringValue.encode({ value: message.linkFlairType }, writer.uint32(442).fork()).ldelim();
    }
    if (message.locked !== void 0) {
      BoolValue.encode({ value: message.locked }, writer.uint32(450).fork()).ldelim();
    }
    if (message.mediaEmbed !== void 0) {
      MediaEmbed.encode(message.mediaEmbed, writer.uint32(458).fork()).ldelim();
    }
    if (message.mediaOnly !== void 0) {
      BoolValue.encode({ value: message.mediaOnly }, writer.uint32(466).fork()).ldelim();
    }
    if (message.media !== void 0) {
      Media.encode(message.media, writer.uint32(474).fork()).ldelim();
    }
    if (message.modNote !== void 0) {
      StringValue.encode({ value: message.modNote }, writer.uint32(482).fork()).ldelim();
    }
    if (message.modReasonBy !== void 0) {
      StringValue.encode({ value: message.modReasonBy }, writer.uint32(490).fork()).ldelim();
    }
    if (message.modReasonTitle !== void 0) {
      StringValue.encode({ value: message.modReasonTitle }, writer.uint32(498).fork()).ldelim();
    }
    for (const v of message.modReports) {
      ListValue.encode(ListValue.wrap(v), writer.uint32(506).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(514).fork()).ldelim();
    }
    if (message.noFollow !== void 0) {
      BoolValue.encode({ value: message.noFollow }, writer.uint32(522).fork()).ldelim();
    }
    if (message.numComments !== void 0) {
      Int32Value.encode({ value: message.numComments }, writer.uint32(530).fork()).ldelim();
    }
    if (message.numCrossposts !== void 0) {
      Int32Value.encode({ value: message.numCrossposts }, writer.uint32(538).fork()).ldelim();
    }
    if (message.numDuplicates !== void 0) {
      Int32Value.encode({ value: message.numDuplicates }, writer.uint32(546).fork()).ldelim();
    }
    if (message.numReports !== void 0) {
      Int32Value.encode({ value: message.numReports }, writer.uint32(554).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(562).fork()).ldelim();
    }
    if (message.parentWhitelistStatus !== void 0) {
      StringValue.encode({ value: message.parentWhitelistStatus }, writer.uint32(570).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(578).fork()).ldelim();
    }
    if (message.pinned !== void 0) {
      BoolValue.encode({ value: message.pinned }, writer.uint32(586).fork()).ldelim();
    }
    if (message.postHint !== void 0) {
      StringValue.encode({ value: message.postHint }, writer.uint32(594).fork()).ldelim();
    }
    if (message.preview !== void 0) {
      Preview.encode(message.preview, writer.uint32(602).fork()).ldelim();
    }
    if (message.pwls !== void 0) {
      Int32Value.encode({ value: message.pwls }, writer.uint32(610).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(618).fork()).ldelim();
    }
    if (message.removalReason !== void 0) {
      StringValue.encode({ value: message.removalReason }, writer.uint32(626).fork()).ldelim();
    }
    if (message.removedByCategory !== void 0) {
      StringValue.encode({ value: message.removedByCategory }, writer.uint32(634).fork()).ldelim();
    }
    if (message.removedBy !== void 0) {
      StringValue.encode({ value: message.removedBy }, writer.uint32(642).fork()).ldelim();
    }
    if (message.removed !== void 0) {
      BoolValue.encode({ value: message.removed }, writer.uint32(650).fork()).ldelim();
    }
    for (const v of message.reportReasons) {
      StringValue.encode({ value: v }, writer.uint32(658).fork()).ldelim();
    }
    if (message.rteMode !== void 0) {
      StringValue.encode({ value: message.rteMode }, writer.uint32(666).fork()).ldelim();
    }
    if (message.saved !== void 0) {
      BoolValue.encode({ value: message.saved }, writer.uint32(674).fork()).ldelim();
    }
    if (message.score !== void 0) {
      Int32Value.encode({ value: message.score }, writer.uint32(682).fork()).ldelim();
    }
    if (message.secureMediaEmbed !== void 0) {
      MediaEmbed.encode(message.secureMediaEmbed, writer.uint32(690).fork()).ldelim();
    }
    if (message.secureMedia !== void 0) {
      Media.encode(message.secureMedia, writer.uint32(698).fork()).ldelim();
    }
    if (message.selftextHtml !== void 0) {
      StringValue.encode({ value: message.selftextHtml }, writer.uint32(706).fork()).ldelim();
    }
    if (message.selftext !== void 0) {
      StringValue.encode({ value: message.selftext }, writer.uint32(714).fork()).ldelim();
    }
    if (message.sendReplies !== void 0) {
      BoolValue.encode({ value: message.sendReplies }, writer.uint32(722).fork()).ldelim();
    }
    if (message.spam !== void 0) {
      BoolValue.encode({ value: message.spam }, writer.uint32(730).fork()).ldelim();
    }
    if (message.spoiler !== void 0) {
      BoolValue.encode({ value: message.spoiler }, writer.uint32(738).fork()).ldelim();
    }
    if (message.stickied !== void 0) {
      BoolValue.encode({ value: message.stickied }, writer.uint32(746).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(754).fork()).ldelim();
    }
    if (message.subredditNamePrefixed !== void 0) {
      StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(762).fork()).ldelim();
    }
    if (message.subredditSubscribers !== void 0) {
      Int32Value.encode({ value: message.subredditSubscribers }, writer.uint32(770).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(778).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(786).fork()).ldelim();
    }
    if (message.suggestedSort !== void 0) {
      StringValue.encode({ value: message.suggestedSort }, writer.uint32(794).fork()).ldelim();
    }
    if (message.thumbnailHeight !== void 0) {
      Int32Value.encode({ value: message.thumbnailHeight }, writer.uint32(802).fork()).ldelim();
    }
    if (message.thumbnailWidth !== void 0) {
      Int32Value.encode({ value: message.thumbnailWidth }, writer.uint32(810).fork()).ldelim();
    }
    if (message.thumbnail !== void 0) {
      StringValue.encode({ value: message.thumbnail }, writer.uint32(818).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(826).fork()).ldelim();
    }
    if (message.topAwardedType !== void 0) {
      StringValue.encode({ value: message.topAwardedType }, writer.uint32(834).fork()).ldelim();
    }
    if (message.totalAwardsReceived !== void 0) {
      Int32Value.encode({ value: message.totalAwardsReceived }, writer.uint32(842).fork()).ldelim();
    }
    for (const v of message.treatmentTags) {
      StringValue.encode({ value: v }, writer.uint32(850).fork()).ldelim();
    }
    if (message.ups !== void 0) {
      Int32Value.encode({ value: message.ups }, writer.uint32(858).fork()).ldelim();
    }
    if (message.upvoteRatio !== void 0) {
      FloatValue.encode({ value: message.upvoteRatio }, writer.uint32(866).fork()).ldelim();
    }
    if (message.urlOverriddenByDest !== void 0) {
      StringValue.encode({ value: message.urlOverriddenByDest }, writer.uint32(874).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(882).fork()).ldelim();
    }
    for (const v of message.userReports) {
      ListValue.encode(ListValue.wrap(v), writer.uint32(890).fork()).ldelim();
    }
    if (message.viewCount !== void 0) {
      Int32Value.encode({ value: message.viewCount }, writer.uint32(898).fork()).ldelim();
    }
    if (message.visited !== void 0) {
      BoolValue.encode({ value: message.visited }, writer.uint32(906).fork()).ldelim();
    }
    if (message.whitelistStatus !== void 0) {
      StringValue.encode({ value: message.whitelistStatus }, writer.uint32(914).fork()).ldelim();
    }
    if (message.wls !== void 0) {
      Int32Value.encode({ value: message.wls }, writer.uint32(922).fork()).ldelim();
    }
    if (message.linkFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.linkFlairTemplateId }, writer.uint32(1202).fork()).ldelim();
    }
    if (message.crowdControlLevel !== void 0) {
      Int32Value.encode({ value: message.crowdControlLevel }, writer.uint32(1210).fork()).ldelim();
    }
    if (message.isGallery !== void 0) {
      BoolValue.encode({ value: message.isGallery }, writer.uint32(1218).fork()).ldelim();
    }
    if (message.isLiveStream !== void 0) {
      BoolValue.encode({ value: message.isLiveStream }, writer.uint32(1226).fork()).ldelim();
    }
    if (message.isMetaDiscussion !== void 0) {
      BoolValue.encode({ value: message.isMetaDiscussion }, writer.uint32(1234).fork()).ldelim();
    }
    if (message.oembed !== void 0) {
      OEmbed.encode(message.oembed, writer.uint32(1242).fork()).ldelim();
    }
    if (message.banInfo !== void 0) {
      BanInfo.encode(message.banInfo, writer.uint32(1250).fork()).ldelim();
    }
    if (message.markedSpam !== void 0) {
      BoolValue.encode({ value: message.markedSpam }, writer.uint32(1258).fork()).ldelim();
    }
    if (message.verdict !== void 0) {
      StringValue.encode({ value: message.verdict }, writer.uint32(1266).fork()).ldelim();
    }
    if (message.gallery !== void 0) {
      RedditPostGallery.encode(message.gallery, writer.uint32(1274).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : new import_minimal7.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.allAwardings.push(Awarding.decode(reader, reader.uint32()));
          break;
        case 2:
          message.allowLiveComments = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.approved = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.approvedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.approvedBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.archived = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.author = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.authorFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.authorFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.authorFlairRichtext.push(AuthorFlairRichText.decode(reader, reader.uint32()));
          break;
        case 11:
          message.authorFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.authorFlairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.authorFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.authorFlairType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.authorFullname = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.authorIsBlocked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.authorPatreonFlair = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.authorPremium = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.awarders.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 20:
          message.bannedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.bannedBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.canGild = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.canModPost = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.category = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.clicked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.contentCategories.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 27:
          message.contestMode = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.created = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.createdUtc = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.discussionType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.distinguished = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.domain = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.downs = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.edited = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 35:
          message.gilded = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.gildings = Gildings.decode(reader, reader.uint32());
          break;
        case 37:
          message.hidden = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 38:
          message.hideScore = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 39:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 40:
          message.ignoreReports = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 41:
          message.isCreatedFromAdsUi = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 42:
          message.isCrosspostable = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 43:
          message.isMeta = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 44:
          message.isOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 45:
          message.isRedditMediaDomain = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 46:
          message.isRobotIndexable = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 47:
          message.isSelf = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 48:
          message.isVideo = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 49:
          message.likes = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 50:
          message.linkFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 51:
          message.linkFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 52:
          message.linkFlairRichtext.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 53:
          message.linkFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 54:
          message.linkFlairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 55:
          message.linkFlairType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 56:
          message.locked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 57:
          message.mediaEmbed = MediaEmbed.decode(reader, reader.uint32());
          break;
        case 58:
          message.mediaOnly = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 59:
          message.media = Media.decode(reader, reader.uint32());
          break;
        case 60:
          message.modNote = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 61:
          message.modReasonBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 62:
          message.modReasonTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 63:
          message.modReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          break;
        case 64:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 65:
          message.noFollow = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 66:
          message.numComments = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 67:
          message.numCrossposts = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 68:
          message.numDuplicates = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 69:
          message.numReports = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 70:
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 71:
          message.parentWhitelistStatus = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 72:
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 73:
          message.pinned = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 74:
          message.postHint = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 75:
          message.preview = Preview.decode(reader, reader.uint32());
          break;
        case 76:
          message.pwls = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 77:
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 78:
          message.removalReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 79:
          message.removedByCategory = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 80:
          message.removedBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 81:
          message.removed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 82:
          message.reportReasons.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 83:
          message.rteMode = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 84:
          message.saved = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 85:
          message.score = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 86:
          message.secureMediaEmbed = MediaEmbed.decode(reader, reader.uint32());
          break;
        case 87:
          message.secureMedia = Media.decode(reader, reader.uint32());
          break;
        case 88:
          message.selftextHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 89:
          message.selftext = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 90:
          message.sendReplies = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 91:
          message.spam = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 92:
          message.spoiler = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 93:
          message.stickied = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 94:
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 95:
          message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 96:
          message.subredditSubscribers = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 97:
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 98:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 99:
          message.suggestedSort = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 100:
          message.thumbnailHeight = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 101:
          message.thumbnailWidth = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 102:
          message.thumbnail = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 103:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 104:
          message.topAwardedType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 105:
          message.totalAwardsReceived = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 106:
          message.treatmentTags.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 107:
          message.ups = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 108:
          message.upvoteRatio = FloatValue.decode(reader, reader.uint32()).value;
          break;
        case 109:
          message.urlOverriddenByDest = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 110:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 111:
          message.userReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          break;
        case 112:
          message.viewCount = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 113:
          message.visited = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 114:
          message.whitelistStatus = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 115:
          message.wls = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 150:
          message.linkFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 151:
          message.crowdControlLevel = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 152:
          message.isGallery = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 153:
          message.isLiveStream = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 154:
          message.isMetaDiscussion = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 155:
          message.oembed = OEmbed.decode(reader, reader.uint32());
          break;
        case 156:
          message.banInfo = BanInfo.decode(reader, reader.uint32());
          break;
        case 157:
          message.markedSpam = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 158:
          message.verdict = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 159:
          message.gallery = RedditPostGallery.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      allAwardings: Array.isArray(object?.allAwardings) ? object.allAwardings.map((e) => Awarding.fromJSON(e)) : [],
      allowLiveComments: isSet6(object.allowLiveComments) ? Boolean(object.allowLiveComments) : void 0,
      approved: isSet6(object.approved) ? Boolean(object.approved) : void 0,
      approvedAtUtc: isSet6(object.approvedAtUtc) ? Number(object.approvedAtUtc) : void 0,
      approvedBy: isSet6(object.approvedBy) ? String(object.approvedBy) : void 0,
      archived: isSet6(object.archived) ? Boolean(object.archived) : void 0,
      author: isSet6(object.author) ? String(object.author) : void 0,
      authorFlairBackgroundColor: isSet6(object.authorFlairBackgroundColor) ? String(object.authorFlairBackgroundColor) : void 0,
      authorFlairCssClass: isSet6(object.authorFlairCssClass) ? String(object.authorFlairCssClass) : void 0,
      authorFlairRichtext: Array.isArray(object?.authorFlairRichtext) ? object.authorFlairRichtext.map((e) => AuthorFlairRichText.fromJSON(e)) : [],
      authorFlairTemplateId: isSet6(object.authorFlairTemplateId) ? String(object.authorFlairTemplateId) : void 0,
      authorFlairText: isSet6(object.authorFlairText) ? String(object.authorFlairText) : void 0,
      authorFlairTextColor: isSet6(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : void 0,
      authorFlairType: isSet6(object.authorFlairType) ? String(object.authorFlairType) : void 0,
      authorFullname: isSet6(object.authorFullname) ? String(object.authorFullname) : void 0,
      authorIsBlocked: isSet6(object.authorIsBlocked) ? Boolean(object.authorIsBlocked) : void 0,
      authorPatreonFlair: isSet6(object.authorPatreonFlair) ? Boolean(object.authorPatreonFlair) : void 0,
      authorPremium: isSet6(object.authorPremium) ? Boolean(object.authorPremium) : void 0,
      awarders: Array.isArray(object?.awarders) ? object.awarders.map((e) => String(e)) : [],
      bannedAtUtc: isSet6(object.bannedAtUtc) ? Number(object.bannedAtUtc) : void 0,
      bannedBy: isSet6(object.bannedBy) ? String(object.bannedBy) : void 0,
      canGild: isSet6(object.canGild) ? Boolean(object.canGild) : void 0,
      canModPost: isSet6(object.canModPost) ? Boolean(object.canModPost) : void 0,
      category: isSet6(object.category) ? String(object.category) : void 0,
      clicked: isSet6(object.clicked) ? Boolean(object.clicked) : void 0,
      contentCategories: Array.isArray(object?.contentCategories) ? object.contentCategories.map((e) => String(e)) : [],
      contestMode: isSet6(object.contestMode) ? Boolean(object.contestMode) : void 0,
      created: isSet6(object.created) ? Number(object.created) : void 0,
      createdUtc: isSet6(object.createdUtc) ? Number(object.createdUtc) : void 0,
      discussionType: isSet6(object.discussionType) ? String(object.discussionType) : void 0,
      distinguished: isSet6(object.distinguished) ? String(object.distinguished) : void 0,
      domain: isSet6(object.domain) ? String(object.domain) : void 0,
      downs: isSet6(object.downs) ? Number(object.downs) : void 0,
      edited: isSet6(object.edited) ? Boolean(object.edited) : void 0,
      gilded: isSet6(object.gilded) ? Number(object.gilded) : void 0,
      gildings: isSet6(object.gildings) ? Gildings.fromJSON(object.gildings) : void 0,
      hidden: isSet6(object.hidden) ? Boolean(object.hidden) : void 0,
      hideScore: isSet6(object.hideScore) ? Boolean(object.hideScore) : void 0,
      id: isSet6(object.id) ? String(object.id) : void 0,
      ignoreReports: isSet6(object.ignoreReports) ? Boolean(object.ignoreReports) : void 0,
      isCreatedFromAdsUi: isSet6(object.isCreatedFromAdsUi) ? Boolean(object.isCreatedFromAdsUi) : void 0,
      isCrosspostable: isSet6(object.isCrosspostable) ? Boolean(object.isCrosspostable) : void 0,
      isMeta: isSet6(object.isMeta) ? Boolean(object.isMeta) : void 0,
      isOriginalContent: isSet6(object.isOriginalContent) ? Boolean(object.isOriginalContent) : void 0,
      isRedditMediaDomain: isSet6(object.isRedditMediaDomain) ? Boolean(object.isRedditMediaDomain) : void 0,
      isRobotIndexable: isSet6(object.isRobotIndexable) ? Boolean(object.isRobotIndexable) : void 0,
      isSelf: isSet6(object.isSelf) ? Boolean(object.isSelf) : void 0,
      isVideo: isSet6(object.isVideo) ? Boolean(object.isVideo) : void 0,
      likes: isSet6(object.likes) ? Boolean(object.likes) : void 0,
      linkFlairBackgroundColor: isSet6(object.linkFlairBackgroundColor) ? String(object.linkFlairBackgroundColor) : void 0,
      linkFlairCssClass: isSet6(object.linkFlairCssClass) ? String(object.linkFlairCssClass) : void 0,
      linkFlairRichtext: Array.isArray(object?.linkFlairRichtext) ? object.linkFlairRichtext.map((e) => String(e)) : [],
      linkFlairTextColor: isSet6(object.linkFlairTextColor) ? String(object.linkFlairTextColor) : void 0,
      linkFlairText: isSet6(object.linkFlairText) ? String(object.linkFlairText) : void 0,
      linkFlairType: isSet6(object.linkFlairType) ? String(object.linkFlairType) : void 0,
      locked: isSet6(object.locked) ? Boolean(object.locked) : void 0,
      mediaEmbed: isSet6(object.mediaEmbed) ? MediaEmbed.fromJSON(object.mediaEmbed) : void 0,
      mediaOnly: isSet6(object.mediaOnly) ? Boolean(object.mediaOnly) : void 0,
      media: isSet6(object.media) ? Media.fromJSON(object.media) : void 0,
      modNote: isSet6(object.modNote) ? String(object.modNote) : void 0,
      modReasonBy: isSet6(object.modReasonBy) ? String(object.modReasonBy) : void 0,
      modReasonTitle: isSet6(object.modReasonTitle) ? String(object.modReasonTitle) : void 0,
      modReports: Array.isArray(object?.modReports) ? object.modReports.map((e) => [...e]) : [],
      name: isSet6(object.name) ? String(object.name) : void 0,
      noFollow: isSet6(object.noFollow) ? Boolean(object.noFollow) : void 0,
      numComments: isSet6(object.numComments) ? Number(object.numComments) : void 0,
      numCrossposts: isSet6(object.numCrossposts) ? Number(object.numCrossposts) : void 0,
      numDuplicates: isSet6(object.numDuplicates) ? Number(object.numDuplicates) : void 0,
      numReports: isSet6(object.numReports) ? Number(object.numReports) : void 0,
      over18: isSet6(object.over18) ? Boolean(object.over18) : void 0,
      parentWhitelistStatus: isSet6(object.parentWhitelistStatus) ? String(object.parentWhitelistStatus) : void 0,
      permalink: isSet6(object.permalink) ? String(object.permalink) : void 0,
      pinned: isSet6(object.pinned) ? Boolean(object.pinned) : void 0,
      postHint: isSet6(object.postHint) ? String(object.postHint) : void 0,
      preview: isSet6(object.preview) ? Preview.fromJSON(object.preview) : void 0,
      pwls: isSet6(object.pwls) ? Number(object.pwls) : void 0,
      quarantine: isSet6(object.quarantine) ? Boolean(object.quarantine) : void 0,
      removalReason: isSet6(object.removalReason) ? String(object.removalReason) : void 0,
      removedByCategory: isSet6(object.removedByCategory) ? String(object.removedByCategory) : void 0,
      removedBy: isSet6(object.removedBy) ? String(object.removedBy) : void 0,
      removed: isSet6(object.removed) ? Boolean(object.removed) : void 0,
      reportReasons: Array.isArray(object?.reportReasons) ? object.reportReasons.map((e) => String(e)) : [],
      rteMode: isSet6(object.rteMode) ? String(object.rteMode) : void 0,
      saved: isSet6(object.saved) ? Boolean(object.saved) : void 0,
      score: isSet6(object.score) ? Number(object.score) : void 0,
      secureMediaEmbed: isSet6(object.secureMediaEmbed) ? MediaEmbed.fromJSON(object.secureMediaEmbed) : void 0,
      secureMedia: isSet6(object.secureMedia) ? Media.fromJSON(object.secureMedia) : void 0,
      selftextHtml: isSet6(object.selftextHtml) ? String(object.selftextHtml) : void 0,
      selftext: isSet6(object.selftext) ? String(object.selftext) : void 0,
      sendReplies: isSet6(object.sendReplies) ? Boolean(object.sendReplies) : void 0,
      spam: isSet6(object.spam) ? Boolean(object.spam) : void 0,
      spoiler: isSet6(object.spoiler) ? Boolean(object.spoiler) : void 0,
      stickied: isSet6(object.stickied) ? Boolean(object.stickied) : void 0,
      subredditId: isSet6(object.subredditId) ? String(object.subredditId) : void 0,
      subredditNamePrefixed: isSet6(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : void 0,
      subredditSubscribers: isSet6(object.subredditSubscribers) ? Number(object.subredditSubscribers) : void 0,
      subredditType: isSet6(object.subredditType) ? String(object.subredditType) : void 0,
      subreddit: isSet6(object.subreddit) ? String(object.subreddit) : void 0,
      suggestedSort: isSet6(object.suggestedSort) ? String(object.suggestedSort) : void 0,
      thumbnailHeight: isSet6(object.thumbnailHeight) ? Number(object.thumbnailHeight) : void 0,
      thumbnailWidth: isSet6(object.thumbnailWidth) ? Number(object.thumbnailWidth) : void 0,
      thumbnail: isSet6(object.thumbnail) ? String(object.thumbnail) : void 0,
      title: isSet6(object.title) ? String(object.title) : void 0,
      topAwardedType: isSet6(object.topAwardedType) ? String(object.topAwardedType) : void 0,
      totalAwardsReceived: isSet6(object.totalAwardsReceived) ? Number(object.totalAwardsReceived) : void 0,
      treatmentTags: Array.isArray(object?.treatmentTags) ? object.treatmentTags.map((e) => String(e)) : [],
      ups: isSet6(object.ups) ? Number(object.ups) : void 0,
      upvoteRatio: isSet6(object.upvoteRatio) ? Number(object.upvoteRatio) : void 0,
      urlOverriddenByDest: isSet6(object.urlOverriddenByDest) ? String(object.urlOverriddenByDest) : void 0,
      url: isSet6(object.url) ? String(object.url) : void 0,
      userReports: Array.isArray(object?.userReports) ? object.userReports.map((e) => [...e]) : [],
      viewCount: isSet6(object.viewCount) ? Number(object.viewCount) : void 0,
      visited: isSet6(object.visited) ? Boolean(object.visited) : void 0,
      whitelistStatus: isSet6(object.whitelistStatus) ? String(object.whitelistStatus) : void 0,
      wls: isSet6(object.wls) ? Number(object.wls) : void 0,
      linkFlairTemplateId: isSet6(object.linkFlairTemplateId) ? String(object.linkFlairTemplateId) : void 0,
      crowdControlLevel: isSet6(object.crowdControlLevel) ? Number(object.crowdControlLevel) : void 0,
      isGallery: isSet6(object.isGallery) ? Boolean(object.isGallery) : void 0,
      isLiveStream: isSet6(object.isLiveStream) ? Boolean(object.isLiveStream) : void 0,
      isMetaDiscussion: isSet6(object.isMetaDiscussion) ? Boolean(object.isMetaDiscussion) : void 0,
      oembed: isSet6(object.oembed) ? OEmbed.fromJSON(object.oembed) : void 0,
      banInfo: isSet6(object.banInfo) ? BanInfo.fromJSON(object.banInfo) : void 0,
      markedSpam: isSet6(object.markedSpam) ? Boolean(object.markedSpam) : void 0,
      verdict: isSet6(object.verdict) ? String(object.verdict) : void 0,
      gallery: isSet6(object.gallery) ? RedditPostGallery.fromJSON(object.gallery) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allAwardings) {
      obj.allAwardings = message.allAwardings.map((e) => e ? Awarding.toJSON(e) : void 0);
    } else {
      obj.allAwardings = [];
    }
    message.allowLiveComments !== void 0 && (obj.allowLiveComments = message.allowLiveComments);
    message.approved !== void 0 && (obj.approved = message.approved);
    message.approvedAtUtc !== void 0 && (obj.approvedAtUtc = message.approvedAtUtc);
    message.approvedBy !== void 0 && (obj.approvedBy = message.approvedBy);
    message.archived !== void 0 && (obj.archived = message.archived);
    message.author !== void 0 && (obj.author = message.author);
    message.authorFlairBackgroundColor !== void 0 && (obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor);
    message.authorFlairCssClass !== void 0 && (obj.authorFlairCssClass = message.authorFlairCssClass);
    if (message.authorFlairRichtext) {
      obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => e ? AuthorFlairRichText.toJSON(e) : void 0);
    } else {
      obj.authorFlairRichtext = [];
    }
    message.authorFlairTemplateId !== void 0 && (obj.authorFlairTemplateId = message.authorFlairTemplateId);
    message.authorFlairText !== void 0 && (obj.authorFlairText = message.authorFlairText);
    message.authorFlairTextColor !== void 0 && (obj.authorFlairTextColor = message.authorFlairTextColor);
    message.authorFlairType !== void 0 && (obj.authorFlairType = message.authorFlairType);
    message.authorFullname !== void 0 && (obj.authorFullname = message.authorFullname);
    message.authorIsBlocked !== void 0 && (obj.authorIsBlocked = message.authorIsBlocked);
    message.authorPatreonFlair !== void 0 && (obj.authorPatreonFlair = message.authorPatreonFlair);
    message.authorPremium !== void 0 && (obj.authorPremium = message.authorPremium);
    if (message.awarders) {
      obj.awarders = message.awarders.map((e) => e);
    } else {
      obj.awarders = [];
    }
    message.bannedAtUtc !== void 0 && (obj.bannedAtUtc = message.bannedAtUtc);
    message.bannedBy !== void 0 && (obj.bannedBy = message.bannedBy);
    message.canGild !== void 0 && (obj.canGild = message.canGild);
    message.canModPost !== void 0 && (obj.canModPost = message.canModPost);
    message.category !== void 0 && (obj.category = message.category);
    message.clicked !== void 0 && (obj.clicked = message.clicked);
    if (message.contentCategories) {
      obj.contentCategories = message.contentCategories.map((e) => e);
    } else {
      obj.contentCategories = [];
    }
    message.contestMode !== void 0 && (obj.contestMode = message.contestMode);
    message.created !== void 0 && (obj.created = message.created);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    message.discussionType !== void 0 && (obj.discussionType = message.discussionType);
    message.distinguished !== void 0 && (obj.distinguished = message.distinguished);
    message.domain !== void 0 && (obj.domain = message.domain);
    message.downs !== void 0 && (obj.downs = message.downs);
    message.edited !== void 0 && (obj.edited = message.edited);
    message.gilded !== void 0 && (obj.gilded = message.gilded);
    message.gildings !== void 0 && (obj.gildings = message.gildings ? Gildings.toJSON(message.gildings) : void 0);
    message.hidden !== void 0 && (obj.hidden = message.hidden);
    message.hideScore !== void 0 && (obj.hideScore = message.hideScore);
    message.id !== void 0 && (obj.id = message.id);
    message.ignoreReports !== void 0 && (obj.ignoreReports = message.ignoreReports);
    message.isCreatedFromAdsUi !== void 0 && (obj.isCreatedFromAdsUi = message.isCreatedFromAdsUi);
    message.isCrosspostable !== void 0 && (obj.isCrosspostable = message.isCrosspostable);
    message.isMeta !== void 0 && (obj.isMeta = message.isMeta);
    message.isOriginalContent !== void 0 && (obj.isOriginalContent = message.isOriginalContent);
    message.isRedditMediaDomain !== void 0 && (obj.isRedditMediaDomain = message.isRedditMediaDomain);
    message.isRobotIndexable !== void 0 && (obj.isRobotIndexable = message.isRobotIndexable);
    message.isSelf !== void 0 && (obj.isSelf = message.isSelf);
    message.isVideo !== void 0 && (obj.isVideo = message.isVideo);
    message.likes !== void 0 && (obj.likes = message.likes);
    message.linkFlairBackgroundColor !== void 0 && (obj.linkFlairBackgroundColor = message.linkFlairBackgroundColor);
    message.linkFlairCssClass !== void 0 && (obj.linkFlairCssClass = message.linkFlairCssClass);
    if (message.linkFlairRichtext) {
      obj.linkFlairRichtext = message.linkFlairRichtext.map((e) => e);
    } else {
      obj.linkFlairRichtext = [];
    }
    message.linkFlairTextColor !== void 0 && (obj.linkFlairTextColor = message.linkFlairTextColor);
    message.linkFlairText !== void 0 && (obj.linkFlairText = message.linkFlairText);
    message.linkFlairType !== void 0 && (obj.linkFlairType = message.linkFlairType);
    message.locked !== void 0 && (obj.locked = message.locked);
    message.mediaEmbed !== void 0 && (obj.mediaEmbed = message.mediaEmbed ? MediaEmbed.toJSON(message.mediaEmbed) : void 0);
    message.mediaOnly !== void 0 && (obj.mediaOnly = message.mediaOnly);
    message.media !== void 0 && (obj.media = message.media ? Media.toJSON(message.media) : void 0);
    message.modNote !== void 0 && (obj.modNote = message.modNote);
    message.modReasonBy !== void 0 && (obj.modReasonBy = message.modReasonBy);
    message.modReasonTitle !== void 0 && (obj.modReasonTitle = message.modReasonTitle);
    if (message.modReports) {
      obj.modReports = message.modReports.map((e) => e);
    } else {
      obj.modReports = [];
    }
    message.name !== void 0 && (obj.name = message.name);
    message.noFollow !== void 0 && (obj.noFollow = message.noFollow);
    message.numComments !== void 0 && (obj.numComments = message.numComments);
    message.numCrossposts !== void 0 && (obj.numCrossposts = message.numCrossposts);
    message.numDuplicates !== void 0 && (obj.numDuplicates = message.numDuplicates);
    message.numReports !== void 0 && (obj.numReports = message.numReports);
    message.over18 !== void 0 && (obj.over18 = message.over18);
    message.parentWhitelistStatus !== void 0 && (obj.parentWhitelistStatus = message.parentWhitelistStatus);
    message.permalink !== void 0 && (obj.permalink = message.permalink);
    message.pinned !== void 0 && (obj.pinned = message.pinned);
    message.postHint !== void 0 && (obj.postHint = message.postHint);
    message.preview !== void 0 && (obj.preview = message.preview ? Preview.toJSON(message.preview) : void 0);
    message.pwls !== void 0 && (obj.pwls = message.pwls);
    message.quarantine !== void 0 && (obj.quarantine = message.quarantine);
    message.removalReason !== void 0 && (obj.removalReason = message.removalReason);
    message.removedByCategory !== void 0 && (obj.removedByCategory = message.removedByCategory);
    message.removedBy !== void 0 && (obj.removedBy = message.removedBy);
    message.removed !== void 0 && (obj.removed = message.removed);
    if (message.reportReasons) {
      obj.reportReasons = message.reportReasons.map((e) => e);
    } else {
      obj.reportReasons = [];
    }
    message.rteMode !== void 0 && (obj.rteMode = message.rteMode);
    message.saved !== void 0 && (obj.saved = message.saved);
    message.score !== void 0 && (obj.score = message.score);
    message.secureMediaEmbed !== void 0 && (obj.secureMediaEmbed = message.secureMediaEmbed ? MediaEmbed.toJSON(message.secureMediaEmbed) : void 0);
    message.secureMedia !== void 0 && (obj.secureMedia = message.secureMedia ? Media.toJSON(message.secureMedia) : void 0);
    message.selftextHtml !== void 0 && (obj.selftextHtml = message.selftextHtml);
    message.selftext !== void 0 && (obj.selftext = message.selftext);
    message.sendReplies !== void 0 && (obj.sendReplies = message.sendReplies);
    message.spam !== void 0 && (obj.spam = message.spam);
    message.spoiler !== void 0 && (obj.spoiler = message.spoiler);
    message.stickied !== void 0 && (obj.stickied = message.stickied);
    message.subredditId !== void 0 && (obj.subredditId = message.subredditId);
    message.subredditNamePrefixed !== void 0 && (obj.subredditNamePrefixed = message.subredditNamePrefixed);
    message.subredditSubscribers !== void 0 && (obj.subredditSubscribers = message.subredditSubscribers);
    message.subredditType !== void 0 && (obj.subredditType = message.subredditType);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.suggestedSort !== void 0 && (obj.suggestedSort = message.suggestedSort);
    message.thumbnailHeight !== void 0 && (obj.thumbnailHeight = message.thumbnailHeight);
    message.thumbnailWidth !== void 0 && (obj.thumbnailWidth = message.thumbnailWidth);
    message.thumbnail !== void 0 && (obj.thumbnail = message.thumbnail);
    message.title !== void 0 && (obj.title = message.title);
    message.topAwardedType !== void 0 && (obj.topAwardedType = message.topAwardedType);
    message.totalAwardsReceived !== void 0 && (obj.totalAwardsReceived = message.totalAwardsReceived);
    if (message.treatmentTags) {
      obj.treatmentTags = message.treatmentTags.map((e) => e);
    } else {
      obj.treatmentTags = [];
    }
    message.ups !== void 0 && (obj.ups = message.ups);
    message.upvoteRatio !== void 0 && (obj.upvoteRatio = message.upvoteRatio);
    message.urlOverriddenByDest !== void 0 && (obj.urlOverriddenByDest = message.urlOverriddenByDest);
    message.url !== void 0 && (obj.url = message.url);
    if (message.userReports) {
      obj.userReports = message.userReports.map((e) => e);
    } else {
      obj.userReports = [];
    }
    message.viewCount !== void 0 && (obj.viewCount = message.viewCount);
    message.visited !== void 0 && (obj.visited = message.visited);
    message.whitelistStatus !== void 0 && (obj.whitelistStatus = message.whitelistStatus);
    message.wls !== void 0 && (obj.wls = message.wls);
    message.linkFlairTemplateId !== void 0 && (obj.linkFlairTemplateId = message.linkFlairTemplateId);
    message.crowdControlLevel !== void 0 && (obj.crowdControlLevel = message.crowdControlLevel);
    message.isGallery !== void 0 && (obj.isGallery = message.isGallery);
    message.isLiveStream !== void 0 && (obj.isLiveStream = message.isLiveStream);
    message.isMetaDiscussion !== void 0 && (obj.isMetaDiscussion = message.isMetaDiscussion);
    message.oembed !== void 0 && (obj.oembed = message.oembed ? OEmbed.toJSON(message.oembed) : void 0);
    message.banInfo !== void 0 && (obj.banInfo = message.banInfo ? BanInfo.toJSON(message.banInfo) : void 0);
    message.markedSpam !== void 0 && (obj.markedSpam = message.markedSpam);
    message.verdict !== void 0 && (obj.verdict = message.verdict);
    message.gallery !== void 0 && (obj.gallery = message.gallery ? RedditPostGallery.toJSON(message.gallery) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePost();
    message.allAwardings = object.allAwardings?.map((e) => Awarding.fromPartial(e)) || [];
    message.allowLiveComments = object.allowLiveComments ?? void 0;
    message.approved = object.approved ?? void 0;
    message.approvedAtUtc = object.approvedAtUtc ?? void 0;
    message.approvedBy = object.approvedBy ?? void 0;
    message.archived = object.archived ?? void 0;
    message.author = object.author ?? void 0;
    message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? void 0;
    message.authorFlairCssClass = object.authorFlairCssClass ?? void 0;
    message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => AuthorFlairRichText.fromPartial(e)) || [];
    message.authorFlairTemplateId = object.authorFlairTemplateId ?? void 0;
    message.authorFlairText = object.authorFlairText ?? void 0;
    message.authorFlairTextColor = object.authorFlairTextColor ?? void 0;
    message.authorFlairType = object.authorFlairType ?? void 0;
    message.authorFullname = object.authorFullname ?? void 0;
    message.authorIsBlocked = object.authorIsBlocked ?? void 0;
    message.authorPatreonFlair = object.authorPatreonFlair ?? void 0;
    message.authorPremium = object.authorPremium ?? void 0;
    message.awarders = object.awarders?.map((e) => e) || [];
    message.bannedAtUtc = object.bannedAtUtc ?? void 0;
    message.bannedBy = object.bannedBy ?? void 0;
    message.canGild = object.canGild ?? void 0;
    message.canModPost = object.canModPost ?? void 0;
    message.category = object.category ?? void 0;
    message.clicked = object.clicked ?? void 0;
    message.contentCategories = object.contentCategories?.map((e) => e) || [];
    message.contestMode = object.contestMode ?? void 0;
    message.created = object.created ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.discussionType = object.discussionType ?? void 0;
    message.distinguished = object.distinguished ?? void 0;
    message.domain = object.domain ?? void 0;
    message.downs = object.downs ?? void 0;
    message.edited = object.edited ?? void 0;
    message.gilded = object.gilded ?? void 0;
    message.gildings = object.gildings !== void 0 && object.gildings !== null ? Gildings.fromPartial(object.gildings) : void 0;
    message.hidden = object.hidden ?? void 0;
    message.hideScore = object.hideScore ?? void 0;
    message.id = object.id ?? void 0;
    message.ignoreReports = object.ignoreReports ?? void 0;
    message.isCreatedFromAdsUi = object.isCreatedFromAdsUi ?? void 0;
    message.isCrosspostable = object.isCrosspostable ?? void 0;
    message.isMeta = object.isMeta ?? void 0;
    message.isOriginalContent = object.isOriginalContent ?? void 0;
    message.isRedditMediaDomain = object.isRedditMediaDomain ?? void 0;
    message.isRobotIndexable = object.isRobotIndexable ?? void 0;
    message.isSelf = object.isSelf ?? void 0;
    message.isVideo = object.isVideo ?? void 0;
    message.likes = object.likes ?? void 0;
    message.linkFlairBackgroundColor = object.linkFlairBackgroundColor ?? void 0;
    message.linkFlairCssClass = object.linkFlairCssClass ?? void 0;
    message.linkFlairRichtext = object.linkFlairRichtext?.map((e) => e) || [];
    message.linkFlairTextColor = object.linkFlairTextColor ?? void 0;
    message.linkFlairText = object.linkFlairText ?? void 0;
    message.linkFlairType = object.linkFlairType ?? void 0;
    message.locked = object.locked ?? void 0;
    message.mediaEmbed = object.mediaEmbed !== void 0 && object.mediaEmbed !== null ? MediaEmbed.fromPartial(object.mediaEmbed) : void 0;
    message.mediaOnly = object.mediaOnly ?? void 0;
    message.media = object.media !== void 0 && object.media !== null ? Media.fromPartial(object.media) : void 0;
    message.modNote = object.modNote ?? void 0;
    message.modReasonBy = object.modReasonBy ?? void 0;
    message.modReasonTitle = object.modReasonTitle ?? void 0;
    message.modReports = object.modReports?.map((e) => e) || [];
    message.name = object.name ?? void 0;
    message.noFollow = object.noFollow ?? void 0;
    message.numComments = object.numComments ?? void 0;
    message.numCrossposts = object.numCrossposts ?? void 0;
    message.numDuplicates = object.numDuplicates ?? void 0;
    message.numReports = object.numReports ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.parentWhitelistStatus = object.parentWhitelistStatus ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.pinned = object.pinned ?? void 0;
    message.postHint = object.postHint ?? void 0;
    message.preview = object.preview !== void 0 && object.preview !== null ? Preview.fromPartial(object.preview) : void 0;
    message.pwls = object.pwls ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.removalReason = object.removalReason ?? void 0;
    message.removedByCategory = object.removedByCategory ?? void 0;
    message.removedBy = object.removedBy ?? void 0;
    message.removed = object.removed ?? void 0;
    message.reportReasons = object.reportReasons?.map((e) => e) || [];
    message.rteMode = object.rteMode ?? void 0;
    message.saved = object.saved ?? void 0;
    message.score = object.score ?? void 0;
    message.secureMediaEmbed = object.secureMediaEmbed !== void 0 && object.secureMediaEmbed !== null ? MediaEmbed.fromPartial(object.secureMediaEmbed) : void 0;
    message.secureMedia = object.secureMedia !== void 0 && object.secureMedia !== null ? Media.fromPartial(object.secureMedia) : void 0;
    message.selftextHtml = object.selftextHtml ?? void 0;
    message.selftext = object.selftext ?? void 0;
    message.sendReplies = object.sendReplies ?? void 0;
    message.spam = object.spam ?? void 0;
    message.spoiler = object.spoiler ?? void 0;
    message.stickied = object.stickied ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.subredditNamePrefixed = object.subredditNamePrefixed ?? void 0;
    message.subredditSubscribers = object.subredditSubscribers ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.suggestedSort = object.suggestedSort ?? void 0;
    message.thumbnailHeight = object.thumbnailHeight ?? void 0;
    message.thumbnailWidth = object.thumbnailWidth ?? void 0;
    message.thumbnail = object.thumbnail ?? void 0;
    message.title = object.title ?? void 0;
    message.topAwardedType = object.topAwardedType ?? void 0;
    message.totalAwardsReceived = object.totalAwardsReceived ?? void 0;
    message.treatmentTags = object.treatmentTags?.map((e) => e) || [];
    message.ups = object.ups ?? void 0;
    message.upvoteRatio = object.upvoteRatio ?? void 0;
    message.urlOverriddenByDest = object.urlOverriddenByDest ?? void 0;
    message.url = object.url ?? void 0;
    message.userReports = object.userReports?.map((e) => e) || [];
    message.viewCount = object.viewCount ?? void 0;
    message.visited = object.visited ?? void 0;
    message.whitelistStatus = object.whitelistStatus ?? void 0;
    message.wls = object.wls ?? void 0;
    message.linkFlairTemplateId = object.linkFlairTemplateId ?? void 0;
    message.crowdControlLevel = object.crowdControlLevel ?? void 0;
    message.isGallery = object.isGallery ?? void 0;
    message.isLiveStream = object.isLiveStream ?? void 0;
    message.isMetaDiscussion = object.isMetaDiscussion ?? void 0;
    message.oembed = object.oembed !== void 0 && object.oembed !== null ? OEmbed.fromPartial(object.oembed) : void 0;
    message.banInfo = object.banInfo !== void 0 && object.banInfo !== null ? BanInfo.fromPartial(object.banInfo) : void 0;
    message.markedSpam = object.markedSpam ?? void 0;
    message.verdict = object.verdict ?? void 0;
    message.gallery = object.gallery !== void 0 && object.gallery !== null ? RedditPostGallery.fromPartial(object.gallery) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.Post", Post);
function createBaseMedia() {
  return { redditVideo: void 0 };
}
var Media = {
  $type: "devvit.reddit.Media",
  encode(message, writer = import_minimal7.default.Writer.create()) {
    if (message.redditVideo !== void 0) {
      Media_RedditVideo.encode(message.redditVideo, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : new import_minimal7.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMedia();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.redditVideo = Media_RedditVideo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { redditVideo: isSet6(object.redditVideo) ? Media_RedditVideo.fromJSON(object.redditVideo) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.redditVideo !== void 0 && (obj.redditVideo = message.redditVideo ? Media_RedditVideo.toJSON(message.redditVideo) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMedia();
    message.redditVideo = object.redditVideo !== void 0 && object.redditVideo !== null ? Media_RedditVideo.fromPartial(object.redditVideo) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.Media", Media);
function createBaseMedia_RedditVideo() {
  return {
    bitrateKbps: void 0,
    dashUrl: void 0,
    duration: void 0,
    fallbackUrl: void 0,
    height: void 0,
    hlsUrl: void 0,
    isGif: void 0,
    scrubberMediaUrl: void 0,
    transcodingStatus: void 0,
    width: void 0
  };
}
var Media_RedditVideo = {
  $type: "devvit.reddit.Media.RedditVideo",
  encode(message, writer = import_minimal7.default.Writer.create()) {
    if (message.bitrateKbps !== void 0) {
      Int32Value.encode({ value: message.bitrateKbps }, writer.uint32(10).fork()).ldelim();
    }
    if (message.dashUrl !== void 0) {
      StringValue.encode({ value: message.dashUrl }, writer.uint32(18).fork()).ldelim();
    }
    if (message.duration !== void 0) {
      Int32Value.encode({ value: message.duration }, writer.uint32(26).fork()).ldelim();
    }
    if (message.fallbackUrl !== void 0) {
      StringValue.encode({ value: message.fallbackUrl }, writer.uint32(34).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(42).fork()).ldelim();
    }
    if (message.hlsUrl !== void 0) {
      StringValue.encode({ value: message.hlsUrl }, writer.uint32(50).fork()).ldelim();
    }
    if (message.isGif !== void 0) {
      BoolValue.encode({ value: message.isGif }, writer.uint32(58).fork()).ldelim();
    }
    if (message.scrubberMediaUrl !== void 0) {
      StringValue.encode({ value: message.scrubberMediaUrl }, writer.uint32(66).fork()).ldelim();
    }
    if (message.transcodingStatus !== void 0) {
      StringValue.encode({ value: message.transcodingStatus }, writer.uint32(74).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : new import_minimal7.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMedia_RedditVideo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bitrateKbps = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.dashUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.duration = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.fallbackUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.hlsUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.isGif = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.scrubberMediaUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.transcodingStatus = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      bitrateKbps: isSet6(object.bitrateKbps) ? Number(object.bitrateKbps) : void 0,
      dashUrl: isSet6(object.dashUrl) ? String(object.dashUrl) : void 0,
      duration: isSet6(object.duration) ? Number(object.duration) : void 0,
      fallbackUrl: isSet6(object.fallbackUrl) ? String(object.fallbackUrl) : void 0,
      height: isSet6(object.height) ? Number(object.height) : void 0,
      hlsUrl: isSet6(object.hlsUrl) ? String(object.hlsUrl) : void 0,
      isGif: isSet6(object.isGif) ? Boolean(object.isGif) : void 0,
      scrubberMediaUrl: isSet6(object.scrubberMediaUrl) ? String(object.scrubberMediaUrl) : void 0,
      transcodingStatus: isSet6(object.transcodingStatus) ? String(object.transcodingStatus) : void 0,
      width: isSet6(object.width) ? Number(object.width) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.bitrateKbps !== void 0 && (obj.bitrateKbps = message.bitrateKbps);
    message.dashUrl !== void 0 && (obj.dashUrl = message.dashUrl);
    message.duration !== void 0 && (obj.duration = message.duration);
    message.fallbackUrl !== void 0 && (obj.fallbackUrl = message.fallbackUrl);
    message.height !== void 0 && (obj.height = message.height);
    message.hlsUrl !== void 0 && (obj.hlsUrl = message.hlsUrl);
    message.isGif !== void 0 && (obj.isGif = message.isGif);
    message.scrubberMediaUrl !== void 0 && (obj.scrubberMediaUrl = message.scrubberMediaUrl);
    message.transcodingStatus !== void 0 && (obj.transcodingStatus = message.transcodingStatus);
    message.width !== void 0 && (obj.width = message.width);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMedia_RedditVideo();
    message.bitrateKbps = object.bitrateKbps ?? void 0;
    message.dashUrl = object.dashUrl ?? void 0;
    message.duration = object.duration ?? void 0;
    message.fallbackUrl = object.fallbackUrl ?? void 0;
    message.height = object.height ?? void 0;
    message.hlsUrl = object.hlsUrl ?? void 0;
    message.isGif = object.isGif ?? void 0;
    message.scrubberMediaUrl = object.scrubberMediaUrl ?? void 0;
    message.transcodingStatus = object.transcodingStatus ?? void 0;
    message.width = object.width ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.Media.RedditVideo", Media_RedditVideo);
function createBasePreview() {
  return { enabled: void 0, images: [] };
}
var Preview = {
  $type: "devvit.reddit.Preview",
  encode(message, writer = import_minimal7.default.Writer.create()) {
    if (message.enabled !== void 0) {
      BoolValue.encode({ value: message.enabled }, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.images) {
      Preview_PreviewImage.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : new import_minimal7.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePreview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.images.push(Preview_PreviewImage.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      enabled: isSet6(object.enabled) ? Boolean(object.enabled) : void 0,
      images: Array.isArray(object?.images) ? object.images.map((e) => Preview_PreviewImage.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    if (message.images) {
      obj.images = message.images.map((e) => e ? Preview_PreviewImage.toJSON(e) : void 0);
    } else {
      obj.images = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBasePreview();
    message.enabled = object.enabled ?? void 0;
    message.images = object.images?.map((e) => Preview_PreviewImage.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.Preview", Preview);
function createBasePreview_PreviewImage() {
  return { id: void 0, resolutions: [], source: void 0, variants: void 0 };
}
var Preview_PreviewImage = {
  $type: "devvit.reddit.Preview.PreviewImage",
  encode(message, writer = import_minimal7.default.Writer.create()) {
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.resolutions) {
      Preview_PreviewImage_Image.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.source !== void 0) {
      Preview_PreviewImage_Image.encode(message.source, writer.uint32(26).fork()).ldelim();
    }
    if (message.variants !== void 0) {
      Preview_PreviewImage_Image.encode(message.variants, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : new import_minimal7.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePreview_PreviewImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.resolutions.push(Preview_PreviewImage_Image.decode(reader, reader.uint32()));
          break;
        case 3:
          message.source = Preview_PreviewImage_Image.decode(reader, reader.uint32());
          break;
        case 4:
          message.variants = Preview_PreviewImage_Image.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet6(object.id) ? String(object.id) : void 0,
      resolutions: Array.isArray(object?.resolutions) ? object.resolutions.map((e) => Preview_PreviewImage_Image.fromJSON(e)) : [],
      source: isSet6(object.source) ? Preview_PreviewImage_Image.fromJSON(object.source) : void 0,
      variants: isSet6(object.variants) ? Preview_PreviewImage_Image.fromJSON(object.variants) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    if (message.resolutions) {
      obj.resolutions = message.resolutions.map((e) => e ? Preview_PreviewImage_Image.toJSON(e) : void 0);
    } else {
      obj.resolutions = [];
    }
    message.source !== void 0 && (obj.source = message.source ? Preview_PreviewImage_Image.toJSON(message.source) : void 0);
    message.variants !== void 0 && (obj.variants = message.variants ? Preview_PreviewImage_Image.toJSON(message.variants) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePreview_PreviewImage();
    message.id = object.id ?? void 0;
    message.resolutions = object.resolutions?.map((e) => Preview_PreviewImage_Image.fromPartial(e)) || [];
    message.source = object.source !== void 0 && object.source !== null ? Preview_PreviewImage_Image.fromPartial(object.source) : void 0;
    message.variants = object.variants !== void 0 && object.variants !== null ? Preview_PreviewImage_Image.fromPartial(object.variants) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.Preview.PreviewImage", Preview_PreviewImage);
function createBasePreview_PreviewImage_Image() {
  return { height: void 0, url: void 0, width: void 0 };
}
var Preview_PreviewImage_Image = {
  $type: "devvit.reddit.Preview.PreviewImage.Image",
  encode(message, writer = import_minimal7.default.Writer.create()) {
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(10).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(18).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : new import_minimal7.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePreview_PreviewImage_Image();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet6(object.height) ? Number(object.height) : void 0,
      url: isSet6(object.url) ? String(object.url) : void 0,
      width: isSet6(object.width) ? Number(object.width) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.height !== void 0 && (obj.height = message.height);
    message.url !== void 0 && (obj.url = message.url);
    message.width !== void 0 && (obj.width = message.width);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePreview_PreviewImage_Image();
    message.height = object.height ?? void 0;
    message.url = object.url ?? void 0;
    message.width = object.width ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.Preview.PreviewImage.Image", Preview_PreviewImage_Image);
function createBaseOEmbed() {
  return { authorName: void 0, authorUrl: void 0, description: void 0, title: void 0 };
}
var OEmbed = {
  $type: "devvit.reddit.OEmbed",
  encode(message, writer = import_minimal7.default.Writer.create()) {
    if (message.authorName !== void 0) {
      StringValue.encode({ value: message.authorName }, writer.uint32(10).fork()).ldelim();
    }
    if (message.authorUrl !== void 0) {
      StringValue.encode({ value: message.authorUrl }, writer.uint32(18).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(26).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : new import_minimal7.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOEmbed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authorName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.authorUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      authorName: isSet6(object.authorName) ? String(object.authorName) : void 0,
      authorUrl: isSet6(object.authorUrl) ? String(object.authorUrl) : void 0,
      description: isSet6(object.description) ? String(object.description) : void 0,
      title: isSet6(object.title) ? String(object.title) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.authorName !== void 0 && (obj.authorName = message.authorName);
    message.authorUrl !== void 0 && (obj.authorUrl = message.authorUrl);
    message.description !== void 0 && (obj.description = message.description);
    message.title !== void 0 && (obj.title = message.title);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseOEmbed();
    message.authorName = object.authorName ?? void 0;
    message.authorUrl = object.authorUrl ?? void 0;
    message.description = object.description ?? void 0;
    message.title = object.title ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.OEmbed", OEmbed);
function createBaseRedditPostGallery() {
  return { body: void 0, domain: void 0, url: void 0 };
}
var RedditPostGallery = {
  $type: "devvit.reddit.RedditPostGallery",
  encode(message, writer = import_minimal7.default.Writer.create()) {
    if (message.body !== void 0) {
      StringValue.encode({ value: message.body }, writer.uint32(10).fork()).ldelim();
    }
    if (message.domain !== void 0) {
      StringValue.encode({ value: message.domain }, writer.uint32(18).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : new import_minimal7.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditPostGallery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.body = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.domain = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      body: isSet6(object.body) ? String(object.body) : void 0,
      domain: isSet6(object.domain) ? String(object.domain) : void 0,
      url: isSet6(object.url) ? String(object.url) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.body !== void 0 && (obj.body = message.body);
    message.domain !== void 0 && (obj.domain = message.domain);
    message.url !== void 0 && (obj.url = message.url);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRedditPostGallery();
    message.body = object.body ?? void 0;
    message.domain = object.domain ?? void 0;
    message.url = object.url ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.RedditPostGallery", RedditPostGallery);
function isSet6(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/subreddit.js
var import_minimal8 = __toESM(require_minimal2(), 1);
function createBaseSubreddit() {
  return {
    acceptFollowers: void 0,
    accountsActiveIsFuzzed: void 0,
    accountsActive: void 0,
    activeUserCount: void 0,
    advertiserCategory: void 0,
    allOriginalContent: void 0,
    allowChatPostCreation: void 0,
    allowDiscovery: void 0,
    allowGalleries: void 0,
    allowImages: void 0,
    allowPolls: void 0,
    allowPredictionContributors: void 0,
    allowPredictionsTournament: void 0,
    allowPredictions: void 0,
    allowTalks: void 0,
    allowVideogifs: void 0,
    allowVideos: void 0,
    allowedMediaInComments: [],
    bannerBackgroundColor: void 0,
    bannerBackgroundImage: void 0,
    bannerImg: void 0,
    bannerSize: [],
    canAssignLinkFlair: void 0,
    canAssignUserFlair: void 0,
    coins: void 0,
    collapseDeletedComments: void 0,
    commentContributionSettings: void 0,
    commentScoreHideMins: void 0,
    communityIcon: void 0,
    communityReviewed: void 0,
    contentCategory: void 0,
    createdUtc: void 0,
    created: void 0,
    defaultSet: void 0,
    description: void 0,
    descriptionHtml: void 0,
    disableContributorRequests: void 0,
    displayName: void 0,
    displayNamePrefixed: void 0,
    emojisCustomSize: [],
    emojisEnabled: void 0,
    freeFormReports: void 0,
    hasMenuWidget: void 0,
    headerImg: void 0,
    headerSize: [],
    headerTitle: void 0,
    hideAds: void 0,
    iconColor: void 0,
    iconImg: void 0,
    iconSize: [],
    id: void 0,
    isChatPostFeatureEnabled: void 0,
    isCrosspostableSubreddit: void 0,
    isDefaultBanner: void 0,
    isDefaultIcon: void 0,
    isEnrolledInNewModmail: void 0,
    keyColor: void 0,
    lang: void 0,
    linkFlairEnabled: void 0,
    linkFlairPosition: void 0,
    mobileBannerImage: void 0,
    name: void 0,
    notificationLevel: void 0,
    originalContentTagEnabled: void 0,
    over18: void 0,
    predictionLeaderboardEntryType: void 0,
    previousNames: [],
    primaryColor: void 0,
    publicDescription: void 0,
    publicDescriptionHtml: void 0,
    publicTraffic: void 0,
    quarantine: void 0,
    restrictCommenting: void 0,
    restrictPosting: void 0,
    shouldArchivePosts: void 0,
    shouldShowMediaInCommentsSetting: void 0,
    showMedia: void 0,
    showMediaPreview: void 0,
    spoilersEnabled: void 0,
    submissionType: void 0,
    submitLinkLabel: void 0,
    submitText: void 0,
    submitTextHtml: void 0,
    submitTextLabel: void 0,
    subredditType: void 0,
    subscribers: void 0,
    suggestedCommentSort: void 0,
    title: void 0,
    url: void 0,
    userCanFlairInSr: void 0,
    userFlairBackgroundColor: void 0,
    userFlairCssClass: void 0,
    userFlairEnabledInSr: void 0,
    userFlairPosition: void 0,
    userFlairRichtext: [],
    userFlairTemplateId: void 0,
    userFlairText: void 0,
    userFlairTextColor: void 0,
    userFlairType: void 0,
    userHasFavorited: void 0,
    userIsBanned: void 0,
    userIsContributor: void 0,
    userIsModerator: void 0,
    userIsMuted: void 0,
    userIsSubscriber: void 0,
    userSrFlairEnabled: void 0,
    userSrThemeEnabled: void 0,
    videostreamLinksCount: void 0,
    whitelistStatus: void 0,
    wikiEnabled: void 0,
    wls: void 0,
    markedSpam: void 0,
    postRequirements: void 0
  };
}
var Subreddit = {
  $type: "devvit.reddit.Subreddit",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(10).fork()).ldelim();
    }
    if (message.accountsActiveIsFuzzed !== void 0) {
      BoolValue.encode({ value: message.accountsActiveIsFuzzed }, writer.uint32(18).fork()).ldelim();
    }
    if (message.accountsActive !== void 0) {
      Int32Value.encode({ value: message.accountsActive }, writer.uint32(26).fork()).ldelim();
    }
    if (message.activeUserCount !== void 0) {
      Int32Value.encode({ value: message.activeUserCount }, writer.uint32(34).fork()).ldelim();
    }
    if (message.advertiserCategory !== void 0) {
      StringValue.encode({ value: message.advertiserCategory }, writer.uint32(42).fork()).ldelim();
    }
    if (message.allOriginalContent !== void 0) {
      BoolValue.encode({ value: message.allOriginalContent }, writer.uint32(50).fork()).ldelim();
    }
    if (message.allowChatPostCreation !== void 0) {
      BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(58).fork()).ldelim();
    }
    if (message.allowDiscovery !== void 0) {
      BoolValue.encode({ value: message.allowDiscovery }, writer.uint32(66).fork()).ldelim();
    }
    if (message.allowGalleries !== void 0) {
      BoolValue.encode({ value: message.allowGalleries }, writer.uint32(74).fork()).ldelim();
    }
    if (message.allowImages !== void 0) {
      BoolValue.encode({ value: message.allowImages }, writer.uint32(82).fork()).ldelim();
    }
    if (message.allowPolls !== void 0) {
      BoolValue.encode({ value: message.allowPolls }, writer.uint32(90).fork()).ldelim();
    }
    if (message.allowPredictionContributors !== void 0) {
      BoolValue.encode({ value: message.allowPredictionContributors }, writer.uint32(98).fork()).ldelim();
    }
    if (message.allowPredictionsTournament !== void 0) {
      BoolValue.encode({ value: message.allowPredictionsTournament }, writer.uint32(106).fork()).ldelim();
    }
    if (message.allowPredictions !== void 0) {
      BoolValue.encode({ value: message.allowPredictions }, writer.uint32(114).fork()).ldelim();
    }
    if (message.allowTalks !== void 0) {
      BoolValue.encode({ value: message.allowTalks }, writer.uint32(122).fork()).ldelim();
    }
    if (message.allowVideogifs !== void 0) {
      BoolValue.encode({ value: message.allowVideogifs }, writer.uint32(130).fork()).ldelim();
    }
    if (message.allowVideos !== void 0) {
      BoolValue.encode({ value: message.allowVideos }, writer.uint32(138).fork()).ldelim();
    }
    for (const v of message.allowedMediaInComments) {
      StringValue.encode({ value: v }, writer.uint32(146).fork()).ldelim();
    }
    if (message.bannerBackgroundColor !== void 0) {
      StringValue.encode({ value: message.bannerBackgroundColor }, writer.uint32(154).fork()).ldelim();
    }
    if (message.bannerBackgroundImage !== void 0) {
      StringValue.encode({ value: message.bannerBackgroundImage }, writer.uint32(162).fork()).ldelim();
    }
    if (message.bannerImg !== void 0) {
      StringValue.encode({ value: message.bannerImg }, writer.uint32(170).fork()).ldelim();
    }
    for (const v of message.bannerSize) {
      Int32Value.encode({ value: v }, writer.uint32(178).fork()).ldelim();
    }
    if (message.canAssignLinkFlair !== void 0) {
      BoolValue.encode({ value: message.canAssignLinkFlair }, writer.uint32(186).fork()).ldelim();
    }
    if (message.canAssignUserFlair !== void 0) {
      BoolValue.encode({ value: message.canAssignUserFlair }, writer.uint32(194).fork()).ldelim();
    }
    if (message.coins !== void 0) {
      Int32Value.encode({ value: message.coins }, writer.uint32(202).fork()).ldelim();
    }
    if (message.collapseDeletedComments !== void 0) {
      BoolValue.encode({ value: message.collapseDeletedComments }, writer.uint32(210).fork()).ldelim();
    }
    if (message.commentContributionSettings !== void 0) {
      CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(218).fork()).ldelim();
    }
    if (message.commentScoreHideMins !== void 0) {
      Int32Value.encode({ value: message.commentScoreHideMins }, writer.uint32(226).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(234).fork()).ldelim();
    }
    if (message.communityReviewed !== void 0) {
      BoolValue.encode({ value: message.communityReviewed }, writer.uint32(242).fork()).ldelim();
    }
    if (message.contentCategory !== void 0) {
      StringValue.encode({ value: message.contentCategory }, writer.uint32(250).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int32Value.encode({ value: message.createdUtc }, writer.uint32(258).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int32Value.encode({ value: message.created }, writer.uint32(266).fork()).ldelim();
    }
    if (message.defaultSet !== void 0) {
      BoolValue.encode({ value: message.defaultSet }, writer.uint32(274).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(282).fork()).ldelim();
    }
    if (message.descriptionHtml !== void 0) {
      StringValue.encode({ value: message.descriptionHtml }, writer.uint32(290).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(298).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(306).fork()).ldelim();
    }
    if (message.displayNamePrefixed !== void 0) {
      StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(314).fork()).ldelim();
    }
    for (const v of message.emojisCustomSize) {
      Int32Value.encode({ value: v }, writer.uint32(322).fork()).ldelim();
    }
    if (message.emojisEnabled !== void 0) {
      BoolValue.encode({ value: message.emojisEnabled }, writer.uint32(330).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(338).fork()).ldelim();
    }
    if (message.hasMenuWidget !== void 0) {
      BoolValue.encode({ value: message.hasMenuWidget }, writer.uint32(346).fork()).ldelim();
    }
    if (message.headerImg !== void 0) {
      StringValue.encode({ value: message.headerImg }, writer.uint32(354).fork()).ldelim();
    }
    for (const v of message.headerSize) {
      Int32Value.encode({ value: v }, writer.uint32(362).fork()).ldelim();
    }
    if (message.headerTitle !== void 0) {
      StringValue.encode({ value: message.headerTitle }, writer.uint32(370).fork()).ldelim();
    }
    if (message.hideAds !== void 0) {
      BoolValue.encode({ value: message.hideAds }, writer.uint32(378).fork()).ldelim();
    }
    if (message.iconColor !== void 0) {
      StringValue.encode({ value: message.iconColor }, writer.uint32(386).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(394).fork()).ldelim();
    }
    for (const v of message.iconSize) {
      Int32Value.encode({ value: v }, writer.uint32(402).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(410).fork()).ldelim();
    }
    if (message.isChatPostFeatureEnabled !== void 0) {
      BoolValue.encode({ value: message.isChatPostFeatureEnabled }, writer.uint32(418).fork()).ldelim();
    }
    if (message.isCrosspostableSubreddit !== void 0) {
      BoolValue.encode({ value: message.isCrosspostableSubreddit }, writer.uint32(426).fork()).ldelim();
    }
    if (message.isDefaultBanner !== void 0) {
      BoolValue.encode({ value: message.isDefaultBanner }, writer.uint32(434).fork()).ldelim();
    }
    if (message.isDefaultIcon !== void 0) {
      BoolValue.encode({ value: message.isDefaultIcon }, writer.uint32(442).fork()).ldelim();
    }
    if (message.isEnrolledInNewModmail !== void 0) {
      BoolValue.encode({ value: message.isEnrolledInNewModmail }, writer.uint32(450).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(458).fork()).ldelim();
    }
    if (message.lang !== void 0) {
      StringValue.encode({ value: message.lang }, writer.uint32(466).fork()).ldelim();
    }
    if (message.linkFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(474).fork()).ldelim();
    }
    if (message.linkFlairPosition !== void 0) {
      StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(482).fork()).ldelim();
    }
    if (message.mobileBannerImage !== void 0) {
      StringValue.encode({ value: message.mobileBannerImage }, writer.uint32(490).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(498).fork()).ldelim();
    }
    if (message.notificationLevel !== void 0) {
      StringValue.encode({ value: message.notificationLevel }, writer.uint32(506).fork()).ldelim();
    }
    if (message.originalContentTagEnabled !== void 0) {
      StringValue.encode({ value: message.originalContentTagEnabled }, writer.uint32(514).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(522).fork()).ldelim();
    }
    if (message.predictionLeaderboardEntryType !== void 0) {
      StringValue.encode({ value: message.predictionLeaderboardEntryType }, writer.uint32(530).fork()).ldelim();
    }
    for (const v of message.previousNames) {
      StringValue.encode({ value: v }, writer.uint32(538).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(546).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(554).fork()).ldelim();
    }
    if (message.publicDescriptionHtml !== void 0) {
      StringValue.encode({ value: message.publicDescriptionHtml }, writer.uint32(562).fork()).ldelim();
    }
    if (message.publicTraffic !== void 0) {
      BoolValue.encode({ value: message.publicTraffic }, writer.uint32(570).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(578).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(586).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(594).fork()).ldelim();
    }
    if (message.shouldArchivePosts !== void 0) {
      BoolValue.encode({ value: message.shouldArchivePosts }, writer.uint32(602).fork()).ldelim();
    }
    if (message.shouldShowMediaInCommentsSetting !== void 0) {
      BoolValue.encode({ value: message.shouldShowMediaInCommentsSetting }, writer.uint32(610).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(618).fork()).ldelim();
    }
    if (message.showMediaPreview !== void 0) {
      BoolValue.encode({ value: message.showMediaPreview }, writer.uint32(626).fork()).ldelim();
    }
    if (message.spoilersEnabled !== void 0) {
      BoolValue.encode({ value: message.spoilersEnabled }, writer.uint32(634).fork()).ldelim();
    }
    if (message.submissionType !== void 0) {
      StringValue.encode({ value: message.submissionType }, writer.uint32(642).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(650).fork()).ldelim();
    }
    if (message.submitText !== void 0) {
      StringValue.encode({ value: message.submitText }, writer.uint32(658).fork()).ldelim();
    }
    if (message.submitTextHtml !== void 0) {
      StringValue.encode({ value: message.submitTextHtml }, writer.uint32(666).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(674).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(682).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int32Value.encode({ value: message.subscribers }, writer.uint32(690).fork()).ldelim();
    }
    if (message.suggestedCommentSort !== void 0) {
      StringValue.encode({ value: message.suggestedCommentSort }, writer.uint32(698).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(706).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(714).fork()).ldelim();
    }
    if (message.userCanFlairInSr !== void 0) {
      BoolValue.encode({ value: message.userCanFlairInSr }, writer.uint32(722).fork()).ldelim();
    }
    if (message.userFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.userFlairBackgroundColor }, writer.uint32(730).fork()).ldelim();
    }
    if (message.userFlairCssClass !== void 0) {
      StringValue.encode({ value: message.userFlairCssClass }, writer.uint32(738).fork()).ldelim();
    }
    if (message.userFlairEnabledInSr !== void 0) {
      BoolValue.encode({ value: message.userFlairEnabledInSr }, writer.uint32(746).fork()).ldelim();
    }
    if (message.userFlairPosition !== void 0) {
      StringValue.encode({ value: message.userFlairPosition }, writer.uint32(754).fork()).ldelim();
    }
    for (const v of message.userFlairRichtext) {
      UserFlairRichtext.encode(v, writer.uint32(762).fork()).ldelim();
    }
    if (message.userFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.userFlairTemplateId }, writer.uint32(770).fork()).ldelim();
    }
    if (message.userFlairText !== void 0) {
      StringValue.encode({ value: message.userFlairText }, writer.uint32(778).fork()).ldelim();
    }
    if (message.userFlairTextColor !== void 0) {
      StringValue.encode({ value: message.userFlairTextColor }, writer.uint32(786).fork()).ldelim();
    }
    if (message.userFlairType !== void 0) {
      StringValue.encode({ value: message.userFlairType }, writer.uint32(794).fork()).ldelim();
    }
    if (message.userHasFavorited !== void 0) {
      BoolValue.encode({ value: message.userHasFavorited }, writer.uint32(802).fork()).ldelim();
    }
    if (message.userIsBanned !== void 0) {
      BoolValue.encode({ value: message.userIsBanned }, writer.uint32(810).fork()).ldelim();
    }
    if (message.userIsContributor !== void 0) {
      BoolValue.encode({ value: message.userIsContributor }, writer.uint32(818).fork()).ldelim();
    }
    if (message.userIsModerator !== void 0) {
      BoolValue.encode({ value: message.userIsModerator }, writer.uint32(826).fork()).ldelim();
    }
    if (message.userIsMuted !== void 0) {
      StringValue.encode({ value: message.userIsMuted }, writer.uint32(834).fork()).ldelim();
    }
    if (message.userIsSubscriber !== void 0) {
      BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(842).fork()).ldelim();
    }
    if (message.userSrFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.userSrFlairEnabled }, writer.uint32(850).fork()).ldelim();
    }
    if (message.userSrThemeEnabled !== void 0) {
      BoolValue.encode({ value: message.userSrThemeEnabled }, writer.uint32(858).fork()).ldelim();
    }
    if (message.videostreamLinksCount !== void 0) {
      Int32Value.encode({ value: message.videostreamLinksCount }, writer.uint32(866).fork()).ldelim();
    }
    if (message.whitelistStatus !== void 0) {
      StringValue.encode({ value: message.whitelistStatus }, writer.uint32(874).fork()).ldelim();
    }
    if (message.wikiEnabled !== void 0) {
      BoolValue.encode({ value: message.wikiEnabled }, writer.uint32(882).fork()).ldelim();
    }
    if (message.wls !== void 0) {
      Int32Value.encode({ value: message.wls }, writer.uint32(890).fork()).ldelim();
    }
    if (message.markedSpam !== void 0) {
      BoolValue.encode({ value: message.markedSpam }, writer.uint32(898).fork()).ldelim();
    }
    if (message.postRequirements !== void 0) {
      Subreddit_PostRequirements.encode(message.postRequirements, writer.uint32(906).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : new import_minimal8.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubreddit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.accountsActiveIsFuzzed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.accountsActive = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.activeUserCount = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.advertiserCategory = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.allOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.allowDiscovery = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.allowGalleries = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.allowPolls = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.allowPredictionContributors = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.allowPredictionsTournament = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.allowPredictions = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.allowTalks = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.allowVideogifs = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.allowVideos = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 19:
          message.bannerBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.bannerBackgroundImage = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.bannerSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 23:
          message.canAssignLinkFlair = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.canAssignUserFlair = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.coins = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.collapseDeletedComments = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 27:
          message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
          break;
        case 28:
          message.commentScoreHideMins = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.communityReviewed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.contentCategory = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.createdUtc = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.created = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 35:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.descriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 37:
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 38:
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 39:
          message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 40:
          message.emojisCustomSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 41:
          message.emojisEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 42:
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 43:
          message.hasMenuWidget = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 44:
          message.headerImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 45:
          message.headerSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 46:
          message.headerTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 47:
          message.hideAds = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 48:
          message.iconColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 49:
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 50:
          message.iconSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 51:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 52:
          message.isChatPostFeatureEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 53:
          message.isCrosspostableSubreddit = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 54:
          message.isDefaultBanner = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 55:
          message.isDefaultIcon = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 56:
          message.isEnrolledInNewModmail = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 57:
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 58:
          message.lang = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 59:
          message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 60:
          message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 61:
          message.mobileBannerImage = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 62:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 63:
          message.notificationLevel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 64:
          message.originalContentTagEnabled = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 65:
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 66:
          message.predictionLeaderboardEntryType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 67:
          message.previousNames.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 68:
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 69:
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 70:
          message.publicDescriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 71:
          message.publicTraffic = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 72:
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 73:
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 74:
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 75:
          message.shouldArchivePosts = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 76:
          message.shouldShowMediaInCommentsSetting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 77:
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 78:
          message.showMediaPreview = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 79:
          message.spoilersEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 80:
          message.submissionType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 81:
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 82:
          message.submitText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 83:
          message.submitTextHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 84:
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 85:
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 86:
          message.subscribers = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 87:
          message.suggestedCommentSort = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 88:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 89:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 90:
          message.userCanFlairInSr = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 91:
          message.userFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 92:
          message.userFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 93:
          message.userFlairEnabledInSr = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 94:
          message.userFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 95:
          message.userFlairRichtext.push(UserFlairRichtext.decode(reader, reader.uint32()));
          break;
        case 96:
          message.userFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 97:
          message.userFlairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 98:
          message.userFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 99:
          message.userFlairType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 100:
          message.userHasFavorited = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 101:
          message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 102:
          message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 103:
          message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 104:
          message.userIsMuted = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 105:
          message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 106:
          message.userSrFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 107:
          message.userSrThemeEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 108:
          message.videostreamLinksCount = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 109:
          message.whitelistStatus = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 110:
          message.wikiEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 111:
          message.wls = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 112:
          message.markedSpam = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 113:
          message.postRequirements = Subreddit_PostRequirements.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      acceptFollowers: isSet7(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      accountsActiveIsFuzzed: isSet7(object.accountsActiveIsFuzzed) ? Boolean(object.accountsActiveIsFuzzed) : void 0,
      accountsActive: isSet7(object.accountsActive) ? Number(object.accountsActive) : void 0,
      activeUserCount: isSet7(object.activeUserCount) ? Number(object.activeUserCount) : void 0,
      advertiserCategory: isSet7(object.advertiserCategory) ? String(object.advertiserCategory) : void 0,
      allOriginalContent: isSet7(object.allOriginalContent) ? Boolean(object.allOriginalContent) : void 0,
      allowChatPostCreation: isSet7(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : void 0,
      allowDiscovery: isSet7(object.allowDiscovery) ? Boolean(object.allowDiscovery) : void 0,
      allowGalleries: isSet7(object.allowGalleries) ? Boolean(object.allowGalleries) : void 0,
      allowImages: isSet7(object.allowImages) ? Boolean(object.allowImages) : void 0,
      allowPolls: isSet7(object.allowPolls) ? Boolean(object.allowPolls) : void 0,
      allowPredictionContributors: isSet7(object.allowPredictionContributors) ? Boolean(object.allowPredictionContributors) : void 0,
      allowPredictionsTournament: isSet7(object.allowPredictionsTournament) ? Boolean(object.allowPredictionsTournament) : void 0,
      allowPredictions: isSet7(object.allowPredictions) ? Boolean(object.allowPredictions) : void 0,
      allowTalks: isSet7(object.allowTalks) ? Boolean(object.allowTalks) : void 0,
      allowVideogifs: isSet7(object.allowVideogifs) ? Boolean(object.allowVideogifs) : void 0,
      allowVideos: isSet7(object.allowVideos) ? Boolean(object.allowVideos) : void 0,
      allowedMediaInComments: Array.isArray(object?.allowedMediaInComments) ? object.allowedMediaInComments.map((e) => String(e)) : [],
      bannerBackgroundColor: isSet7(object.bannerBackgroundColor) ? String(object.bannerBackgroundColor) : void 0,
      bannerBackgroundImage: isSet7(object.bannerBackgroundImage) ? String(object.bannerBackgroundImage) : void 0,
      bannerImg: isSet7(object.bannerImg) ? String(object.bannerImg) : void 0,
      bannerSize: Array.isArray(object?.bannerSize) ? object.bannerSize.map((e) => Number(e)) : [],
      canAssignLinkFlair: isSet7(object.canAssignLinkFlair) ? Boolean(object.canAssignLinkFlair) : void 0,
      canAssignUserFlair: isSet7(object.canAssignUserFlair) ? Boolean(object.canAssignUserFlair) : void 0,
      coins: isSet7(object.coins) ? Number(object.coins) : void 0,
      collapseDeletedComments: isSet7(object.collapseDeletedComments) ? Boolean(object.collapseDeletedComments) : void 0,
      commentContributionSettings: isSet7(object.commentContributionSettings) ? CommentContributionSettings.fromJSON(object.commentContributionSettings) : void 0,
      commentScoreHideMins: isSet7(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : void 0,
      communityIcon: isSet7(object.communityIcon) ? String(object.communityIcon) : void 0,
      communityReviewed: isSet7(object.communityReviewed) ? Boolean(object.communityReviewed) : void 0,
      contentCategory: isSet7(object.contentCategory) ? String(object.contentCategory) : void 0,
      createdUtc: isSet7(object.createdUtc) ? Number(object.createdUtc) : void 0,
      created: isSet7(object.created) ? Number(object.created) : void 0,
      defaultSet: isSet7(object.defaultSet) ? Boolean(object.defaultSet) : void 0,
      description: isSet7(object.description) ? String(object.description) : void 0,
      descriptionHtml: isSet7(object.descriptionHtml) ? String(object.descriptionHtml) : void 0,
      disableContributorRequests: isSet7(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      displayName: isSet7(object.displayName) ? String(object.displayName) : void 0,
      displayNamePrefixed: isSet7(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : void 0,
      emojisCustomSize: Array.isArray(object?.emojisCustomSize) ? object.emojisCustomSize.map((e) => Number(e)) : [],
      emojisEnabled: isSet7(object.emojisEnabled) ? Boolean(object.emojisEnabled) : void 0,
      freeFormReports: isSet7(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      hasMenuWidget: isSet7(object.hasMenuWidget) ? Boolean(object.hasMenuWidget) : void 0,
      headerImg: isSet7(object.headerImg) ? String(object.headerImg) : void 0,
      headerSize: Array.isArray(object?.headerSize) ? object.headerSize.map((e) => Number(e)) : [],
      headerTitle: isSet7(object.headerTitle) ? String(object.headerTitle) : void 0,
      hideAds: isSet7(object.hideAds) ? Boolean(object.hideAds) : void 0,
      iconColor: isSet7(object.iconColor) ? String(object.iconColor) : void 0,
      iconImg: isSet7(object.iconImg) ? String(object.iconImg) : void 0,
      iconSize: Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
      id: isSet7(object.id) ? String(object.id) : void 0,
      isChatPostFeatureEnabled: isSet7(object.isChatPostFeatureEnabled) ? Boolean(object.isChatPostFeatureEnabled) : void 0,
      isCrosspostableSubreddit: isSet7(object.isCrosspostableSubreddit) ? Boolean(object.isCrosspostableSubreddit) : void 0,
      isDefaultBanner: isSet7(object.isDefaultBanner) ? Boolean(object.isDefaultBanner) : void 0,
      isDefaultIcon: isSet7(object.isDefaultIcon) ? Boolean(object.isDefaultIcon) : void 0,
      isEnrolledInNewModmail: isSet7(object.isEnrolledInNewModmail) ? Boolean(object.isEnrolledInNewModmail) : void 0,
      keyColor: isSet7(object.keyColor) ? String(object.keyColor) : void 0,
      lang: isSet7(object.lang) ? String(object.lang) : void 0,
      linkFlairEnabled: isSet7(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : void 0,
      linkFlairPosition: isSet7(object.linkFlairPosition) ? String(object.linkFlairPosition) : void 0,
      mobileBannerImage: isSet7(object.mobileBannerImage) ? String(object.mobileBannerImage) : void 0,
      name: isSet7(object.name) ? String(object.name) : void 0,
      notificationLevel: isSet7(object.notificationLevel) ? String(object.notificationLevel) : void 0,
      originalContentTagEnabled: isSet7(object.originalContentTagEnabled) ? String(object.originalContentTagEnabled) : void 0,
      over18: isSet7(object.over18) ? Boolean(object.over18) : void 0,
      predictionLeaderboardEntryType: isSet7(object.predictionLeaderboardEntryType) ? String(object.predictionLeaderboardEntryType) : void 0,
      previousNames: Array.isArray(object?.previousNames) ? object.previousNames.map((e) => String(e)) : [],
      primaryColor: isSet7(object.primaryColor) ? String(object.primaryColor) : void 0,
      publicDescription: isSet7(object.publicDescription) ? String(object.publicDescription) : void 0,
      publicDescriptionHtml: isSet7(object.publicDescriptionHtml) ? String(object.publicDescriptionHtml) : void 0,
      publicTraffic: isSet7(object.publicTraffic) ? Boolean(object.publicTraffic) : void 0,
      quarantine: isSet7(object.quarantine) ? Boolean(object.quarantine) : void 0,
      restrictCommenting: isSet7(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      restrictPosting: isSet7(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      shouldArchivePosts: isSet7(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : void 0,
      shouldShowMediaInCommentsSetting: isSet7(object.shouldShowMediaInCommentsSetting) ? Boolean(object.shouldShowMediaInCommentsSetting) : void 0,
      showMedia: isSet7(object.showMedia) ? Boolean(object.showMedia) : void 0,
      showMediaPreview: isSet7(object.showMediaPreview) ? Boolean(object.showMediaPreview) : void 0,
      spoilersEnabled: isSet7(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : void 0,
      submissionType: isSet7(object.submissionType) ? String(object.submissionType) : void 0,
      submitLinkLabel: isSet7(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      submitText: isSet7(object.submitText) ? String(object.submitText) : void 0,
      submitTextHtml: isSet7(object.submitTextHtml) ? String(object.submitTextHtml) : void 0,
      submitTextLabel: isSet7(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      subredditType: isSet7(object.subredditType) ? String(object.subredditType) : void 0,
      subscribers: isSet7(object.subscribers) ? Number(object.subscribers) : void 0,
      suggestedCommentSort: isSet7(object.suggestedCommentSort) ? String(object.suggestedCommentSort) : void 0,
      title: isSet7(object.title) ? String(object.title) : void 0,
      url: isSet7(object.url) ? String(object.url) : void 0,
      userCanFlairInSr: isSet7(object.userCanFlairInSr) ? Boolean(object.userCanFlairInSr) : void 0,
      userFlairBackgroundColor: isSet7(object.userFlairBackgroundColor) ? String(object.userFlairBackgroundColor) : void 0,
      userFlairCssClass: isSet7(object.userFlairCssClass) ? String(object.userFlairCssClass) : void 0,
      userFlairEnabledInSr: isSet7(object.userFlairEnabledInSr) ? Boolean(object.userFlairEnabledInSr) : void 0,
      userFlairPosition: isSet7(object.userFlairPosition) ? String(object.userFlairPosition) : void 0,
      userFlairRichtext: Array.isArray(object?.userFlairRichtext) ? object.userFlairRichtext.map((e) => UserFlairRichtext.fromJSON(e)) : [],
      userFlairTemplateId: isSet7(object.userFlairTemplateId) ? String(object.userFlairTemplateId) : void 0,
      userFlairText: isSet7(object.userFlairText) ? String(object.userFlairText) : void 0,
      userFlairTextColor: isSet7(object.userFlairTextColor) ? String(object.userFlairTextColor) : void 0,
      userFlairType: isSet7(object.userFlairType) ? String(object.userFlairType) : void 0,
      userHasFavorited: isSet7(object.userHasFavorited) ? Boolean(object.userHasFavorited) : void 0,
      userIsBanned: isSet7(object.userIsBanned) ? Boolean(object.userIsBanned) : void 0,
      userIsContributor: isSet7(object.userIsContributor) ? Boolean(object.userIsContributor) : void 0,
      userIsModerator: isSet7(object.userIsModerator) ? Boolean(object.userIsModerator) : void 0,
      userIsMuted: isSet7(object.userIsMuted) ? String(object.userIsMuted) : void 0,
      userIsSubscriber: isSet7(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : void 0,
      userSrFlairEnabled: isSet7(object.userSrFlairEnabled) ? Boolean(object.userSrFlairEnabled) : void 0,
      userSrThemeEnabled: isSet7(object.userSrThemeEnabled) ? Boolean(object.userSrThemeEnabled) : void 0,
      videostreamLinksCount: isSet7(object.videostreamLinksCount) ? Number(object.videostreamLinksCount) : void 0,
      whitelistStatus: isSet7(object.whitelistStatus) ? String(object.whitelistStatus) : void 0,
      wikiEnabled: isSet7(object.wikiEnabled) ? Boolean(object.wikiEnabled) : void 0,
      wls: isSet7(object.wls) ? Number(object.wls) : void 0,
      markedSpam: isSet7(object.markedSpam) ? Boolean(object.markedSpam) : void 0,
      postRequirements: isSet7(object.postRequirements) ? Subreddit_PostRequirements.fromJSON(object.postRequirements) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.acceptFollowers !== void 0 && (obj.acceptFollowers = message.acceptFollowers);
    message.accountsActiveIsFuzzed !== void 0 && (obj.accountsActiveIsFuzzed = message.accountsActiveIsFuzzed);
    message.accountsActive !== void 0 && (obj.accountsActive = message.accountsActive);
    message.activeUserCount !== void 0 && (obj.activeUserCount = message.activeUserCount);
    message.advertiserCategory !== void 0 && (obj.advertiserCategory = message.advertiserCategory);
    message.allOriginalContent !== void 0 && (obj.allOriginalContent = message.allOriginalContent);
    message.allowChatPostCreation !== void 0 && (obj.allowChatPostCreation = message.allowChatPostCreation);
    message.allowDiscovery !== void 0 && (obj.allowDiscovery = message.allowDiscovery);
    message.allowGalleries !== void 0 && (obj.allowGalleries = message.allowGalleries);
    message.allowImages !== void 0 && (obj.allowImages = message.allowImages);
    message.allowPolls !== void 0 && (obj.allowPolls = message.allowPolls);
    message.allowPredictionContributors !== void 0 && (obj.allowPredictionContributors = message.allowPredictionContributors);
    message.allowPredictionsTournament !== void 0 && (obj.allowPredictionsTournament = message.allowPredictionsTournament);
    message.allowPredictions !== void 0 && (obj.allowPredictions = message.allowPredictions);
    message.allowTalks !== void 0 && (obj.allowTalks = message.allowTalks);
    message.allowVideogifs !== void 0 && (obj.allowVideogifs = message.allowVideogifs);
    message.allowVideos !== void 0 && (obj.allowVideos = message.allowVideos);
    if (message.allowedMediaInComments) {
      obj.allowedMediaInComments = message.allowedMediaInComments.map((e) => e);
    } else {
      obj.allowedMediaInComments = [];
    }
    message.bannerBackgroundColor !== void 0 && (obj.bannerBackgroundColor = message.bannerBackgroundColor);
    message.bannerBackgroundImage !== void 0 && (obj.bannerBackgroundImage = message.bannerBackgroundImage);
    message.bannerImg !== void 0 && (obj.bannerImg = message.bannerImg);
    if (message.bannerSize) {
      obj.bannerSize = message.bannerSize.map((e) => e);
    } else {
      obj.bannerSize = [];
    }
    message.canAssignLinkFlair !== void 0 && (obj.canAssignLinkFlair = message.canAssignLinkFlair);
    message.canAssignUserFlair !== void 0 && (obj.canAssignUserFlair = message.canAssignUserFlair);
    message.coins !== void 0 && (obj.coins = message.coins);
    message.collapseDeletedComments !== void 0 && (obj.collapseDeletedComments = message.collapseDeletedComments);
    message.commentContributionSettings !== void 0 && (obj.commentContributionSettings = message.commentContributionSettings ? CommentContributionSettings.toJSON(message.commentContributionSettings) : void 0);
    message.commentScoreHideMins !== void 0 && (obj.commentScoreHideMins = message.commentScoreHideMins);
    message.communityIcon !== void 0 && (obj.communityIcon = message.communityIcon);
    message.communityReviewed !== void 0 && (obj.communityReviewed = message.communityReviewed);
    message.contentCategory !== void 0 && (obj.contentCategory = message.contentCategory);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    message.created !== void 0 && (obj.created = message.created);
    message.defaultSet !== void 0 && (obj.defaultSet = message.defaultSet);
    message.description !== void 0 && (obj.description = message.description);
    message.descriptionHtml !== void 0 && (obj.descriptionHtml = message.descriptionHtml);
    message.disableContributorRequests !== void 0 && (obj.disableContributorRequests = message.disableContributorRequests);
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    message.displayNamePrefixed !== void 0 && (obj.displayNamePrefixed = message.displayNamePrefixed);
    if (message.emojisCustomSize) {
      obj.emojisCustomSize = message.emojisCustomSize.map((e) => e);
    } else {
      obj.emojisCustomSize = [];
    }
    message.emojisEnabled !== void 0 && (obj.emojisEnabled = message.emojisEnabled);
    message.freeFormReports !== void 0 && (obj.freeFormReports = message.freeFormReports);
    message.hasMenuWidget !== void 0 && (obj.hasMenuWidget = message.hasMenuWidget);
    message.headerImg !== void 0 && (obj.headerImg = message.headerImg);
    if (message.headerSize) {
      obj.headerSize = message.headerSize.map((e) => e);
    } else {
      obj.headerSize = [];
    }
    message.headerTitle !== void 0 && (obj.headerTitle = message.headerTitle);
    message.hideAds !== void 0 && (obj.hideAds = message.hideAds);
    message.iconColor !== void 0 && (obj.iconColor = message.iconColor);
    message.iconImg !== void 0 && (obj.iconImg = message.iconImg);
    if (message.iconSize) {
      obj.iconSize = message.iconSize.map((e) => e);
    } else {
      obj.iconSize = [];
    }
    message.id !== void 0 && (obj.id = message.id);
    message.isChatPostFeatureEnabled !== void 0 && (obj.isChatPostFeatureEnabled = message.isChatPostFeatureEnabled);
    message.isCrosspostableSubreddit !== void 0 && (obj.isCrosspostableSubreddit = message.isCrosspostableSubreddit);
    message.isDefaultBanner !== void 0 && (obj.isDefaultBanner = message.isDefaultBanner);
    message.isDefaultIcon !== void 0 && (obj.isDefaultIcon = message.isDefaultIcon);
    message.isEnrolledInNewModmail !== void 0 && (obj.isEnrolledInNewModmail = message.isEnrolledInNewModmail);
    message.keyColor !== void 0 && (obj.keyColor = message.keyColor);
    message.lang !== void 0 && (obj.lang = message.lang);
    message.linkFlairEnabled !== void 0 && (obj.linkFlairEnabled = message.linkFlairEnabled);
    message.linkFlairPosition !== void 0 && (obj.linkFlairPosition = message.linkFlairPosition);
    message.mobileBannerImage !== void 0 && (obj.mobileBannerImage = message.mobileBannerImage);
    message.name !== void 0 && (obj.name = message.name);
    message.notificationLevel !== void 0 && (obj.notificationLevel = message.notificationLevel);
    message.originalContentTagEnabled !== void 0 && (obj.originalContentTagEnabled = message.originalContentTagEnabled);
    message.over18 !== void 0 && (obj.over18 = message.over18);
    message.predictionLeaderboardEntryType !== void 0 && (obj.predictionLeaderboardEntryType = message.predictionLeaderboardEntryType);
    if (message.previousNames) {
      obj.previousNames = message.previousNames.map((e) => e);
    } else {
      obj.previousNames = [];
    }
    message.primaryColor !== void 0 && (obj.primaryColor = message.primaryColor);
    message.publicDescription !== void 0 && (obj.publicDescription = message.publicDescription);
    message.publicDescriptionHtml !== void 0 && (obj.publicDescriptionHtml = message.publicDescriptionHtml);
    message.publicTraffic !== void 0 && (obj.publicTraffic = message.publicTraffic);
    message.quarantine !== void 0 && (obj.quarantine = message.quarantine);
    message.restrictCommenting !== void 0 && (obj.restrictCommenting = message.restrictCommenting);
    message.restrictPosting !== void 0 && (obj.restrictPosting = message.restrictPosting);
    message.shouldArchivePosts !== void 0 && (obj.shouldArchivePosts = message.shouldArchivePosts);
    message.shouldShowMediaInCommentsSetting !== void 0 && (obj.shouldShowMediaInCommentsSetting = message.shouldShowMediaInCommentsSetting);
    message.showMedia !== void 0 && (obj.showMedia = message.showMedia);
    message.showMediaPreview !== void 0 && (obj.showMediaPreview = message.showMediaPreview);
    message.spoilersEnabled !== void 0 && (obj.spoilersEnabled = message.spoilersEnabled);
    message.submissionType !== void 0 && (obj.submissionType = message.submissionType);
    message.submitLinkLabel !== void 0 && (obj.submitLinkLabel = message.submitLinkLabel);
    message.submitText !== void 0 && (obj.submitText = message.submitText);
    message.submitTextHtml !== void 0 && (obj.submitTextHtml = message.submitTextHtml);
    message.submitTextLabel !== void 0 && (obj.submitTextLabel = message.submitTextLabel);
    message.subredditType !== void 0 && (obj.subredditType = message.subredditType);
    message.subscribers !== void 0 && (obj.subscribers = message.subscribers);
    message.suggestedCommentSort !== void 0 && (obj.suggestedCommentSort = message.suggestedCommentSort);
    message.title !== void 0 && (obj.title = message.title);
    message.url !== void 0 && (obj.url = message.url);
    message.userCanFlairInSr !== void 0 && (obj.userCanFlairInSr = message.userCanFlairInSr);
    message.userFlairBackgroundColor !== void 0 && (obj.userFlairBackgroundColor = message.userFlairBackgroundColor);
    message.userFlairCssClass !== void 0 && (obj.userFlairCssClass = message.userFlairCssClass);
    message.userFlairEnabledInSr !== void 0 && (obj.userFlairEnabledInSr = message.userFlairEnabledInSr);
    message.userFlairPosition !== void 0 && (obj.userFlairPosition = message.userFlairPosition);
    if (message.userFlairRichtext) {
      obj.userFlairRichtext = message.userFlairRichtext.map((e) => e ? UserFlairRichtext.toJSON(e) : void 0);
    } else {
      obj.userFlairRichtext = [];
    }
    message.userFlairTemplateId !== void 0 && (obj.userFlairTemplateId = message.userFlairTemplateId);
    message.userFlairText !== void 0 && (obj.userFlairText = message.userFlairText);
    message.userFlairTextColor !== void 0 && (obj.userFlairTextColor = message.userFlairTextColor);
    message.userFlairType !== void 0 && (obj.userFlairType = message.userFlairType);
    message.userHasFavorited !== void 0 && (obj.userHasFavorited = message.userHasFavorited);
    message.userIsBanned !== void 0 && (obj.userIsBanned = message.userIsBanned);
    message.userIsContributor !== void 0 && (obj.userIsContributor = message.userIsContributor);
    message.userIsModerator !== void 0 && (obj.userIsModerator = message.userIsModerator);
    message.userIsMuted !== void 0 && (obj.userIsMuted = message.userIsMuted);
    message.userIsSubscriber !== void 0 && (obj.userIsSubscriber = message.userIsSubscriber);
    message.userSrFlairEnabled !== void 0 && (obj.userSrFlairEnabled = message.userSrFlairEnabled);
    message.userSrThemeEnabled !== void 0 && (obj.userSrThemeEnabled = message.userSrThemeEnabled);
    message.videostreamLinksCount !== void 0 && (obj.videostreamLinksCount = message.videostreamLinksCount);
    message.whitelistStatus !== void 0 && (obj.whitelistStatus = message.whitelistStatus);
    message.wikiEnabled !== void 0 && (obj.wikiEnabled = message.wikiEnabled);
    message.wls !== void 0 && (obj.wls = message.wls);
    message.markedSpam !== void 0 && (obj.markedSpam = message.markedSpam);
    message.postRequirements !== void 0 && (obj.postRequirements = message.postRequirements ? Subreddit_PostRequirements.toJSON(message.postRequirements) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubreddit();
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.accountsActiveIsFuzzed = object.accountsActiveIsFuzzed ?? void 0;
    message.accountsActive = object.accountsActive ?? void 0;
    message.activeUserCount = object.activeUserCount ?? void 0;
    message.advertiserCategory = object.advertiserCategory ?? void 0;
    message.allOriginalContent = object.allOriginalContent ?? void 0;
    message.allowChatPostCreation = object.allowChatPostCreation ?? void 0;
    message.allowDiscovery = object.allowDiscovery ?? void 0;
    message.allowGalleries = object.allowGalleries ?? void 0;
    message.allowImages = object.allowImages ?? void 0;
    message.allowPolls = object.allowPolls ?? void 0;
    message.allowPredictionContributors = object.allowPredictionContributors ?? void 0;
    message.allowPredictionsTournament = object.allowPredictionsTournament ?? void 0;
    message.allowPredictions = object.allowPredictions ?? void 0;
    message.allowTalks = object.allowTalks ?? void 0;
    message.allowVideogifs = object.allowVideogifs ?? void 0;
    message.allowVideos = object.allowVideos ?? void 0;
    message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
    message.bannerBackgroundColor = object.bannerBackgroundColor ?? void 0;
    message.bannerBackgroundImage = object.bannerBackgroundImage ?? void 0;
    message.bannerImg = object.bannerImg ?? void 0;
    message.bannerSize = object.bannerSize?.map((e) => e) || [];
    message.canAssignLinkFlair = object.canAssignLinkFlair ?? void 0;
    message.canAssignUserFlair = object.canAssignUserFlair ?? void 0;
    message.coins = object.coins ?? void 0;
    message.collapseDeletedComments = object.collapseDeletedComments ?? void 0;
    message.commentContributionSettings = object.commentContributionSettings !== void 0 && object.commentContributionSettings !== null ? CommentContributionSettings.fromPartial(object.commentContributionSettings) : void 0;
    message.commentScoreHideMins = object.commentScoreHideMins ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.communityReviewed = object.communityReviewed ?? void 0;
    message.contentCategory = object.contentCategory ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.created = object.created ?? void 0;
    message.defaultSet = object.defaultSet ?? void 0;
    message.description = object.description ?? void 0;
    message.descriptionHtml = object.descriptionHtml ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.displayNamePrefixed = object.displayNamePrefixed ?? void 0;
    message.emojisCustomSize = object.emojisCustomSize?.map((e) => e) || [];
    message.emojisEnabled = object.emojisEnabled ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.hasMenuWidget = object.hasMenuWidget ?? void 0;
    message.headerImg = object.headerImg ?? void 0;
    message.headerSize = object.headerSize?.map((e) => e) || [];
    message.headerTitle = object.headerTitle ?? void 0;
    message.hideAds = object.hideAds ?? void 0;
    message.iconColor = object.iconColor ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.iconSize = object.iconSize?.map((e) => e) || [];
    message.id = object.id ?? void 0;
    message.isChatPostFeatureEnabled = object.isChatPostFeatureEnabled ?? void 0;
    message.isCrosspostableSubreddit = object.isCrosspostableSubreddit ?? void 0;
    message.isDefaultBanner = object.isDefaultBanner ?? void 0;
    message.isDefaultIcon = object.isDefaultIcon ?? void 0;
    message.isEnrolledInNewModmail = object.isEnrolledInNewModmail ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.lang = object.lang ?? void 0;
    message.linkFlairEnabled = object.linkFlairEnabled ?? void 0;
    message.linkFlairPosition = object.linkFlairPosition ?? void 0;
    message.mobileBannerImage = object.mobileBannerImage ?? void 0;
    message.name = object.name ?? void 0;
    message.notificationLevel = object.notificationLevel ?? void 0;
    message.originalContentTagEnabled = object.originalContentTagEnabled ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? void 0;
    message.previousNames = object.previousNames?.map((e) => e) || [];
    message.primaryColor = object.primaryColor ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.publicDescriptionHtml = object.publicDescriptionHtml ?? void 0;
    message.publicTraffic = object.publicTraffic ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.shouldArchivePosts = object.shouldArchivePosts ?? void 0;
    message.shouldShowMediaInCommentsSetting = object.shouldShowMediaInCommentsSetting ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.showMediaPreview = object.showMediaPreview ?? void 0;
    message.spoilersEnabled = object.spoilersEnabled ?? void 0;
    message.submissionType = object.submissionType ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.submitText = object.submitText ?? void 0;
    message.submitTextHtml = object.submitTextHtml ?? void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.suggestedCommentSort = object.suggestedCommentSort ?? void 0;
    message.title = object.title ?? void 0;
    message.url = object.url ?? void 0;
    message.userCanFlairInSr = object.userCanFlairInSr ?? void 0;
    message.userFlairBackgroundColor = object.userFlairBackgroundColor ?? void 0;
    message.userFlairCssClass = object.userFlairCssClass ?? void 0;
    message.userFlairEnabledInSr = object.userFlairEnabledInSr ?? void 0;
    message.userFlairPosition = object.userFlairPosition ?? void 0;
    message.userFlairRichtext = object.userFlairRichtext?.map((e) => UserFlairRichtext.fromPartial(e)) || [];
    message.userFlairTemplateId = object.userFlairTemplateId ?? void 0;
    message.userFlairText = object.userFlairText ?? void 0;
    message.userFlairTextColor = object.userFlairTextColor ?? void 0;
    message.userFlairType = object.userFlairType ?? void 0;
    message.userHasFavorited = object.userHasFavorited ?? void 0;
    message.userIsBanned = object.userIsBanned ?? void 0;
    message.userIsContributor = object.userIsContributor ?? void 0;
    message.userIsModerator = object.userIsModerator ?? void 0;
    message.userIsMuted = object.userIsMuted ?? void 0;
    message.userIsSubscriber = object.userIsSubscriber ?? void 0;
    message.userSrFlairEnabled = object.userSrFlairEnabled ?? void 0;
    message.userSrThemeEnabled = object.userSrThemeEnabled ?? void 0;
    message.videostreamLinksCount = object.videostreamLinksCount ?? void 0;
    message.whitelistStatus = object.whitelistStatus ?? void 0;
    message.wikiEnabled = object.wikiEnabled ?? void 0;
    message.wls = object.wls ?? void 0;
    message.markedSpam = object.markedSpam ?? void 0;
    message.postRequirements = object.postRequirements !== void 0 && object.postRequirements !== null ? Subreddit_PostRequirements.fromPartial(object.postRequirements) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.Subreddit", Subreddit);
function createBaseSubreddit_PostRequirements() {
  return { bodyRestrictionPolicy: void 0 };
}
var Subreddit_PostRequirements = {
  $type: "devvit.reddit.Subreddit.PostRequirements",
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.bodyRestrictionPolicy !== void 0) {
      StringValue.encode({ value: message.bodyRestrictionPolicy }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : new import_minimal8.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubreddit_PostRequirements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bodyRestrictionPolicy = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      bodyRestrictionPolicy: isSet7(object.bodyRestrictionPolicy) ? String(object.bodyRestrictionPolicy) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.bodyRestrictionPolicy !== void 0 && (obj.bodyRestrictionPolicy = message.bodyRestrictionPolicy);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubreddit_PostRequirements();
    message.bodyRestrictionPolicy = object.bodyRestrictionPolicy ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.Subreddit.PostRequirements", Subreddit_PostRequirements);
function isSet7(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/user.js
var import_minimal9 = __toESM(require_minimal2(), 1);
function createBaseUser() {
  return {
    acceptChats: void 0,
    acceptFollowers: void 0,
    acceptPms: void 0,
    awardeeKarma: void 0,
    awarderKarma: void 0,
    canCreateSubreddit: void 0,
    canEditName: void 0,
    coins: void 0,
    commentKarma: void 0,
    created: void 0,
    createdUtc: void 0,
    features: void 0,
    forcePasswordReset: void 0,
    goldCreddits: void 0,
    goldExpiration: void 0,
    hasAndroidSubscription: void 0,
    hasExternalAccount: void 0,
    hasGoldSubscription: void 0,
    hasIosSubscription: void 0,
    hasMail: void 0,
    hasModMail: void 0,
    hasPaypalSubscription: void 0,
    hasStripeSubscription: void 0,
    hasSubscribed: void 0,
    hasSubscribedToPremium: void 0,
    hasVerifiedEmail: void 0,
    hasVisitedNewProfile: void 0,
    hideFromRobots: void 0,
    iconImg: void 0,
    id: void 0,
    inBeta: void 0,
    inChat: void 0,
    inRedesignBeta: void 0,
    inboxCount: void 0,
    isBlocked: void 0,
    isEmployee: void 0,
    isFriend: void 0,
    isGold: void 0,
    isMod: void 0,
    isSponsor: void 0,
    isSuspended: void 0,
    linkKarma: void 0,
    modhash: void 0,
    name: void 0,
    newModmailExists: void 0,
    numFriends: void 0,
    over18: void 0,
    passwordSet: void 0,
    prefAutoplay: void 0,
    prefClickgadget: void 0,
    prefGeopopular: void 0,
    prefNightmode: void 0,
    prefNoProfanity: void 0,
    prefShowPresence: void 0,
    prefShowSnoovatar: void 0,
    prefShowTrending: void 0,
    prefShowTwitter: void 0,
    prefTopKarmaSubreddits: void 0,
    prefVideoAutoplay: void 0,
    snoovatarImg: void 0,
    snoovatarSize: [],
    subreddit: void 0,
    suspensionExpirationUtc: void 0,
    totalKarma: void 0,
    verified: void 0,
    hasPhoneNumber: void 0,
    subredditsModerated: void 0,
    hasMetaSubscription: void 0,
    metaSubscriptionAge: void 0,
    metaPointsBalance: void 0,
    metaLockedPointsBalance: void 0,
    commentSubredditKarma: void 0,
    postSubredditKarma: void 0,
    markedSpam: void 0,
    isSubredditProxyAccount: void 0
  };
}
var User = {
  $type: "devvit.reddit.User",
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.acceptChats !== void 0) {
      BoolValue.encode({ value: message.acceptChats }, writer.uint32(10).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(18).fork()).ldelim();
    }
    if (message.acceptPms !== void 0) {
      BoolValue.encode({ value: message.acceptPms }, writer.uint32(26).fork()).ldelim();
    }
    if (message.awardeeKarma !== void 0) {
      Int32Value.encode({ value: message.awardeeKarma }, writer.uint32(34).fork()).ldelim();
    }
    if (message.awarderKarma !== void 0) {
      Int32Value.encode({ value: message.awarderKarma }, writer.uint32(42).fork()).ldelim();
    }
    if (message.canCreateSubreddit !== void 0) {
      BoolValue.encode({ value: message.canCreateSubreddit }, writer.uint32(50).fork()).ldelim();
    }
    if (message.canEditName !== void 0) {
      BoolValue.encode({ value: message.canEditName }, writer.uint32(58).fork()).ldelim();
    }
    if (message.coins !== void 0) {
      Int32Value.encode({ value: message.coins }, writer.uint32(66).fork()).ldelim();
    }
    if (message.commentKarma !== void 0) {
      Int32Value.encode({ value: message.commentKarma }, writer.uint32(74).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int32Value.encode({ value: message.created }, writer.uint32(82).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int32Value.encode({ value: message.createdUtc }, writer.uint32(90).fork()).ldelim();
    }
    if (message.features !== void 0) {
      UserFeatures.encode(message.features, writer.uint32(98).fork()).ldelim();
    }
    if (message.forcePasswordReset !== void 0) {
      BoolValue.encode({ value: message.forcePasswordReset }, writer.uint32(106).fork()).ldelim();
    }
    if (message.goldCreddits !== void 0) {
      Int32Value.encode({ value: message.goldCreddits }, writer.uint32(114).fork()).ldelim();
    }
    if (message.goldExpiration !== void 0) {
      StringValue.encode({ value: message.goldExpiration }, writer.uint32(122).fork()).ldelim();
    }
    if (message.hasAndroidSubscription !== void 0) {
      BoolValue.encode({ value: message.hasAndroidSubscription }, writer.uint32(130).fork()).ldelim();
    }
    if (message.hasExternalAccount !== void 0) {
      BoolValue.encode({ value: message.hasExternalAccount }, writer.uint32(138).fork()).ldelim();
    }
    if (message.hasGoldSubscription !== void 0) {
      BoolValue.encode({ value: message.hasGoldSubscription }, writer.uint32(146).fork()).ldelim();
    }
    if (message.hasIosSubscription !== void 0) {
      BoolValue.encode({ value: message.hasIosSubscription }, writer.uint32(154).fork()).ldelim();
    }
    if (message.hasMail !== void 0) {
      BoolValue.encode({ value: message.hasMail }, writer.uint32(162).fork()).ldelim();
    }
    if (message.hasModMail !== void 0) {
      BoolValue.encode({ value: message.hasModMail }, writer.uint32(170).fork()).ldelim();
    }
    if (message.hasPaypalSubscription !== void 0) {
      BoolValue.encode({ value: message.hasPaypalSubscription }, writer.uint32(178).fork()).ldelim();
    }
    if (message.hasStripeSubscription !== void 0) {
      BoolValue.encode({ value: message.hasStripeSubscription }, writer.uint32(186).fork()).ldelim();
    }
    if (message.hasSubscribed !== void 0) {
      BoolValue.encode({ value: message.hasSubscribed }, writer.uint32(194).fork()).ldelim();
    }
    if (message.hasSubscribedToPremium !== void 0) {
      BoolValue.encode({ value: message.hasSubscribedToPremium }, writer.uint32(202).fork()).ldelim();
    }
    if (message.hasVerifiedEmail !== void 0) {
      BoolValue.encode({ value: message.hasVerifiedEmail }, writer.uint32(210).fork()).ldelim();
    }
    if (message.hasVisitedNewProfile !== void 0) {
      BoolValue.encode({ value: message.hasVisitedNewProfile }, writer.uint32(218).fork()).ldelim();
    }
    if (message.hideFromRobots !== void 0) {
      BoolValue.encode({ value: message.hideFromRobots }, writer.uint32(226).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(234).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(242).fork()).ldelim();
    }
    if (message.inBeta !== void 0) {
      BoolValue.encode({ value: message.inBeta }, writer.uint32(250).fork()).ldelim();
    }
    if (message.inChat !== void 0) {
      BoolValue.encode({ value: message.inChat }, writer.uint32(258).fork()).ldelim();
    }
    if (message.inRedesignBeta !== void 0) {
      BoolValue.encode({ value: message.inRedesignBeta }, writer.uint32(266).fork()).ldelim();
    }
    if (message.inboxCount !== void 0) {
      Int32Value.encode({ value: message.inboxCount }, writer.uint32(274).fork()).ldelim();
    }
    if (message.isBlocked !== void 0) {
      BoolValue.encode({ value: message.isBlocked }, writer.uint32(282).fork()).ldelim();
    }
    if (message.isEmployee !== void 0) {
      BoolValue.encode({ value: message.isEmployee }, writer.uint32(290).fork()).ldelim();
    }
    if (message.isFriend !== void 0) {
      BoolValue.encode({ value: message.isFriend }, writer.uint32(298).fork()).ldelim();
    }
    if (message.isGold !== void 0) {
      BoolValue.encode({ value: message.isGold }, writer.uint32(306).fork()).ldelim();
    }
    if (message.isMod !== void 0) {
      BoolValue.encode({ value: message.isMod }, writer.uint32(314).fork()).ldelim();
    }
    if (message.isSponsor !== void 0) {
      BoolValue.encode({ value: message.isSponsor }, writer.uint32(322).fork()).ldelim();
    }
    if (message.isSuspended !== void 0) {
      BoolValue.encode({ value: message.isSuspended }, writer.uint32(330).fork()).ldelim();
    }
    if (message.linkKarma !== void 0) {
      Int32Value.encode({ value: message.linkKarma }, writer.uint32(338).fork()).ldelim();
    }
    if (message.modhash !== void 0) {
      StringValue.encode({ value: message.modhash }, writer.uint32(346).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(354).fork()).ldelim();
    }
    if (message.newModmailExists !== void 0) {
      BoolValue.encode({ value: message.newModmailExists }, writer.uint32(362).fork()).ldelim();
    }
    if (message.numFriends !== void 0) {
      Int32Value.encode({ value: message.numFriends }, writer.uint32(370).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(378).fork()).ldelim();
    }
    if (message.passwordSet !== void 0) {
      BoolValue.encode({ value: message.passwordSet }, writer.uint32(386).fork()).ldelim();
    }
    if (message.prefAutoplay !== void 0) {
      BoolValue.encode({ value: message.prefAutoplay }, writer.uint32(394).fork()).ldelim();
    }
    if (message.prefClickgadget !== void 0) {
      Int32Value.encode({ value: message.prefClickgadget }, writer.uint32(402).fork()).ldelim();
    }
    if (message.prefGeopopular !== void 0) {
      StringValue.encode({ value: message.prefGeopopular }, writer.uint32(410).fork()).ldelim();
    }
    if (message.prefNightmode !== void 0) {
      BoolValue.encode({ value: message.prefNightmode }, writer.uint32(418).fork()).ldelim();
    }
    if (message.prefNoProfanity !== void 0) {
      BoolValue.encode({ value: message.prefNoProfanity }, writer.uint32(426).fork()).ldelim();
    }
    if (message.prefShowPresence !== void 0) {
      BoolValue.encode({ value: message.prefShowPresence }, writer.uint32(434).fork()).ldelim();
    }
    if (message.prefShowSnoovatar !== void 0) {
      BoolValue.encode({ value: message.prefShowSnoovatar }, writer.uint32(442).fork()).ldelim();
    }
    if (message.prefShowTrending !== void 0) {
      BoolValue.encode({ value: message.prefShowTrending }, writer.uint32(450).fork()).ldelim();
    }
    if (message.prefShowTwitter !== void 0) {
      BoolValue.encode({ value: message.prefShowTwitter }, writer.uint32(458).fork()).ldelim();
    }
    if (message.prefTopKarmaSubreddits !== void 0) {
      BoolValue.encode({ value: message.prefTopKarmaSubreddits }, writer.uint32(466).fork()).ldelim();
    }
    if (message.prefVideoAutoplay !== void 0) {
      BoolValue.encode({ value: message.prefVideoAutoplay }, writer.uint32(474).fork()).ldelim();
    }
    if (message.snoovatarImg !== void 0) {
      StringValue.encode({ value: message.snoovatarImg }, writer.uint32(482).fork()).ldelim();
    }
    for (const v of message.snoovatarSize) {
      Int32Value.encode({ value: v }, writer.uint32(490).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      Subreddit.encode(message.subreddit, writer.uint32(498).fork()).ldelim();
    }
    if (message.suspensionExpirationUtc !== void 0) {
      StringValue.encode({ value: message.suspensionExpirationUtc }, writer.uint32(506).fork()).ldelim();
    }
    if (message.totalKarma !== void 0) {
      Int32Value.encode({ value: message.totalKarma }, writer.uint32(514).fork()).ldelim();
    }
    if (message.verified !== void 0) {
      BoolValue.encode({ value: message.verified }, writer.uint32(522).fork()).ldelim();
    }
    if (message.hasPhoneNumber !== void 0) {
      BoolValue.encode({ value: message.hasPhoneNumber }, writer.uint32(530).fork()).ldelim();
    }
    if (message.subredditsModerated !== void 0) {
      Int32Value.encode({ value: message.subredditsModerated }, writer.uint32(802).fork()).ldelim();
    }
    if (message.hasMetaSubscription !== void 0) {
      BoolValue.encode({ value: message.hasMetaSubscription }, writer.uint32(810).fork()).ldelim();
    }
    if (message.metaSubscriptionAge !== void 0) {
      Int32Value.encode({ value: message.metaSubscriptionAge }, writer.uint32(818).fork()).ldelim();
    }
    if (message.metaPointsBalance !== void 0) {
      StringValue.encode({ value: message.metaPointsBalance }, writer.uint32(826).fork()).ldelim();
    }
    if (message.metaLockedPointsBalance !== void 0) {
      StringValue.encode({ value: message.metaLockedPointsBalance }, writer.uint32(834).fork()).ldelim();
    }
    if (message.commentSubredditKarma !== void 0) {
      Int32Value.encode({ value: message.commentSubredditKarma }, writer.uint32(842).fork()).ldelim();
    }
    if (message.postSubredditKarma !== void 0) {
      Int32Value.encode({ value: message.postSubredditKarma }, writer.uint32(850).fork()).ldelim();
    }
    if (message.markedSpam !== void 0) {
      BoolValue.encode({ value: message.markedSpam }, writer.uint32(858).fork()).ldelim();
    }
    if (message.isSubredditProxyAccount !== void 0) {
      BoolValue.encode({ value: message.isSubredditProxyAccount }, writer.uint32(866).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.acceptChats = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.acceptPms = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.awardeeKarma = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.awarderKarma = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.canCreateSubreddit = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.canEditName = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.coins = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.commentKarma = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.created = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.createdUtc = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.features = UserFeatures.decode(reader, reader.uint32());
          break;
        case 13:
          message.forcePasswordReset = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.goldCreddits = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.goldExpiration = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.hasAndroidSubscription = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.hasExternalAccount = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.hasGoldSubscription = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.hasIosSubscription = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.hasMail = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.hasModMail = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.hasPaypalSubscription = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.hasStripeSubscription = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.hasSubscribed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.hasSubscribedToPremium = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.hasVerifiedEmail = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 27:
          message.hasVisitedNewProfile = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.hideFromRobots = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.inBeta = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.inChat = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.inRedesignBeta = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.inboxCount = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 35:
          message.isBlocked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.isEmployee = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 37:
          message.isFriend = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 38:
          message.isGold = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 39:
          message.isMod = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 40:
          message.isSponsor = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 41:
          message.isSuspended = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 42:
          message.linkKarma = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 43:
          message.modhash = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 44:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 45:
          message.newModmailExists = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 46:
          message.numFriends = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 47:
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 48:
          message.passwordSet = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 49:
          message.prefAutoplay = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 50:
          message.prefClickgadget = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 51:
          message.prefGeopopular = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 52:
          message.prefNightmode = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 53:
          message.prefNoProfanity = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 54:
          message.prefShowPresence = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 55:
          message.prefShowSnoovatar = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 56:
          message.prefShowTrending = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 57:
          message.prefShowTwitter = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 58:
          message.prefTopKarmaSubreddits = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 59:
          message.prefVideoAutoplay = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 60:
          message.snoovatarImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 61:
          message.snoovatarSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 62:
          message.subreddit = Subreddit.decode(reader, reader.uint32());
          break;
        case 63:
          message.suspensionExpirationUtc = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 64:
          message.totalKarma = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 65:
          message.verified = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 66:
          message.hasPhoneNumber = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 100:
          message.subredditsModerated = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 101:
          message.hasMetaSubscription = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 102:
          message.metaSubscriptionAge = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 103:
          message.metaPointsBalance = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 104:
          message.metaLockedPointsBalance = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 105:
          message.commentSubredditKarma = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 106:
          message.postSubredditKarma = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 107:
          message.markedSpam = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 108:
          message.isSubredditProxyAccount = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      acceptChats: isSet8(object.acceptChats) ? Boolean(object.acceptChats) : void 0,
      acceptFollowers: isSet8(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      acceptPms: isSet8(object.acceptPms) ? Boolean(object.acceptPms) : void 0,
      awardeeKarma: isSet8(object.awardeeKarma) ? Number(object.awardeeKarma) : void 0,
      awarderKarma: isSet8(object.awarderKarma) ? Number(object.awarderKarma) : void 0,
      canCreateSubreddit: isSet8(object.canCreateSubreddit) ? Boolean(object.canCreateSubreddit) : void 0,
      canEditName: isSet8(object.canEditName) ? Boolean(object.canEditName) : void 0,
      coins: isSet8(object.coins) ? Number(object.coins) : void 0,
      commentKarma: isSet8(object.commentKarma) ? Number(object.commentKarma) : void 0,
      created: isSet8(object.created) ? Number(object.created) : void 0,
      createdUtc: isSet8(object.createdUtc) ? Number(object.createdUtc) : void 0,
      features: isSet8(object.features) ? UserFeatures.fromJSON(object.features) : void 0,
      forcePasswordReset: isSet8(object.forcePasswordReset) ? Boolean(object.forcePasswordReset) : void 0,
      goldCreddits: isSet8(object.goldCreddits) ? Number(object.goldCreddits) : void 0,
      goldExpiration: isSet8(object.goldExpiration) ? String(object.goldExpiration) : void 0,
      hasAndroidSubscription: isSet8(object.hasAndroidSubscription) ? Boolean(object.hasAndroidSubscription) : void 0,
      hasExternalAccount: isSet8(object.hasExternalAccount) ? Boolean(object.hasExternalAccount) : void 0,
      hasGoldSubscription: isSet8(object.hasGoldSubscription) ? Boolean(object.hasGoldSubscription) : void 0,
      hasIosSubscription: isSet8(object.hasIosSubscription) ? Boolean(object.hasIosSubscription) : void 0,
      hasMail: isSet8(object.hasMail) ? Boolean(object.hasMail) : void 0,
      hasModMail: isSet8(object.hasModMail) ? Boolean(object.hasModMail) : void 0,
      hasPaypalSubscription: isSet8(object.hasPaypalSubscription) ? Boolean(object.hasPaypalSubscription) : void 0,
      hasStripeSubscription: isSet8(object.hasStripeSubscription) ? Boolean(object.hasStripeSubscription) : void 0,
      hasSubscribed: isSet8(object.hasSubscribed) ? Boolean(object.hasSubscribed) : void 0,
      hasSubscribedToPremium: isSet8(object.hasSubscribedToPremium) ? Boolean(object.hasSubscribedToPremium) : void 0,
      hasVerifiedEmail: isSet8(object.hasVerifiedEmail) ? Boolean(object.hasVerifiedEmail) : void 0,
      hasVisitedNewProfile: isSet8(object.hasVisitedNewProfile) ? Boolean(object.hasVisitedNewProfile) : void 0,
      hideFromRobots: isSet8(object.hideFromRobots) ? Boolean(object.hideFromRobots) : void 0,
      iconImg: isSet8(object.iconImg) ? String(object.iconImg) : void 0,
      id: isSet8(object.id) ? String(object.id) : void 0,
      inBeta: isSet8(object.inBeta) ? Boolean(object.inBeta) : void 0,
      inChat: isSet8(object.inChat) ? Boolean(object.inChat) : void 0,
      inRedesignBeta: isSet8(object.inRedesignBeta) ? Boolean(object.inRedesignBeta) : void 0,
      inboxCount: isSet8(object.inboxCount) ? Number(object.inboxCount) : void 0,
      isBlocked: isSet8(object.isBlocked) ? Boolean(object.isBlocked) : void 0,
      isEmployee: isSet8(object.isEmployee) ? Boolean(object.isEmployee) : void 0,
      isFriend: isSet8(object.isFriend) ? Boolean(object.isFriend) : void 0,
      isGold: isSet8(object.isGold) ? Boolean(object.isGold) : void 0,
      isMod: isSet8(object.isMod) ? Boolean(object.isMod) : void 0,
      isSponsor: isSet8(object.isSponsor) ? Boolean(object.isSponsor) : void 0,
      isSuspended: isSet8(object.isSuspended) ? Boolean(object.isSuspended) : void 0,
      linkKarma: isSet8(object.linkKarma) ? Number(object.linkKarma) : void 0,
      modhash: isSet8(object.modhash) ? String(object.modhash) : void 0,
      name: isSet8(object.name) ? String(object.name) : void 0,
      newModmailExists: isSet8(object.newModmailExists) ? Boolean(object.newModmailExists) : void 0,
      numFriends: isSet8(object.numFriends) ? Number(object.numFriends) : void 0,
      over18: isSet8(object.over18) ? Boolean(object.over18) : void 0,
      passwordSet: isSet8(object.passwordSet) ? Boolean(object.passwordSet) : void 0,
      prefAutoplay: isSet8(object.prefAutoplay) ? Boolean(object.prefAutoplay) : void 0,
      prefClickgadget: isSet8(object.prefClickgadget) ? Number(object.prefClickgadget) : void 0,
      prefGeopopular: isSet8(object.prefGeopopular) ? String(object.prefGeopopular) : void 0,
      prefNightmode: isSet8(object.prefNightmode) ? Boolean(object.prefNightmode) : void 0,
      prefNoProfanity: isSet8(object.prefNoProfanity) ? Boolean(object.prefNoProfanity) : void 0,
      prefShowPresence: isSet8(object.prefShowPresence) ? Boolean(object.prefShowPresence) : void 0,
      prefShowSnoovatar: isSet8(object.prefShowSnoovatar) ? Boolean(object.prefShowSnoovatar) : void 0,
      prefShowTrending: isSet8(object.prefShowTrending) ? Boolean(object.prefShowTrending) : void 0,
      prefShowTwitter: isSet8(object.prefShowTwitter) ? Boolean(object.prefShowTwitter) : void 0,
      prefTopKarmaSubreddits: isSet8(object.prefTopKarmaSubreddits) ? Boolean(object.prefTopKarmaSubreddits) : void 0,
      prefVideoAutoplay: isSet8(object.prefVideoAutoplay) ? Boolean(object.prefVideoAutoplay) : void 0,
      snoovatarImg: isSet8(object.snoovatarImg) ? String(object.snoovatarImg) : void 0,
      snoovatarSize: Array.isArray(object?.snoovatarSize) ? object.snoovatarSize.map((e) => Number(e)) : [],
      subreddit: isSet8(object.subreddit) ? Subreddit.fromJSON(object.subreddit) : void 0,
      suspensionExpirationUtc: isSet8(object.suspensionExpirationUtc) ? String(object.suspensionExpirationUtc) : void 0,
      totalKarma: isSet8(object.totalKarma) ? Number(object.totalKarma) : void 0,
      verified: isSet8(object.verified) ? Boolean(object.verified) : void 0,
      hasPhoneNumber: isSet8(object.hasPhoneNumber) ? Boolean(object.hasPhoneNumber) : void 0,
      subredditsModerated: isSet8(object.subredditsModerated) ? Number(object.subredditsModerated) : void 0,
      hasMetaSubscription: isSet8(object.hasMetaSubscription) ? Boolean(object.hasMetaSubscription) : void 0,
      metaSubscriptionAge: isSet8(object.metaSubscriptionAge) ? Number(object.metaSubscriptionAge) : void 0,
      metaPointsBalance: isSet8(object.metaPointsBalance) ? String(object.metaPointsBalance) : void 0,
      metaLockedPointsBalance: isSet8(object.metaLockedPointsBalance) ? String(object.metaLockedPointsBalance) : void 0,
      commentSubredditKarma: isSet8(object.commentSubredditKarma) ? Number(object.commentSubredditKarma) : void 0,
      postSubredditKarma: isSet8(object.postSubredditKarma) ? Number(object.postSubredditKarma) : void 0,
      markedSpam: isSet8(object.markedSpam) ? Boolean(object.markedSpam) : void 0,
      isSubredditProxyAccount: isSet8(object.isSubredditProxyAccount) ? Boolean(object.isSubredditProxyAccount) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.acceptChats !== void 0 && (obj.acceptChats = message.acceptChats);
    message.acceptFollowers !== void 0 && (obj.acceptFollowers = message.acceptFollowers);
    message.acceptPms !== void 0 && (obj.acceptPms = message.acceptPms);
    message.awardeeKarma !== void 0 && (obj.awardeeKarma = message.awardeeKarma);
    message.awarderKarma !== void 0 && (obj.awarderKarma = message.awarderKarma);
    message.canCreateSubreddit !== void 0 && (obj.canCreateSubreddit = message.canCreateSubreddit);
    message.canEditName !== void 0 && (obj.canEditName = message.canEditName);
    message.coins !== void 0 && (obj.coins = message.coins);
    message.commentKarma !== void 0 && (obj.commentKarma = message.commentKarma);
    message.created !== void 0 && (obj.created = message.created);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    message.features !== void 0 && (obj.features = message.features ? UserFeatures.toJSON(message.features) : void 0);
    message.forcePasswordReset !== void 0 && (obj.forcePasswordReset = message.forcePasswordReset);
    message.goldCreddits !== void 0 && (obj.goldCreddits = message.goldCreddits);
    message.goldExpiration !== void 0 && (obj.goldExpiration = message.goldExpiration);
    message.hasAndroidSubscription !== void 0 && (obj.hasAndroidSubscription = message.hasAndroidSubscription);
    message.hasExternalAccount !== void 0 && (obj.hasExternalAccount = message.hasExternalAccount);
    message.hasGoldSubscription !== void 0 && (obj.hasGoldSubscription = message.hasGoldSubscription);
    message.hasIosSubscription !== void 0 && (obj.hasIosSubscription = message.hasIosSubscription);
    message.hasMail !== void 0 && (obj.hasMail = message.hasMail);
    message.hasModMail !== void 0 && (obj.hasModMail = message.hasModMail);
    message.hasPaypalSubscription !== void 0 && (obj.hasPaypalSubscription = message.hasPaypalSubscription);
    message.hasStripeSubscription !== void 0 && (obj.hasStripeSubscription = message.hasStripeSubscription);
    message.hasSubscribed !== void 0 && (obj.hasSubscribed = message.hasSubscribed);
    message.hasSubscribedToPremium !== void 0 && (obj.hasSubscribedToPremium = message.hasSubscribedToPremium);
    message.hasVerifiedEmail !== void 0 && (obj.hasVerifiedEmail = message.hasVerifiedEmail);
    message.hasVisitedNewProfile !== void 0 && (obj.hasVisitedNewProfile = message.hasVisitedNewProfile);
    message.hideFromRobots !== void 0 && (obj.hideFromRobots = message.hideFromRobots);
    message.iconImg !== void 0 && (obj.iconImg = message.iconImg);
    message.id !== void 0 && (obj.id = message.id);
    message.inBeta !== void 0 && (obj.inBeta = message.inBeta);
    message.inChat !== void 0 && (obj.inChat = message.inChat);
    message.inRedesignBeta !== void 0 && (obj.inRedesignBeta = message.inRedesignBeta);
    message.inboxCount !== void 0 && (obj.inboxCount = message.inboxCount);
    message.isBlocked !== void 0 && (obj.isBlocked = message.isBlocked);
    message.isEmployee !== void 0 && (obj.isEmployee = message.isEmployee);
    message.isFriend !== void 0 && (obj.isFriend = message.isFriend);
    message.isGold !== void 0 && (obj.isGold = message.isGold);
    message.isMod !== void 0 && (obj.isMod = message.isMod);
    message.isSponsor !== void 0 && (obj.isSponsor = message.isSponsor);
    message.isSuspended !== void 0 && (obj.isSuspended = message.isSuspended);
    message.linkKarma !== void 0 && (obj.linkKarma = message.linkKarma);
    message.modhash !== void 0 && (obj.modhash = message.modhash);
    message.name !== void 0 && (obj.name = message.name);
    message.newModmailExists !== void 0 && (obj.newModmailExists = message.newModmailExists);
    message.numFriends !== void 0 && (obj.numFriends = message.numFriends);
    message.over18 !== void 0 && (obj.over18 = message.over18);
    message.passwordSet !== void 0 && (obj.passwordSet = message.passwordSet);
    message.prefAutoplay !== void 0 && (obj.prefAutoplay = message.prefAutoplay);
    message.prefClickgadget !== void 0 && (obj.prefClickgadget = message.prefClickgadget);
    message.prefGeopopular !== void 0 && (obj.prefGeopopular = message.prefGeopopular);
    message.prefNightmode !== void 0 && (obj.prefNightmode = message.prefNightmode);
    message.prefNoProfanity !== void 0 && (obj.prefNoProfanity = message.prefNoProfanity);
    message.prefShowPresence !== void 0 && (obj.prefShowPresence = message.prefShowPresence);
    message.prefShowSnoovatar !== void 0 && (obj.prefShowSnoovatar = message.prefShowSnoovatar);
    message.prefShowTrending !== void 0 && (obj.prefShowTrending = message.prefShowTrending);
    message.prefShowTwitter !== void 0 && (obj.prefShowTwitter = message.prefShowTwitter);
    message.prefTopKarmaSubreddits !== void 0 && (obj.prefTopKarmaSubreddits = message.prefTopKarmaSubreddits);
    message.prefVideoAutoplay !== void 0 && (obj.prefVideoAutoplay = message.prefVideoAutoplay);
    message.snoovatarImg !== void 0 && (obj.snoovatarImg = message.snoovatarImg);
    if (message.snoovatarSize) {
      obj.snoovatarSize = message.snoovatarSize.map((e) => e);
    } else {
      obj.snoovatarSize = [];
    }
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? Subreddit.toJSON(message.subreddit) : void 0);
    message.suspensionExpirationUtc !== void 0 && (obj.suspensionExpirationUtc = message.suspensionExpirationUtc);
    message.totalKarma !== void 0 && (obj.totalKarma = message.totalKarma);
    message.verified !== void 0 && (obj.verified = message.verified);
    message.hasPhoneNumber !== void 0 && (obj.hasPhoneNumber = message.hasPhoneNumber);
    message.subredditsModerated !== void 0 && (obj.subredditsModerated = message.subredditsModerated);
    message.hasMetaSubscription !== void 0 && (obj.hasMetaSubscription = message.hasMetaSubscription);
    message.metaSubscriptionAge !== void 0 && (obj.metaSubscriptionAge = message.metaSubscriptionAge);
    message.metaPointsBalance !== void 0 && (obj.metaPointsBalance = message.metaPointsBalance);
    message.metaLockedPointsBalance !== void 0 && (obj.metaLockedPointsBalance = message.metaLockedPointsBalance);
    message.commentSubredditKarma !== void 0 && (obj.commentSubredditKarma = message.commentSubredditKarma);
    message.postSubredditKarma !== void 0 && (obj.postSubredditKarma = message.postSubredditKarma);
    message.markedSpam !== void 0 && (obj.markedSpam = message.markedSpam);
    message.isSubredditProxyAccount !== void 0 && (obj.isSubredditProxyAccount = message.isSubredditProxyAccount);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUser();
    message.acceptChats = object.acceptChats ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.acceptPms = object.acceptPms ?? void 0;
    message.awardeeKarma = object.awardeeKarma ?? void 0;
    message.awarderKarma = object.awarderKarma ?? void 0;
    message.canCreateSubreddit = object.canCreateSubreddit ?? void 0;
    message.canEditName = object.canEditName ?? void 0;
    message.coins = object.coins ?? void 0;
    message.commentKarma = object.commentKarma ?? void 0;
    message.created = object.created ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.features = object.features !== void 0 && object.features !== null ? UserFeatures.fromPartial(object.features) : void 0;
    message.forcePasswordReset = object.forcePasswordReset ?? void 0;
    message.goldCreddits = object.goldCreddits ?? void 0;
    message.goldExpiration = object.goldExpiration ?? void 0;
    message.hasAndroidSubscription = object.hasAndroidSubscription ?? void 0;
    message.hasExternalAccount = object.hasExternalAccount ?? void 0;
    message.hasGoldSubscription = object.hasGoldSubscription ?? void 0;
    message.hasIosSubscription = object.hasIosSubscription ?? void 0;
    message.hasMail = object.hasMail ?? void 0;
    message.hasModMail = object.hasModMail ?? void 0;
    message.hasPaypalSubscription = object.hasPaypalSubscription ?? void 0;
    message.hasStripeSubscription = object.hasStripeSubscription ?? void 0;
    message.hasSubscribed = object.hasSubscribed ?? void 0;
    message.hasSubscribedToPremium = object.hasSubscribedToPremium ?? void 0;
    message.hasVerifiedEmail = object.hasVerifiedEmail ?? void 0;
    message.hasVisitedNewProfile = object.hasVisitedNewProfile ?? void 0;
    message.hideFromRobots = object.hideFromRobots ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.id = object.id ?? void 0;
    message.inBeta = object.inBeta ?? void 0;
    message.inChat = object.inChat ?? void 0;
    message.inRedesignBeta = object.inRedesignBeta ?? void 0;
    message.inboxCount = object.inboxCount ?? void 0;
    message.isBlocked = object.isBlocked ?? void 0;
    message.isEmployee = object.isEmployee ?? void 0;
    message.isFriend = object.isFriend ?? void 0;
    message.isGold = object.isGold ?? void 0;
    message.isMod = object.isMod ?? void 0;
    message.isSponsor = object.isSponsor ?? void 0;
    message.isSuspended = object.isSuspended ?? void 0;
    message.linkKarma = object.linkKarma ?? void 0;
    message.modhash = object.modhash ?? void 0;
    message.name = object.name ?? void 0;
    message.newModmailExists = object.newModmailExists ?? void 0;
    message.numFriends = object.numFriends ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.passwordSet = object.passwordSet ?? void 0;
    message.prefAutoplay = object.prefAutoplay ?? void 0;
    message.prefClickgadget = object.prefClickgadget ?? void 0;
    message.prefGeopopular = object.prefGeopopular ?? void 0;
    message.prefNightmode = object.prefNightmode ?? void 0;
    message.prefNoProfanity = object.prefNoProfanity ?? void 0;
    message.prefShowPresence = object.prefShowPresence ?? void 0;
    message.prefShowSnoovatar = object.prefShowSnoovatar ?? void 0;
    message.prefShowTrending = object.prefShowTrending ?? void 0;
    message.prefShowTwitter = object.prefShowTwitter ?? void 0;
    message.prefTopKarmaSubreddits = object.prefTopKarmaSubreddits ?? void 0;
    message.prefVideoAutoplay = object.prefVideoAutoplay ?? void 0;
    message.snoovatarImg = object.snoovatarImg ?? void 0;
    message.snoovatarSize = object.snoovatarSize?.map((e) => e) || [];
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? Subreddit.fromPartial(object.subreddit) : void 0;
    message.suspensionExpirationUtc = object.suspensionExpirationUtc ?? void 0;
    message.totalKarma = object.totalKarma ?? void 0;
    message.verified = object.verified ?? void 0;
    message.hasPhoneNumber = object.hasPhoneNumber ?? void 0;
    message.subredditsModerated = object.subredditsModerated ?? void 0;
    message.hasMetaSubscription = object.hasMetaSubscription ?? void 0;
    message.metaSubscriptionAge = object.metaSubscriptionAge ?? void 0;
    message.metaPointsBalance = object.metaPointsBalance ?? void 0;
    message.metaLockedPointsBalance = object.metaLockedPointsBalance ?? void 0;
    message.commentSubredditKarma = object.commentSubredditKarma ?? void 0;
    message.postSubredditKarma = object.postSubredditKarma ?? void 0;
    message.markedSpam = object.markedSpam ?? void 0;
    message.isSubredditProxyAccount = object.isSubredditProxyAccount ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.User", User);
function createBaseUserFeatures() {
  return {
    awardsOnStreams: void 0,
    canMakeMobileTestBuildPurchases: void 0,
    chatGroupRollout: void 0,
    chatSubreddit: void 0,
    chatUserSettings: void 0,
    chat: void 0,
    cookieConsentBanner: void 0,
    crosspostNotif: void 0,
    crowdControlForPost: void 0,
    customFeedImage: void 0,
    doNotTrack: void 0,
    expensiveCoinsPackage: void 0,
    isEmailPermissionRequired: void 0,
    liveComments: void 0,
    liveOrangereds: void 0,
    modAwards: void 0,
    modServiceMuteReads: void 0,
    modServiceMuteWrites: void 0,
    modlogCopyrightRemoval: void 0,
    mwebNsfwXpromo: void 0,
    mwebXpromoInterstitialCommentsAndroid: void 0,
    mwebXpromoInterstitialCommentsIos: void 0,
    mwebXpromoModalListingClickDailyDismissibleAndroid: void 0,
    mwebXpromoModalListingClickDailyDismissibleIos: void 0,
    mwebXpromoRevampV2: void 0,
    mwebXpromoRevampV3: void 0,
    noreferrerToNoopener: void 0,
    pollsMobile: void 0,
    premiumSubscriptionsTable: void 0,
    promotedTrendBlanks: void 0,
    resizedStylesImages: void 0,
    showAmpLink: void 0,
    showNpsSurvey: void 0,
    spezModal: void 0,
    usePrefAccountDeployment: void 0,
    userFlairMigrationTesting: void 0,
    webhookConfig: void 0
  };
}
var UserFeatures = {
  $type: "devvit.reddit.UserFeatures",
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.awardsOnStreams !== void 0) {
      BoolValue.encode({ value: message.awardsOnStreams }, writer.uint32(10).fork()).ldelim();
    }
    if (message.canMakeMobileTestBuildPurchases !== void 0) {
      BoolValue.encode({ value: message.canMakeMobileTestBuildPurchases }, writer.uint32(18).fork()).ldelim();
    }
    if (message.chatGroupRollout !== void 0) {
      BoolValue.encode({ value: message.chatGroupRollout }, writer.uint32(26).fork()).ldelim();
    }
    if (message.chatSubreddit !== void 0) {
      BoolValue.encode({ value: message.chatSubreddit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.chatUserSettings !== void 0) {
      BoolValue.encode({ value: message.chatUserSettings }, writer.uint32(42).fork()).ldelim();
    }
    if (message.chat !== void 0) {
      BoolValue.encode({ value: message.chat }, writer.uint32(50).fork()).ldelim();
    }
    if (message.cookieConsentBanner !== void 0) {
      BoolValue.encode({ value: message.cookieConsentBanner }, writer.uint32(58).fork()).ldelim();
    }
    if (message.crosspostNotif !== void 0) {
      BoolValue.encode({ value: message.crosspostNotif }, writer.uint32(66).fork()).ldelim();
    }
    if (message.crowdControlForPost !== void 0) {
      BoolValue.encode({ value: message.crowdControlForPost }, writer.uint32(74).fork()).ldelim();
    }
    if (message.customFeedImage !== void 0) {
      BoolValue.encode({ value: message.customFeedImage }, writer.uint32(82).fork()).ldelim();
    }
    if (message.doNotTrack !== void 0) {
      BoolValue.encode({ value: message.doNotTrack }, writer.uint32(90).fork()).ldelim();
    }
    if (message.expensiveCoinsPackage !== void 0) {
      BoolValue.encode({ value: message.expensiveCoinsPackage }, writer.uint32(98).fork()).ldelim();
    }
    if (message.isEmailPermissionRequired !== void 0) {
      BoolValue.encode({ value: message.isEmailPermissionRequired }, writer.uint32(106).fork()).ldelim();
    }
    if (message.liveComments !== void 0) {
      BoolValue.encode({ value: message.liveComments }, writer.uint32(114).fork()).ldelim();
    }
    if (message.liveOrangereds !== void 0) {
      BoolValue.encode({ value: message.liveOrangereds }, writer.uint32(122).fork()).ldelim();
    }
    if (message.modAwards !== void 0) {
      BoolValue.encode({ value: message.modAwards }, writer.uint32(130).fork()).ldelim();
    }
    if (message.modServiceMuteReads !== void 0) {
      BoolValue.encode({ value: message.modServiceMuteReads }, writer.uint32(138).fork()).ldelim();
    }
    if (message.modServiceMuteWrites !== void 0) {
      BoolValue.encode({ value: message.modServiceMuteWrites }, writer.uint32(146).fork()).ldelim();
    }
    if (message.modlogCopyrightRemoval !== void 0) {
      BoolValue.encode({ value: message.modlogCopyrightRemoval }, writer.uint32(154).fork()).ldelim();
    }
    if (message.mwebNsfwXpromo !== void 0) {
      UserFeatures_Experiment.encode(message.mwebNsfwXpromo, writer.uint32(162).fork()).ldelim();
    }
    if (message.mwebXpromoInterstitialCommentsAndroid !== void 0) {
      BoolValue.encode({ value: message.mwebXpromoInterstitialCommentsAndroid }, writer.uint32(170).fork()).ldelim();
    }
    if (message.mwebXpromoInterstitialCommentsIos !== void 0) {
      BoolValue.encode({ value: message.mwebXpromoInterstitialCommentsIos }, writer.uint32(178).fork()).ldelim();
    }
    if (message.mwebXpromoModalListingClickDailyDismissibleAndroid !== void 0) {
      BoolValue.encode({ value: message.mwebXpromoModalListingClickDailyDismissibleAndroid }, writer.uint32(186).fork()).ldelim();
    }
    if (message.mwebXpromoModalListingClickDailyDismissibleIos !== void 0) {
      BoolValue.encode({ value: message.mwebXpromoModalListingClickDailyDismissibleIos }, writer.uint32(194).fork()).ldelim();
    }
    if (message.mwebXpromoRevampV2 !== void 0) {
      UserFeatures_Experiment.encode(message.mwebXpromoRevampV2, writer.uint32(202).fork()).ldelim();
    }
    if (message.mwebXpromoRevampV3 !== void 0) {
      UserFeatures_Experiment.encode(message.mwebXpromoRevampV3, writer.uint32(210).fork()).ldelim();
    }
    if (message.noreferrerToNoopener !== void 0) {
      BoolValue.encode({ value: message.noreferrerToNoopener }, writer.uint32(218).fork()).ldelim();
    }
    if (message.pollsMobile !== void 0) {
      BoolValue.encode({ value: message.pollsMobile }, writer.uint32(226).fork()).ldelim();
    }
    if (message.premiumSubscriptionsTable !== void 0) {
      BoolValue.encode({ value: message.premiumSubscriptionsTable }, writer.uint32(234).fork()).ldelim();
    }
    if (message.promotedTrendBlanks !== void 0) {
      BoolValue.encode({ value: message.promotedTrendBlanks }, writer.uint32(242).fork()).ldelim();
    }
    if (message.resizedStylesImages !== void 0) {
      BoolValue.encode({ value: message.resizedStylesImages }, writer.uint32(250).fork()).ldelim();
    }
    if (message.showAmpLink !== void 0) {
      BoolValue.encode({ value: message.showAmpLink }, writer.uint32(258).fork()).ldelim();
    }
    if (message.showNpsSurvey !== void 0) {
      BoolValue.encode({ value: message.showNpsSurvey }, writer.uint32(266).fork()).ldelim();
    }
    if (message.spezModal !== void 0) {
      BoolValue.encode({ value: message.spezModal }, writer.uint32(274).fork()).ldelim();
    }
    if (message.usePrefAccountDeployment !== void 0) {
      BoolValue.encode({ value: message.usePrefAccountDeployment }, writer.uint32(282).fork()).ldelim();
    }
    if (message.userFlairMigrationTesting !== void 0) {
      BoolValue.encode({ value: message.userFlairMigrationTesting }, writer.uint32(290).fork()).ldelim();
    }
    if (message.webhookConfig !== void 0) {
      BoolValue.encode({ value: message.webhookConfig }, writer.uint32(298).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserFeatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.awardsOnStreams = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.canMakeMobileTestBuildPurchases = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.chatGroupRollout = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.chatSubreddit = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.chatUserSettings = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.chat = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.cookieConsentBanner = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.crosspostNotif = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.crowdControlForPost = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.customFeedImage = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.doNotTrack = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.expensiveCoinsPackage = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.isEmailPermissionRequired = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.liveComments = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.liveOrangereds = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.modAwards = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.modServiceMuteReads = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.modServiceMuteWrites = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.modlogCopyrightRemoval = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.mwebNsfwXpromo = UserFeatures_Experiment.decode(reader, reader.uint32());
          break;
        case 21:
          message.mwebXpromoInterstitialCommentsAndroid = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.mwebXpromoInterstitialCommentsIos = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.mwebXpromoModalListingClickDailyDismissibleAndroid = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.mwebXpromoModalListingClickDailyDismissibleIos = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.mwebXpromoRevampV2 = UserFeatures_Experiment.decode(reader, reader.uint32());
          break;
        case 26:
          message.mwebXpromoRevampV3 = UserFeatures_Experiment.decode(reader, reader.uint32());
          break;
        case 27:
          message.noreferrerToNoopener = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.pollsMobile = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.premiumSubscriptionsTable = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.promotedTrendBlanks = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.resizedStylesImages = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.showAmpLink = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.showNpsSurvey = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.spezModal = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 35:
          message.usePrefAccountDeployment = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.userFlairMigrationTesting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 37:
          message.webhookConfig = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      awardsOnStreams: isSet8(object.awardsOnStreams) ? Boolean(object.awardsOnStreams) : void 0,
      canMakeMobileTestBuildPurchases: isSet8(object.canMakeMobileTestBuildPurchases) ? Boolean(object.canMakeMobileTestBuildPurchases) : void 0,
      chatGroupRollout: isSet8(object.chatGroupRollout) ? Boolean(object.chatGroupRollout) : void 0,
      chatSubreddit: isSet8(object.chatSubreddit) ? Boolean(object.chatSubreddit) : void 0,
      chatUserSettings: isSet8(object.chatUserSettings) ? Boolean(object.chatUserSettings) : void 0,
      chat: isSet8(object.chat) ? Boolean(object.chat) : void 0,
      cookieConsentBanner: isSet8(object.cookieConsentBanner) ? Boolean(object.cookieConsentBanner) : void 0,
      crosspostNotif: isSet8(object.crosspostNotif) ? Boolean(object.crosspostNotif) : void 0,
      crowdControlForPost: isSet8(object.crowdControlForPost) ? Boolean(object.crowdControlForPost) : void 0,
      customFeedImage: isSet8(object.customFeedImage) ? Boolean(object.customFeedImage) : void 0,
      doNotTrack: isSet8(object.doNotTrack) ? Boolean(object.doNotTrack) : void 0,
      expensiveCoinsPackage: isSet8(object.expensiveCoinsPackage) ? Boolean(object.expensiveCoinsPackage) : void 0,
      isEmailPermissionRequired: isSet8(object.isEmailPermissionRequired) ? Boolean(object.isEmailPermissionRequired) : void 0,
      liveComments: isSet8(object.liveComments) ? Boolean(object.liveComments) : void 0,
      liveOrangereds: isSet8(object.liveOrangereds) ? Boolean(object.liveOrangereds) : void 0,
      modAwards: isSet8(object.modAwards) ? Boolean(object.modAwards) : void 0,
      modServiceMuteReads: isSet8(object.modServiceMuteReads) ? Boolean(object.modServiceMuteReads) : void 0,
      modServiceMuteWrites: isSet8(object.modServiceMuteWrites) ? Boolean(object.modServiceMuteWrites) : void 0,
      modlogCopyrightRemoval: isSet8(object.modlogCopyrightRemoval) ? Boolean(object.modlogCopyrightRemoval) : void 0,
      mwebNsfwXpromo: isSet8(object.mwebNsfwXpromo) ? UserFeatures_Experiment.fromJSON(object.mwebNsfwXpromo) : void 0,
      mwebXpromoInterstitialCommentsAndroid: isSet8(object.mwebXpromoInterstitialCommentsAndroid) ? Boolean(object.mwebXpromoInterstitialCommentsAndroid) : void 0,
      mwebXpromoInterstitialCommentsIos: isSet8(object.mwebXpromoInterstitialCommentsIos) ? Boolean(object.mwebXpromoInterstitialCommentsIos) : void 0,
      mwebXpromoModalListingClickDailyDismissibleAndroid: isSet8(object.mwebXpromoModalListingClickDailyDismissibleAndroid) ? Boolean(object.mwebXpromoModalListingClickDailyDismissibleAndroid) : void 0,
      mwebXpromoModalListingClickDailyDismissibleIos: isSet8(object.mwebXpromoModalListingClickDailyDismissibleIos) ? Boolean(object.mwebXpromoModalListingClickDailyDismissibleIos) : void 0,
      mwebXpromoRevampV2: isSet8(object.mwebXpromoRevampV2) ? UserFeatures_Experiment.fromJSON(object.mwebXpromoRevampV2) : void 0,
      mwebXpromoRevampV3: isSet8(object.mwebXpromoRevampV3) ? UserFeatures_Experiment.fromJSON(object.mwebXpromoRevampV3) : void 0,
      noreferrerToNoopener: isSet8(object.noreferrerToNoopener) ? Boolean(object.noreferrerToNoopener) : void 0,
      pollsMobile: isSet8(object.pollsMobile) ? Boolean(object.pollsMobile) : void 0,
      premiumSubscriptionsTable: isSet8(object.premiumSubscriptionsTable) ? Boolean(object.premiumSubscriptionsTable) : void 0,
      promotedTrendBlanks: isSet8(object.promotedTrendBlanks) ? Boolean(object.promotedTrendBlanks) : void 0,
      resizedStylesImages: isSet8(object.resizedStylesImages) ? Boolean(object.resizedStylesImages) : void 0,
      showAmpLink: isSet8(object.showAmpLink) ? Boolean(object.showAmpLink) : void 0,
      showNpsSurvey: isSet8(object.showNpsSurvey) ? Boolean(object.showNpsSurvey) : void 0,
      spezModal: isSet8(object.spezModal) ? Boolean(object.spezModal) : void 0,
      usePrefAccountDeployment: isSet8(object.usePrefAccountDeployment) ? Boolean(object.usePrefAccountDeployment) : void 0,
      userFlairMigrationTesting: isSet8(object.userFlairMigrationTesting) ? Boolean(object.userFlairMigrationTesting) : void 0,
      webhookConfig: isSet8(object.webhookConfig) ? Boolean(object.webhookConfig) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.awardsOnStreams !== void 0 && (obj.awardsOnStreams = message.awardsOnStreams);
    message.canMakeMobileTestBuildPurchases !== void 0 && (obj.canMakeMobileTestBuildPurchases = message.canMakeMobileTestBuildPurchases);
    message.chatGroupRollout !== void 0 && (obj.chatGroupRollout = message.chatGroupRollout);
    message.chatSubreddit !== void 0 && (obj.chatSubreddit = message.chatSubreddit);
    message.chatUserSettings !== void 0 && (obj.chatUserSettings = message.chatUserSettings);
    message.chat !== void 0 && (obj.chat = message.chat);
    message.cookieConsentBanner !== void 0 && (obj.cookieConsentBanner = message.cookieConsentBanner);
    message.crosspostNotif !== void 0 && (obj.crosspostNotif = message.crosspostNotif);
    message.crowdControlForPost !== void 0 && (obj.crowdControlForPost = message.crowdControlForPost);
    message.customFeedImage !== void 0 && (obj.customFeedImage = message.customFeedImage);
    message.doNotTrack !== void 0 && (obj.doNotTrack = message.doNotTrack);
    message.expensiveCoinsPackage !== void 0 && (obj.expensiveCoinsPackage = message.expensiveCoinsPackage);
    message.isEmailPermissionRequired !== void 0 && (obj.isEmailPermissionRequired = message.isEmailPermissionRequired);
    message.liveComments !== void 0 && (obj.liveComments = message.liveComments);
    message.liveOrangereds !== void 0 && (obj.liveOrangereds = message.liveOrangereds);
    message.modAwards !== void 0 && (obj.modAwards = message.modAwards);
    message.modServiceMuteReads !== void 0 && (obj.modServiceMuteReads = message.modServiceMuteReads);
    message.modServiceMuteWrites !== void 0 && (obj.modServiceMuteWrites = message.modServiceMuteWrites);
    message.modlogCopyrightRemoval !== void 0 && (obj.modlogCopyrightRemoval = message.modlogCopyrightRemoval);
    message.mwebNsfwXpromo !== void 0 && (obj.mwebNsfwXpromo = message.mwebNsfwXpromo ? UserFeatures_Experiment.toJSON(message.mwebNsfwXpromo) : void 0);
    message.mwebXpromoInterstitialCommentsAndroid !== void 0 && (obj.mwebXpromoInterstitialCommentsAndroid = message.mwebXpromoInterstitialCommentsAndroid);
    message.mwebXpromoInterstitialCommentsIos !== void 0 && (obj.mwebXpromoInterstitialCommentsIos = message.mwebXpromoInterstitialCommentsIos);
    message.mwebXpromoModalListingClickDailyDismissibleAndroid !== void 0 && (obj.mwebXpromoModalListingClickDailyDismissibleAndroid = message.mwebXpromoModalListingClickDailyDismissibleAndroid);
    message.mwebXpromoModalListingClickDailyDismissibleIos !== void 0 && (obj.mwebXpromoModalListingClickDailyDismissibleIos = message.mwebXpromoModalListingClickDailyDismissibleIos);
    message.mwebXpromoRevampV2 !== void 0 && (obj.mwebXpromoRevampV2 = message.mwebXpromoRevampV2 ? UserFeatures_Experiment.toJSON(message.mwebXpromoRevampV2) : void 0);
    message.mwebXpromoRevampV3 !== void 0 && (obj.mwebXpromoRevampV3 = message.mwebXpromoRevampV3 ? UserFeatures_Experiment.toJSON(message.mwebXpromoRevampV3) : void 0);
    message.noreferrerToNoopener !== void 0 && (obj.noreferrerToNoopener = message.noreferrerToNoopener);
    message.pollsMobile !== void 0 && (obj.pollsMobile = message.pollsMobile);
    message.premiumSubscriptionsTable !== void 0 && (obj.premiumSubscriptionsTable = message.premiumSubscriptionsTable);
    message.promotedTrendBlanks !== void 0 && (obj.promotedTrendBlanks = message.promotedTrendBlanks);
    message.resizedStylesImages !== void 0 && (obj.resizedStylesImages = message.resizedStylesImages);
    message.showAmpLink !== void 0 && (obj.showAmpLink = message.showAmpLink);
    message.showNpsSurvey !== void 0 && (obj.showNpsSurvey = message.showNpsSurvey);
    message.spezModal !== void 0 && (obj.spezModal = message.spezModal);
    message.usePrefAccountDeployment !== void 0 && (obj.usePrefAccountDeployment = message.usePrefAccountDeployment);
    message.userFlairMigrationTesting !== void 0 && (obj.userFlairMigrationTesting = message.userFlairMigrationTesting);
    message.webhookConfig !== void 0 && (obj.webhookConfig = message.webhookConfig);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserFeatures();
    message.awardsOnStreams = object.awardsOnStreams ?? void 0;
    message.canMakeMobileTestBuildPurchases = object.canMakeMobileTestBuildPurchases ?? void 0;
    message.chatGroupRollout = object.chatGroupRollout ?? void 0;
    message.chatSubreddit = object.chatSubreddit ?? void 0;
    message.chatUserSettings = object.chatUserSettings ?? void 0;
    message.chat = object.chat ?? void 0;
    message.cookieConsentBanner = object.cookieConsentBanner ?? void 0;
    message.crosspostNotif = object.crosspostNotif ?? void 0;
    message.crowdControlForPost = object.crowdControlForPost ?? void 0;
    message.customFeedImage = object.customFeedImage ?? void 0;
    message.doNotTrack = object.doNotTrack ?? void 0;
    message.expensiveCoinsPackage = object.expensiveCoinsPackage ?? void 0;
    message.isEmailPermissionRequired = object.isEmailPermissionRequired ?? void 0;
    message.liveComments = object.liveComments ?? void 0;
    message.liveOrangereds = object.liveOrangereds ?? void 0;
    message.modAwards = object.modAwards ?? void 0;
    message.modServiceMuteReads = object.modServiceMuteReads ?? void 0;
    message.modServiceMuteWrites = object.modServiceMuteWrites ?? void 0;
    message.modlogCopyrightRemoval = object.modlogCopyrightRemoval ?? void 0;
    message.mwebNsfwXpromo = object.mwebNsfwXpromo !== void 0 && object.mwebNsfwXpromo !== null ? UserFeatures_Experiment.fromPartial(object.mwebNsfwXpromo) : void 0;
    message.mwebXpromoInterstitialCommentsAndroid = object.mwebXpromoInterstitialCommentsAndroid ?? void 0;
    message.mwebXpromoInterstitialCommentsIos = object.mwebXpromoInterstitialCommentsIos ?? void 0;
    message.mwebXpromoModalListingClickDailyDismissibleAndroid = object.mwebXpromoModalListingClickDailyDismissibleAndroid ?? void 0;
    message.mwebXpromoModalListingClickDailyDismissibleIos = object.mwebXpromoModalListingClickDailyDismissibleIos ?? void 0;
    message.mwebXpromoRevampV2 = object.mwebXpromoRevampV2 !== void 0 && object.mwebXpromoRevampV2 !== null ? UserFeatures_Experiment.fromPartial(object.mwebXpromoRevampV2) : void 0;
    message.mwebXpromoRevampV3 = object.mwebXpromoRevampV3 !== void 0 && object.mwebXpromoRevampV3 !== null ? UserFeatures_Experiment.fromPartial(object.mwebXpromoRevampV3) : void 0;
    message.noreferrerToNoopener = object.noreferrerToNoopener ?? void 0;
    message.pollsMobile = object.pollsMobile ?? void 0;
    message.premiumSubscriptionsTable = object.premiumSubscriptionsTable ?? void 0;
    message.promotedTrendBlanks = object.promotedTrendBlanks ?? void 0;
    message.resizedStylesImages = object.resizedStylesImages ?? void 0;
    message.showAmpLink = object.showAmpLink ?? void 0;
    message.showNpsSurvey = object.showNpsSurvey ?? void 0;
    message.spezModal = object.spezModal ?? void 0;
    message.usePrefAccountDeployment = object.usePrefAccountDeployment ?? void 0;
    message.userFlairMigrationTesting = object.userFlairMigrationTesting ?? void 0;
    message.webhookConfig = object.webhookConfig ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.UserFeatures", UserFeatures);
function createBaseUserFeatures_Experiment() {
  return { experimentId: void 0, owner: void 0, variant: void 0 };
}
var UserFeatures_Experiment = {
  $type: "devvit.reddit.UserFeatures.Experiment",
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.experimentId !== void 0) {
      Int32Value.encode({ value: message.experimentId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.owner !== void 0) {
      StringValue.encode({ value: message.owner }, writer.uint32(18).fork()).ldelim();
    }
    if (message.variant !== void 0) {
      StringValue.encode({ value: message.variant }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserFeatures_Experiment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.experimentId = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.owner = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.variant = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      experimentId: isSet8(object.experimentId) ? Number(object.experimentId) : void 0,
      owner: isSet8(object.owner) ? String(object.owner) : void 0,
      variant: isSet8(object.variant) ? String(object.variant) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.experimentId !== void 0 && (obj.experimentId = message.experimentId);
    message.owner !== void 0 && (obj.owner = message.owner);
    message.variant !== void 0 && (obj.variant = message.variant);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserFeatures_Experiment();
    message.experimentId = object.experimentId ?? void 0;
    message.owner = object.owner ?? void 0;
    message.variant = object.variant ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.UserFeatures.Experiment", UserFeatures_Experiment);
function isSet8(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/automation/v1alpha/step.js
var import_minimal10 = __toESM(require_minimal2(), 1);
function createBaseStepDescription() {
  return { actor: "", config: void 0 };
}
var StepDescription = {
  $type: "devvit.actor.automation.v1alpha.StepDescription",
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    if (message.config !== void 0) {
      Struct.encode(Struct.wrap(message.config), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : new import_minimal10.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actor = reader.string();
          break;
        case 2:
          message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet9(object.actor) ? String(object.actor) : "",
      config: isObject2(object.config) ? object.config : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.actor !== void 0 && (obj.actor = message.actor);
    message.config !== void 0 && (obj.config = message.config);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStepDescription();
    message.actor = object.actor ?? "";
    message.config = object.config ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepDescription", StepDescription);
function createBaseStepInput() {
  return { config: void 0, prev: void 0 };
}
var StepInput = {
  $type: "devvit.actor.automation.v1alpha.StepInput",
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.config !== void 0) {
      Struct.encode(Struct.wrap(message.config), writer.uint32(10).fork()).ldelim();
    }
    if (message.prev !== void 0) {
      Struct.encode(Struct.wrap(message.prev), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : new import_minimal10.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.config = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        case 2:
          message.prev = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      config: isObject2(object.config) ? object.config : void 0,
      prev: isObject2(object.prev) ? object.prev : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.config !== void 0 && (obj.config = message.config);
    message.prev !== void 0 && (obj.prev = message.prev);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStepInput();
    message.config = object.config ?? void 0;
    message.prev = object.prev ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepInput", StepInput);
function createBaseStepCommentInput() {
  return { input: void 0, comment: void 0 };
}
var StepCommentInput = {
  $type: "devvit.actor.automation.v1alpha.StepCommentInput",
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.input !== void 0) {
      StepInput.encode(message.input, writer.uint32(10).fork()).ldelim();
    }
    if (message.comment !== void 0) {
      Comment.encode(message.comment, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : new import_minimal10.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepCommentInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.input = StepInput.decode(reader, reader.uint32());
          break;
        case 2:
          message.comment = Comment.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      input: isSet9(object.input) ? StepInput.fromJSON(object.input) : void 0,
      comment: isSet9(object.comment) ? Comment.fromJSON(object.comment) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.input !== void 0 && (obj.input = message.input ? StepInput.toJSON(message.input) : void 0);
    message.comment !== void 0 && (obj.comment = message.comment ? Comment.toJSON(message.comment) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStepCommentInput();
    message.input = object.input !== void 0 && object.input !== null ? StepInput.fromPartial(object.input) : void 0;
    message.comment = object.comment !== void 0 && object.comment !== null ? Comment.fromPartial(object.comment) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepCommentInput", StepCommentInput);
function createBaseStepPostInput() {
  return { input: void 0, post: void 0 };
}
var StepPostInput = {
  $type: "devvit.actor.automation.v1alpha.StepPostInput",
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.input !== void 0) {
      StepInput.encode(message.input, writer.uint32(10).fork()).ldelim();
    }
    if (message.post !== void 0) {
      Post.encode(message.post, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : new import_minimal10.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepPostInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.input = StepInput.decode(reader, reader.uint32());
          break;
        case 2:
          message.post = Post.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      input: isSet9(object.input) ? StepInput.fromJSON(object.input) : void 0,
      post: isSet9(object.post) ? Post.fromJSON(object.post) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.input !== void 0 && (obj.input = message.input ? StepInput.toJSON(message.input) : void 0);
    message.post !== void 0 && (obj.post = message.post ? Post.toJSON(message.post) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStepPostInput();
    message.input = object.input !== void 0 && object.input !== null ? StepInput.fromPartial(object.input) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? Post.fromPartial(object.post) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepPostInput", StepPostInput);
function createBaseStepUserInput() {
  return { input: void 0, user: void 0 };
}
var StepUserInput = {
  $type: "devvit.actor.automation.v1alpha.StepUserInput",
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.input !== void 0) {
      StepInput.encode(message.input, writer.uint32(10).fork()).ldelim();
    }
    if (message.user !== void 0) {
      User.encode(message.user, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : new import_minimal10.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepUserInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.input = StepInput.decode(reader, reader.uint32());
          break;
        case 2:
          message.user = User.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      input: isSet9(object.input) ? StepInput.fromJSON(object.input) : void 0,
      user: isSet9(object.user) ? User.fromJSON(object.user) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.input !== void 0 && (obj.input = message.input ? StepInput.toJSON(message.input) : void 0);
    message.user !== void 0 && (obj.user = message.user ? User.toJSON(message.user) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStepUserInput();
    message.input = object.input !== void 0 && object.input !== null ? StepInput.fromPartial(object.input) : void 0;
    message.user = object.user !== void 0 && object.user !== null ? User.fromPartial(object.user) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepUserInput", StepUserInput);
function createBaseStepResult() {
  return { output: void 0, stop: false };
}
var StepResult = {
  $type: "devvit.actor.automation.v1alpha.StepResult",
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.output !== void 0) {
      Struct.encode(Struct.wrap(message.output), writer.uint32(10).fork()).ldelim();
    }
    if (message.stop === true) {
      writer.uint32(16).bool(message.stop);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : new import_minimal10.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.output = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        case 2:
          message.stop = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      output: isObject2(object.output) ? object.output : void 0,
      stop: isSet9(object.stop) ? Boolean(object.stop) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.output !== void 0 && (obj.output = message.output);
    message.stop !== void 0 && (obj.stop = message.stop);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStepResult();
    message.output = object.output ?? void 0;
    message.stop = object.stop ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepResult", StepResult);
function createBaseStepReport() {
  return { actor: "", message: "", duration: 0, success: false, data: void 0 };
}
var StepReport = {
  $type: "devvit.actor.automation.v1alpha.StepReport",
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.duration !== 0) {
      writer.uint32(29).float(message.duration);
    }
    if (message.success === true) {
      writer.uint32(32).bool(message.success);
    }
    if (message.data !== void 0) {
      StepResult.encode(message.data, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : new import_minimal10.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actor = reader.string();
          break;
        case 2:
          message.message = reader.string();
          break;
        case 3:
          message.duration = reader.float();
          break;
        case 4:
          message.success = reader.bool();
          break;
        case 5:
          message.data = StepResult.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet9(object.actor) ? String(object.actor) : "",
      message: isSet9(object.message) ? String(object.message) : "",
      duration: isSet9(object.duration) ? Number(object.duration) : 0,
      success: isSet9(object.success) ? Boolean(object.success) : false,
      data: isSet9(object.data) ? StepResult.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.actor !== void 0 && (obj.actor = message.actor);
    message.message !== void 0 && (obj.message = message.message);
    message.duration !== void 0 && (obj.duration = message.duration);
    message.success !== void 0 && (obj.success = message.success);
    message.data !== void 0 && (obj.data = message.data ? StepResult.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStepReport();
    message.actor = object.actor ?? "";
    message.message = object.message ?? "";
    message.duration = object.duration ?? 0;
    message.success = object.success ?? false;
    message.data = object.data !== void 0 && object.data !== null ? StepResult.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepReport", StepReport);
function isObject2(value) {
  return typeof value === "object" && value !== null;
}
function isSet9(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/automation/v1alpha/trigger.js
var import_minimal11 = __toESM(require_minimal2(), 1);
var TriggerType;
(function(TriggerType2) {
  TriggerType2[TriggerType2["POST"] = 0] = "POST";
  TriggerType2[TriggerType2["COMMENT"] = 1] = "COMMENT";
  TriggerType2[TriggerType2["USER"] = 2] = "USER";
  TriggerType2[TriggerType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TriggerType || (TriggerType = {}));
function triggerTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "POST":
      return TriggerType.POST;
    case 1:
    case "COMMENT":
      return TriggerType.COMMENT;
    case 2:
    case "USER":
      return TriggerType.USER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TriggerType.UNRECOGNIZED;
  }
}
function triggerTypeToJSON(object) {
  switch (object) {
    case TriggerType.POST:
      return 0;
    case TriggerType.COMMENT:
      return 1;
    case TriggerType.USER:
      return 2;
    case TriggerType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseTrigger() {
  return { id: "", name: "", label: "", type: 0 };
}
var Trigger = {
  $type: "devvit.actor.automation.v1alpha.Trigger",
  encode(message, writer = import_minimal11.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal11.default.Reader ? input : new import_minimal11.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.label = reader.string();
          break;
        case 4:
          message.type = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet10(object.id) ? String(object.id) : "",
      name: isSet10(object.name) ? String(object.name) : "",
      label: isSet10(object.label) ? String(object.label) : "",
      type: isSet10(object.type) ? triggerTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.name !== void 0 && (obj.name = message.name);
    message.label !== void 0 && (obj.label = message.label);
    message.type !== void 0 && (obj.type = triggerTypeToJSON(message.type));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTrigger();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.label = object.label ?? "";
    message.type = object.type ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.Trigger", Trigger);
function isSet10(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/automation/v1alpha/automation.js
var AutomationStatus;
(function(AutomationStatus2) {
  AutomationStatus2[AutomationStatus2["INSTALLED"] = 0] = "INSTALLED";
  AutomationStatus2[AutomationStatus2["ENABLED"] = 1] = "ENABLED";
  AutomationStatus2[AutomationStatus2["DISABLED"] = 2] = "DISABLED";
  AutomationStatus2[AutomationStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AutomationStatus || (AutomationStatus = {}));
function automationStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "INSTALLED":
      return AutomationStatus.INSTALLED;
    case 1:
    case "ENABLED":
      return AutomationStatus.ENABLED;
    case 2:
    case "DISABLED":
      return AutomationStatus.DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutomationStatus.UNRECOGNIZED;
  }
}
function automationStatusToJSON(object) {
  switch (object) {
    case AutomationStatus.INSTALLED:
      return 0;
    case AutomationStatus.ENABLED:
      return 1;
    case AutomationStatus.DISABLED:
      return 2;
    case AutomationStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}
var AutomationVisibility;
(function(AutomationVisibility2) {
  AutomationVisibility2[AutomationVisibility2["PRIVATE"] = 0] = "PRIVATE";
  AutomationVisibility2[AutomationVisibility2["PUBLIC"] = 1] = "PUBLIC";
  AutomationVisibility2[AutomationVisibility2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AutomationVisibility || (AutomationVisibility = {}));
function automationVisibilityFromJSON(object) {
  switch (object) {
    case 0:
    case "PRIVATE":
      return AutomationVisibility.PRIVATE;
    case 1:
    case "PUBLIC":
      return AutomationVisibility.PUBLIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutomationVisibility.UNRECOGNIZED;
  }
}
function automationVisibilityToJSON(object) {
  switch (object) {
    case AutomationVisibility.PRIVATE:
      return 0;
    case AutomationVisibility.PUBLIC:
      return 1;
    case AutomationVisibility.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseAutomation() {
  return { id: "", name: "", description: "", status: 0, visibility: 0, trigger: void 0, steps: [] };
}
var Automation = {
  $type: "devvit.actor.automation.v1alpha.Automation",
  encode(message, writer = import_minimal12.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.visibility !== 0) {
      writer.uint32(40).int32(message.visibility);
    }
    if (message.trigger !== void 0) {
      Trigger.encode(message.trigger, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.steps) {
      StepDescription.encode(v, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal12.default.Reader ? input : new import_minimal12.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          message.status = reader.int32();
          break;
        case 5:
          message.visibility = reader.int32();
          break;
        case 6:
          message.trigger = Trigger.decode(reader, reader.uint32());
          break;
        case 7:
          message.steps.push(StepDescription.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet11(object.id) ? String(object.id) : "",
      name: isSet11(object.name) ? String(object.name) : "",
      description: isSet11(object.description) ? String(object.description) : "",
      status: isSet11(object.status) ? automationStatusFromJSON(object.status) : 0,
      visibility: isSet11(object.visibility) ? automationVisibilityFromJSON(object.visibility) : 0,
      trigger: isSet11(object.trigger) ? Trigger.fromJSON(object.trigger) : void 0,
      steps: Array.isArray(object?.steps) ? object.steps.map((e) => StepDescription.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.name !== void 0 && (obj.name = message.name);
    message.description !== void 0 && (obj.description = message.description);
    message.status !== void 0 && (obj.status = automationStatusToJSON(message.status));
    message.visibility !== void 0 && (obj.visibility = automationVisibilityToJSON(message.visibility));
    message.trigger !== void 0 && (obj.trigger = message.trigger ? Trigger.toJSON(message.trigger) : void 0);
    if (message.steps) {
      obj.steps = message.steps.map((e) => e ? StepDescription.toJSON(e) : void 0);
    } else {
      obj.steps = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomation();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.status = object.status ?? 0;
    message.visibility = object.visibility ?? 0;
    message.trigger = object.trigger !== void 0 && object.trigger !== null ? Trigger.fromPartial(object.trigger) : void 0;
    message.steps = object.steps?.map((e) => StepDescription.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.Automation", Automation);
function createBaseAutomationResult() {
  return { id: "", steps: [] };
}
var AutomationResult = {
  $type: "devvit.actor.automation.v1alpha.AutomationResult",
  encode(message, writer = import_minimal12.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.steps) {
      StepReport.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal12.default.Reader ? input : new import_minimal12.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.steps.push(StepReport.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet11(object.id) ? String(object.id) : "",
      steps: Array.isArray(object?.steps) ? object.steps.map((e) => StepReport.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    if (message.steps) {
      obj.steps = message.steps.map((e) => e ? StepReport.toJSON(e) : void 0);
    } else {
      obj.steps = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationResult();
    message.id = object.id ?? "";
    message.steps = object.steps?.map((e) => StepReport.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.AutomationResult", AutomationResult);
function createBaseAutomationInvocation() {
  return { id: "", automation: void 0, comment: void 0, post: void 0, user: void 0, subreddit: void 0 };
}
var AutomationInvocation = {
  $type: "devvit.actor.automation.v1alpha.AutomationInvocation",
  encode(message, writer = import_minimal12.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.automation !== void 0) {
      Automation.encode(message.automation, writer.uint32(18).fork()).ldelim();
    }
    if (message.comment !== void 0) {
      Comment.encode(message.comment, writer.uint32(26).fork()).ldelim();
    }
    if (message.post !== void 0) {
      Post.encode(message.post, writer.uint32(34).fork()).ldelim();
    }
    if (message.user !== void 0) {
      User.encode(message.user, writer.uint32(42).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      Subreddit.encode(message.subreddit, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal12.default.Reader ? input : new import_minimal12.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationInvocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.automation = Automation.decode(reader, reader.uint32());
          break;
        case 3:
          message.comment = Comment.decode(reader, reader.uint32());
          break;
        case 4:
          message.post = Post.decode(reader, reader.uint32());
          break;
        case 5:
          message.user = User.decode(reader, reader.uint32());
          break;
        case 6:
          message.subreddit = Subreddit.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet11(object.id) ? String(object.id) : "",
      automation: isSet11(object.automation) ? Automation.fromJSON(object.automation) : void 0,
      comment: isSet11(object.comment) ? Comment.fromJSON(object.comment) : void 0,
      post: isSet11(object.post) ? Post.fromJSON(object.post) : void 0,
      user: isSet11(object.user) ? User.fromJSON(object.user) : void 0,
      subreddit: isSet11(object.subreddit) ? Subreddit.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.automation !== void 0 && (obj.automation = message.automation ? Automation.toJSON(message.automation) : void 0);
    message.comment !== void 0 && (obj.comment = message.comment ? Comment.toJSON(message.comment) : void 0);
    message.post !== void 0 && (obj.post = message.post ? Post.toJSON(message.post) : void 0);
    message.user !== void 0 && (obj.user = message.user ? User.toJSON(message.user) : void 0);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? Subreddit.toJSON(message.subreddit) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationInvocation();
    message.id = object.id ?? "";
    message.automation = object.automation !== void 0 && object.automation !== null ? Automation.fromPartial(object.automation) : void 0;
    message.comment = object.comment !== void 0 && object.comment !== null ? Comment.fromPartial(object.comment) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? Post.fromPartial(object.post) : void 0;
    message.user = object.user !== void 0 && object.user !== null ? User.fromPartial(object.user) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? Subreddit.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.AutomationInvocation", AutomationInvocation);
function isSet11(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/automation/v1alpha/automation_builder.js
var StepType;
(function(StepType2) {
  StepType2[StepType2["ACTION"] = 0] = "ACTION";
  StepType2[StepType2["FILTER"] = 1] = "FILTER";
  StepType2[StepType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(StepType || (StepType = {}));
function stepTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ACTION":
      return StepType.ACTION;
    case 1:
    case "FILTER":
      return StepType.FILTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StepType.UNRECOGNIZED;
  }
}
function stepTypeToJSON(object) {
  switch (object) {
    case StepType.ACTION:
      return 0;
    case StepType.FILTER:
      return 1;
    case StepType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseGetTriggersRequest() {
  return {};
}
var GetTriggersRequest = {
  $type: "devvit.actor.automation.v1alpha.GetTriggersRequest",
  encode(_, writer = import_minimal13.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetTriggersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseGetTriggersRequest();
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.GetTriggersRequest", GetTriggersRequest);
function createBaseListStepsRequest() {
  return { location: "", triggerType: 0, stepType: 0 };
}
var ListStepsRequest = {
  $type: "devvit.actor.automation.v1alpha.ListStepsRequest",
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    if (message.triggerType !== 0) {
      writer.uint32(16).int32(message.triggerType);
    }
    if (message.stepType !== 0) {
      writer.uint32(24).int32(message.stepType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListStepsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.location = reader.string();
          break;
        case 2:
          message.triggerType = reader.int32();
          break;
        case 3:
          message.stepType = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      location: isSet12(object.location) ? String(object.location) : "",
      triggerType: isSet12(object.triggerType) ? triggerTypeFromJSON(object.triggerType) : 0,
      stepType: isSet12(object.stepType) ? stepTypeFromJSON(object.stepType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.location !== void 0 && (obj.location = message.location);
    message.triggerType !== void 0 && (obj.triggerType = triggerTypeToJSON(message.triggerType));
    message.stepType !== void 0 && (obj.stepType = stepTypeToJSON(message.stepType));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseListStepsRequest();
    message.location = object.location ?? "";
    message.triggerType = object.triggerType ?? 0;
    message.stepType = object.stepType ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.ListStepsRequest", ListStepsRequest);
function createBaseListAutomationRequest() {
  return { location: "" };
}
var ListAutomationRequest = {
  $type: "devvit.actor.automation.v1alpha.ListAutomationRequest",
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListAutomationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.location = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { location: isSet12(object.location) ? String(object.location) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.location !== void 0 && (obj.location = message.location);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseListAutomationRequest();
    message.location = object.location ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.ListAutomationRequest", ListAutomationRequest);
function createBaseStepActor() {
  return { actor: "", label: "", description: "", type: 0 };
}
var StepActor = {
  $type: "devvit.actor.automation.v1alpha.StepActor",
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepActor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actor = reader.string();
          break;
        case 2:
          message.label = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          message.type = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet12(object.actor) ? String(object.actor) : "",
      label: isSet12(object.label) ? String(object.label) : "",
      description: isSet12(object.description) ? String(object.description) : "",
      type: isSet12(object.type) ? stepTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.actor !== void 0 && (obj.actor = message.actor);
    message.label !== void 0 && (obj.label = message.label);
    message.description !== void 0 && (obj.description = message.description);
    message.type !== void 0 && (obj.type = stepTypeToJSON(message.type));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStepActor();
    message.actor = object.actor ?? "";
    message.label = object.label ?? "";
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.StepActor", StepActor);
function createBaseActorList() {
  return { actors: [] };
}
var ActorList = {
  $type: "devvit.actor.automation.v1alpha.ActorList",
  encode(message, writer = import_minimal13.default.Writer.create()) {
    for (const v of message.actors) {
      StepActor.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseActorList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actors.push(StepActor.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { actors: Array.isArray(object?.actors) ? object.actors.map((e) => StepActor.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.actors) {
      obj.actors = message.actors.map((e) => e ? StepActor.toJSON(e) : void 0);
    } else {
      obj.actors = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseActorList();
    message.actors = object.actors?.map((e) => StepActor.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.ActorList", ActorList);
function createBaseAutomationList() {
  return { automations: [] };
}
var AutomationList = {
  $type: "devvit.actor.automation.v1alpha.AutomationList",
  encode(message, writer = import_minimal13.default.Writer.create()) {
    for (const v of message.automations) {
      Automation.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.automations.push(Automation.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      automations: Array.isArray(object?.automations) ? object.automations.map((e) => Automation.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.automations) {
      obj.automations = message.automations.map((e) => e ? Automation.toJSON(e) : void 0);
    } else {
      obj.automations = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationList();
    message.automations = object.automations?.map((e) => Automation.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.AutomationList", AutomationList);
function createBaseTriggerList() {
  return { triggers: [] };
}
var TriggerList = {
  $type: "devvit.actor.automation.v1alpha.TriggerList",
  encode(message, writer = import_minimal13.default.Writer.create()) {
    for (const v of message.triggers) {
      Trigger.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTriggerList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.triggers.push(Trigger.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { triggers: Array.isArray(object?.triggers) ? object.triggers.map((e) => Trigger.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.triggers) {
      obj.triggers = message.triggers.map((e) => e ? Trigger.toJSON(e) : void 0);
    } else {
      obj.triggers = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTriggerList();
    message.triggers = object.triggers?.map((e) => Trigger.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.TriggerList", TriggerList);
function createBaseUpdateAutomationRequest() {
  return { automation: void 0, location: "" };
}
var UpdateAutomationRequest = {
  $type: "devvit.actor.automation.v1alpha.UpdateAutomationRequest",
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.automation !== void 0) {
      Automation.encode(message.automation, writer.uint32(10).fork()).ldelim();
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateAutomationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.automation = Automation.decode(reader, reader.uint32());
          break;
        case 2:
          message.location = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      automation: isSet12(object.automation) ? Automation.fromJSON(object.automation) : void 0,
      location: isSet12(object.location) ? String(object.location) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.automation !== void 0 && (obj.automation = message.automation ? Automation.toJSON(message.automation) : void 0);
    message.location !== void 0 && (obj.location = message.location);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateAutomationRequest();
    message.automation = object.automation !== void 0 && object.automation !== null ? Automation.fromPartial(object.automation) : void 0;
    message.location = object.location ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.UpdateAutomationRequest", UpdateAutomationRequest);
function createBaseGetStepFormRequest() {
  return { actor: "" };
}
var GetStepFormRequest = {
  $type: "devvit.actor.automation.v1alpha.GetStepFormRequest",
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetStepFormRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { actor: isSet12(object.actor) ? String(object.actor) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.actor !== void 0 && (obj.actor = message.actor);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetStepFormRequest();
    message.actor = object.actor ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.GetStepFormRequest", GetStepFormRequest);
function isSet12(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/automation/v1alpha/event_handlers.js
var import_minimal20 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/events/v1alpha/events.js
var import_minimal19 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/reddit/v2alpha/commentv2.js
var import_minimal14 = __toESM(require_minimal2(), 1);
function createBaseCommentV2() {
  return {
    id: "",
    parentId: "",
    body: "",
    author: "",
    numReports: 0,
    collapsedBecauseCrowdControl: false,
    spam: false,
    deleted: false
  };
}
var CommentV2 = {
  $type: "devvit.reddit.v2alpha.CommentV2",
  encode(message, writer = import_minimal14.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.parentId !== "") {
      writer.uint32(18).string(message.parentId);
    }
    if (message.body !== "") {
      writer.uint32(26).string(message.body);
    }
    if (message.author !== "") {
      writer.uint32(34).string(message.author);
    }
    if (message.numReports !== 0) {
      writer.uint32(40).int32(message.numReports);
    }
    if (message.collapsedBecauseCrowdControl === true) {
      writer.uint32(48).bool(message.collapsedBecauseCrowdControl);
    }
    if (message.spam === true) {
      writer.uint32(56).bool(message.spam);
    }
    if (message.deleted === true) {
      writer.uint32(64).bool(message.deleted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : new import_minimal14.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.parentId = reader.string();
          break;
        case 3:
          message.body = reader.string();
          break;
        case 4:
          message.author = reader.string();
          break;
        case 5:
          message.numReports = reader.int32();
          break;
        case 6:
          message.collapsedBecauseCrowdControl = reader.bool();
          break;
        case 7:
          message.spam = reader.bool();
          break;
        case 8:
          message.deleted = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet13(object.id) ? String(object.id) : "",
      parentId: isSet13(object.parentId) ? String(object.parentId) : "",
      body: isSet13(object.body) ? String(object.body) : "",
      author: isSet13(object.author) ? String(object.author) : "",
      numReports: isSet13(object.numReports) ? Number(object.numReports) : 0,
      collapsedBecauseCrowdControl: isSet13(object.collapsedBecauseCrowdControl) ? Boolean(object.collapsedBecauseCrowdControl) : false,
      spam: isSet13(object.spam) ? Boolean(object.spam) : false,
      deleted: isSet13(object.deleted) ? Boolean(object.deleted) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.parentId !== void 0 && (obj.parentId = message.parentId);
    message.body !== void 0 && (obj.body = message.body);
    message.author !== void 0 && (obj.author = message.author);
    message.numReports !== void 0 && (obj.numReports = Math.round(message.numReports));
    message.collapsedBecauseCrowdControl !== void 0 && (obj.collapsedBecauseCrowdControl = message.collapsedBecauseCrowdControl);
    message.spam !== void 0 && (obj.spam = message.spam);
    message.deleted !== void 0 && (obj.deleted = message.deleted);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommentV2();
    message.id = object.id ?? "";
    message.parentId = object.parentId ?? "";
    message.body = object.body ?? "";
    message.author = object.author ?? "";
    message.numReports = object.numReports ?? 0;
    message.collapsedBecauseCrowdControl = object.collapsedBecauseCrowdControl ?? false;
    message.spam = object.spam ?? false;
    message.deleted = object.deleted ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.v2alpha.CommentV2", CommentV2);
function isSet13(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/v2alpha/postv2.js
var import_long2 = __toESM(require_long(), 1);
var import_minimal16 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/reddit/v2alpha/flair.js
var import_minimal15 = __toESM(require_minimal2(), 1);
function createBaseLinkFlairV2() {
  return { text: "", cssClass: "", backgroundColor: "", templateId: "", textColor: "" };
}
var LinkFlairV2 = {
  $type: "devvit.reddit.v2alpha.LinkFlairV2",
  encode(message, writer = import_minimal15.default.Writer.create()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.cssClass !== "") {
      writer.uint32(18).string(message.cssClass);
    }
    if (message.backgroundColor !== "") {
      writer.uint32(26).string(message.backgroundColor);
    }
    if (message.templateId !== "") {
      writer.uint32(34).string(message.templateId);
    }
    if (message.textColor !== "") {
      writer.uint32(42).string(message.textColor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal15.default.Reader ? input : new import_minimal15.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkFlairV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.text = reader.string();
          break;
        case 2:
          message.cssClass = reader.string();
          break;
        case 3:
          message.backgroundColor = reader.string();
          break;
        case 4:
          message.templateId = reader.string();
          break;
        case 5:
          message.textColor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet14(object.text) ? String(object.text) : "",
      cssClass: isSet14(object.cssClass) ? String(object.cssClass) : "",
      backgroundColor: isSet14(object.backgroundColor) ? String(object.backgroundColor) : "",
      templateId: isSet14(object.templateId) ? String(object.templateId) : "",
      textColor: isSet14(object.textColor) ? String(object.textColor) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.text !== void 0 && (obj.text = message.text);
    message.cssClass !== void 0 && (obj.cssClass = message.cssClass);
    message.backgroundColor !== void 0 && (obj.backgroundColor = message.backgroundColor);
    message.templateId !== void 0 && (obj.templateId = message.templateId);
    message.textColor !== void 0 && (obj.textColor = message.textColor);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseLinkFlairV2();
    message.text = object.text ?? "";
    message.cssClass = object.cssClass ?? "";
    message.backgroundColor = object.backgroundColor ?? "";
    message.templateId = object.templateId ?? "";
    message.textColor = object.textColor ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.v2alpha.LinkFlairV2", LinkFlairV2);
function createBaseUserFlairV2() {
  return {
    userId: "",
    subredditId: "",
    text: "",
    cssClass: "",
    templateId: "",
    textColor: "",
    backgroundColor: "",
    enabled: false
  };
}
var UserFlairV2 = {
  $type: "devvit.reddit.v2alpha.UserFlairV2",
  encode(message, writer = import_minimal15.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.subredditId !== "") {
      writer.uint32(18).string(message.subredditId);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.cssClass !== "") {
      writer.uint32(34).string(message.cssClass);
    }
    if (message.templateId !== "") {
      writer.uint32(42).string(message.templateId);
    }
    if (message.textColor !== "") {
      writer.uint32(50).string(message.textColor);
    }
    if (message.backgroundColor !== "") {
      writer.uint32(58).string(message.backgroundColor);
    }
    if (message.enabled === true) {
      writer.uint32(64).bool(message.enabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal15.default.Reader ? input : new import_minimal15.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserFlairV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.userId = reader.string();
          break;
        case 2:
          message.subredditId = reader.string();
          break;
        case 3:
          message.text = reader.string();
          break;
        case 4:
          message.cssClass = reader.string();
          break;
        case 5:
          message.templateId = reader.string();
          break;
        case 6:
          message.textColor = reader.string();
          break;
        case 7:
          message.backgroundColor = reader.string();
          break;
        case 8:
          message.enabled = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet14(object.userId) ? String(object.userId) : "",
      subredditId: isSet14(object.subredditId) ? String(object.subredditId) : "",
      text: isSet14(object.text) ? String(object.text) : "",
      cssClass: isSet14(object.cssClass) ? String(object.cssClass) : "",
      templateId: isSet14(object.templateId) ? String(object.templateId) : "",
      textColor: isSet14(object.textColor) ? String(object.textColor) : "",
      backgroundColor: isSet14(object.backgroundColor) ? String(object.backgroundColor) : "",
      enabled: isSet14(object.enabled) ? Boolean(object.enabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.userId !== void 0 && (obj.userId = message.userId);
    message.subredditId !== void 0 && (obj.subredditId = message.subredditId);
    message.text !== void 0 && (obj.text = message.text);
    message.cssClass !== void 0 && (obj.cssClass = message.cssClass);
    message.templateId !== void 0 && (obj.templateId = message.templateId);
    message.textColor !== void 0 && (obj.textColor = message.textColor);
    message.backgroundColor !== void 0 && (obj.backgroundColor = message.backgroundColor);
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserFlairV2();
    message.userId = object.userId ?? "";
    message.subredditId = object.subredditId ?? "";
    message.text = object.text ?? "";
    message.cssClass = object.cssClass ?? "";
    message.templateId = object.templateId ?? "";
    message.textColor = object.textColor ?? "";
    message.backgroundColor = object.backgroundColor ?? "";
    message.enabled = object.enabled ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.v2alpha.UserFlairV2", UserFlairV2);
function isSet14(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/v2alpha/postv2.js
var CrowdControlLevel;
(function(CrowdControlLevel2) {
  CrowdControlLevel2[CrowdControlLevel2["OFF"] = 0] = "OFF";
  CrowdControlLevel2[CrowdControlLevel2["LENIENT"] = 1] = "LENIENT";
  CrowdControlLevel2[CrowdControlLevel2["MEDIUM"] = 2] = "MEDIUM";
  CrowdControlLevel2[CrowdControlLevel2["STRICT"] = 3] = "STRICT";
  CrowdControlLevel2[CrowdControlLevel2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CrowdControlLevel || (CrowdControlLevel = {}));
function crowdControlLevelFromJSON(object) {
  switch (object) {
    case 0:
    case "OFF":
      return CrowdControlLevel.OFF;
    case 1:
    case "LENIENT":
      return CrowdControlLevel.LENIENT;
    case 2:
    case "MEDIUM":
      return CrowdControlLevel.MEDIUM;
    case 3:
    case "STRICT":
      return CrowdControlLevel.STRICT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CrowdControlLevel.UNRECOGNIZED;
  }
}
function crowdControlLevelToJSON(object) {
  switch (object) {
    case CrowdControlLevel.OFF:
      return 0;
    case CrowdControlLevel.LENIENT:
      return 1;
    case CrowdControlLevel.MEDIUM:
      return 2;
    case CrowdControlLevel.STRICT:
      return 3;
    case CrowdControlLevel.UNRECOGNIZED:
    default:
      return -1;
  }
}
var DistinguishType;
(function(DistinguishType2) {
  DistinguishType2[DistinguishType2["NULL_VALUE"] = 0] = "NULL_VALUE";
  DistinguishType2[DistinguishType2["ADMIN"] = 1] = "ADMIN";
  DistinguishType2[DistinguishType2["GOLD"] = 2] = "GOLD";
  DistinguishType2[DistinguishType2["GOLD_AUTO"] = 3] = "GOLD_AUTO";
  DistinguishType2[DistinguishType2["YES"] = 4] = "YES";
  DistinguishType2[DistinguishType2["SPECIAL"] = 5] = "SPECIAL";
  DistinguishType2[DistinguishType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DistinguishType || (DistinguishType = {}));
function distinguishTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "NULL_VALUE":
      return DistinguishType.NULL_VALUE;
    case 1:
    case "ADMIN":
      return DistinguishType.ADMIN;
    case 2:
    case "GOLD":
      return DistinguishType.GOLD;
    case 3:
    case "GOLD_AUTO":
      return DistinguishType.GOLD_AUTO;
    case 4:
    case "YES":
      return DistinguishType.YES;
    case 5:
    case "SPECIAL":
      return DistinguishType.SPECIAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DistinguishType.UNRECOGNIZED;
  }
}
function distinguishTypeToJSON(object) {
  switch (object) {
    case DistinguishType.NULL_VALUE:
      return 0;
    case DistinguishType.ADMIN:
      return 1;
    case DistinguishType.GOLD:
      return 2;
    case DistinguishType.GOLD_AUTO:
      return 3;
    case DistinguishType.YES:
      return 4;
    case DistinguishType.SPECIAL:
      return 5;
    case DistinguishType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBasePostV2() {
  return {
    id: "",
    title: "",
    selftext: "",
    nsfw: false,
    authorId: "",
    crowdControlLevel: 0,
    numReports: 0,
    isGallery: false,
    isMeta: false,
    createdAt: 0,
    isApproved: false,
    isArchived: false,
    distinguished: 0,
    ignoreReports: false,
    isSelf: false,
    isVideo: false,
    isLocked: false,
    isSpoiler: false,
    subredditId: "",
    upvotes: 0,
    downvotes: 0,
    url: "",
    isSticky: false,
    linkFlair: void 0,
    authorFlair: void 0,
    spam: false,
    deleted: false
  };
}
var PostV2 = {
  $type: "devvit.reddit.v2alpha.PostV2",
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.selftext !== "") {
      writer.uint32(26).string(message.selftext);
    }
    if (message.nsfw === true) {
      writer.uint32(32).bool(message.nsfw);
    }
    if (message.authorId !== "") {
      writer.uint32(42).string(message.authorId);
    }
    if (message.crowdControlLevel !== 0) {
      writer.uint32(48).int32(message.crowdControlLevel);
    }
    if (message.numReports !== 0) {
      writer.uint32(56).int32(message.numReports);
    }
    if (message.isGallery === true) {
      writer.uint32(64).bool(message.isGallery);
    }
    if (message.isMeta === true) {
      writer.uint32(72).bool(message.isMeta);
    }
    if (message.createdAt !== 0) {
      writer.uint32(80).int64(message.createdAt);
    }
    if (message.isApproved === true) {
      writer.uint32(88).bool(message.isApproved);
    }
    if (message.isArchived === true) {
      writer.uint32(96).bool(message.isArchived);
    }
    if (message.distinguished !== 0) {
      writer.uint32(104).int32(message.distinguished);
    }
    if (message.ignoreReports === true) {
      writer.uint32(112).bool(message.ignoreReports);
    }
    if (message.isSelf === true) {
      writer.uint32(120).bool(message.isSelf);
    }
    if (message.isVideo === true) {
      writer.uint32(128).bool(message.isVideo);
    }
    if (message.isLocked === true) {
      writer.uint32(136).bool(message.isLocked);
    }
    if (message.isSpoiler === true) {
      writer.uint32(144).bool(message.isSpoiler);
    }
    if (message.subredditId !== "") {
      writer.uint32(154).string(message.subredditId);
    }
    if (message.upvotes !== 0) {
      writer.uint32(160).int32(message.upvotes);
    }
    if (message.downvotes !== 0) {
      writer.uint32(168).int32(message.downvotes);
    }
    if (message.url !== "") {
      writer.uint32(178).string(message.url);
    }
    if (message.isSticky === true) {
      writer.uint32(184).bool(message.isSticky);
    }
    if (message.linkFlair !== void 0) {
      LinkFlairV2.encode(message.linkFlair, writer.uint32(194).fork()).ldelim();
    }
    if (message.authorFlair !== void 0) {
      UserFlairV2.encode(message.authorFlair, writer.uint32(202).fork()).ldelim();
    }
    if (message.spam === true) {
      writer.uint32(208).bool(message.spam);
    }
    if (message.deleted === true) {
      writer.uint32(216).bool(message.deleted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.title = reader.string();
          break;
        case 3:
          message.selftext = reader.string();
          break;
        case 4:
          message.nsfw = reader.bool();
          break;
        case 5:
          message.authorId = reader.string();
          break;
        case 6:
          message.crowdControlLevel = reader.int32();
          break;
        case 7:
          message.numReports = reader.int32();
          break;
        case 8:
          message.isGallery = reader.bool();
          break;
        case 9:
          message.isMeta = reader.bool();
          break;
        case 10:
          message.createdAt = longToNumber2(reader.int64());
          break;
        case 11:
          message.isApproved = reader.bool();
          break;
        case 12:
          message.isArchived = reader.bool();
          break;
        case 13:
          message.distinguished = reader.int32();
          break;
        case 14:
          message.ignoreReports = reader.bool();
          break;
        case 15:
          message.isSelf = reader.bool();
          break;
        case 16:
          message.isVideo = reader.bool();
          break;
        case 17:
          message.isLocked = reader.bool();
          break;
        case 18:
          message.isSpoiler = reader.bool();
          break;
        case 19:
          message.subredditId = reader.string();
          break;
        case 20:
          message.upvotes = reader.int32();
          break;
        case 21:
          message.downvotes = reader.int32();
          break;
        case 22:
          message.url = reader.string();
          break;
        case 23:
          message.isSticky = reader.bool();
          break;
        case 24:
          message.linkFlair = LinkFlairV2.decode(reader, reader.uint32());
          break;
        case 25:
          message.authorFlair = UserFlairV2.decode(reader, reader.uint32());
          break;
        case 26:
          message.spam = reader.bool();
          break;
        case 27:
          message.deleted = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet15(object.id) ? String(object.id) : "",
      title: isSet15(object.title) ? String(object.title) : "",
      selftext: isSet15(object.selftext) ? String(object.selftext) : "",
      nsfw: isSet15(object.nsfw) ? Boolean(object.nsfw) : false,
      authorId: isSet15(object.authorId) ? String(object.authorId) : "",
      crowdControlLevel: isSet15(object.crowdControlLevel) ? crowdControlLevelFromJSON(object.crowdControlLevel) : 0,
      numReports: isSet15(object.numReports) ? Number(object.numReports) : 0,
      isGallery: isSet15(object.isGallery) ? Boolean(object.isGallery) : false,
      isMeta: isSet15(object.isMeta) ? Boolean(object.isMeta) : false,
      createdAt: isSet15(object.createdAt) ? Number(object.createdAt) : 0,
      isApproved: isSet15(object.isApproved) ? Boolean(object.isApproved) : false,
      isArchived: isSet15(object.isArchived) ? Boolean(object.isArchived) : false,
      distinguished: isSet15(object.distinguished) ? distinguishTypeFromJSON(object.distinguished) : 0,
      ignoreReports: isSet15(object.ignoreReports) ? Boolean(object.ignoreReports) : false,
      isSelf: isSet15(object.isSelf) ? Boolean(object.isSelf) : false,
      isVideo: isSet15(object.isVideo) ? Boolean(object.isVideo) : false,
      isLocked: isSet15(object.isLocked) ? Boolean(object.isLocked) : false,
      isSpoiler: isSet15(object.isSpoiler) ? Boolean(object.isSpoiler) : false,
      subredditId: isSet15(object.subredditId) ? String(object.subredditId) : "",
      upvotes: isSet15(object.upvotes) ? Number(object.upvotes) : 0,
      downvotes: isSet15(object.downvotes) ? Number(object.downvotes) : 0,
      url: isSet15(object.url) ? String(object.url) : "",
      isSticky: isSet15(object.isSticky) ? Boolean(object.isSticky) : false,
      linkFlair: isSet15(object.linkFlair) ? LinkFlairV2.fromJSON(object.linkFlair) : void 0,
      authorFlair: isSet15(object.authorFlair) ? UserFlairV2.fromJSON(object.authorFlair) : void 0,
      spam: isSet15(object.spam) ? Boolean(object.spam) : false,
      deleted: isSet15(object.deleted) ? Boolean(object.deleted) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.title !== void 0 && (obj.title = message.title);
    message.selftext !== void 0 && (obj.selftext = message.selftext);
    message.nsfw !== void 0 && (obj.nsfw = message.nsfw);
    message.authorId !== void 0 && (obj.authorId = message.authorId);
    message.crowdControlLevel !== void 0 && (obj.crowdControlLevel = crowdControlLevelToJSON(message.crowdControlLevel));
    message.numReports !== void 0 && (obj.numReports = Math.round(message.numReports));
    message.isGallery !== void 0 && (obj.isGallery = message.isGallery);
    message.isMeta !== void 0 && (obj.isMeta = message.isMeta);
    message.createdAt !== void 0 && (obj.createdAt = Math.round(message.createdAt));
    message.isApproved !== void 0 && (obj.isApproved = message.isApproved);
    message.isArchived !== void 0 && (obj.isArchived = message.isArchived);
    message.distinguished !== void 0 && (obj.distinguished = distinguishTypeToJSON(message.distinguished));
    message.ignoreReports !== void 0 && (obj.ignoreReports = message.ignoreReports);
    message.isSelf !== void 0 && (obj.isSelf = message.isSelf);
    message.isVideo !== void 0 && (obj.isVideo = message.isVideo);
    message.isLocked !== void 0 && (obj.isLocked = message.isLocked);
    message.isSpoiler !== void 0 && (obj.isSpoiler = message.isSpoiler);
    message.subredditId !== void 0 && (obj.subredditId = message.subredditId);
    message.upvotes !== void 0 && (obj.upvotes = Math.round(message.upvotes));
    message.downvotes !== void 0 && (obj.downvotes = Math.round(message.downvotes));
    message.url !== void 0 && (obj.url = message.url);
    message.isSticky !== void 0 && (obj.isSticky = message.isSticky);
    message.linkFlair !== void 0 && (obj.linkFlair = message.linkFlair ? LinkFlairV2.toJSON(message.linkFlair) : void 0);
    message.authorFlair !== void 0 && (obj.authorFlair = message.authorFlair ? UserFlairV2.toJSON(message.authorFlair) : void 0);
    message.spam !== void 0 && (obj.spam = message.spam);
    message.deleted !== void 0 && (obj.deleted = message.deleted);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePostV2();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.selftext = object.selftext ?? "";
    message.nsfw = object.nsfw ?? false;
    message.authorId = object.authorId ?? "";
    message.crowdControlLevel = object.crowdControlLevel ?? 0;
    message.numReports = object.numReports ?? 0;
    message.isGallery = object.isGallery ?? false;
    message.isMeta = object.isMeta ?? false;
    message.createdAt = object.createdAt ?? 0;
    message.isApproved = object.isApproved ?? false;
    message.isArchived = object.isArchived ?? false;
    message.distinguished = object.distinguished ?? 0;
    message.ignoreReports = object.ignoreReports ?? false;
    message.isSelf = object.isSelf ?? false;
    message.isVideo = object.isVideo ?? false;
    message.isLocked = object.isLocked ?? false;
    message.isSpoiler = object.isSpoiler ?? false;
    message.subredditId = object.subredditId ?? "";
    message.upvotes = object.upvotes ?? 0;
    message.downvotes = object.downvotes ?? 0;
    message.url = object.url ?? "";
    message.isSticky = object.isSticky ?? false;
    message.linkFlair = object.linkFlair !== void 0 && object.linkFlair !== null ? LinkFlairV2.fromPartial(object.linkFlair) : void 0;
    message.authorFlair = object.authorFlair !== void 0 && object.authorFlair !== null ? UserFlairV2.fromPartial(object.authorFlair) : void 0;
    message.spam = object.spam ?? false;
    message.deleted = object.deleted ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.v2alpha.PostV2", PostV2);
var globalThis3 = (() => {
  if (typeof globalThis3 !== "undefined") {
    return globalThis3;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function longToNumber2(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis3.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal16.default.util.Long !== import_long2.default) {
  import_minimal16.default.util.Long = import_long2.default;
  import_minimal16.default.configure();
}
function isSet15(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/v2alpha/subredditv2.js
var import_minimal17 = __toESM(require_minimal2(), 1);
var SubredditType;
(function(SubredditType2) {
  SubredditType2[SubredditType2["ARCHIVED"] = 0] = "ARCHIVED";
  SubredditType2[SubredditType2["EMPLOYEES_ONLY"] = 1] = "EMPLOYEES_ONLY";
  SubredditType2[SubredditType2["GOLD_ONLY"] = 2] = "GOLD_ONLY";
  SubredditType2[SubredditType2["GOLD_RESTRICTED"] = 3] = "GOLD_RESTRICTED";
  SubredditType2[SubredditType2["PRIVATE"] = 4] = "PRIVATE";
  SubredditType2[SubredditType2["PUBLIC"] = 5] = "PUBLIC";
  SubredditType2[SubredditType2["RESTRICTED"] = 6] = "RESTRICTED";
  SubredditType2[SubredditType2["USER"] = 7] = "USER";
  SubredditType2[SubredditType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SubredditType || (SubredditType = {}));
function subredditTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ARCHIVED":
      return SubredditType.ARCHIVED;
    case 1:
    case "EMPLOYEES_ONLY":
      return SubredditType.EMPLOYEES_ONLY;
    case 2:
    case "GOLD_ONLY":
      return SubredditType.GOLD_ONLY;
    case 3:
    case "GOLD_RESTRICTED":
      return SubredditType.GOLD_RESTRICTED;
    case 4:
    case "PRIVATE":
      return SubredditType.PRIVATE;
    case 5:
    case "PUBLIC":
      return SubredditType.PUBLIC;
    case 6:
    case "RESTRICTED":
      return SubredditType.RESTRICTED;
    case 7:
    case "USER":
      return SubredditType.USER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubredditType.UNRECOGNIZED;
  }
}
function subredditTypeToJSON(object) {
  switch (object) {
    case SubredditType.ARCHIVED:
      return 0;
    case SubredditType.EMPLOYEES_ONLY:
      return 1;
    case SubredditType.GOLD_ONLY:
      return 2;
    case SubredditType.GOLD_RESTRICTED:
      return 3;
    case SubredditType.PRIVATE:
      return 4;
    case SubredditType.PUBLIC:
      return 5;
    case SubredditType.RESTRICTED:
      return 6;
    case SubredditType.USER:
      return 7;
    case SubredditType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseSubredditV2() {
  return { id: "", name: "", nsfw: false, type: 0, spam: false, quarantined: false };
}
var SubredditV2 = {
  $type: "devvit.reddit.v2alpha.SubredditV2",
  encode(message, writer = import_minimal17.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nsfw === true) {
      writer.uint32(24).bool(message.nsfw);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.spam === true) {
      writer.uint32(40).bool(message.spam);
    }
    if (message.quarantined === true) {
      writer.uint32(48).bool(message.quarantined);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal17.default.Reader ? input : new import_minimal17.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.nsfw = reader.bool();
          break;
        case 4:
          message.type = reader.int32();
          break;
        case 5:
          message.spam = reader.bool();
          break;
        case 6:
          message.quarantined = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet16(object.id) ? String(object.id) : "",
      name: isSet16(object.name) ? String(object.name) : "",
      nsfw: isSet16(object.nsfw) ? Boolean(object.nsfw) : false,
      type: isSet16(object.type) ? subredditTypeFromJSON(object.type) : 0,
      spam: isSet16(object.spam) ? Boolean(object.spam) : false,
      quarantined: isSet16(object.quarantined) ? Boolean(object.quarantined) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.name !== void 0 && (obj.name = message.name);
    message.nsfw !== void 0 && (obj.nsfw = message.nsfw);
    message.type !== void 0 && (obj.type = subredditTypeToJSON(message.type));
    message.spam !== void 0 && (obj.spam = message.spam);
    message.quarantined !== void 0 && (obj.quarantined = message.quarantined);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditV2();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.nsfw = object.nsfw ?? false;
    message.type = object.type ?? 0;
    message.spam = object.spam ?? false;
    message.quarantined = object.quarantined ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.v2alpha.SubredditV2", SubredditV2);
function isSet16(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/v2alpha/userv2.js
var import_minimal18 = __toESM(require_minimal2(), 1);
function createBaseUserV2() {
  return { id: "", name: "", isGold: false };
}
var UserV2 = {
  $type: "devvit.reddit.v2alpha.UserV2",
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.isGold === true) {
      writer.uint32(24).bool(message.isGold);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.isGold = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet17(object.id) ? String(object.id) : "",
      name: isSet17(object.name) ? String(object.name) : "",
      isGold: isSet17(object.isGold) ? Boolean(object.isGold) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.name !== void 0 && (obj.name = message.name);
    message.isGold !== void 0 && (obj.isGold = message.isGold);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserV2();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.isGold = object.isGold ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.v2alpha.UserV2", UserV2);
function isSet17(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/events/v1alpha/events.js
function createBasePostSubmit() {
  return { post: void 0, author: void 0, subreddit: void 0 };
}
var PostSubmit = {
  $type: "devvit.events.v1alpha.PostSubmit",
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : new import_minimal19.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostSubmit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.post = PostV2.decode(reader, reader.uint32());
          break;
        case 2:
          message.author = UserV2.decode(reader, reader.uint32());
          break;
        case 10:
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      post: isSet18(object.post) ? PostV2.fromJSON(object.post) : void 0,
      author: isSet18(object.author) ? UserV2.fromJSON(object.author) : void 0,
      subreddit: isSet18(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.post !== void 0 && (obj.post = message.post ? PostV2.toJSON(message.post) : void 0);
    message.author !== void 0 && (obj.author = message.author ? UserV2.toJSON(message.author) : void 0);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? SubredditV2.toJSON(message.subreddit) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePostSubmit();
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.events.v1alpha.PostSubmit", PostSubmit);
function createBasePostUpdate() {
  return { post: void 0, author: void 0, subreddit: void 0 };
}
var PostUpdate = {
  $type: "devvit.events.v1alpha.PostUpdate",
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : new import_minimal19.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.post = PostV2.decode(reader, reader.uint32());
          break;
        case 2:
          message.author = UserV2.decode(reader, reader.uint32());
          break;
        case 10:
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      post: isSet18(object.post) ? PostV2.fromJSON(object.post) : void 0,
      author: isSet18(object.author) ? UserV2.fromJSON(object.author) : void 0,
      subreddit: isSet18(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.post !== void 0 && (obj.post = message.post ? PostV2.toJSON(message.post) : void 0);
    message.author !== void 0 && (obj.author = message.author ? UserV2.toJSON(message.author) : void 0);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? SubredditV2.toJSON(message.subreddit) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePostUpdate();
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.events.v1alpha.PostUpdate", PostUpdate);
function createBasePostReport() {
  return { post: void 0, reporter: void 0, subreddit: void 0 };
}
var PostReport = {
  $type: "devvit.events.v1alpha.PostReport",
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(10).fork()).ldelim();
    }
    if (message.reporter !== void 0) {
      UserV2.encode(message.reporter, writer.uint32(18).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : new import_minimal19.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.post = PostV2.decode(reader, reader.uint32());
          break;
        case 2:
          message.reporter = UserV2.decode(reader, reader.uint32());
          break;
        case 10:
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      post: isSet18(object.post) ? PostV2.fromJSON(object.post) : void 0,
      reporter: isSet18(object.reporter) ? UserV2.fromJSON(object.reporter) : void 0,
      subreddit: isSet18(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.post !== void 0 && (obj.post = message.post ? PostV2.toJSON(message.post) : void 0);
    message.reporter !== void 0 && (obj.reporter = message.reporter ? UserV2.toJSON(message.reporter) : void 0);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? SubredditV2.toJSON(message.subreddit) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePostReport();
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.reporter = object.reporter !== void 0 && object.reporter !== null ? UserV2.fromPartial(object.reporter) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.events.v1alpha.PostReport", PostReport);
function createBaseCommentSubmit() {
  return { comment: void 0, author: void 0, post: void 0, subreddit: void 0 };
}
var CommentSubmit = {
  $type: "devvit.events.v1alpha.CommentSubmit",
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.comment !== void 0) {
      CommentV2.encode(message.comment, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(26).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : new import_minimal19.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentSubmit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.comment = CommentV2.decode(reader, reader.uint32());
          break;
        case 2:
          message.author = UserV2.decode(reader, reader.uint32());
          break;
        case 3:
          message.post = PostV2.decode(reader, reader.uint32());
          break;
        case 10:
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      comment: isSet18(object.comment) ? CommentV2.fromJSON(object.comment) : void 0,
      author: isSet18(object.author) ? UserV2.fromJSON(object.author) : void 0,
      post: isSet18(object.post) ? PostV2.fromJSON(object.post) : void 0,
      subreddit: isSet18(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.comment !== void 0 && (obj.comment = message.comment ? CommentV2.toJSON(message.comment) : void 0);
    message.author !== void 0 && (obj.author = message.author ? UserV2.toJSON(message.author) : void 0);
    message.post !== void 0 && (obj.post = message.post ? PostV2.toJSON(message.post) : void 0);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? SubredditV2.toJSON(message.subreddit) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommentSubmit();
    message.comment = object.comment !== void 0 && object.comment !== null ? CommentV2.fromPartial(object.comment) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.events.v1alpha.CommentSubmit", CommentSubmit);
function createBaseCommentUpdate() {
  return { comment: void 0, author: void 0, post: void 0, subreddit: void 0 };
}
var CommentUpdate = {
  $type: "devvit.events.v1alpha.CommentUpdate",
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.comment !== void 0) {
      CommentV2.encode(message.comment, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      UserV2.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.post !== void 0) {
      PostV2.encode(message.post, writer.uint32(26).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : new import_minimal19.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.comment = CommentV2.decode(reader, reader.uint32());
          break;
        case 2:
          message.author = UserV2.decode(reader, reader.uint32());
          break;
        case 3:
          message.post = PostV2.decode(reader, reader.uint32());
          break;
        case 10:
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      comment: isSet18(object.comment) ? CommentV2.fromJSON(object.comment) : void 0,
      author: isSet18(object.author) ? UserV2.fromJSON(object.author) : void 0,
      post: isSet18(object.post) ? PostV2.fromJSON(object.post) : void 0,
      subreddit: isSet18(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.comment !== void 0 && (obj.comment = message.comment ? CommentV2.toJSON(message.comment) : void 0);
    message.author !== void 0 && (obj.author = message.author ? UserV2.toJSON(message.author) : void 0);
    message.post !== void 0 && (obj.post = message.post ? PostV2.toJSON(message.post) : void 0);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? SubredditV2.toJSON(message.subreddit) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommentUpdate();
    message.comment = object.comment !== void 0 && object.comment !== null ? CommentV2.fromPartial(object.comment) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? UserV2.fromPartial(object.author) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? PostV2.fromPartial(object.post) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.events.v1alpha.CommentUpdate", CommentUpdate);
function createBaseCommentReport() {
  return { comment: void 0, reporter: void 0, subreddit: void 0 };
}
var CommentReport = {
  $type: "devvit.events.v1alpha.CommentReport",
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.comment !== void 0) {
      CommentV2.encode(message.comment, writer.uint32(10).fork()).ldelim();
    }
    if (message.reporter !== void 0) {
      UserV2.encode(message.reporter, writer.uint32(18).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : new import_minimal19.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.comment = CommentV2.decode(reader, reader.uint32());
          break;
        case 2:
          message.reporter = UserV2.decode(reader, reader.uint32());
          break;
        case 10:
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      comment: isSet18(object.comment) ? CommentV2.fromJSON(object.comment) : void 0,
      reporter: isSet18(object.reporter) ? UserV2.fromJSON(object.reporter) : void 0,
      subreddit: isSet18(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.comment !== void 0 && (obj.comment = message.comment ? CommentV2.toJSON(message.comment) : void 0);
    message.reporter !== void 0 && (obj.reporter = message.reporter ? UserV2.toJSON(message.reporter) : void 0);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? SubredditV2.toJSON(message.subreddit) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommentReport();
    message.comment = object.comment !== void 0 && object.comment !== null ? CommentV2.fromPartial(object.comment) : void 0;
    message.reporter = object.reporter !== void 0 && object.reporter !== null ? UserV2.fromPartial(object.reporter) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.events.v1alpha.CommentReport", CommentReport);
function createBaseSubredditSubscribe() {
  return { subreddit: void 0, subscriber: void 0 };
}
var SubredditSubscribe = {
  $type: "devvit.events.v1alpha.SubredditSubscribe",
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(10).fork()).ldelim();
    }
    if (message.subscriber !== void 0) {
      UserV2.encode(message.subscriber, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : new import_minimal19.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditSubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          break;
        case 2:
          message.subscriber = UserV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet18(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0,
      subscriber: isSet18(object.subscriber) ? UserV2.fromJSON(object.subscriber) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? SubredditV2.toJSON(message.subreddit) : void 0);
    message.subscriber !== void 0 && (obj.subscriber = message.subscriber ? UserV2.toJSON(message.subscriber) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditSubscribe();
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    message.subscriber = object.subscriber !== void 0 && object.subscriber !== null ? UserV2.fromPartial(object.subscriber) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.events.v1alpha.SubredditSubscribe", SubredditSubscribe);
function createBaseAppInstall() {
  return { subreddit: void 0, installer: void 0 };
}
var AppInstall = {
  $type: "devvit.events.v1alpha.AppInstall",
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(10).fork()).ldelim();
    }
    if (message.installer !== void 0) {
      UserV2.encode(message.installer, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : new import_minimal19.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppInstall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          break;
        case 2:
          message.installer = UserV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet18(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0,
      installer: isSet18(object.installer) ? UserV2.fromJSON(object.installer) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? SubredditV2.toJSON(message.subreddit) : void 0);
    message.installer !== void 0 && (obj.installer = message.installer ? UserV2.toJSON(message.installer) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppInstall();
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    message.installer = object.installer !== void 0 && object.installer !== null ? UserV2.fromPartial(object.installer) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.events.v1alpha.AppInstall", AppInstall);
function createBaseAppUpgrade() {
  return { subreddit: void 0, installer: void 0 };
}
var AppUpgrade = {
  $type: "devvit.events.v1alpha.AppUpgrade",
  encode(message, writer = import_minimal19.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      SubredditV2.encode(message.subreddit, writer.uint32(10).fork()).ldelim();
    }
    if (message.installer !== void 0) {
      UserV2.encode(message.installer, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : new import_minimal19.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppUpgrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = SubredditV2.decode(reader, reader.uint32());
          break;
        case 2:
          message.installer = UserV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet18(object.subreddit) ? SubredditV2.fromJSON(object.subreddit) : void 0,
      installer: isSet18(object.installer) ? UserV2.fromJSON(object.installer) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? SubredditV2.toJSON(message.subreddit) : void 0);
    message.installer !== void 0 && (obj.installer = message.installer ? UserV2.toJSON(message.installer) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppUpgrade();
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditV2.fromPartial(object.subreddit) : void 0;
    message.installer = object.installer !== void 0 && object.installer !== null ? UserV2.fromPartial(object.installer) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.events.v1alpha.AppUpgrade", AppUpgrade);
function isSet18(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/automation/v1alpha/event_handlers.js
function createBaseHandlerResult() {
  return {};
}
var HandlerResult = {
  $type: "devvit.actor.automation.v1alpha.HandlerResult",
  encode(_, writer = import_minimal20.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal20.default.Reader ? input : new import_minimal20.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHandlerResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseHandlerResult();
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v1alpha.HandlerResult", HandlerResult);

// ../protos/dist/types/devvit/actor/automation/v2alpha/automation_ui_builder.js
var import_minimal24 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/form_builder/v1alpha/form.js
var import_minimal23 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/form_builder/v1alpha/field.js
var import_minimal22 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/form_builder/v1alpha/type.js
var FormFieldType;
(function(FormFieldType2) {
  FormFieldType2[FormFieldType2["STRING"] = 0] = "STRING";
  FormFieldType2[FormFieldType2["PARAGRAPH"] = 1] = "PARAGRAPH";
  FormFieldType2[FormFieldType2["NUMBER"] = 2] = "NUMBER";
  FormFieldType2[FormFieldType2["BOOLEAN"] = 3] = "BOOLEAN";
  FormFieldType2[FormFieldType2["LIST"] = 4] = "LIST";
  FormFieldType2[FormFieldType2["SELECTION"] = 5] = "SELECTION";
  FormFieldType2[FormFieldType2["GROUP"] = 6] = "GROUP";
  FormFieldType2[FormFieldType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FormFieldType || (FormFieldType = {}));
function formFieldTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "STRING":
      return FormFieldType.STRING;
    case 1:
    case "PARAGRAPH":
      return FormFieldType.PARAGRAPH;
    case 2:
    case "NUMBER":
      return FormFieldType.NUMBER;
    case 3:
    case "BOOLEAN":
      return FormFieldType.BOOLEAN;
    case 4:
    case "LIST":
      return FormFieldType.LIST;
    case 5:
    case "SELECTION":
      return FormFieldType.SELECTION;
    case 6:
    case "GROUP":
      return FormFieldType.GROUP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FormFieldType.UNRECOGNIZED;
  }
}
function formFieldTypeToJSON(object) {
  switch (object) {
    case FormFieldType.STRING:
      return 0;
    case FormFieldType.PARAGRAPH:
      return 1;
    case FormFieldType.NUMBER:
      return 2;
    case FormFieldType.BOOLEAN:
      return 3;
    case FormFieldType.LIST:
      return 4;
    case FormFieldType.SELECTION:
      return 5;
    case FormFieldType.GROUP:
      return 6;
    case FormFieldType.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/ui/form_builder/v1alpha/value.js
var import_minimal21 = __toESM(require_minimal2(), 1);
function createBaseFormFieldValue() {
  return {
    fieldType: 0,
    stringValue: void 0,
    numberValue: void 0,
    boolValue: void 0,
    listValue: void 0,
    selectionValue: void 0,
    groupValue: void 0
  };
}
var FormFieldValue = {
  $type: "devvit.ui.form_builder.v1alpha.FormFieldValue",
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.fieldType !== 0) {
      writer.uint32(8).int32(message.fieldType);
    }
    if (message.stringValue !== void 0) {
      writer.uint32(18).string(message.stringValue);
    }
    if (message.numberValue !== void 0) {
      writer.uint32(25).double(message.numberValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.listValue !== void 0) {
      FormFieldValue_ListValue.encode(message.listValue, writer.uint32(42).fork()).ldelim();
    }
    if (message.selectionValue !== void 0) {
      FormFieldValue_SelectionValue.encode(message.selectionValue, writer.uint32(50).fork()).ldelim();
    }
    if (message.groupValue !== void 0) {
      FormFieldValue_GroupValue.encode(message.groupValue, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormFieldValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fieldType = reader.int32();
          break;
        case 2:
          message.stringValue = reader.string();
          break;
        case 3:
          message.numberValue = reader.double();
          break;
        case 4:
          message.boolValue = reader.bool();
          break;
        case 5:
          message.listValue = FormFieldValue_ListValue.decode(reader, reader.uint32());
          break;
        case 6:
          message.selectionValue = FormFieldValue_SelectionValue.decode(reader, reader.uint32());
          break;
        case 7:
          message.groupValue = FormFieldValue_GroupValue.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fieldType: isSet19(object.fieldType) ? formFieldTypeFromJSON(object.fieldType) : 0,
      stringValue: isSet19(object.stringValue) ? String(object.stringValue) : void 0,
      numberValue: isSet19(object.numberValue) ? Number(object.numberValue) : void 0,
      boolValue: isSet19(object.boolValue) ? Boolean(object.boolValue) : void 0,
      listValue: isSet19(object.listValue) ? FormFieldValue_ListValue.fromJSON(object.listValue) : void 0,
      selectionValue: isSet19(object.selectionValue) ? FormFieldValue_SelectionValue.fromJSON(object.selectionValue) : void 0,
      groupValue: isSet19(object.groupValue) ? FormFieldValue_GroupValue.fromJSON(object.groupValue) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fieldType !== void 0 && (obj.fieldType = formFieldTypeToJSON(message.fieldType));
    message.stringValue !== void 0 && (obj.stringValue = message.stringValue);
    message.numberValue !== void 0 && (obj.numberValue = message.numberValue);
    message.boolValue !== void 0 && (obj.boolValue = message.boolValue);
    message.listValue !== void 0 && (obj.listValue = message.listValue ? FormFieldValue_ListValue.toJSON(message.listValue) : void 0);
    message.selectionValue !== void 0 && (obj.selectionValue = message.selectionValue ? FormFieldValue_SelectionValue.toJSON(message.selectionValue) : void 0);
    message.groupValue !== void 0 && (obj.groupValue = message.groupValue ? FormFieldValue_GroupValue.toJSON(message.groupValue) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFormFieldValue();
    message.fieldType = object.fieldType ?? 0;
    message.stringValue = object.stringValue ?? void 0;
    message.numberValue = object.numberValue ?? void 0;
    message.boolValue = object.boolValue ?? void 0;
    message.listValue = object.listValue !== void 0 && object.listValue !== null ? FormFieldValue_ListValue.fromPartial(object.listValue) : void 0;
    message.selectionValue = object.selectionValue !== void 0 && object.selectionValue !== null ? FormFieldValue_SelectionValue.fromPartial(object.selectionValue) : void 0;
    message.groupValue = object.groupValue !== void 0 && object.groupValue !== null ? FormFieldValue_GroupValue.fromPartial(object.groupValue) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FormFieldValue", FormFieldValue);
function createBaseFormFieldValue_ListValue() {
  return { itemType: 0, items: [] };
}
var FormFieldValue_ListValue = {
  $type: "devvit.ui.form_builder.v1alpha.FormFieldValue.ListValue",
  encode(message, writer = import_minimal21.default.Writer.create()) {
    if (message.itemType !== 0) {
      writer.uint32(8).int32(message.itemType);
    }
    for (const v of message.items) {
      FormFieldValue.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormFieldValue_ListValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemType = reader.int32();
          break;
        case 2:
          message.items.push(FormFieldValue.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      itemType: isSet19(object.itemType) ? formFieldTypeFromJSON(object.itemType) : 0,
      items: Array.isArray(object?.items) ? object.items.map((e) => FormFieldValue.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.itemType !== void 0 && (obj.itemType = formFieldTypeToJSON(message.itemType));
    if (message.items) {
      obj.items = message.items.map((e) => e ? FormFieldValue.toJSON(e) : void 0);
    } else {
      obj.items = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFormFieldValue_ListValue();
    message.itemType = object.itemType ?? 0;
    message.items = object.items?.map((e) => FormFieldValue.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FormFieldValue.ListValue", FormFieldValue_ListValue);
function createBaseFormFieldValue_SelectionValue() {
  return { values: [] };
}
var FormFieldValue_SelectionValue = {
  $type: "devvit.ui.form_builder.v1alpha.FormFieldValue.SelectionValue",
  encode(message, writer = import_minimal21.default.Writer.create()) {
    for (const v of message.values) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormFieldValue_SelectionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.values.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { values: Array.isArray(object?.values) ? object.values.map((e) => String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.values) {
      obj.values = message.values.map((e) => e);
    } else {
      obj.values = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFormFieldValue_SelectionValue();
    message.values = object.values?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FormFieldValue.SelectionValue", FormFieldValue_SelectionValue);
function createBaseFormFieldValue_GroupValue() {
  return {};
}
var FormFieldValue_GroupValue = {
  $type: "devvit.ui.form_builder.v1alpha.FormFieldValue.GroupValue",
  encode(_, writer = import_minimal21.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormFieldValue_GroupValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseFormFieldValue_GroupValue();
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FormFieldValue.GroupValue", FormFieldValue_GroupValue);
function isSet19(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/form_builder/v1alpha/field.js
function createBaseFormField() {
  return {
    fieldId: "",
    fieldType: 0,
    label: "",
    helpText: void 0,
    defaultValue: void 0,
    required: void 0,
    disabled: void 0,
    fieldConfig: void 0
  };
}
var FormField = {
  $type: "devvit.ui.form_builder.v1alpha.FormField",
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.fieldId !== "") {
      writer.uint32(10).string(message.fieldId);
    }
    if (message.fieldType !== 0) {
      writer.uint32(16).int32(message.fieldType);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.helpText !== void 0) {
      writer.uint32(34).string(message.helpText);
    }
    if (message.defaultValue !== void 0) {
      FormFieldValue.encode(message.defaultValue, writer.uint32(42).fork()).ldelim();
    }
    if (message.required !== void 0) {
      writer.uint32(48).bool(message.required);
    }
    if (message.disabled !== void 0) {
      writer.uint32(56).bool(message.disabled);
    }
    if (message.fieldConfig !== void 0) {
      FieldConfig.encode(message.fieldConfig, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fieldId = reader.string();
          break;
        case 2:
          message.fieldType = reader.int32();
          break;
        case 3:
          message.label = reader.string();
          break;
        case 4:
          message.helpText = reader.string();
          break;
        case 5:
          message.defaultValue = FormFieldValue.decode(reader, reader.uint32());
          break;
        case 6:
          message.required = reader.bool();
          break;
        case 7:
          message.disabled = reader.bool();
          break;
        case 8:
          message.fieldConfig = FieldConfig.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fieldId: isSet20(object.fieldId) ? String(object.fieldId) : "",
      fieldType: isSet20(object.fieldType) ? formFieldTypeFromJSON(object.fieldType) : 0,
      label: isSet20(object.label) ? String(object.label) : "",
      helpText: isSet20(object.helpText) ? String(object.helpText) : void 0,
      defaultValue: isSet20(object.defaultValue) ? FormFieldValue.fromJSON(object.defaultValue) : void 0,
      required: isSet20(object.required) ? Boolean(object.required) : void 0,
      disabled: isSet20(object.disabled) ? Boolean(object.disabled) : void 0,
      fieldConfig: isSet20(object.fieldConfig) ? FieldConfig.fromJSON(object.fieldConfig) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fieldId !== void 0 && (obj.fieldId = message.fieldId);
    message.fieldType !== void 0 && (obj.fieldType = formFieldTypeToJSON(message.fieldType));
    message.label !== void 0 && (obj.label = message.label);
    message.helpText !== void 0 && (obj.helpText = message.helpText);
    message.defaultValue !== void 0 && (obj.defaultValue = message.defaultValue ? FormFieldValue.toJSON(message.defaultValue) : void 0);
    message.required !== void 0 && (obj.required = message.required);
    message.disabled !== void 0 && (obj.disabled = message.disabled);
    message.fieldConfig !== void 0 && (obj.fieldConfig = message.fieldConfig ? FieldConfig.toJSON(message.fieldConfig) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFormField();
    message.fieldId = object.fieldId ?? "";
    message.fieldType = object.fieldType ?? 0;
    message.label = object.label ?? "";
    message.helpText = object.helpText ?? void 0;
    message.defaultValue = object.defaultValue !== void 0 && object.defaultValue !== null ? FormFieldValue.fromPartial(object.defaultValue) : void 0;
    message.required = object.required ?? void 0;
    message.disabled = object.disabled ?? void 0;
    message.fieldConfig = object.fieldConfig !== void 0 && object.fieldConfig !== null ? FieldConfig.fromPartial(object.fieldConfig) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FormField", FormField);
function createBaseFieldConfig() {
  return {
    stringConfig: void 0,
    paragraphConfig: void 0,
    numberConfig: void 0,
    booleanConfig: void 0,
    listConfig: void 0,
    selectionConfig: void 0,
    groupConfig: void 0
  };
}
var FieldConfig = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig",
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.stringConfig !== void 0) {
      FieldConfig_String.encode(message.stringConfig, writer.uint32(10).fork()).ldelim();
    }
    if (message.paragraphConfig !== void 0) {
      FieldConfig_Paragraph.encode(message.paragraphConfig, writer.uint32(18).fork()).ldelim();
    }
    if (message.numberConfig !== void 0) {
      FieldConfig_Number.encode(message.numberConfig, writer.uint32(26).fork()).ldelim();
    }
    if (message.booleanConfig !== void 0) {
      FieldConfig_Boolean.encode(message.booleanConfig, writer.uint32(34).fork()).ldelim();
    }
    if (message.listConfig !== void 0) {
      FieldConfig_List.encode(message.listConfig, writer.uint32(42).fork()).ldelim();
    }
    if (message.selectionConfig !== void 0) {
      FieldConfig_Selection.encode(message.selectionConfig, writer.uint32(50).fork()).ldelim();
    }
    if (message.groupConfig !== void 0) {
      FieldConfig_Group.encode(message.groupConfig, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.stringConfig = FieldConfig_String.decode(reader, reader.uint32());
          break;
        case 2:
          message.paragraphConfig = FieldConfig_Paragraph.decode(reader, reader.uint32());
          break;
        case 3:
          message.numberConfig = FieldConfig_Number.decode(reader, reader.uint32());
          break;
        case 4:
          message.booleanConfig = FieldConfig_Boolean.decode(reader, reader.uint32());
          break;
        case 5:
          message.listConfig = FieldConfig_List.decode(reader, reader.uint32());
          break;
        case 6:
          message.selectionConfig = FieldConfig_Selection.decode(reader, reader.uint32());
          break;
        case 7:
          message.groupConfig = FieldConfig_Group.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      stringConfig: isSet20(object.stringConfig) ? FieldConfig_String.fromJSON(object.stringConfig) : void 0,
      paragraphConfig: isSet20(object.paragraphConfig) ? FieldConfig_Paragraph.fromJSON(object.paragraphConfig) : void 0,
      numberConfig: isSet20(object.numberConfig) ? FieldConfig_Number.fromJSON(object.numberConfig) : void 0,
      booleanConfig: isSet20(object.booleanConfig) ? FieldConfig_Boolean.fromJSON(object.booleanConfig) : void 0,
      listConfig: isSet20(object.listConfig) ? FieldConfig_List.fromJSON(object.listConfig) : void 0,
      selectionConfig: isSet20(object.selectionConfig) ? FieldConfig_Selection.fromJSON(object.selectionConfig) : void 0,
      groupConfig: isSet20(object.groupConfig) ? FieldConfig_Group.fromJSON(object.groupConfig) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.stringConfig !== void 0 && (obj.stringConfig = message.stringConfig ? FieldConfig_String.toJSON(message.stringConfig) : void 0);
    message.paragraphConfig !== void 0 && (obj.paragraphConfig = message.paragraphConfig ? FieldConfig_Paragraph.toJSON(message.paragraphConfig) : void 0);
    message.numberConfig !== void 0 && (obj.numberConfig = message.numberConfig ? FieldConfig_Number.toJSON(message.numberConfig) : void 0);
    message.booleanConfig !== void 0 && (obj.booleanConfig = message.booleanConfig ? FieldConfig_Boolean.toJSON(message.booleanConfig) : void 0);
    message.listConfig !== void 0 && (obj.listConfig = message.listConfig ? FieldConfig_List.toJSON(message.listConfig) : void 0);
    message.selectionConfig !== void 0 && (obj.selectionConfig = message.selectionConfig ? FieldConfig_Selection.toJSON(message.selectionConfig) : void 0);
    message.groupConfig !== void 0 && (obj.groupConfig = message.groupConfig ? FieldConfig_Group.toJSON(message.groupConfig) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFieldConfig();
    message.stringConfig = object.stringConfig !== void 0 && object.stringConfig !== null ? FieldConfig_String.fromPartial(object.stringConfig) : void 0;
    message.paragraphConfig = object.paragraphConfig !== void 0 && object.paragraphConfig !== null ? FieldConfig_Paragraph.fromPartial(object.paragraphConfig) : void 0;
    message.numberConfig = object.numberConfig !== void 0 && object.numberConfig !== null ? FieldConfig_Number.fromPartial(object.numberConfig) : void 0;
    message.booleanConfig = object.booleanConfig !== void 0 && object.booleanConfig !== null ? FieldConfig_Boolean.fromPartial(object.booleanConfig) : void 0;
    message.listConfig = object.listConfig !== void 0 && object.listConfig !== null ? FieldConfig_List.fromPartial(object.listConfig) : void 0;
    message.selectionConfig = object.selectionConfig !== void 0 && object.selectionConfig !== null ? FieldConfig_Selection.fromPartial(object.selectionConfig) : void 0;
    message.groupConfig = object.groupConfig !== void 0 && object.groupConfig !== null ? FieldConfig_Group.fromPartial(object.groupConfig) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FieldConfig", FieldConfig);
function createBaseFieldConfig_String() {
  return { minLength: void 0, maxLength: void 0, placeholder: void 0 };
}
var FieldConfig_String = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.String",
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.minLength !== void 0) {
      writer.uint32(8).int32(message.minLength);
    }
    if (message.maxLength !== void 0) {
      writer.uint32(16).int32(message.maxLength);
    }
    if (message.placeholder !== void 0) {
      writer.uint32(26).string(message.placeholder);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_String();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.minLength = reader.int32();
          break;
        case 2:
          message.maxLength = reader.int32();
          break;
        case 3:
          message.placeholder = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      minLength: isSet20(object.minLength) ? Number(object.minLength) : void 0,
      maxLength: isSet20(object.maxLength) ? Number(object.maxLength) : void 0,
      placeholder: isSet20(object.placeholder) ? String(object.placeholder) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.minLength !== void 0 && (obj.minLength = Math.round(message.minLength));
    message.maxLength !== void 0 && (obj.maxLength = Math.round(message.maxLength));
    message.placeholder !== void 0 && (obj.placeholder = message.placeholder);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_String();
    message.minLength = object.minLength ?? void 0;
    message.maxLength = object.maxLength ?? void 0;
    message.placeholder = object.placeholder ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FieldConfig.String", FieldConfig_String);
function createBaseFieldConfig_Paragraph() {
  return { maxCharacters: void 0, lineHeight: void 0, placeholder: void 0 };
}
var FieldConfig_Paragraph = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Paragraph",
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.maxCharacters !== void 0) {
      writer.uint32(8).int32(message.maxCharacters);
    }
    if (message.lineHeight !== void 0) {
      writer.uint32(16).int32(message.lineHeight);
    }
    if (message.placeholder !== void 0) {
      writer.uint32(26).string(message.placeholder);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_Paragraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxCharacters = reader.int32();
          break;
        case 2:
          message.lineHeight = reader.int32();
          break;
        case 3:
          message.placeholder = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      maxCharacters: isSet20(object.maxCharacters) ? Number(object.maxCharacters) : void 0,
      lineHeight: isSet20(object.lineHeight) ? Number(object.lineHeight) : void 0,
      placeholder: isSet20(object.placeholder) ? String(object.placeholder) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.maxCharacters !== void 0 && (obj.maxCharacters = Math.round(message.maxCharacters));
    message.lineHeight !== void 0 && (obj.lineHeight = Math.round(message.lineHeight));
    message.placeholder !== void 0 && (obj.placeholder = message.placeholder);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_Paragraph();
    message.maxCharacters = object.maxCharacters ?? void 0;
    message.lineHeight = object.lineHeight ?? void 0;
    message.placeholder = object.placeholder ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FieldConfig.Paragraph", FieldConfig_Paragraph);
function createBaseFieldConfig_Number() {
  return { step: void 0, min: void 0, max: void 0 };
}
var FieldConfig_Number = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Number",
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.step !== void 0) {
      writer.uint32(9).double(message.step);
    }
    if (message.min !== void 0) {
      writer.uint32(17).double(message.min);
    }
    if (message.max !== void 0) {
      writer.uint32(25).double(message.max);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_Number();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.step = reader.double();
          break;
        case 2:
          message.min = reader.double();
          break;
        case 3:
          message.max = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      step: isSet20(object.step) ? Number(object.step) : void 0,
      min: isSet20(object.min) ? Number(object.min) : void 0,
      max: isSet20(object.max) ? Number(object.max) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.step !== void 0 && (obj.step = message.step);
    message.min !== void 0 && (obj.min = message.min);
    message.max !== void 0 && (obj.max = message.max);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_Number();
    message.step = object.step ?? void 0;
    message.min = object.min ?? void 0;
    message.max = object.max ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FieldConfig.Number", FieldConfig_Number);
function createBaseFieldConfig_Boolean() {
  return {};
}
var FieldConfig_Boolean = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Boolean",
  encode(_, writer = import_minimal22.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_Boolean();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseFieldConfig_Boolean();
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FieldConfig.Boolean", FieldConfig_Boolean);
function createBaseFieldConfig_List() {
  return { itemType: 0, itemConfig: void 0, minEntries: void 0, maxEntries: void 0, entryLabel: void 0 };
}
var FieldConfig_List = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.List",
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.itemType !== 0) {
      writer.uint32(8).int32(message.itemType);
    }
    if (message.itemConfig !== void 0) {
      FieldConfig.encode(message.itemConfig, writer.uint32(18).fork()).ldelim();
    }
    if (message.minEntries !== void 0) {
      writer.uint32(24).int32(message.minEntries);
    }
    if (message.maxEntries !== void 0) {
      writer.uint32(32).int32(message.maxEntries);
    }
    if (message.entryLabel !== void 0) {
      writer.uint32(42).string(message.entryLabel);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_List();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemType = reader.int32();
          break;
        case 2:
          message.itemConfig = FieldConfig.decode(reader, reader.uint32());
          break;
        case 3:
          message.minEntries = reader.int32();
          break;
        case 4:
          message.maxEntries = reader.int32();
          break;
        case 5:
          message.entryLabel = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      itemType: isSet20(object.itemType) ? formFieldTypeFromJSON(object.itemType) : 0,
      itemConfig: isSet20(object.itemConfig) ? FieldConfig.fromJSON(object.itemConfig) : void 0,
      minEntries: isSet20(object.minEntries) ? Number(object.minEntries) : void 0,
      maxEntries: isSet20(object.maxEntries) ? Number(object.maxEntries) : void 0,
      entryLabel: isSet20(object.entryLabel) ? String(object.entryLabel) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.itemType !== void 0 && (obj.itemType = formFieldTypeToJSON(message.itemType));
    message.itemConfig !== void 0 && (obj.itemConfig = message.itemConfig ? FieldConfig.toJSON(message.itemConfig) : void 0);
    message.minEntries !== void 0 && (obj.minEntries = Math.round(message.minEntries));
    message.maxEntries !== void 0 && (obj.maxEntries = Math.round(message.maxEntries));
    message.entryLabel !== void 0 && (obj.entryLabel = message.entryLabel);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_List();
    message.itemType = object.itemType ?? 0;
    message.itemConfig = object.itemConfig !== void 0 && object.itemConfig !== null ? FieldConfig.fromPartial(object.itemConfig) : void 0;
    message.minEntries = object.minEntries ?? void 0;
    message.maxEntries = object.maxEntries ?? void 0;
    message.entryLabel = object.entryLabel ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FieldConfig.List", FieldConfig_List);
function createBaseFieldConfig_Selection() {
  return {
    choices: [],
    multiSelect: void 0,
    minSelections: void 0,
    maxSelections: void 0,
    renderAsList: void 0
  };
}
var FieldConfig_Selection = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Selection",
  encode(message, writer = import_minimal22.default.Writer.create()) {
    for (const v of message.choices) {
      FieldConfig_Selection_Item.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.multiSelect !== void 0) {
      writer.uint32(16).bool(message.multiSelect);
    }
    if (message.minSelections !== void 0) {
      writer.uint32(24).int32(message.minSelections);
    }
    if (message.maxSelections !== void 0) {
      writer.uint32(32).int32(message.maxSelections);
    }
    if (message.renderAsList !== void 0) {
      writer.uint32(40).bool(message.renderAsList);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_Selection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.choices.push(FieldConfig_Selection_Item.decode(reader, reader.uint32()));
          break;
        case 2:
          message.multiSelect = reader.bool();
          break;
        case 3:
          message.minSelections = reader.int32();
          break;
        case 4:
          message.maxSelections = reader.int32();
          break;
        case 5:
          message.renderAsList = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      choices: Array.isArray(object?.choices) ? object.choices.map((e) => FieldConfig_Selection_Item.fromJSON(e)) : [],
      multiSelect: isSet20(object.multiSelect) ? Boolean(object.multiSelect) : void 0,
      minSelections: isSet20(object.minSelections) ? Number(object.minSelections) : void 0,
      maxSelections: isSet20(object.maxSelections) ? Number(object.maxSelections) : void 0,
      renderAsList: isSet20(object.renderAsList) ? Boolean(object.renderAsList) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.choices) {
      obj.choices = message.choices.map((e) => e ? FieldConfig_Selection_Item.toJSON(e) : void 0);
    } else {
      obj.choices = [];
    }
    message.multiSelect !== void 0 && (obj.multiSelect = message.multiSelect);
    message.minSelections !== void 0 && (obj.minSelections = Math.round(message.minSelections));
    message.maxSelections !== void 0 && (obj.maxSelections = Math.round(message.maxSelections));
    message.renderAsList !== void 0 && (obj.renderAsList = message.renderAsList);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_Selection();
    message.choices = object.choices?.map((e) => FieldConfig_Selection_Item.fromPartial(e)) || [];
    message.multiSelect = object.multiSelect ?? void 0;
    message.minSelections = object.minSelections ?? void 0;
    message.maxSelections = object.maxSelections ?? void 0;
    message.renderAsList = object.renderAsList ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FieldConfig.Selection", FieldConfig_Selection);
function createBaseFieldConfig_Selection_Item() {
  return { label: "", value: "" };
}
var FieldConfig_Selection_Item = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Selection.Item",
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_Selection_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.label = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      label: isSet20(object.label) ? String(object.label) : "",
      value: isSet20(object.value) ? String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.label !== void 0 && (obj.label = message.label);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_Selection_Item();
    message.label = object.label ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FieldConfig.Selection.Item", FieldConfig_Selection_Item);
function createBaseFieldConfig_Group() {
  return { fields: [] };
}
var FieldConfig_Group = {
  $type: "devvit.ui.form_builder.v1alpha.FieldConfig.Group",
  encode(message, writer = import_minimal22.default.Writer.create()) {
    for (const v of message.fields) {
      FormField.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig_Group();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fields.push(FormField.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { fields: Array.isArray(object?.fields) ? object.fields.map((e) => FormField.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.fields) {
      obj.fields = message.fields.map((e) => e ? FormField.toJSON(e) : void 0);
    } else {
      obj.fields = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFieldConfig_Group();
    message.fields = object.fields?.map((e) => FormField.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.FieldConfig.Group", FieldConfig_Group);
function isSet20(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/form_builder/v1alpha/form.js
function createBaseForm() {
  return {
    fields: [],
    title: void 0,
    shortDescription: void 0,
    acceptLabel: void 0,
    cancelLabel: void 0,
    id: void 0
  };
}
var Form = {
  $type: "devvit.ui.form_builder.v1alpha.Form",
  encode(message, writer = import_minimal23.default.Writer.create()) {
    for (const v of message.fields) {
      FormField.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.title !== void 0) {
      writer.uint32(18).string(message.title);
    }
    if (message.shortDescription !== void 0) {
      writer.uint32(26).string(message.shortDescription);
    }
    if (message.acceptLabel !== void 0) {
      writer.uint32(34).string(message.acceptLabel);
    }
    if (message.cancelLabel !== void 0) {
      writer.uint32(42).string(message.cancelLabel);
    }
    if (message.id !== void 0) {
      writer.uint32(50).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal23.default.Reader ? input : new import_minimal23.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseForm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fields.push(FormField.decode(reader, reader.uint32()));
          break;
        case 2:
          message.title = reader.string();
          break;
        case 3:
          message.shortDescription = reader.string();
          break;
        case 4:
          message.acceptLabel = reader.string();
          break;
        case 5:
          message.cancelLabel = reader.string();
          break;
        case 6:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fields: Array.isArray(object?.fields) ? object.fields.map((e) => FormField.fromJSON(e)) : [],
      title: isSet21(object.title) ? String(object.title) : void 0,
      shortDescription: isSet21(object.shortDescription) ? String(object.shortDescription) : void 0,
      acceptLabel: isSet21(object.acceptLabel) ? String(object.acceptLabel) : void 0,
      cancelLabel: isSet21(object.cancelLabel) ? String(object.cancelLabel) : void 0,
      id: isSet21(object.id) ? String(object.id) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fields) {
      obj.fields = message.fields.map((e) => e ? FormField.toJSON(e) : void 0);
    } else {
      obj.fields = [];
    }
    message.title !== void 0 && (obj.title = message.title);
    message.shortDescription !== void 0 && (obj.shortDescription = message.shortDescription);
    message.acceptLabel !== void 0 && (obj.acceptLabel = message.acceptLabel);
    message.cancelLabel !== void 0 && (obj.cancelLabel = message.cancelLabel);
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseForm();
    message.fields = object.fields?.map((e) => FormField.fromPartial(e)) || [];
    message.title = object.title ?? void 0;
    message.shortDescription = object.shortDescription ?? void 0;
    message.acceptLabel = object.acceptLabel ?? void 0;
    message.cancelLabel = object.cancelLabel ?? void 0;
    message.id = object.id ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.form_builder.v1alpha.Form", Form);
function isSet21(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/automation/v2alpha/automation_ui_builder.js
var AutomationUIBuilderStepType;
(function(AutomationUIBuilderStepType2) {
  AutomationUIBuilderStepType2[AutomationUIBuilderStepType2["ACTION"] = 0] = "ACTION";
  AutomationUIBuilderStepType2[AutomationUIBuilderStepType2["FILTER"] = 1] = "FILTER";
  AutomationUIBuilderStepType2[AutomationUIBuilderStepType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AutomationUIBuilderStepType || (AutomationUIBuilderStepType = {}));
function automationUIBuilderStepTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ACTION":
      return AutomationUIBuilderStepType.ACTION;
    case 1:
    case "FILTER":
      return AutomationUIBuilderStepType.FILTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutomationUIBuilderStepType.UNRECOGNIZED;
  }
}
function automationUIBuilderStepTypeToJSON(object) {
  switch (object) {
    case AutomationUIBuilderStepType.ACTION:
      return 0;
    case AutomationUIBuilderStepType.FILTER:
      return 1;
    case AutomationUIBuilderStepType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseAutomationUIBuilderListTriggersRequest() {
  return {};
}
var AutomationUIBuilderListTriggersRequest = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderListTriggersRequest",
  encode(_, writer = import_minimal24.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderListTriggersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseAutomationUIBuilderListTriggersRequest();
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderListTriggersRequest", AutomationUIBuilderListTriggersRequest);
function createBaseAutomationUIBuilderListTriggersResponse() {
  return { triggers: [] };
}
var AutomationUIBuilderListTriggersResponse = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderListTriggersResponse",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    for (const v of message.triggers) {
      Trigger.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderListTriggersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.triggers.push(Trigger.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { triggers: Array.isArray(object?.triggers) ? object.triggers.map((e) => Trigger.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.triggers) {
      obj.triggers = message.triggers.map((e) => e ? Trigger.toJSON(e) : void 0);
    } else {
      obj.triggers = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderListTriggersResponse();
    message.triggers = object.triggers?.map((e) => Trigger.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderListTriggersResponse", AutomationUIBuilderListTriggersResponse);
function createBaseAutomationUIBuilderListStepsRequest() {
  return { location: "", triggerType: 0, stepType: 0 };
}
var AutomationUIBuilderListStepsRequest = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderListStepsRequest",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    if (message.triggerType !== 0) {
      writer.uint32(16).int32(message.triggerType);
    }
    if (message.stepType !== 0) {
      writer.uint32(24).int32(message.stepType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderListStepsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.location = reader.string();
          break;
        case 2:
          message.triggerType = reader.int32();
          break;
        case 3:
          message.stepType = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      location: isSet22(object.location) ? String(object.location) : "",
      triggerType: isSet22(object.triggerType) ? triggerTypeFromJSON(object.triggerType) : 0,
      stepType: isSet22(object.stepType) ? automationUIBuilderStepTypeFromJSON(object.stepType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.location !== void 0 && (obj.location = message.location);
    message.triggerType !== void 0 && (obj.triggerType = triggerTypeToJSON(message.triggerType));
    message.stepType !== void 0 && (obj.stepType = automationUIBuilderStepTypeToJSON(message.stepType));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderListStepsRequest();
    message.location = object.location ?? "";
    message.triggerType = object.triggerType ?? 0;
    message.stepType = object.stepType ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderListStepsRequest", AutomationUIBuilderListStepsRequest);
function createBaseAutomationUIBuilderStepActor() {
  return { actor: "", label: "", description: "", type: 0 };
}
var AutomationUIBuilderStepActor = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderStepActor",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderStepActor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actor = reader.string();
          break;
        case 2:
          message.label = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          message.type = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet22(object.actor) ? String(object.actor) : "",
      label: isSet22(object.label) ? String(object.label) : "",
      description: isSet22(object.description) ? String(object.description) : "",
      type: isSet22(object.type) ? automationUIBuilderStepTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.actor !== void 0 && (obj.actor = message.actor);
    message.label !== void 0 && (obj.label = message.label);
    message.description !== void 0 && (obj.description = message.description);
    message.type !== void 0 && (obj.type = automationUIBuilderStepTypeToJSON(message.type));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderStepActor();
    message.actor = object.actor ?? "";
    message.label = object.label ?? "";
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderStepActor", AutomationUIBuilderStepActor);
function createBaseAutomationUIBuilderListStepsResponse() {
  return { steps: [] };
}
var AutomationUIBuilderListStepsResponse = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderListStepsResponse",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    for (const v of message.steps) {
      AutomationUIBuilderStepActor.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderListStepsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.steps.push(AutomationUIBuilderStepActor.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      steps: Array.isArray(object?.steps) ? object.steps.map((e) => AutomationUIBuilderStepActor.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.steps) {
      obj.steps = message.steps.map((e) => e ? AutomationUIBuilderStepActor.toJSON(e) : void 0);
    } else {
      obj.steps = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderListStepsResponse();
    message.steps = object.steps?.map((e) => AutomationUIBuilderStepActor.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderListStepsResponse", AutomationUIBuilderListStepsResponse);
function createBaseAutomationUIBuilderListAutomationsRequest() {
  return { location: "" };
}
var AutomationUIBuilderListAutomationsRequest = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderListAutomationsRequest",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderListAutomationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.location = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { location: isSet22(object.location) ? String(object.location) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.location !== void 0 && (obj.location = message.location);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderListAutomationsRequest();
    message.location = object.location ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderListAutomationsRequest", AutomationUIBuilderListAutomationsRequest);
function createBaseAutomationUIBuilderListAutomationsResponse() {
  return { automations: [] };
}
var AutomationUIBuilderListAutomationsResponse = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderListAutomationsResponse",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    for (const v of message.automations) {
      Automation.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderListAutomationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.automations.push(Automation.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      automations: Array.isArray(object?.automations) ? object.automations.map((e) => Automation.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.automations) {
      obj.automations = message.automations.map((e) => e ? Automation.toJSON(e) : void 0);
    } else {
      obj.automations = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderListAutomationsResponse();
    message.automations = object.automations?.map((e) => Automation.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderListAutomationsResponse", AutomationUIBuilderListAutomationsResponse);
function createBaseAutomationUIBuilderGetAutomationRequest() {
  return { id: "" };
}
var AutomationUIBuilderGetAutomationRequest = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderGetAutomationRequest",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderGetAutomationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet22(object.id) ? String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderGetAutomationRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderGetAutomationRequest", AutomationUIBuilderGetAutomationRequest);
function createBaseAutomationUIBuilderGetAutomationResponse() {
  return { automation: void 0 };
}
var AutomationUIBuilderGetAutomationResponse = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderGetAutomationResponse",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.automation !== void 0) {
      Automation.encode(message.automation, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderGetAutomationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.automation = Automation.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { automation: isSet22(object.automation) ? Automation.fromJSON(object.automation) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.automation !== void 0 && (obj.automation = message.automation ? Automation.toJSON(message.automation) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderGetAutomationResponse();
    message.automation = object.automation !== void 0 && object.automation !== null ? Automation.fromPartial(object.automation) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderGetAutomationResponse", AutomationUIBuilderGetAutomationResponse);
function createBaseAutomationUIBuilderGetStepFormRequest() {
  return { actor: "" };
}
var AutomationUIBuilderGetStepFormRequest = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderGetStepFormRequest",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderGetStepFormRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { actor: isSet22(object.actor) ? String(object.actor) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.actor !== void 0 && (obj.actor = message.actor);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderGetStepFormRequest();
    message.actor = object.actor ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderGetStepFormRequest", AutomationUIBuilderGetStepFormRequest);
function createBaseAutomationUIBuilderGetStepFormResponse() {
  return { form: void 0 };
}
var AutomationUIBuilderGetStepFormResponse = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderGetStepFormResponse",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.form !== void 0) {
      Form.encode(message.form, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderGetStepFormResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.form = Form.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { form: isSet22(object.form) ? Form.fromJSON(object.form) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.form !== void 0 && (obj.form = message.form ? Form.toJSON(message.form) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderGetStepFormResponse();
    message.form = object.form !== void 0 && object.form !== null ? Form.fromPartial(object.form) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderGetStepFormResponse", AutomationUIBuilderGetStepFormResponse);
function createBaseAutomationUIBuilderUpdateAutomationRequest() {
  return { id: "", automation: void 0 };
}
var AutomationUIBuilderUpdateAutomationRequest = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderUpdateAutomationRequest",
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.automation !== void 0) {
      Automation.encode(message.automation, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderUpdateAutomationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.automation = Automation.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet22(object.id) ? String(object.id) : "",
      automation: isSet22(object.automation) ? Automation.fromJSON(object.automation) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.automation !== void 0 && (obj.automation = message.automation ? Automation.toJSON(message.automation) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomationUIBuilderUpdateAutomationRequest();
    message.id = object.id ?? "";
    message.automation = object.automation !== void 0 && object.automation !== null ? Automation.fromPartial(object.automation) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderUpdateAutomationRequest", AutomationUIBuilderUpdateAutomationRequest);
function createBaseAutomationUIBuilderUpdateAutomationResponse() {
  return {};
}
var AutomationUIBuilderUpdateAutomationResponse = {
  $type: "devvit.actor.automation.v2alpha.AutomationUIBuilderUpdateAutomationResponse",
  encode(_, writer = import_minimal24.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomationUIBuilderUpdateAutomationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseAutomationUIBuilderUpdateAutomationResponse();
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.automation.v2alpha.AutomationUIBuilderUpdateAutomationResponse", AutomationUIBuilderUpdateAutomationResponse);
function isSet22(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/bot/bot.js
var import_minimal25 = __toESM(require_minimal2(), 1);
function createBaseCommandDescription() {
  return { name: "", command: "", description: "", usage: "" };
}
var CommandDescription = {
  $type: "devvit.actor.bot.CommandDescription",
  encode(message, writer = import_minimal25.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.command !== "") {
      writer.uint32(18).string(message.command);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.usage !== "") {
      writer.uint32(34).string(message.usage);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal25.default.Reader ? input : new import_minimal25.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommandDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.command = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          message.usage = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet23(object.name) ? String(object.name) : "",
      command: isSet23(object.command) ? String(object.command) : "",
      description: isSet23(object.description) ? String(object.description) : "",
      usage: isSet23(object.usage) ? String(object.usage) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.command !== void 0 && (obj.command = message.command);
    message.description !== void 0 && (obj.description = message.description);
    message.usage !== void 0 && (obj.usage = message.usage);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommandDescription();
    message.name = object.name ?? "";
    message.command = object.command ?? "";
    message.description = object.description ?? "";
    message.usage = object.usage ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.bot.CommandDescription", CommandDescription);
function createBaseCommandsList() {
  return { commands: [] };
}
var CommandsList = {
  $type: "devvit.actor.bot.CommandsList",
  encode(message, writer = import_minimal25.default.Writer.create()) {
    for (const v of message.commands) {
      CommandDescription.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal25.default.Reader ? input : new import_minimal25.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommandsList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.commands.push(CommandDescription.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      commands: Array.isArray(object?.commands) ? object.commands.map((e) => CommandDescription.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.commands) {
      obj.commands = message.commands.map((e) => e ? CommandDescription.toJSON(e) : void 0);
    } else {
      obj.commands = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommandsList();
    message.commands = object.commands?.map((e) => CommandDescription.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.bot.CommandsList", CommandsList);
function createBaseCommandContext() {
  return { user: "", subreddit: "", post: "", comment: "" };
}
var CommandContext = {
  $type: "devvit.actor.bot.CommandContext",
  encode(message, writer = import_minimal25.default.Writer.create()) {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.subreddit !== "") {
      writer.uint32(18).string(message.subreddit);
    }
    if (message.post !== "") {
      writer.uint32(26).string(message.post);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal25.default.Reader ? input : new import_minimal25.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommandContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        case 2:
          message.subreddit = reader.string();
          break;
        case 3:
          message.post = reader.string();
          break;
        case 4:
          message.comment = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      user: isSet23(object.user) ? String(object.user) : "",
      subreddit: isSet23(object.subreddit) ? String(object.subreddit) : "",
      post: isSet23(object.post) ? String(object.post) : "",
      comment: isSet23(object.comment) ? String(object.comment) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.user !== void 0 && (obj.user = message.user);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.post !== void 0 && (obj.post = message.post);
    message.comment !== void 0 && (obj.comment = message.comment);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommandContext();
    message.user = object.user ?? "";
    message.subreddit = object.subreddit ?? "";
    message.post = object.post ?? "";
    message.comment = object.comment ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.bot.CommandContext", CommandContext);
function createBaseCommandRequest() {
  return { context: void 0, command: "", args: "" };
}
var CommandRequest = {
  $type: "devvit.actor.bot.CommandRequest",
  encode(message, writer = import_minimal25.default.Writer.create()) {
    if (message.context !== void 0) {
      CommandContext.encode(message.context, writer.uint32(10).fork()).ldelim();
    }
    if (message.command !== "") {
      writer.uint32(18).string(message.command);
    }
    if (message.args !== "") {
      writer.uint32(26).string(message.args);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal25.default.Reader ? input : new import_minimal25.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.context = CommandContext.decode(reader, reader.uint32());
          break;
        case 2:
          message.command = reader.string();
          break;
        case 3:
          message.args = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      context: isSet23(object.context) ? CommandContext.fromJSON(object.context) : void 0,
      command: isSet23(object.command) ? String(object.command) : "",
      args: isSet23(object.args) ? String(object.args) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.context !== void 0 && (obj.context = message.context ? CommandContext.toJSON(message.context) : void 0);
    message.command !== void 0 && (obj.command = message.command);
    message.args !== void 0 && (obj.args = message.args);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommandRequest();
    message.context = object.context !== void 0 && object.context !== null ? CommandContext.fromPartial(object.context) : void 0;
    message.command = object.command ?? "";
    message.args = object.args ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.bot.CommandRequest", CommandRequest);
function isSet23(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/gl/glclient.js
var import_minimal26 = __toESM(require_minimal2(), 1);
function createBaseConfigMessage() {
  return { width: 0, height: 0 };
}
var ConfigMessage = {
  $type: "devvit.actor.gl.ConfigMessage",
  encode(message, writer = import_minimal26.default.Writer.create()) {
    if (message.width !== 0) {
      writer.uint32(8).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal26.default.Reader ? input : new import_minimal26.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.width = reader.int32();
          break;
        case 2:
          message.height = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      width: isSet24(object.width) ? Number(object.width) : 0,
      height: isSet24(object.height) ? Number(object.height) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.width !== void 0 && (obj.width = Math.round(message.width));
    message.height !== void 0 && (obj.height = Math.round(message.height));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConfigMessage();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.gl.ConfigMessage", ConfigMessage);
function createBaseTickMessage() {
  return {};
}
var TickMessage = {
  $type: "devvit.actor.gl.TickMessage",
  encode(_, writer = import_minimal26.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal26.default.Reader ? input : new import_minimal26.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTickMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseTickMessage();
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.gl.TickMessage", TickMessage);
function createBaseInputMessage() {
  return {};
}
var InputMessage = {
  $type: "devvit.actor.gl.InputMessage",
  encode(_, writer = import_minimal26.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal26.default.Reader ? input : new import_minimal26.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInputMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseInputMessage();
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.gl.InputMessage", InputMessage);
function isSet24(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/hello/hello.js
var import_minimal27 = __toESM(require_minimal2(), 1);
function createBasePingMessage() {
  return { message: "", delayMillis: 0, successProbability: 0 };
}
var PingMessage = {
  $type: "devvit.actor.hello.PingMessage",
  encode(message, writer = import_minimal27.default.Writer.create()) {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.delayMillis !== 0) {
      writer.uint32(16).int32(message.delayMillis);
    }
    if (message.successProbability !== 0) {
      writer.uint32(29).float(message.successProbability);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal27.default.Reader ? input : new import_minimal27.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePingMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = reader.string();
          break;
        case 2:
          message.delayMillis = reader.int32();
          break;
        case 3:
          message.successProbability = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet25(object.message) ? String(object.message) : "",
      delayMillis: isSet25(object.delayMillis) ? Number(object.delayMillis) : 0,
      successProbability: isSet25(object.successProbability) ? Number(object.successProbability) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message);
    message.delayMillis !== void 0 && (obj.delayMillis = Math.round(message.delayMillis));
    message.successProbability !== void 0 && (obj.successProbability = message.successProbability);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePingMessage();
    message.message = object.message ?? "";
    message.delayMillis = object.delayMillis ?? 0;
    message.successProbability = object.successProbability ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.hello.PingMessage", PingMessage);
function isSet25(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/permissions/permissions.js
var import_minimal28 = __toESM(require_minimal2(), 1);
var Permission;
(function(Permission2) {
  Permission2[Permission2["SYSTEM"] = 0] = "SYSTEM";
  Permission2[Permission2["HTTP"] = 1] = "HTTP";
  Permission2[Permission2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Permission || (Permission = {}));
function permissionFromJSON(object) {
  switch (object) {
    case 0:
    case "SYSTEM":
      return Permission.SYSTEM;
    case 1:
    case "HTTP":
      return Permission.HTTP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Permission.UNRECOGNIZED;
  }
}
function permissionToJSON(object) {
  switch (object) {
    case Permission.SYSTEM:
      return 0;
    case Permission.HTTP:
      return 1;
    case Permission.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseNestedRule() {
  return { requires: [] };
}
var NestedRule = {
  $type: "devvit.actor.permissions.NestedRule",
  encode(message, writer = import_minimal28.default.Writer.create()) {
    for (const v of message.requires) {
      PermissionOrRule.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal28.default.Reader ? input : new import_minimal28.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNestedRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.requires.push(PermissionOrRule.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      requires: Array.isArray(object?.requires) ? object.requires.map((e) => PermissionOrRule.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.requires) {
      obj.requires = message.requires.map((e) => e ? PermissionOrRule.toJSON(e) : void 0);
    } else {
      obj.requires = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseNestedRule();
    message.requires = object.requires?.map((e) => PermissionOrRule.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.permissions.NestedRule", NestedRule);
function createBasePermissionOrRule() {
  return { permission: void 0, and: void 0, or: void 0 };
}
var PermissionOrRule = {
  $type: "devvit.actor.permissions.PermissionOrRule",
  encode(message, writer = import_minimal28.default.Writer.create()) {
    if (message.permission !== void 0) {
      writer.uint32(8).int32(message.permission);
    }
    if (message.and !== void 0) {
      NestedRule.encode(message.and, writer.uint32(18).fork()).ldelim();
    }
    if (message.or !== void 0) {
      NestedRule.encode(message.or, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal28.default.Reader ? input : new import_minimal28.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePermissionOrRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.permission = reader.int32();
          break;
        case 2:
          message.and = NestedRule.decode(reader, reader.uint32());
          break;
        case 3:
          message.or = NestedRule.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      permission: isSet26(object.permission) ? permissionFromJSON(object.permission) : void 0,
      and: isSet26(object.and) ? NestedRule.fromJSON(object.and) : void 0,
      or: isSet26(object.or) ? NestedRule.fromJSON(object.or) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.permission !== void 0 && (obj.permission = message.permission !== void 0 ? permissionToJSON(message.permission) : void 0);
    message.and !== void 0 && (obj.and = message.and ? NestedRule.toJSON(message.and) : void 0);
    message.or !== void 0 && (obj.or = message.or ? NestedRule.toJSON(message.or) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePermissionOrRule();
    message.permission = object.permission ?? void 0;
    message.and = object.and !== void 0 && object.and !== null ? NestedRule.fromPartial(object.and) : void 0;
    message.or = object.or !== void 0 && object.or !== null ? NestedRule.fromPartial(object.or) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.permissions.PermissionOrRule", PermissionOrRule);
function createBasePermissionConfig() {
  return { actor: "", has: [], requires: [] };
}
var PermissionConfig = {
  $type: "devvit.actor.permissions.PermissionConfig",
  encode(message, writer = import_minimal28.default.Writer.create()) {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    writer.uint32(18).fork();
    for (const v of message.has) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.requires) {
      PermissionOrRule.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal28.default.Reader ? input : new import_minimal28.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePermissionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actor = reader.string();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.has.push(reader.int32());
            }
          } else {
            message.has.push(reader.int32());
          }
          break;
        case 3:
          message.requires.push(PermissionOrRule.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet26(object.actor) ? String(object.actor) : "",
      has: Array.isArray(object?.has) ? object.has.map((e) => permissionFromJSON(e)) : [],
      requires: Array.isArray(object?.requires) ? object.requires.map((e) => PermissionOrRule.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.actor !== void 0 && (obj.actor = message.actor);
    if (message.has) {
      obj.has = message.has.map((e) => permissionToJSON(e));
    } else {
      obj.has = [];
    }
    if (message.requires) {
      obj.requires = message.requires.map((e) => e ? PermissionOrRule.toJSON(e) : void 0);
    } else {
      obj.requires = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBasePermissionConfig();
    message.actor = object.actor ?? "";
    message.has = object.has?.map((e) => e) || [];
    message.requires = object.requires?.map((e) => PermissionOrRule.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.permissions.PermissionConfig", PermissionConfig);
function createBasePermissionList() {
  return { permissions: [] };
}
var PermissionList = {
  $type: "devvit.actor.permissions.PermissionList",
  encode(message, writer = import_minimal28.default.Writer.create()) {
    for (const v of message.permissions) {
      PermissionConfig.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal28.default.Reader ? input : new import_minimal28.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePermissionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.permissions.push(PermissionConfig.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      permissions: Array.isArray(object?.permissions) ? object.permissions.map((e) => PermissionConfig.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.permissions) {
      obj.permissions = message.permissions.map((e) => e ? PermissionConfig.toJSON(e) : void 0);
    } else {
      obj.permissions = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBasePermissionList();
    message.permissions = object.permissions?.map((e) => PermissionConfig.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.permissions.PermissionList", PermissionList);
function isSet26(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/producer/producer.js
var import_long3 = __toESM(require_long(), 1);
var import_minimal29 = __toESM(require_minimal2(), 1);

// ../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// ../../node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// ../../node_modules/rxjs/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// ../../node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// ../../node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// ../../node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// ../../node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription3(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription3.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription3.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription3) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription3.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription3.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription3.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription3.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription3) {
      teardown._removeParent(this);
    }
  };
  Subscription3.EMPTY = function() {
    var empty = new Subscription3();
    empty.closed = true;
    return empty;
  }();
  return Subscription3;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// ../../node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// ../../node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// ../../node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// ../../node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// ../../node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// ../../node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// ../../node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// ../../node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// ../../node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable3(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable3.prototype.lift = function(operator) {
    var observable2 = new Observable3();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable3.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable3.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable3.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable3.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable3.prototype[observable] = function() {
    return this;
  };
  Observable3.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable3.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable3.create = function(subscribe) {
    return new Observable3(subscribe);
  };
  return Observable3;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// ../../node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// ../../node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// ../../node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// ../../node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// ../../node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// ../../node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last = i;
      }
      last && _buffer.splice(0, last + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// ../protos/dist/types/devvit/actor/producer/producer.js
function createBaseArg() {
  return { str: void 0, i32: void 0, i64: void 0 };
}
var Arg = {
  $type: "devvit.actor.producer.Arg",
  encode(message, writer = import_minimal29.default.Writer.create()) {
    if (message.str !== void 0) {
      writer.uint32(10).string(message.str);
    }
    if (message.i32 !== void 0) {
      writer.uint32(16).int32(message.i32);
    }
    if (message.i64 !== void 0) {
      writer.uint32(24).int64(message.i64);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal29.default.Reader ? input : new import_minimal29.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseArg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.str = reader.string();
          break;
        case 2:
          message.i32 = reader.int32();
          break;
        case 3:
          message.i64 = longToNumber3(reader.int64());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      str: isSet27(object.str) ? String(object.str) : void 0,
      i32: isSet27(object.i32) ? Number(object.i32) : void 0,
      i64: isSet27(object.i64) ? Number(object.i64) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.str !== void 0 && (obj.str = message.str);
    message.i32 !== void 0 && (obj.i32 = Math.round(message.i32));
    message.i64 !== void 0 && (obj.i64 = Math.round(message.i64));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseArg();
    message.str = object.str ?? void 0;
    message.i32 = object.i32 ?? void 0;
    message.i64 = object.i64 ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.producer.Arg", Arg);
function createBaseArgs() {
  return { elements: [] };
}
var Args = {
  $type: "devvit.actor.producer.Args",
  encode(message, writer = import_minimal29.default.Writer.create()) {
    for (const v of message.elements) {
      Arg.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal29.default.Reader ? input : new import_minimal29.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseArgs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.elements.push(Arg.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { elements: Array.isArray(object?.elements) ? object.elements.map((e) => Arg.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.elements) {
      obj.elements = message.elements.map((e) => e ? Arg.toJSON(e) : void 0);
    } else {
      obj.elements = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseArgs();
    message.elements = object.elements?.map((e) => Arg.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.producer.Args", Args);
var globalThis4 = (() => {
  if (typeof globalThis4 !== "undefined") {
    return globalThis4;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function longToNumber3(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis4.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal29.default.util.Long !== import_long3.default) {
  import_minimal29.default.util.Long = import_long3.default;
  import_minimal29.default.configure();
}
function isSet27(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/reddit/context_action.js
var import_minimal41 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/redditapi/common/common_msg.js
var import_minimal31 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/google/protobuf/any.js
var import_minimal30 = __toESM(require_minimal2(), 1);
function createBaseAny() {
  return { typeUrl: "", value: new Uint8Array() };
}
var Any = {
  $type: "google.protobuf.Any",
  encode(message, writer = import_minimal30.default.Writer.create()) {
    if (message.typeUrl !== "") {
      writer.uint32(10).string(message.typeUrl);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal30.default.Reader ? input : new import_minimal30.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAny();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.typeUrl = reader.string();
          break;
        case 2:
          message.value = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      typeUrl: isSet28(object.typeUrl) ? String(object.typeUrl) : "",
      value: isSet28(object.value) ? bytesFromBase642(object.value) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.typeUrl !== void 0 && (obj.typeUrl = message.typeUrl);
    message.value !== void 0 && (obj.value = base64FromBytes2(message.value !== void 0 ? message.value : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAny();
    message.typeUrl = object.typeUrl ?? "";
    message.value = object.value ?? new Uint8Array();
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.Any", Any);
var globalThis5 = (() => {
  if (typeof globalThis5 !== "undefined") {
    return globalThis5;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase642(b64) {
  if (globalThis5.Buffer) {
    return Uint8Array.from(globalThis5.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis5.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes2(arr) {
  if (globalThis5.Buffer) {
    return globalThis5.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return globalThis5.btoa(bin.join(""));
  }
}
function isSet28(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/common/common_msg.js
function createBaseListing() {
  return { kind: "", data: void 0 };
}
var Listing = {
  $type: "devvit.plugin.redditapi.common.Listing",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      Listing_ListingData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : new import_minimal31.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.data = Listing_ListingData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet29(object.kind) ? String(object.kind) : "",
      data: isSet29(object.data) ? Listing_ListingData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? Listing_ListingData.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseListing();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? Listing_ListingData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.Listing", Listing);
function createBaseListing_ListingData() {
  return { after: void 0, before: void 0, children: [], dist: void 0 };
}
var Listing_ListingData = {
  $type: "devvit.plugin.redditapi.common.Listing.ListingData",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.children) {
      WrappedRedditObject.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int64Value.encode({ value: message.dist }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : new import_minimal31.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListing_ListingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.children.push(WrappedRedditObject.decode(reader, reader.uint32()));
          break;
        case 4:
          message.dist = Int64Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet29(object.after) ? String(object.after) : void 0,
      before: isSet29(object.before) ? String(object.before) : void 0,
      children: Array.isArray(object?.children) ? object.children.map((e) => WrappedRedditObject.fromJSON(e)) : [],
      dist: isSet29(object.dist) ? Number(object.dist) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    if (message.children) {
      obj.children = message.children.map((e) => e ? WrappedRedditObject.toJSON(e) : void 0);
    } else {
      obj.children = [];
    }
    message.dist !== void 0 && (obj.dist = message.dist);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseListing_ListingData();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.children = object.children?.map((e) => WrappedRedditObject.fromPartial(e)) || [];
    message.dist = object.dist ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.Listing.ListingData", Listing_ListingData);
function createBaseWrappedRedditObject() {
  return { kind: "", data: void 0 };
}
var WrappedRedditObject = {
  $type: "devvit.plugin.redditapi.common.WrappedRedditObject",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      RedditObject.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : new import_minimal31.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWrappedRedditObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.data = RedditObject.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet29(object.kind) ? String(object.kind) : "",
      data: isSet29(object.data) ? RedditObject.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? RedditObject.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWrappedRedditObject();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? RedditObject.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.WrappedRedditObject", WrappedRedditObject);
function createBaseJsonRedditObjects() {
  return { json: void 0 };
}
var JsonRedditObjects = {
  $type: "devvit.plugin.redditapi.common.JsonRedditObjects",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    if (message.json !== void 0) {
      JsonRedditObjects_JsonType.encode(message.json, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : new import_minimal31.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonRedditObjects();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          message.json = JsonRedditObjects_JsonType.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { json: isSet29(object.json) ? JsonRedditObjects_JsonType.fromJSON(object.json) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.json !== void 0 && (obj.json = message.json ? JsonRedditObjects_JsonType.toJSON(message.json) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseJsonRedditObjects();
    message.json = object.json !== void 0 && object.json !== null ? JsonRedditObjects_JsonType.fromPartial(object.json) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.JsonRedditObjects", JsonRedditObjects);
function createBaseJsonRedditObjects_JsonType() {
  return { errors: [], data: void 0 };
}
var JsonRedditObjects_JsonType = {
  $type: "devvit.plugin.redditapi.common.JsonRedditObjects.JsonType",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    for (const v of message.errors) {
      Any.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      JsonRedditObjects_JsonType_JsonData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : new import_minimal31.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonRedditObjects_JsonType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.errors.push(Any.decode(reader, reader.uint32()));
          break;
        case 2:
          message.data = JsonRedditObjects_JsonType_JsonData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      errors: Array.isArray(object?.errors) ? object.errors.map((e) => Any.fromJSON(e)) : [],
      data: isSet29(object.data) ? JsonRedditObjects_JsonType_JsonData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.errors) {
      obj.errors = message.errors.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.errors = [];
    }
    message.data !== void 0 && (obj.data = message.data ? JsonRedditObjects_JsonType_JsonData.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseJsonRedditObjects_JsonType();
    message.errors = object.errors?.map((e) => Any.fromPartial(e)) || [];
    message.data = object.data !== void 0 && object.data !== null ? JsonRedditObjects_JsonType_JsonData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.JsonRedditObjects.JsonType", JsonRedditObjects_JsonType);
function createBaseJsonRedditObjects_JsonType_JsonData() {
  return { things: [] };
}
var JsonRedditObjects_JsonType_JsonData = {
  $type: "devvit.plugin.redditapi.common.JsonRedditObjects.JsonType.JsonData",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    for (const v of message.things) {
      WrappedRedditObject.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : new import_minimal31.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonRedditObjects_JsonType_JsonData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.things.push(WrappedRedditObject.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      things: Array.isArray(object?.things) ? object.things.map((e) => WrappedRedditObject.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.things) {
      obj.things = message.things.map((e) => e ? WrappedRedditObject.toJSON(e) : void 0);
    } else {
      obj.things = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseJsonRedditObjects_JsonType_JsonData();
    message.things = object.things?.map((e) => WrappedRedditObject.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.JsonRedditObjects.JsonType.JsonData", JsonRedditObjects_JsonType_JsonData);
function createBaseRedditObject() {
  return {
    allAwardings: [],
    approved: void 0,
    approvedAtUtc: void 0,
    approvedBy: void 0,
    archived: void 0,
    associatedAward: void 0,
    author: void 0,
    authorFlairBackgroundColor: void 0,
    authorFlairCssClass: void 0,
    authorFlairRichtext: [],
    authorFlairTemplateId: void 0,
    authorFlairText: void 0,
    authorFlairTextColor: void 0,
    authorFlairType: void 0,
    authorFullname: void 0,
    authorIsBlocked: void 0,
    authorPatreonFlair: void 0,
    authorPremium: void 0,
    awarders: [],
    bannedAtUtc: void 0,
    bannedBy: void 0,
    body: void 0,
    bodyHtml: void 0,
    canGild: void 0,
    canModPost: void 0,
    collapsed: void 0,
    collapsedBecauseCrowdControl: void 0,
    collapsedReason: void 0,
    collapsedReasonCode: void 0,
    commentType: void 0,
    controversiality: void 0,
    created: void 0,
    createdUtc: void 0,
    distinguished: void 0,
    downs: void 0,
    edited: void 0,
    gilded: void 0,
    gildings: void 0,
    id: void 0,
    ignoreReports: void 0,
    isSubmitter: void 0,
    likes: void 0,
    linkId: void 0,
    locked: void 0,
    modNote: void 0,
    modReasonBy: void 0,
    modReasonTitle: void 0,
    modReports: [],
    name: void 0,
    noFollow: void 0,
    numReports: void 0,
    parentId: void 0,
    permalink: void 0,
    removalReason: void 0,
    removed: void 0,
    replies: void 0,
    reportReasons: void 0,
    rteMode: void 0,
    saved: void 0,
    score: void 0,
    scoreHidden: void 0,
    sendReplies: void 0,
    spam: void 0,
    stickied: void 0,
    subreddit: void 0,
    subredditId: void 0,
    subredditNamePrefixed: void 0,
    subredditType: void 0,
    topAwardedType: void 0,
    totalAwardsReceived: void 0,
    treatmentTags: [],
    unrepliableReason: void 0,
    ups: void 0,
    userReports: [],
    depth: void 0,
    linkTitle: void 0,
    linkAuthor: void 0,
    numComments: void 0,
    over18: void 0,
    linkPermalink: void 0,
    quarantine: void 0,
    linkUrl: void 0,
    selftext: void 0,
    selftextHtml: void 0,
    spoiler: void 0,
    thumbnail: void 0,
    thumbnailWidth: void 0,
    thumbnailHeight: void 0,
    title: void 0,
    url: void 0,
    displayName: void 0,
    modPermissions: [],
    count: void 0,
    children: void 0,
    replyList: void 0,
    hidden: void 0
  };
}
var RedditObject = {
  $type: "devvit.plugin.redditapi.common.RedditObject",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    for (const v of message.allAwardings) {
      Any.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.approved !== void 0) {
      BoolValue.encode({ value: message.approved }, writer.uint32(18).fork()).ldelim();
    }
    if (message.approvedAtUtc !== void 0) {
      Int64Value.encode({ value: message.approvedAtUtc }, writer.uint32(26).fork()).ldelim();
    }
    if (message.approvedBy !== void 0) {
      StringValue.encode({ value: message.approvedBy }, writer.uint32(34).fork()).ldelim();
    }
    if (message.archived !== void 0) {
      BoolValue.encode({ value: message.archived }, writer.uint32(42).fork()).ldelim();
    }
    if (message.associatedAward !== void 0) {
      StringValue.encode({ value: message.associatedAward }, writer.uint32(50).fork()).ldelim();
    }
    if (message.author !== void 0) {
      StringValue.encode({ value: message.author }, writer.uint32(58).fork()).ldelim();
    }
    if (message.authorFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.authorFlairBackgroundColor }, writer.uint32(66).fork()).ldelim();
    }
    if (message.authorFlairCssClass !== void 0) {
      StringValue.encode({ value: message.authorFlairCssClass }, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.authorFlairRichtext) {
      RedditObject_AuthorFlairRichText.encode(v, writer.uint32(82).fork()).ldelim();
    }
    if (message.authorFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.authorFlairTemplateId }, writer.uint32(90).fork()).ldelim();
    }
    if (message.authorFlairText !== void 0) {
      StringValue.encode({ value: message.authorFlairText }, writer.uint32(98).fork()).ldelim();
    }
    if (message.authorFlairTextColor !== void 0) {
      StringValue.encode({ value: message.authorFlairTextColor }, writer.uint32(106).fork()).ldelim();
    }
    if (message.authorFlairType !== void 0) {
      StringValue.encode({ value: message.authorFlairType }, writer.uint32(114).fork()).ldelim();
    }
    if (message.authorFullname !== void 0) {
      StringValue.encode({ value: message.authorFullname }, writer.uint32(122).fork()).ldelim();
    }
    if (message.authorIsBlocked !== void 0) {
      BoolValue.encode({ value: message.authorIsBlocked }, writer.uint32(130).fork()).ldelim();
    }
    if (message.authorPatreonFlair !== void 0) {
      BoolValue.encode({ value: message.authorPatreonFlair }, writer.uint32(138).fork()).ldelim();
    }
    if (message.authorPremium !== void 0) {
      BoolValue.encode({ value: message.authorPremium }, writer.uint32(146).fork()).ldelim();
    }
    for (const v of message.awarders) {
      StringValue.encode({ value: v }, writer.uint32(154).fork()).ldelim();
    }
    if (message.bannedAtUtc !== void 0) {
      Int64Value.encode({ value: message.bannedAtUtc }, writer.uint32(162).fork()).ldelim();
    }
    if (message.bannedBy !== void 0) {
      StringValue.encode({ value: message.bannedBy }, writer.uint32(170).fork()).ldelim();
    }
    if (message.body !== void 0) {
      StringValue.encode({ value: message.body }, writer.uint32(178).fork()).ldelim();
    }
    if (message.bodyHtml !== void 0) {
      StringValue.encode({ value: message.bodyHtml }, writer.uint32(186).fork()).ldelim();
    }
    if (message.canGild !== void 0) {
      BoolValue.encode({ value: message.canGild }, writer.uint32(194).fork()).ldelim();
    }
    if (message.canModPost !== void 0) {
      BoolValue.encode({ value: message.canModPost }, writer.uint32(202).fork()).ldelim();
    }
    if (message.collapsed !== void 0) {
      BoolValue.encode({ value: message.collapsed }, writer.uint32(210).fork()).ldelim();
    }
    if (message.collapsedBecauseCrowdControl !== void 0) {
      BoolValue.encode({ value: message.collapsedBecauseCrowdControl }, writer.uint32(218).fork()).ldelim();
    }
    if (message.collapsedReason !== void 0) {
      StringValue.encode({ value: message.collapsedReason }, writer.uint32(226).fork()).ldelim();
    }
    if (message.collapsedReasonCode !== void 0) {
      StringValue.encode({ value: message.collapsedReasonCode }, writer.uint32(234).fork()).ldelim();
    }
    if (message.commentType !== void 0) {
      StringValue.encode({ value: message.commentType }, writer.uint32(242).fork()).ldelim();
    }
    if (message.controversiality !== void 0) {
      Int64Value.encode({ value: message.controversiality }, writer.uint32(250).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int64Value.encode({ value: message.created }, writer.uint32(258).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(266).fork()).ldelim();
    }
    if (message.distinguished !== void 0) {
      StringValue.encode({ value: message.distinguished }, writer.uint32(274).fork()).ldelim();
    }
    if (message.downs !== void 0) {
      Int64Value.encode({ value: message.downs }, writer.uint32(282).fork()).ldelim();
    }
    if (message.edited !== void 0) {
      BoolValue.encode({ value: message.edited }, writer.uint32(290).fork()).ldelim();
    }
    if (message.gilded !== void 0) {
      Int64Value.encode({ value: message.gilded }, writer.uint32(298).fork()).ldelim();
    }
    if (message.gildings !== void 0) {
      Any.encode(message.gildings, writer.uint32(306).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(314).fork()).ldelim();
    }
    if (message.ignoreReports !== void 0) {
      BoolValue.encode({ value: message.ignoreReports }, writer.uint32(322).fork()).ldelim();
    }
    if (message.isSubmitter !== void 0) {
      BoolValue.encode({ value: message.isSubmitter }, writer.uint32(330).fork()).ldelim();
    }
    if (message.likes !== void 0) {
      BoolValue.encode({ value: message.likes }, writer.uint32(338).fork()).ldelim();
    }
    if (message.linkId !== void 0) {
      StringValue.encode({ value: message.linkId }, writer.uint32(346).fork()).ldelim();
    }
    if (message.locked !== void 0) {
      BoolValue.encode({ value: message.locked }, writer.uint32(354).fork()).ldelim();
    }
    if (message.modNote !== void 0) {
      StringValue.encode({ value: message.modNote }, writer.uint32(362).fork()).ldelim();
    }
    if (message.modReasonBy !== void 0) {
      StringValue.encode({ value: message.modReasonBy }, writer.uint32(370).fork()).ldelim();
    }
    if (message.modReasonTitle !== void 0) {
      StringValue.encode({ value: message.modReasonTitle }, writer.uint32(378).fork()).ldelim();
    }
    for (const v of message.modReports) {
      Any.encode(v, writer.uint32(386).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(394).fork()).ldelim();
    }
    if (message.noFollow !== void 0) {
      BoolValue.encode({ value: message.noFollow }, writer.uint32(402).fork()).ldelim();
    }
    if (message.numReports !== void 0) {
      Int64Value.encode({ value: message.numReports }, writer.uint32(418).fork()).ldelim();
    }
    if (message.parentId !== void 0) {
      StringValue.encode({ value: message.parentId }, writer.uint32(426).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(434).fork()).ldelim();
    }
    if (message.removalReason !== void 0) {
      StringValue.encode({ value: message.removalReason }, writer.uint32(442).fork()).ldelim();
    }
    if (message.removed !== void 0) {
      BoolValue.encode({ value: message.removed }, writer.uint32(450).fork()).ldelim();
    }
    if (message.replies !== void 0) {
      StringValue.encode({ value: message.replies }, writer.uint32(458).fork()).ldelim();
    }
    if (message.reportReasons !== void 0) {
      ListValue.encode(ListValue.wrap(message.reportReasons), writer.uint32(466).fork()).ldelim();
    }
    if (message.rteMode !== void 0) {
      StringValue.encode({ value: message.rteMode }, writer.uint32(474).fork()).ldelim();
    }
    if (message.saved !== void 0) {
      BoolValue.encode({ value: message.saved }, writer.uint32(482).fork()).ldelim();
    }
    if (message.score !== void 0) {
      Int64Value.encode({ value: message.score }, writer.uint32(490).fork()).ldelim();
    }
    if (message.scoreHidden !== void 0) {
      BoolValue.encode({ value: message.scoreHidden }, writer.uint32(498).fork()).ldelim();
    }
    if (message.sendReplies !== void 0) {
      BoolValue.encode({ value: message.sendReplies }, writer.uint32(506).fork()).ldelim();
    }
    if (message.spam !== void 0) {
      BoolValue.encode({ value: message.spam }, writer.uint32(514).fork()).ldelim();
    }
    if (message.stickied !== void 0) {
      BoolValue.encode({ value: message.stickied }, writer.uint32(522).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(530).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(538).fork()).ldelim();
    }
    if (message.subredditNamePrefixed !== void 0) {
      StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(546).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(554).fork()).ldelim();
    }
    if (message.topAwardedType !== void 0) {
      StringValue.encode({ value: message.topAwardedType }, writer.uint32(562).fork()).ldelim();
    }
    if (message.totalAwardsReceived !== void 0) {
      Int64Value.encode({ value: message.totalAwardsReceived }, writer.uint32(570).fork()).ldelim();
    }
    for (const v of message.treatmentTags) {
      Any.encode(v, writer.uint32(578).fork()).ldelim();
    }
    if (message.unrepliableReason !== void 0) {
      StringValue.encode({ value: message.unrepliableReason }, writer.uint32(586).fork()).ldelim();
    }
    if (message.ups !== void 0) {
      Int64Value.encode({ value: message.ups }, writer.uint32(594).fork()).ldelim();
    }
    for (const v of message.userReports) {
      Any.encode(v, writer.uint32(602).fork()).ldelim();
    }
    if (message.depth !== void 0) {
      Int64Value.encode({ value: message.depth }, writer.uint32(610).fork()).ldelim();
    }
    if (message.linkTitle !== void 0) {
      StringValue.encode({ value: message.linkTitle }, writer.uint32(618).fork()).ldelim();
    }
    if (message.linkAuthor !== void 0) {
      StringValue.encode({ value: message.linkAuthor }, writer.uint32(626).fork()).ldelim();
    }
    if (message.numComments !== void 0) {
      Int64Value.encode({ value: message.numComments }, writer.uint32(634).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(642).fork()).ldelim();
    }
    if (message.linkPermalink !== void 0) {
      StringValue.encode({ value: message.linkPermalink }, writer.uint32(650).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(658).fork()).ldelim();
    }
    if (message.linkUrl !== void 0) {
      StringValue.encode({ value: message.linkUrl }, writer.uint32(666).fork()).ldelim();
    }
    if (message.selftext !== void 0) {
      StringValue.encode({ value: message.selftext }, writer.uint32(674).fork()).ldelim();
    }
    if (message.selftextHtml !== void 0) {
      StringValue.encode({ value: message.selftextHtml }, writer.uint32(682).fork()).ldelim();
    }
    if (message.spoiler !== void 0) {
      StringValue.encode({ value: message.spoiler }, writer.uint32(690).fork()).ldelim();
    }
    if (message.thumbnail !== void 0) {
      StringValue.encode({ value: message.thumbnail }, writer.uint32(698).fork()).ldelim();
    }
    if (message.thumbnailWidth !== void 0) {
      Int64Value.encode({ value: message.thumbnailWidth }, writer.uint32(706).fork()).ldelim();
    }
    if (message.thumbnailHeight !== void 0) {
      Int64Value.encode({ value: message.thumbnailHeight }, writer.uint32(714).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(722).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(730).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(738).fork()).ldelim();
    }
    for (const v of message.modPermissions) {
      StringValue.encode({ value: v }, writer.uint32(746).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(754).fork()).ldelim();
    }
    if (message.children !== void 0) {
      ListValue.encode(ListValue.wrap(message.children), writer.uint32(762).fork()).ldelim();
    }
    if (message.replyList !== void 0) {
      Listing.encode(message.replyList, writer.uint32(770).fork()).ldelim();
    }
    if (message.hidden !== void 0) {
      BoolValue.encode({ value: message.hidden }, writer.uint32(778).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : new import_minimal31.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.allAwardings.push(Any.decode(reader, reader.uint32()));
          break;
        case 2:
          message.approved = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.approvedAtUtc = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.approvedBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.archived = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.associatedAward = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.author = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.authorFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.authorFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.authorFlairRichtext.push(RedditObject_AuthorFlairRichText.decode(reader, reader.uint32()));
          break;
        case 11:
          message.authorFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.authorFlairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.authorFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.authorFlairType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.authorFullname = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.authorIsBlocked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.authorPatreonFlair = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.authorPremium = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.awarders.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 20:
          message.bannedAtUtc = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.bannedBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.body = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.bodyHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.canGild = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.canModPost = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.collapsed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 27:
          message.collapsedBecauseCrowdControl = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.collapsedReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.collapsedReasonCode = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.commentType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.controversiality = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.created = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.distinguished = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 35:
          message.downs = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.edited = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 37:
          message.gilded = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 38:
          message.gildings = Any.decode(reader, reader.uint32());
          break;
        case 39:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 40:
          message.ignoreReports = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 41:
          message.isSubmitter = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 42:
          message.likes = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 43:
          message.linkId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 44:
          message.locked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 45:
          message.modNote = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 46:
          message.modReasonBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 47:
          message.modReasonTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 48:
          message.modReports.push(Any.decode(reader, reader.uint32()));
          break;
        case 49:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 50:
          message.noFollow = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 52:
          message.numReports = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 53:
          message.parentId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 54:
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 55:
          message.removalReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 56:
          message.removed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 57:
          message.replies = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 58:
          message.reportReasons = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          break;
        case 59:
          message.rteMode = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 60:
          message.saved = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 61:
          message.score = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 62:
          message.scoreHidden = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 63:
          message.sendReplies = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 64:
          message.spam = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 65:
          message.stickied = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 66:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 67:
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 68:
          message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 69:
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 70:
          message.topAwardedType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 71:
          message.totalAwardsReceived = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 72:
          message.treatmentTags.push(Any.decode(reader, reader.uint32()));
          break;
        case 73:
          message.unrepliableReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 74:
          message.ups = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 75:
          message.userReports.push(Any.decode(reader, reader.uint32()));
          break;
        case 76:
          message.depth = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 77:
          message.linkTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 78:
          message.linkAuthor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 79:
          message.numComments = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 80:
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 81:
          message.linkPermalink = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 82:
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 83:
          message.linkUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 84:
          message.selftext = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 85:
          message.selftextHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 86:
          message.spoiler = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 87:
          message.thumbnail = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 88:
          message.thumbnailWidth = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 89:
          message.thumbnailHeight = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 90:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 91:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 92:
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 93:
          message.modPermissions.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 94:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 95:
          message.children = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          break;
        case 96:
          message.replyList = Listing.decode(reader, reader.uint32());
          break;
        case 97:
          message.hidden = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      allAwardings: Array.isArray(object?.allAwardings) ? object.allAwardings.map((e) => Any.fromJSON(e)) : [],
      approved: isSet29(object.approved) ? Boolean(object.approved) : void 0,
      approvedAtUtc: isSet29(object.approvedAtUtc) ? Number(object.approvedAtUtc) : void 0,
      approvedBy: isSet29(object.approvedBy) ? String(object.approvedBy) : void 0,
      archived: isSet29(object.archived) ? Boolean(object.archived) : void 0,
      associatedAward: isSet29(object.associatedAward) ? String(object.associatedAward) : void 0,
      author: isSet29(object.author) ? String(object.author) : void 0,
      authorFlairBackgroundColor: isSet29(object.authorFlairBackgroundColor) ? String(object.authorFlairBackgroundColor) : void 0,
      authorFlairCssClass: isSet29(object.authorFlairCssClass) ? String(object.authorFlairCssClass) : void 0,
      authorFlairRichtext: Array.isArray(object?.authorFlairRichtext) ? object.authorFlairRichtext.map((e) => RedditObject_AuthorFlairRichText.fromJSON(e)) : [],
      authorFlairTemplateId: isSet29(object.authorFlairTemplateId) ? String(object.authorFlairTemplateId) : void 0,
      authorFlairText: isSet29(object.authorFlairText) ? String(object.authorFlairText) : void 0,
      authorFlairTextColor: isSet29(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : void 0,
      authorFlairType: isSet29(object.authorFlairType) ? String(object.authorFlairType) : void 0,
      authorFullname: isSet29(object.authorFullname) ? String(object.authorFullname) : void 0,
      authorIsBlocked: isSet29(object.authorIsBlocked) ? Boolean(object.authorIsBlocked) : void 0,
      authorPatreonFlair: isSet29(object.authorPatreonFlair) ? Boolean(object.authorPatreonFlair) : void 0,
      authorPremium: isSet29(object.authorPremium) ? Boolean(object.authorPremium) : void 0,
      awarders: Array.isArray(object?.awarders) ? object.awarders.map((e) => String(e)) : [],
      bannedAtUtc: isSet29(object.bannedAtUtc) ? Number(object.bannedAtUtc) : void 0,
      bannedBy: isSet29(object.bannedBy) ? String(object.bannedBy) : void 0,
      body: isSet29(object.body) ? String(object.body) : void 0,
      bodyHtml: isSet29(object.bodyHtml) ? String(object.bodyHtml) : void 0,
      canGild: isSet29(object.canGild) ? Boolean(object.canGild) : void 0,
      canModPost: isSet29(object.canModPost) ? Boolean(object.canModPost) : void 0,
      collapsed: isSet29(object.collapsed) ? Boolean(object.collapsed) : void 0,
      collapsedBecauseCrowdControl: isSet29(object.collapsedBecauseCrowdControl) ? Boolean(object.collapsedBecauseCrowdControl) : void 0,
      collapsedReason: isSet29(object.collapsedReason) ? String(object.collapsedReason) : void 0,
      collapsedReasonCode: isSet29(object.collapsedReasonCode) ? String(object.collapsedReasonCode) : void 0,
      commentType: isSet29(object.commentType) ? String(object.commentType) : void 0,
      controversiality: isSet29(object.controversiality) ? Number(object.controversiality) : void 0,
      created: isSet29(object.created) ? Number(object.created) : void 0,
      createdUtc: isSet29(object.createdUtc) ? Number(object.createdUtc) : void 0,
      distinguished: isSet29(object.distinguished) ? String(object.distinguished) : void 0,
      downs: isSet29(object.downs) ? Number(object.downs) : void 0,
      edited: isSet29(object.edited) ? Boolean(object.edited) : void 0,
      gilded: isSet29(object.gilded) ? Number(object.gilded) : void 0,
      gildings: isSet29(object.gildings) ? Any.fromJSON(object.gildings) : void 0,
      id: isSet29(object.id) ? String(object.id) : void 0,
      ignoreReports: isSet29(object.ignoreReports) ? Boolean(object.ignoreReports) : void 0,
      isSubmitter: isSet29(object.isSubmitter) ? Boolean(object.isSubmitter) : void 0,
      likes: isSet29(object.likes) ? Boolean(object.likes) : void 0,
      linkId: isSet29(object.linkId) ? String(object.linkId) : void 0,
      locked: isSet29(object.locked) ? Boolean(object.locked) : void 0,
      modNote: isSet29(object.modNote) ? String(object.modNote) : void 0,
      modReasonBy: isSet29(object.modReasonBy) ? String(object.modReasonBy) : void 0,
      modReasonTitle: isSet29(object.modReasonTitle) ? String(object.modReasonTitle) : void 0,
      modReports: Array.isArray(object?.modReports) ? object.modReports.map((e) => Any.fromJSON(e)) : [],
      name: isSet29(object.name) ? String(object.name) : void 0,
      noFollow: isSet29(object.noFollow) ? Boolean(object.noFollow) : void 0,
      numReports: isSet29(object.numReports) ? Number(object.numReports) : void 0,
      parentId: isSet29(object.parentId) ? String(object.parentId) : void 0,
      permalink: isSet29(object.permalink) ? String(object.permalink) : void 0,
      removalReason: isSet29(object.removalReason) ? String(object.removalReason) : void 0,
      removed: isSet29(object.removed) ? Boolean(object.removed) : void 0,
      replies: isSet29(object.replies) ? String(object.replies) : void 0,
      reportReasons: Array.isArray(object.reportReasons) ? [...object.reportReasons] : void 0,
      rteMode: isSet29(object.rteMode) ? String(object.rteMode) : void 0,
      saved: isSet29(object.saved) ? Boolean(object.saved) : void 0,
      score: isSet29(object.score) ? Number(object.score) : void 0,
      scoreHidden: isSet29(object.scoreHidden) ? Boolean(object.scoreHidden) : void 0,
      sendReplies: isSet29(object.sendReplies) ? Boolean(object.sendReplies) : void 0,
      spam: isSet29(object.spam) ? Boolean(object.spam) : void 0,
      stickied: isSet29(object.stickied) ? Boolean(object.stickied) : void 0,
      subreddit: isSet29(object.subreddit) ? String(object.subreddit) : void 0,
      subredditId: isSet29(object.subredditId) ? String(object.subredditId) : void 0,
      subredditNamePrefixed: isSet29(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : void 0,
      subredditType: isSet29(object.subredditType) ? String(object.subredditType) : void 0,
      topAwardedType: isSet29(object.topAwardedType) ? String(object.topAwardedType) : void 0,
      totalAwardsReceived: isSet29(object.totalAwardsReceived) ? Number(object.totalAwardsReceived) : void 0,
      treatmentTags: Array.isArray(object?.treatmentTags) ? object.treatmentTags.map((e) => Any.fromJSON(e)) : [],
      unrepliableReason: isSet29(object.unrepliableReason) ? String(object.unrepliableReason) : void 0,
      ups: isSet29(object.ups) ? Number(object.ups) : void 0,
      userReports: Array.isArray(object?.userReports) ? object.userReports.map((e) => Any.fromJSON(e)) : [],
      depth: isSet29(object.depth) ? Number(object.depth) : void 0,
      linkTitle: isSet29(object.linkTitle) ? String(object.linkTitle) : void 0,
      linkAuthor: isSet29(object.linkAuthor) ? String(object.linkAuthor) : void 0,
      numComments: isSet29(object.numComments) ? Number(object.numComments) : void 0,
      over18: isSet29(object.over18) ? Boolean(object.over18) : void 0,
      linkPermalink: isSet29(object.linkPermalink) ? String(object.linkPermalink) : void 0,
      quarantine: isSet29(object.quarantine) ? Boolean(object.quarantine) : void 0,
      linkUrl: isSet29(object.linkUrl) ? String(object.linkUrl) : void 0,
      selftext: isSet29(object.selftext) ? String(object.selftext) : void 0,
      selftextHtml: isSet29(object.selftextHtml) ? String(object.selftextHtml) : void 0,
      spoiler: isSet29(object.spoiler) ? String(object.spoiler) : void 0,
      thumbnail: isSet29(object.thumbnail) ? String(object.thumbnail) : void 0,
      thumbnailWidth: isSet29(object.thumbnailWidth) ? Number(object.thumbnailWidth) : void 0,
      thumbnailHeight: isSet29(object.thumbnailHeight) ? Number(object.thumbnailHeight) : void 0,
      title: isSet29(object.title) ? String(object.title) : void 0,
      url: isSet29(object.url) ? String(object.url) : void 0,
      displayName: isSet29(object.displayName) ? String(object.displayName) : void 0,
      modPermissions: Array.isArray(object?.modPermissions) ? object.modPermissions.map((e) => String(e)) : [],
      count: isSet29(object.count) ? Number(object.count) : void 0,
      children: Array.isArray(object.children) ? [...object.children] : void 0,
      replyList: isSet29(object.replyList) ? Listing.fromJSON(object.replyList) : void 0,
      hidden: isSet29(object.hidden) ? Boolean(object.hidden) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allAwardings) {
      obj.allAwardings = message.allAwardings.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.allAwardings = [];
    }
    message.approved !== void 0 && (obj.approved = message.approved);
    message.approvedAtUtc !== void 0 && (obj.approvedAtUtc = message.approvedAtUtc);
    message.approvedBy !== void 0 && (obj.approvedBy = message.approvedBy);
    message.archived !== void 0 && (obj.archived = message.archived);
    message.associatedAward !== void 0 && (obj.associatedAward = message.associatedAward);
    message.author !== void 0 && (obj.author = message.author);
    message.authorFlairBackgroundColor !== void 0 && (obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor);
    message.authorFlairCssClass !== void 0 && (obj.authorFlairCssClass = message.authorFlairCssClass);
    if (message.authorFlairRichtext) {
      obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => e ? RedditObject_AuthorFlairRichText.toJSON(e) : void 0);
    } else {
      obj.authorFlairRichtext = [];
    }
    message.authorFlairTemplateId !== void 0 && (obj.authorFlairTemplateId = message.authorFlairTemplateId);
    message.authorFlairText !== void 0 && (obj.authorFlairText = message.authorFlairText);
    message.authorFlairTextColor !== void 0 && (obj.authorFlairTextColor = message.authorFlairTextColor);
    message.authorFlairType !== void 0 && (obj.authorFlairType = message.authorFlairType);
    message.authorFullname !== void 0 && (obj.authorFullname = message.authorFullname);
    message.authorIsBlocked !== void 0 && (obj.authorIsBlocked = message.authorIsBlocked);
    message.authorPatreonFlair !== void 0 && (obj.authorPatreonFlair = message.authorPatreonFlair);
    message.authorPremium !== void 0 && (obj.authorPremium = message.authorPremium);
    if (message.awarders) {
      obj.awarders = message.awarders.map((e) => e);
    } else {
      obj.awarders = [];
    }
    message.bannedAtUtc !== void 0 && (obj.bannedAtUtc = message.bannedAtUtc);
    message.bannedBy !== void 0 && (obj.bannedBy = message.bannedBy);
    message.body !== void 0 && (obj.body = message.body);
    message.bodyHtml !== void 0 && (obj.bodyHtml = message.bodyHtml);
    message.canGild !== void 0 && (obj.canGild = message.canGild);
    message.canModPost !== void 0 && (obj.canModPost = message.canModPost);
    message.collapsed !== void 0 && (obj.collapsed = message.collapsed);
    message.collapsedBecauseCrowdControl !== void 0 && (obj.collapsedBecauseCrowdControl = message.collapsedBecauseCrowdControl);
    message.collapsedReason !== void 0 && (obj.collapsedReason = message.collapsedReason);
    message.collapsedReasonCode !== void 0 && (obj.collapsedReasonCode = message.collapsedReasonCode);
    message.commentType !== void 0 && (obj.commentType = message.commentType);
    message.controversiality !== void 0 && (obj.controversiality = message.controversiality);
    message.created !== void 0 && (obj.created = message.created);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    message.distinguished !== void 0 && (obj.distinguished = message.distinguished);
    message.downs !== void 0 && (obj.downs = message.downs);
    message.edited !== void 0 && (obj.edited = message.edited);
    message.gilded !== void 0 && (obj.gilded = message.gilded);
    message.gildings !== void 0 && (obj.gildings = message.gildings ? Any.toJSON(message.gildings) : void 0);
    message.id !== void 0 && (obj.id = message.id);
    message.ignoreReports !== void 0 && (obj.ignoreReports = message.ignoreReports);
    message.isSubmitter !== void 0 && (obj.isSubmitter = message.isSubmitter);
    message.likes !== void 0 && (obj.likes = message.likes);
    message.linkId !== void 0 && (obj.linkId = message.linkId);
    message.locked !== void 0 && (obj.locked = message.locked);
    message.modNote !== void 0 && (obj.modNote = message.modNote);
    message.modReasonBy !== void 0 && (obj.modReasonBy = message.modReasonBy);
    message.modReasonTitle !== void 0 && (obj.modReasonTitle = message.modReasonTitle);
    if (message.modReports) {
      obj.modReports = message.modReports.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.modReports = [];
    }
    message.name !== void 0 && (obj.name = message.name);
    message.noFollow !== void 0 && (obj.noFollow = message.noFollow);
    message.numReports !== void 0 && (obj.numReports = message.numReports);
    message.parentId !== void 0 && (obj.parentId = message.parentId);
    message.permalink !== void 0 && (obj.permalink = message.permalink);
    message.removalReason !== void 0 && (obj.removalReason = message.removalReason);
    message.removed !== void 0 && (obj.removed = message.removed);
    message.replies !== void 0 && (obj.replies = message.replies);
    message.reportReasons !== void 0 && (obj.reportReasons = message.reportReasons);
    message.rteMode !== void 0 && (obj.rteMode = message.rteMode);
    message.saved !== void 0 && (obj.saved = message.saved);
    message.score !== void 0 && (obj.score = message.score);
    message.scoreHidden !== void 0 && (obj.scoreHidden = message.scoreHidden);
    message.sendReplies !== void 0 && (obj.sendReplies = message.sendReplies);
    message.spam !== void 0 && (obj.spam = message.spam);
    message.stickied !== void 0 && (obj.stickied = message.stickied);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.subredditId !== void 0 && (obj.subredditId = message.subredditId);
    message.subredditNamePrefixed !== void 0 && (obj.subredditNamePrefixed = message.subredditNamePrefixed);
    message.subredditType !== void 0 && (obj.subredditType = message.subredditType);
    message.topAwardedType !== void 0 && (obj.topAwardedType = message.topAwardedType);
    message.totalAwardsReceived !== void 0 && (obj.totalAwardsReceived = message.totalAwardsReceived);
    if (message.treatmentTags) {
      obj.treatmentTags = message.treatmentTags.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.treatmentTags = [];
    }
    message.unrepliableReason !== void 0 && (obj.unrepliableReason = message.unrepliableReason);
    message.ups !== void 0 && (obj.ups = message.ups);
    if (message.userReports) {
      obj.userReports = message.userReports.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.userReports = [];
    }
    message.depth !== void 0 && (obj.depth = message.depth);
    message.linkTitle !== void 0 && (obj.linkTitle = message.linkTitle);
    message.linkAuthor !== void 0 && (obj.linkAuthor = message.linkAuthor);
    message.numComments !== void 0 && (obj.numComments = message.numComments);
    message.over18 !== void 0 && (obj.over18 = message.over18);
    message.linkPermalink !== void 0 && (obj.linkPermalink = message.linkPermalink);
    message.quarantine !== void 0 && (obj.quarantine = message.quarantine);
    message.linkUrl !== void 0 && (obj.linkUrl = message.linkUrl);
    message.selftext !== void 0 && (obj.selftext = message.selftext);
    message.selftextHtml !== void 0 && (obj.selftextHtml = message.selftextHtml);
    message.spoiler !== void 0 && (obj.spoiler = message.spoiler);
    message.thumbnail !== void 0 && (obj.thumbnail = message.thumbnail);
    message.thumbnailWidth !== void 0 && (obj.thumbnailWidth = message.thumbnailWidth);
    message.thumbnailHeight !== void 0 && (obj.thumbnailHeight = message.thumbnailHeight);
    message.title !== void 0 && (obj.title = message.title);
    message.url !== void 0 && (obj.url = message.url);
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    if (message.modPermissions) {
      obj.modPermissions = message.modPermissions.map((e) => e);
    } else {
      obj.modPermissions = [];
    }
    message.count !== void 0 && (obj.count = message.count);
    message.children !== void 0 && (obj.children = message.children);
    message.replyList !== void 0 && (obj.replyList = message.replyList ? Listing.toJSON(message.replyList) : void 0);
    message.hidden !== void 0 && (obj.hidden = message.hidden);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRedditObject();
    message.allAwardings = object.allAwardings?.map((e) => Any.fromPartial(e)) || [];
    message.approved = object.approved ?? void 0;
    message.approvedAtUtc = object.approvedAtUtc ?? void 0;
    message.approvedBy = object.approvedBy ?? void 0;
    message.archived = object.archived ?? void 0;
    message.associatedAward = object.associatedAward ?? void 0;
    message.author = object.author ?? void 0;
    message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? void 0;
    message.authorFlairCssClass = object.authorFlairCssClass ?? void 0;
    message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => RedditObject_AuthorFlairRichText.fromPartial(e)) || [];
    message.authorFlairTemplateId = object.authorFlairTemplateId ?? void 0;
    message.authorFlairText = object.authorFlairText ?? void 0;
    message.authorFlairTextColor = object.authorFlairTextColor ?? void 0;
    message.authorFlairType = object.authorFlairType ?? void 0;
    message.authorFullname = object.authorFullname ?? void 0;
    message.authorIsBlocked = object.authorIsBlocked ?? void 0;
    message.authorPatreonFlair = object.authorPatreonFlair ?? void 0;
    message.authorPremium = object.authorPremium ?? void 0;
    message.awarders = object.awarders?.map((e) => e) || [];
    message.bannedAtUtc = object.bannedAtUtc ?? void 0;
    message.bannedBy = object.bannedBy ?? void 0;
    message.body = object.body ?? void 0;
    message.bodyHtml = object.bodyHtml ?? void 0;
    message.canGild = object.canGild ?? void 0;
    message.canModPost = object.canModPost ?? void 0;
    message.collapsed = object.collapsed ?? void 0;
    message.collapsedBecauseCrowdControl = object.collapsedBecauseCrowdControl ?? void 0;
    message.collapsedReason = object.collapsedReason ?? void 0;
    message.collapsedReasonCode = object.collapsedReasonCode ?? void 0;
    message.commentType = object.commentType ?? void 0;
    message.controversiality = object.controversiality ?? void 0;
    message.created = object.created ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.distinguished = object.distinguished ?? void 0;
    message.downs = object.downs ?? void 0;
    message.edited = object.edited ?? void 0;
    message.gilded = object.gilded ?? void 0;
    message.gildings = object.gildings !== void 0 && object.gildings !== null ? Any.fromPartial(object.gildings) : void 0;
    message.id = object.id ?? void 0;
    message.ignoreReports = object.ignoreReports ?? void 0;
    message.isSubmitter = object.isSubmitter ?? void 0;
    message.likes = object.likes ?? void 0;
    message.linkId = object.linkId ?? void 0;
    message.locked = object.locked ?? void 0;
    message.modNote = object.modNote ?? void 0;
    message.modReasonBy = object.modReasonBy ?? void 0;
    message.modReasonTitle = object.modReasonTitle ?? void 0;
    message.modReports = object.modReports?.map((e) => Any.fromPartial(e)) || [];
    message.name = object.name ?? void 0;
    message.noFollow = object.noFollow ?? void 0;
    message.numReports = object.numReports ?? void 0;
    message.parentId = object.parentId ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.removalReason = object.removalReason ?? void 0;
    message.removed = object.removed ?? void 0;
    message.replies = object.replies ?? void 0;
    message.reportReasons = object.reportReasons ?? void 0;
    message.rteMode = object.rteMode ?? void 0;
    message.saved = object.saved ?? void 0;
    message.score = object.score ?? void 0;
    message.scoreHidden = object.scoreHidden ?? void 0;
    message.sendReplies = object.sendReplies ?? void 0;
    message.spam = object.spam ?? void 0;
    message.stickied = object.stickied ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.subredditNamePrefixed = object.subredditNamePrefixed ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.topAwardedType = object.topAwardedType ?? void 0;
    message.totalAwardsReceived = object.totalAwardsReceived ?? void 0;
    message.treatmentTags = object.treatmentTags?.map((e) => Any.fromPartial(e)) || [];
    message.unrepliableReason = object.unrepliableReason ?? void 0;
    message.ups = object.ups ?? void 0;
    message.userReports = object.userReports?.map((e) => Any.fromPartial(e)) || [];
    message.depth = object.depth ?? void 0;
    message.linkTitle = object.linkTitle ?? void 0;
    message.linkAuthor = object.linkAuthor ?? void 0;
    message.numComments = object.numComments ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.linkPermalink = object.linkPermalink ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.linkUrl = object.linkUrl ?? void 0;
    message.selftext = object.selftext ?? void 0;
    message.selftextHtml = object.selftextHtml ?? void 0;
    message.spoiler = object.spoiler ?? void 0;
    message.thumbnail = object.thumbnail ?? void 0;
    message.thumbnailWidth = object.thumbnailWidth ?? void 0;
    message.thumbnailHeight = object.thumbnailHeight ?? void 0;
    message.title = object.title ?? void 0;
    message.url = object.url ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.modPermissions = object.modPermissions?.map((e) => e) || [];
    message.count = object.count ?? void 0;
    message.children = object.children ?? void 0;
    message.replyList = object.replyList !== void 0 && object.replyList !== null ? Listing.fromPartial(object.replyList) : void 0;
    message.hidden = object.hidden ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.RedditObject", RedditObject);
function createBaseRedditObject_AuthorFlairRichText() {
  return { e: void 0, t: void 0 };
}
var RedditObject_AuthorFlairRichText = {
  $type: "devvit.plugin.redditapi.common.RedditObject.AuthorFlairRichText",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    if (message.e !== void 0) {
      StringValue.encode({ value: message.e }, writer.uint32(10).fork()).ldelim();
    }
    if (message.t !== void 0) {
      StringValue.encode({ value: message.t }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : new import_minimal31.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditObject_AuthorFlairRichText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.e = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.t = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { e: isSet29(object.e) ? String(object.e) : void 0, t: isSet29(object.t) ? String(object.t) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.e !== void 0 && (obj.e = message.e);
    message.t !== void 0 && (obj.t = message.t);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRedditObject_AuthorFlairRichText();
    message.e = object.e ?? void 0;
    message.t = object.t ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.RedditObject.AuthorFlairRichText", RedditObject_AuthorFlairRichText);
function createBaseSubredditObject() {
  return {
    defaultSet: void 0,
    userIsContributor: void 0,
    bannerImg: void 0,
    restrictPosting: void 0,
    userIsBanned: void 0,
    freeFormReports: void 0,
    communityIcon: void 0,
    showMedia: void 0,
    iconColor: void 0,
    userIsMuted: void 0,
    displayName: void 0,
    headerImg: void 0,
    title: void 0,
    coins: void 0,
    previousNames: [],
    over18: void 0,
    iconSize: [],
    primaryColor: void 0,
    iconImg: void 0,
    description: void 0,
    submitLinkLabel: void 0,
    headerSize: void 0,
    restrictCommenting: void 0,
    subscribers: void 0,
    submitTextLabel: void 0,
    isDefaultIcon: void 0,
    linkFlairPosition: void 0,
    displayNamePrefixed: void 0,
    keyColor: void 0,
    name: void 0,
    isDefaultBanner: void 0,
    url: void 0,
    quarantine: void 0,
    bannerSize: [],
    userIsModerator: void 0,
    acceptFollowers: void 0,
    publicDescription: void 0,
    linkFlairEnabled: void 0,
    disableContributorRequests: void 0,
    subredditType: void 0,
    userIsSubscriber: void 0,
    publicDescriptionHtml: void 0,
    id: void 0
  };
}
var SubredditObject = {
  $type: "devvit.plugin.redditapi.common.SubredditObject",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    if (message.defaultSet !== void 0) {
      BoolValue.encode({ value: message.defaultSet }, writer.uint32(10).fork()).ldelim();
    }
    if (message.userIsContributor !== void 0) {
      BoolValue.encode({ value: message.userIsContributor }, writer.uint32(18).fork()).ldelim();
    }
    if (message.bannerImg !== void 0) {
      StringValue.encode({ value: message.bannerImg }, writer.uint32(26).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(34).fork()).ldelim();
    }
    if (message.userIsBanned !== void 0) {
      BoolValue.encode({ value: message.userIsBanned }, writer.uint32(42).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(50).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(58).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(66).fork()).ldelim();
    }
    if (message.iconColor !== void 0) {
      StringValue.encode({ value: message.iconColor }, writer.uint32(74).fork()).ldelim();
    }
    if (message.userIsMuted !== void 0) {
      StringValue.encode({ value: message.userIsMuted }, writer.uint32(82).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(90).fork()).ldelim();
    }
    if (message.headerImg !== void 0) {
      StringValue.encode({ value: message.headerImg }, writer.uint32(98).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(106).fork()).ldelim();
    }
    if (message.coins !== void 0) {
      Int64Value.encode({ value: message.coins }, writer.uint32(114).fork()).ldelim();
    }
    for (const v of message.previousNames) {
      StringValue.encode({ value: v }, writer.uint32(122).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(130).fork()).ldelim();
    }
    for (const v of message.iconSize) {
      Int32Value.encode({ value: v }, writer.uint32(138).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(146).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(154).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(162).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(170).fork()).ldelim();
    }
    if (message.headerSize !== void 0) {
      StringValue.encode({ value: message.headerSize }, writer.uint32(178).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(186).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int64Value.encode({ value: message.subscribers }, writer.uint32(194).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(202).fork()).ldelim();
    }
    if (message.isDefaultIcon !== void 0) {
      BoolValue.encode({ value: message.isDefaultIcon }, writer.uint32(210).fork()).ldelim();
    }
    if (message.linkFlairPosition !== void 0) {
      StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(218).fork()).ldelim();
    }
    if (message.displayNamePrefixed !== void 0) {
      StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(226).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(234).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(242).fork()).ldelim();
    }
    if (message.isDefaultBanner !== void 0) {
      BoolValue.encode({ value: message.isDefaultBanner }, writer.uint32(250).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(258).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(266).fork()).ldelim();
    }
    for (const v of message.bannerSize) {
      Int32Value.encode({ value: v }, writer.uint32(274).fork()).ldelim();
    }
    if (message.userIsModerator !== void 0) {
      BoolValue.encode({ value: message.userIsModerator }, writer.uint32(282).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(290).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(298).fork()).ldelim();
    }
    if (message.linkFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(306).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(314).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(322).fork()).ldelim();
    }
    if (message.userIsSubscriber !== void 0) {
      BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(330).fork()).ldelim();
    }
    if (message.publicDescriptionHtml !== void 0) {
      StringValue.encode({ value: message.publicDescriptionHtml }, writer.uint32(338).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(346).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : new import_minimal31.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.iconColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.userIsMuted = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.headerImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.coins = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.previousNames.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 16:
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.iconSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 18:
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.headerSize = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.isDefaultIcon = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 27:
          message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.isDefaultBanner = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.bannerSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 35:
          message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 37:
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 38:
          message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 39:
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 40:
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 41:
          message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 42:
          message.publicDescriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 43:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      defaultSet: isSet29(object.defaultSet) ? Boolean(object.defaultSet) : void 0,
      userIsContributor: isSet29(object.userIsContributor) ? Boolean(object.userIsContributor) : void 0,
      bannerImg: isSet29(object.bannerImg) ? String(object.bannerImg) : void 0,
      restrictPosting: isSet29(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      userIsBanned: isSet29(object.userIsBanned) ? Boolean(object.userIsBanned) : void 0,
      freeFormReports: isSet29(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      communityIcon: isSet29(object.communityIcon) ? String(object.communityIcon) : void 0,
      showMedia: isSet29(object.showMedia) ? Boolean(object.showMedia) : void 0,
      iconColor: isSet29(object.iconColor) ? String(object.iconColor) : void 0,
      userIsMuted: isSet29(object.userIsMuted) ? String(object.userIsMuted) : void 0,
      displayName: isSet29(object.displayName) ? String(object.displayName) : void 0,
      headerImg: isSet29(object.headerImg) ? String(object.headerImg) : void 0,
      title: isSet29(object.title) ? String(object.title) : void 0,
      coins: isSet29(object.coins) ? Number(object.coins) : void 0,
      previousNames: Array.isArray(object?.previousNames) ? object.previousNames.map((e) => String(e)) : [],
      over18: isSet29(object.over18) ? Boolean(object.over18) : void 0,
      iconSize: Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
      primaryColor: isSet29(object.primaryColor) ? String(object.primaryColor) : void 0,
      iconImg: isSet29(object.iconImg) ? String(object.iconImg) : void 0,
      description: isSet29(object.description) ? String(object.description) : void 0,
      submitLinkLabel: isSet29(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      headerSize: isSet29(object.headerSize) ? String(object.headerSize) : void 0,
      restrictCommenting: isSet29(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      subscribers: isSet29(object.subscribers) ? Number(object.subscribers) : void 0,
      submitTextLabel: isSet29(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      isDefaultIcon: isSet29(object.isDefaultIcon) ? Boolean(object.isDefaultIcon) : void 0,
      linkFlairPosition: isSet29(object.linkFlairPosition) ? String(object.linkFlairPosition) : void 0,
      displayNamePrefixed: isSet29(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : void 0,
      keyColor: isSet29(object.keyColor) ? String(object.keyColor) : void 0,
      name: isSet29(object.name) ? String(object.name) : void 0,
      isDefaultBanner: isSet29(object.isDefaultBanner) ? Boolean(object.isDefaultBanner) : void 0,
      url: isSet29(object.url) ? String(object.url) : void 0,
      quarantine: isSet29(object.quarantine) ? Boolean(object.quarantine) : void 0,
      bannerSize: Array.isArray(object?.bannerSize) ? object.bannerSize.map((e) => Number(e)) : [],
      userIsModerator: isSet29(object.userIsModerator) ? Boolean(object.userIsModerator) : void 0,
      acceptFollowers: isSet29(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      publicDescription: isSet29(object.publicDescription) ? String(object.publicDescription) : void 0,
      linkFlairEnabled: isSet29(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : void 0,
      disableContributorRequests: isSet29(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      subredditType: isSet29(object.subredditType) ? String(object.subredditType) : void 0,
      userIsSubscriber: isSet29(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : void 0,
      publicDescriptionHtml: isSet29(object.publicDescriptionHtml) ? String(object.publicDescriptionHtml) : void 0,
      id: isSet29(object.id) ? String(object.id) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.defaultSet !== void 0 && (obj.defaultSet = message.defaultSet);
    message.userIsContributor !== void 0 && (obj.userIsContributor = message.userIsContributor);
    message.bannerImg !== void 0 && (obj.bannerImg = message.bannerImg);
    message.restrictPosting !== void 0 && (obj.restrictPosting = message.restrictPosting);
    message.userIsBanned !== void 0 && (obj.userIsBanned = message.userIsBanned);
    message.freeFormReports !== void 0 && (obj.freeFormReports = message.freeFormReports);
    message.communityIcon !== void 0 && (obj.communityIcon = message.communityIcon);
    message.showMedia !== void 0 && (obj.showMedia = message.showMedia);
    message.iconColor !== void 0 && (obj.iconColor = message.iconColor);
    message.userIsMuted !== void 0 && (obj.userIsMuted = message.userIsMuted);
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    message.headerImg !== void 0 && (obj.headerImg = message.headerImg);
    message.title !== void 0 && (obj.title = message.title);
    message.coins !== void 0 && (obj.coins = message.coins);
    if (message.previousNames) {
      obj.previousNames = message.previousNames.map((e) => e);
    } else {
      obj.previousNames = [];
    }
    message.over18 !== void 0 && (obj.over18 = message.over18);
    if (message.iconSize) {
      obj.iconSize = message.iconSize.map((e) => e);
    } else {
      obj.iconSize = [];
    }
    message.primaryColor !== void 0 && (obj.primaryColor = message.primaryColor);
    message.iconImg !== void 0 && (obj.iconImg = message.iconImg);
    message.description !== void 0 && (obj.description = message.description);
    message.submitLinkLabel !== void 0 && (obj.submitLinkLabel = message.submitLinkLabel);
    message.headerSize !== void 0 && (obj.headerSize = message.headerSize);
    message.restrictCommenting !== void 0 && (obj.restrictCommenting = message.restrictCommenting);
    message.subscribers !== void 0 && (obj.subscribers = message.subscribers);
    message.submitTextLabel !== void 0 && (obj.submitTextLabel = message.submitTextLabel);
    message.isDefaultIcon !== void 0 && (obj.isDefaultIcon = message.isDefaultIcon);
    message.linkFlairPosition !== void 0 && (obj.linkFlairPosition = message.linkFlairPosition);
    message.displayNamePrefixed !== void 0 && (obj.displayNamePrefixed = message.displayNamePrefixed);
    message.keyColor !== void 0 && (obj.keyColor = message.keyColor);
    message.name !== void 0 && (obj.name = message.name);
    message.isDefaultBanner !== void 0 && (obj.isDefaultBanner = message.isDefaultBanner);
    message.url !== void 0 && (obj.url = message.url);
    message.quarantine !== void 0 && (obj.quarantine = message.quarantine);
    if (message.bannerSize) {
      obj.bannerSize = message.bannerSize.map((e) => e);
    } else {
      obj.bannerSize = [];
    }
    message.userIsModerator !== void 0 && (obj.userIsModerator = message.userIsModerator);
    message.acceptFollowers !== void 0 && (obj.acceptFollowers = message.acceptFollowers);
    message.publicDescription !== void 0 && (obj.publicDescription = message.publicDescription);
    message.linkFlairEnabled !== void 0 && (obj.linkFlairEnabled = message.linkFlairEnabled);
    message.disableContributorRequests !== void 0 && (obj.disableContributorRequests = message.disableContributorRequests);
    message.subredditType !== void 0 && (obj.subredditType = message.subredditType);
    message.userIsSubscriber !== void 0 && (obj.userIsSubscriber = message.userIsSubscriber);
    message.publicDescriptionHtml !== void 0 && (obj.publicDescriptionHtml = message.publicDescriptionHtml);
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditObject();
    message.defaultSet = object.defaultSet ?? void 0;
    message.userIsContributor = object.userIsContributor ?? void 0;
    message.bannerImg = object.bannerImg ?? void 0;
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.userIsBanned = object.userIsBanned ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.iconColor = object.iconColor ?? void 0;
    message.userIsMuted = object.userIsMuted ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.headerImg = object.headerImg ?? void 0;
    message.title = object.title ?? void 0;
    message.coins = object.coins ?? void 0;
    message.previousNames = object.previousNames?.map((e) => e) || [];
    message.over18 = object.over18 ?? void 0;
    message.iconSize = object.iconSize?.map((e) => e) || [];
    message.primaryColor = object.primaryColor ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.description = object.description ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.headerSize = object.headerSize ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.isDefaultIcon = object.isDefaultIcon ?? void 0;
    message.linkFlairPosition = object.linkFlairPosition ?? void 0;
    message.displayNamePrefixed = object.displayNamePrefixed ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.name = object.name ?? void 0;
    message.isDefaultBanner = object.isDefaultBanner ?? void 0;
    message.url = object.url ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.bannerSize = object.bannerSize?.map((e) => e) || [];
    message.userIsModerator = object.userIsModerator ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.linkFlairEnabled = object.linkFlairEnabled ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.userIsSubscriber = object.userIsSubscriber ?? void 0;
    message.publicDescriptionHtml = object.publicDescriptionHtml ?? void 0;
    message.id = object.id ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.SubredditObject", SubredditObject);
function createBaseJsonStatus() {
  return { json: void 0 };
}
var JsonStatus = {
  $type: "devvit.plugin.redditapi.common.JsonStatus",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    if (message.json !== void 0) {
      JsonStatus_JsonErrorType.encode(message.json, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : new import_minimal31.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          message.json = JsonStatus_JsonErrorType.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { json: isSet29(object.json) ? JsonStatus_JsonErrorType.fromJSON(object.json) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.json !== void 0 && (obj.json = message.json ? JsonStatus_JsonErrorType.toJSON(message.json) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseJsonStatus();
    message.json = object.json !== void 0 && object.json !== null ? JsonStatus_JsonErrorType.fromPartial(object.json) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.JsonStatus", JsonStatus);
function createBaseJsonStatus_JsonErrorType() {
  return { errors: [] };
}
var JsonStatus_JsonErrorType = {
  $type: "devvit.plugin.redditapi.common.JsonStatus.JsonErrorType",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    for (const v of message.errors) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : new import_minimal31.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonStatus_JsonErrorType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.errors.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { errors: Array.isArray(object?.errors) ? object.errors.map((e) => String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.errors) {
      obj.errors = message.errors.map((e) => e);
    } else {
      obj.errors = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseJsonStatus_JsonErrorType();
    message.errors = object.errors?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.JsonStatus.JsonErrorType", JsonStatus_JsonErrorType);
function createBaseWrappedUserObject() {
  return { id: void 0, data: void 0 };
}
var WrappedUserObject = {
  $type: "devvit.plugin.redditapi.common.WrappedUserObject",
  encode(message, writer = import_minimal31.default.Writer.create()) {
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      User.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal31.default.Reader ? input : new import_minimal31.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWrappedUserObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = User.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet29(object.id) ? String(object.id) : void 0,
      data: isSet29(object.data) ? User.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.data !== void 0 && (obj.data = message.data ? User.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWrappedUserObject();
    message.id = object.id ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? User.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.common.WrappedUserObject", WrappedUserObject);
function isSet29(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/effect.js
var import_minimal40 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/effects/v1alpha/realtime_subscriptions.js
var import_minimal33 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/events/v1alpha/realtime.js
var import_minimal32 = __toESM(require_minimal2(), 1);
function createBaseRealtimeRequest() {
  return { channels: [] };
}
var RealtimeRequest = {
  $type: "devvit.events.v1alpha.RealtimeRequest",
  encode(message, writer = import_minimal32.default.Writer.create()) {
    for (const v of message.channels) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal32.default.Reader ? input : new import_minimal32.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRealtimeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.channels.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { channels: Array.isArray(object?.channels) ? object.channels.map((e) => String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.channels) {
      obj.channels = message.channels.map((e) => e);
    } else {
      obj.channels = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRealtimeRequest();
    message.channels = object.channels?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.events.v1alpha.RealtimeRequest", RealtimeRequest);
function createBaseRealtimeEvent() {
  return { channel: "", data: void 0 };
}
var RealtimeEvent = {
  $type: "devvit.events.v1alpha.RealtimeEvent",
  encode(message, writer = import_minimal32.default.Writer.create()) {
    if (message.channel !== "") {
      writer.uint32(10).string(message.channel);
    }
    if (message.data !== void 0) {
      Value.encode(Value.wrap(message.data), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal32.default.Reader ? input : new import_minimal32.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRealtimeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.channel = reader.string();
          break;
        case 2:
          message.data = Value.unwrap(Value.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      channel: isSet30(object.channel) ? String(object.channel) : "",
      data: isSet30(object?.data) ? object.data : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.channel !== void 0 && (obj.channel = message.channel);
    message.data !== void 0 && (obj.data = message.data);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRealtimeEvent();
    message.channel = object.channel ?? "";
    message.data = object.data ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.events.v1alpha.RealtimeEvent", RealtimeEvent);
function isSet30(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/realtime_subscriptions.js
function createBaseRealtimeSubscriptionsEffect() {
  return { subscriptionIds: [] };
}
var RealtimeSubscriptionsEffect = {
  $type: "devvit.ui.effects.v1alpha.RealtimeSubscriptionsEffect",
  encode(message, writer = import_minimal33.default.Writer.create()) {
    for (const v of message.subscriptionIds) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal33.default.Reader ? input : new import_minimal33.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRealtimeSubscriptionsEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subscriptionIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subscriptionIds: Array.isArray(object?.subscriptionIds) ? object.subscriptionIds.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subscriptionIds) {
      obj.subscriptionIds = message.subscriptionIds.map((e) => e);
    } else {
      obj.subscriptionIds = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRealtimeSubscriptionsEffect();
    message.subscriptionIds = object.subscriptionIds?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.RealtimeSubscriptionsEffect", RealtimeSubscriptionsEffect);
function createBaseRealtimeSubscriptionEvent() {
  return { event: void 0 };
}
var RealtimeSubscriptionEvent = {
  $type: "devvit.ui.effects.v1alpha.RealtimeSubscriptionEvent",
  encode(message, writer = import_minimal33.default.Writer.create()) {
    if (message.event !== void 0) {
      RealtimeEvent.encode(message.event, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal33.default.Reader ? input : new import_minimal33.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRealtimeSubscriptionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.event = RealtimeEvent.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { event: isSet31(object.event) ? RealtimeEvent.fromJSON(object.event) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.event !== void 0 && (obj.event = message.event ? RealtimeEvent.toJSON(message.event) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRealtimeSubscriptionEvent();
    message.event = object.event !== void 0 && object.event !== null ? RealtimeEvent.fromPartial(object.event) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.RealtimeSubscriptionEvent", RealtimeSubscriptionEvent);
function isSet31(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/reload_part.js
var import_minimal34 = __toESM(require_minimal2(), 1);
function createBaseReloadPartEffect() {
  return { subreddit: void 0, post: void 0, comment: void 0 };
}
var ReloadPartEffect = {
  $type: "devvit.ui.effects.v1alpha.ReloadPartEffect",
  encode(message, writer = import_minimal34.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      ReloadPartEffect_Subreddit.encode(message.subreddit, writer.uint32(10).fork()).ldelim();
    }
    if (message.post !== void 0) {
      ReloadPartEffect_Post.encode(message.post, writer.uint32(18).fork()).ldelim();
    }
    if (message.comment !== void 0) {
      ReloadPartEffect_Comment.encode(message.comment, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal34.default.Reader ? input : new import_minimal34.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReloadPartEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = ReloadPartEffect_Subreddit.decode(reader, reader.uint32());
          break;
        case 2:
          message.post = ReloadPartEffect_Post.decode(reader, reader.uint32());
          break;
        case 3:
          message.comment = ReloadPartEffect_Comment.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet32(object.subreddit) ? ReloadPartEffect_Subreddit.fromJSON(object.subreddit) : void 0,
      post: isSet32(object.post) ? ReloadPartEffect_Post.fromJSON(object.post) : void 0,
      comment: isSet32(object.comment) ? ReloadPartEffect_Comment.fromJSON(object.comment) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? ReloadPartEffect_Subreddit.toJSON(message.subreddit) : void 0);
    message.post !== void 0 && (obj.post = message.post ? ReloadPartEffect_Post.toJSON(message.post) : void 0);
    message.comment !== void 0 && (obj.comment = message.comment ? ReloadPartEffect_Comment.toJSON(message.comment) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseReloadPartEffect();
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? ReloadPartEffect_Subreddit.fromPartial(object.subreddit) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? ReloadPartEffect_Post.fromPartial(object.post) : void 0;
    message.comment = object.comment !== void 0 && object.comment !== null ? ReloadPartEffect_Comment.fromPartial(object.comment) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.ReloadPartEffect", ReloadPartEffect);
function createBaseReloadPartEffect_Subreddit() {
  return { subredditId: "" };
}
var ReloadPartEffect_Subreddit = {
  $type: "devvit.ui.effects.v1alpha.ReloadPartEffect.Subreddit",
  encode(message, writer = import_minimal34.default.Writer.create()) {
    if (message.subredditId !== "") {
      writer.uint32(10).string(message.subredditId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal34.default.Reader ? input : new import_minimal34.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReloadPartEffect_Subreddit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subredditId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { subredditId: isSet32(object.subredditId) ? String(object.subredditId) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.subredditId !== void 0 && (obj.subredditId = message.subredditId);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseReloadPartEffect_Subreddit();
    message.subredditId = object.subredditId ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.ReloadPartEffect.Subreddit", ReloadPartEffect_Subreddit);
function createBaseReloadPartEffect_Post() {
  return { postId: "", body: void 0, comments: void 0 };
}
var ReloadPartEffect_Post = {
  $type: "devvit.ui.effects.v1alpha.ReloadPartEffect.Post",
  encode(message, writer = import_minimal34.default.Writer.create()) {
    if (message.postId !== "") {
      writer.uint32(10).string(message.postId);
    }
    if (message.body !== void 0) {
      writer.uint32(16).bool(message.body);
    }
    if (message.comments !== void 0) {
      writer.uint32(24).bool(message.comments);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal34.default.Reader ? input : new import_minimal34.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReloadPartEffect_Post();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.postId = reader.string();
          break;
        case 2:
          message.body = reader.bool();
          break;
        case 3:
          message.comments = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      postId: isSet32(object.postId) ? String(object.postId) : "",
      body: isSet32(object.body) ? Boolean(object.body) : void 0,
      comments: isSet32(object.comments) ? Boolean(object.comments) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.postId !== void 0 && (obj.postId = message.postId);
    message.body !== void 0 && (obj.body = message.body);
    message.comments !== void 0 && (obj.comments = message.comments);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseReloadPartEffect_Post();
    message.postId = object.postId ?? "";
    message.body = object.body ?? void 0;
    message.comments = object.comments ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.ReloadPartEffect.Post", ReloadPartEffect_Post);
function createBaseReloadPartEffect_Comment() {
  return { postId: "", commentId: "", replies: void 0 };
}
var ReloadPartEffect_Comment = {
  $type: "devvit.ui.effects.v1alpha.ReloadPartEffect.Comment",
  encode(message, writer = import_minimal34.default.Writer.create()) {
    if (message.postId !== "") {
      writer.uint32(10).string(message.postId);
    }
    if (message.commentId !== "") {
      writer.uint32(18).string(message.commentId);
    }
    if (message.replies !== void 0) {
      writer.uint32(24).bool(message.replies);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal34.default.Reader ? input : new import_minimal34.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReloadPartEffect_Comment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.postId = reader.string();
          break;
        case 2:
          message.commentId = reader.string();
          break;
        case 3:
          message.replies = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      postId: isSet32(object.postId) ? String(object.postId) : "",
      commentId: isSet32(object.commentId) ? String(object.commentId) : "",
      replies: isSet32(object.replies) ? Boolean(object.replies) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.postId !== void 0 && (obj.postId = message.postId);
    message.commentId !== void 0 && (obj.commentId = message.commentId);
    message.replies !== void 0 && (obj.replies = message.replies);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseReloadPartEffect_Comment();
    message.postId = object.postId ?? "";
    message.commentId = object.commentId ?? "";
    message.replies = object.replies ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.ReloadPartEffect.Comment", ReloadPartEffect_Comment);
function isSet32(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/rerender_ui.js
var import_minimal35 = __toESM(require_minimal2(), 1);
function createBaseRerenderEffect() {
  return { delaySeconds: void 0 };
}
var RerenderEffect = {
  $type: "devvit.ui.effects.v1alpha.RerenderEffect",
  encode(message, writer = import_minimal35.default.Writer.create()) {
    if (message.delaySeconds !== void 0) {
      writer.uint32(13).float(message.delaySeconds);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal35.default.Reader ? input : new import_minimal35.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRerenderEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.delaySeconds = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { delaySeconds: isSet33(object.delaySeconds) ? Number(object.delaySeconds) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.delaySeconds !== void 0 && (obj.delaySeconds = message.delaySeconds);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRerenderEffect();
    message.delaySeconds = object.delaySeconds ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.RerenderEffect", RerenderEffect);
function isSet33(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/show_form.js
var import_minimal36 = __toESM(require_minimal2(), 1);
function createBaseShowFormEffect() {
  return { form: void 0 };
}
var ShowFormEffect = {
  $type: "devvit.ui.effects.v1alpha.ShowFormEffect",
  encode(message, writer = import_minimal36.default.Writer.create()) {
    if (message.form !== void 0) {
      Form.encode(message.form, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal36.default.Reader ? input : new import_minimal36.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShowFormEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.form = Form.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { form: isSet34(object.form) ? Form.fromJSON(object.form) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.form !== void 0 && (obj.form = message.form ? Form.toJSON(message.form) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseShowFormEffect();
    message.form = object.form !== void 0 && object.form !== null ? Form.fromPartial(object.form) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.ShowFormEffect", ShowFormEffect);
function createBaseFormSubmittedEvent() {
  return { results: {}, formId: void 0 };
}
var FormSubmittedEvent = {
  $type: "devvit.ui.effects.v1alpha.FormSubmittedEvent",
  encode(message, writer = import_minimal36.default.Writer.create()) {
    Object.entries(message.results).forEach(([key, value]) => {
      FormSubmittedEvent_ResultsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    if (message.formId !== void 0) {
      writer.uint32(18).string(message.formId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal36.default.Reader ? input : new import_minimal36.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormSubmittedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = FormSubmittedEvent_ResultsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.results[entry1.key] = entry1.value;
          }
          break;
        case 2:
          message.formId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      results: isObject3(object.results) ? Object.entries(object.results).reduce((acc, [key, value]) => {
        acc[key] = FormFieldValue.fromJSON(value);
        return acc;
      }, {}) : {},
      formId: isSet34(object.formId) ? String(object.formId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    obj.results = {};
    if (message.results) {
      Object.entries(message.results).forEach(([k, v]) => {
        obj.results[k] = FormFieldValue.toJSON(v);
      });
    }
    message.formId !== void 0 && (obj.formId = message.formId);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFormSubmittedEvent();
    message.results = Object.entries(object.results ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = FormFieldValue.fromPartial(value);
      }
      return acc;
    }, {});
    message.formId = object.formId ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.FormSubmittedEvent", FormSubmittedEvent);
function createBaseFormSubmittedEvent_ResultsEntry() {
  return { key: "", value: void 0 };
}
var FormSubmittedEvent_ResultsEntry = {
  $type: "devvit.ui.effects.v1alpha.FormSubmittedEvent.ResultsEntry",
  encode(message, writer = import_minimal36.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      FormFieldValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal36.default.Reader ? input : new import_minimal36.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFormSubmittedEvent_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = FormFieldValue.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet34(object.key) ? String(object.key) : "",
      value: isSet34(object.value) ? FormFieldValue.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? FormFieldValue.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFormSubmittedEvent_ResultsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? FormFieldValue.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.FormSubmittedEvent.ResultsEntry", FormSubmittedEvent_ResultsEntry);
function isObject3(value) {
  return typeof value === "object" && value !== null;
}
function isSet34(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/show_toast.js
var import_minimal38 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/toast/toast.js
var import_minimal37 = __toESM(require_minimal2(), 1);
var ToastAppearance;
(function(ToastAppearance2) {
  ToastAppearance2[ToastAppearance2["NEUTRAL"] = 0] = "NEUTRAL";
  ToastAppearance2[ToastAppearance2["SUCCESS"] = 1] = "SUCCESS";
  ToastAppearance2[ToastAppearance2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ToastAppearance || (ToastAppearance = {}));
function toastAppearanceFromJSON(object) {
  switch (object) {
    case 0:
    case "NEUTRAL":
      return ToastAppearance.NEUTRAL;
    case 1:
    case "SUCCESS":
      return ToastAppearance.SUCCESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ToastAppearance.UNRECOGNIZED;
  }
}
function toastAppearanceToJSON(object) {
  switch (object) {
    case ToastAppearance.NEUTRAL:
      return 0;
    case ToastAppearance.SUCCESS:
      return 1;
    case ToastAppearance.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseToastLeadingElement() {
  return { icon: void 0, emoji: void 0, avatar: void 0 };
}
var ToastLeadingElement = {
  $type: "devvit.ui.toast.ToastLeadingElement",
  encode(message, writer = import_minimal37.default.Writer.create()) {
    if (message.icon !== void 0) {
      writer.uint32(10).string(message.icon);
    }
    if (message.emoji !== void 0) {
      writer.uint32(18).string(message.emoji);
    }
    if (message.avatar !== void 0) {
      writer.uint32(26).string(message.avatar);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal37.default.Reader ? input : new import_minimal37.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToastLeadingElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.icon = reader.string();
          break;
        case 2:
          message.emoji = reader.string();
          break;
        case 3:
          message.avatar = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      icon: isSet35(object.icon) ? String(object.icon) : void 0,
      emoji: isSet35(object.emoji) ? String(object.emoji) : void 0,
      avatar: isSet35(object.avatar) ? String(object.avatar) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.icon !== void 0 && (obj.icon = message.icon);
    message.emoji !== void 0 && (obj.emoji = message.emoji);
    message.avatar !== void 0 && (obj.avatar = message.avatar);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseToastLeadingElement();
    message.icon = object.icon ?? void 0;
    message.emoji = object.emoji ?? void 0;
    message.avatar = object.avatar ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.toast.ToastLeadingElement", ToastLeadingElement);
function createBaseToastTrailingElement() {
  return { label: void 0, icon: void 0 };
}
var ToastTrailingElement = {
  $type: "devvit.ui.toast.ToastTrailingElement",
  encode(message, writer = import_minimal37.default.Writer.create()) {
    if (message.label !== void 0) {
      writer.uint32(10).string(message.label);
    }
    if (message.icon !== void 0) {
      writer.uint32(18).string(message.icon);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal37.default.Reader ? input : new import_minimal37.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToastTrailingElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.label = reader.string();
          break;
        case 2:
          message.icon = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      label: isSet35(object.label) ? String(object.label) : void 0,
      icon: isSet35(object.icon) ? String(object.icon) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.label !== void 0 && (obj.label = message.label);
    message.icon !== void 0 && (obj.icon = message.icon);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseToastTrailingElement();
    message.label = object.label ?? void 0;
    message.icon = object.icon ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.toast.ToastTrailingElement", ToastTrailingElement);
function createBaseToast() {
  return { text: "", appearance: void 0, leadingElement: void 0, trailingElement: void 0 };
}
var Toast = {
  $type: "devvit.ui.toast.Toast",
  encode(message, writer = import_minimal37.default.Writer.create()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.appearance !== void 0) {
      writer.uint32(16).int32(message.appearance);
    }
    if (message.leadingElement !== void 0) {
      ToastLeadingElement.encode(message.leadingElement, writer.uint32(26).fork()).ldelim();
    }
    if (message.trailingElement !== void 0) {
      ToastTrailingElement.encode(message.trailingElement, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal37.default.Reader ? input : new import_minimal37.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.text = reader.string();
          break;
        case 2:
          message.appearance = reader.int32();
          break;
        case 3:
          message.leadingElement = ToastLeadingElement.decode(reader, reader.uint32());
          break;
        case 4:
          message.trailingElement = ToastTrailingElement.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet35(object.text) ? String(object.text) : "",
      appearance: isSet35(object.appearance) ? toastAppearanceFromJSON(object.appearance) : void 0,
      leadingElement: isSet35(object.leadingElement) ? ToastLeadingElement.fromJSON(object.leadingElement) : void 0,
      trailingElement: isSet35(object.trailingElement) ? ToastTrailingElement.fromJSON(object.trailingElement) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.text !== void 0 && (obj.text = message.text);
    message.appearance !== void 0 && (obj.appearance = message.appearance !== void 0 ? toastAppearanceToJSON(message.appearance) : void 0);
    message.leadingElement !== void 0 && (obj.leadingElement = message.leadingElement ? ToastLeadingElement.toJSON(message.leadingElement) : void 0);
    message.trailingElement !== void 0 && (obj.trailingElement = message.trailingElement ? ToastTrailingElement.toJSON(message.trailingElement) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseToast();
    message.text = object.text ?? "";
    message.appearance = object.appearance ?? void 0;
    message.leadingElement = object.leadingElement !== void 0 && object.leadingElement !== null ? ToastLeadingElement.fromPartial(object.leadingElement) : void 0;
    message.trailingElement = object.trailingElement !== void 0 && object.trailingElement !== null ? ToastTrailingElement.fromPartial(object.trailingElement) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.toast.Toast", Toast);
function isSet35(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/show_toast.js
function createBaseShowToastEffect() {
  return { toast: void 0 };
}
var ShowToastEffect = {
  $type: "devvit.ui.effects.v1alpha.ShowToastEffect",
  encode(message, writer = import_minimal38.default.Writer.create()) {
    if (message.toast !== void 0) {
      Toast.encode(message.toast, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal38.default.Reader ? input : new import_minimal38.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShowToastEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.toast = Toast.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { toast: isSet36(object.toast) ? Toast.fromJSON(object.toast) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.toast !== void 0 && (obj.toast = message.toast ? Toast.toJSON(message.toast) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseShowToastEffect();
    message.toast = object.toast !== void 0 && object.toast !== null ? Toast.fromPartial(object.toast) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.ShowToastEffect", ShowToastEffect);
function createBaseToastActionEvent() {
  return {};
}
var ToastActionEvent = {
  $type: "devvit.ui.effects.v1alpha.ToastActionEvent",
  encode(_, writer = import_minimal38.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal38.default.Reader ? input : new import_minimal38.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToastActionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseToastActionEvent();
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.ToastActionEvent", ToastActionEvent);
function isSet36(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/view_thing.js
var import_minimal39 = __toESM(require_minimal2(), 1);
function createBaseViewThingEffect() {
  return { thingId: "" };
}
var ViewThingEffect = {
  $type: "devvit.ui.effects.v1alpha.ViewThingEffect",
  encode(message, writer = import_minimal39.default.Writer.create()) {
    if (message.thingId !== "") {
      writer.uint32(10).string(message.thingId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal39.default.Reader ? input : new import_minimal39.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseViewThingEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.thingId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { thingId: isSet37(object.thingId) ? String(object.thingId) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.thingId !== void 0 && (obj.thingId = message.thingId);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseViewThingEffect();
    message.thingId = object.thingId ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.ViewThingEffect", ViewThingEffect);
function isSet37(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/effects/v1alpha/effect.js
var EffectType;
(function(EffectType2) {
  EffectType2[EffectType2["EFFECT_REALTIME_SUB"] = 0] = "EFFECT_REALTIME_SUB";
  EffectType2[EffectType2["EFFECT_RERENDER_UI"] = 1] = "EFFECT_RERENDER_UI";
  EffectType2[EffectType2["EFFECT_RELOAD_PART"] = 2] = "EFFECT_RELOAD_PART";
  EffectType2[EffectType2["EFFECT_SHOW_FORM"] = 3] = "EFFECT_SHOW_FORM";
  EffectType2[EffectType2["EFFECT_SHOW_TOAST"] = 4] = "EFFECT_SHOW_TOAST";
  EffectType2[EffectType2["EFFECT_VIEW_THING"] = 5] = "EFFECT_VIEW_THING";
  EffectType2[EffectType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(EffectType || (EffectType = {}));
function effectTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "EFFECT_REALTIME_SUB":
      return EffectType.EFFECT_REALTIME_SUB;
    case 1:
    case "EFFECT_RERENDER_UI":
      return EffectType.EFFECT_RERENDER_UI;
    case 2:
    case "EFFECT_RELOAD_PART":
      return EffectType.EFFECT_RELOAD_PART;
    case 3:
    case "EFFECT_SHOW_FORM":
      return EffectType.EFFECT_SHOW_FORM;
    case 4:
    case "EFFECT_SHOW_TOAST":
      return EffectType.EFFECT_SHOW_TOAST;
    case 5:
    case "EFFECT_VIEW_THING":
      return EffectType.EFFECT_VIEW_THING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectType.UNRECOGNIZED;
  }
}
function effectTypeToJSON(object) {
  switch (object) {
    case EffectType.EFFECT_REALTIME_SUB:
      return 0;
    case EffectType.EFFECT_RERENDER_UI:
      return 1;
    case EffectType.EFFECT_RELOAD_PART:
      return 2;
    case EffectType.EFFECT_SHOW_FORM:
      return 3;
    case EffectType.EFFECT_SHOW_TOAST:
      return 4;
    case EffectType.EFFECT_VIEW_THING:
      return 5;
    case EffectType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseEffect() {
  return {
    realtimeSubscriptions: void 0,
    rerenderUi: void 0,
    reloadPart: void 0,
    showForm: void 0,
    showToast: void 0,
    viewThing: void 0,
    type: 0
  };
}
var Effect = {
  $type: "devvit.ui.effects.v1alpha.Effect",
  encode(message, writer = import_minimal40.default.Writer.create()) {
    if (message.realtimeSubscriptions !== void 0) {
      RealtimeSubscriptionsEffect.encode(message.realtimeSubscriptions, writer.uint32(10).fork()).ldelim();
    }
    if (message.rerenderUi !== void 0) {
      RerenderEffect.encode(message.rerenderUi, writer.uint32(18).fork()).ldelim();
    }
    if (message.reloadPart !== void 0) {
      ReloadPartEffect.encode(message.reloadPart, writer.uint32(26).fork()).ldelim();
    }
    if (message.showForm !== void 0) {
      ShowFormEffect.encode(message.showForm, writer.uint32(34).fork()).ldelim();
    }
    if (message.showToast !== void 0) {
      ShowToastEffect.encode(message.showToast, writer.uint32(42).fork()).ldelim();
    }
    if (message.viewThing !== void 0) {
      ViewThingEffect.encode(message.viewThing, writer.uint32(50).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal40.default.Reader ? input : new import_minimal40.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.realtimeSubscriptions = RealtimeSubscriptionsEffect.decode(reader, reader.uint32());
          break;
        case 2:
          message.rerenderUi = RerenderEffect.decode(reader, reader.uint32());
          break;
        case 3:
          message.reloadPart = ReloadPartEffect.decode(reader, reader.uint32());
          break;
        case 4:
          message.showForm = ShowFormEffect.decode(reader, reader.uint32());
          break;
        case 5:
          message.showToast = ShowToastEffect.decode(reader, reader.uint32());
          break;
        case 6:
          message.viewThing = ViewThingEffect.decode(reader, reader.uint32());
          break;
        case 7:
          message.type = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      realtimeSubscriptions: isSet38(object.realtimeSubscriptions) ? RealtimeSubscriptionsEffect.fromJSON(object.realtimeSubscriptions) : void 0,
      rerenderUi: isSet38(object.rerenderUi) ? RerenderEffect.fromJSON(object.rerenderUi) : void 0,
      reloadPart: isSet38(object.reloadPart) ? ReloadPartEffect.fromJSON(object.reloadPart) : void 0,
      showForm: isSet38(object.showForm) ? ShowFormEffect.fromJSON(object.showForm) : void 0,
      showToast: isSet38(object.showToast) ? ShowToastEffect.fromJSON(object.showToast) : void 0,
      viewThing: isSet38(object.viewThing) ? ViewThingEffect.fromJSON(object.viewThing) : void 0,
      type: isSet38(object.type) ? effectTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.realtimeSubscriptions !== void 0 && (obj.realtimeSubscriptions = message.realtimeSubscriptions ? RealtimeSubscriptionsEffect.toJSON(message.realtimeSubscriptions) : void 0);
    message.rerenderUi !== void 0 && (obj.rerenderUi = message.rerenderUi ? RerenderEffect.toJSON(message.rerenderUi) : void 0);
    message.reloadPart !== void 0 && (obj.reloadPart = message.reloadPart ? ReloadPartEffect.toJSON(message.reloadPart) : void 0);
    message.showForm !== void 0 && (obj.showForm = message.showForm ? ShowFormEffect.toJSON(message.showForm) : void 0);
    message.showToast !== void 0 && (obj.showToast = message.showToast ? ShowToastEffect.toJSON(message.showToast) : void 0);
    message.viewThing !== void 0 && (obj.viewThing = message.viewThing ? ViewThingEffect.toJSON(message.viewThing) : void 0);
    message.type !== void 0 && (obj.type = effectTypeToJSON(message.type));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEffect();
    message.realtimeSubscriptions = object.realtimeSubscriptions !== void 0 && object.realtimeSubscriptions !== null ? RealtimeSubscriptionsEffect.fromPartial(object.realtimeSubscriptions) : void 0;
    message.rerenderUi = object.rerenderUi !== void 0 && object.rerenderUi !== null ? RerenderEffect.fromPartial(object.rerenderUi) : void 0;
    message.reloadPart = object.reloadPart !== void 0 && object.reloadPart !== null ? ReloadPartEffect.fromPartial(object.reloadPart) : void 0;
    message.showForm = object.showForm !== void 0 && object.showForm !== null ? ShowFormEffect.fromPartial(object.showForm) : void 0;
    message.showToast = object.showToast !== void 0 && object.showToast !== null ? ShowToastEffect.fromPartial(object.showToast) : void 0;
    message.viewThing = object.viewThing !== void 0 && object.viewThing !== null ? ViewThingEffect.fromPartial(object.viewThing) : void 0;
    message.type = object.type ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.effects.v1alpha.Effect", Effect);
function isSet38(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/reddit/context_type.js
var ContextType;
(function(ContextType2) {
  ContextType2[ContextType2["POST"] = 0] = "POST";
  ContextType2[ContextType2["COMMENT"] = 1] = "COMMENT";
  ContextType2[ContextType2["SUBREDDIT"] = 2] = "SUBREDDIT";
  ContextType2[ContextType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ContextType || (ContextType = {}));
function contextTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "POST":
      return ContextType.POST;
    case 1:
    case "COMMENT":
      return ContextType.COMMENT;
    case 2:
    case "SUBREDDIT":
      return ContextType.SUBREDDIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ContextType.UNRECOGNIZED;
  }
}
function contextTypeToJSON(object) {
  switch (object) {
    case ContextType.POST:
      return 0;
    case ContextType.COMMENT:
      return 1;
    case ContextType.SUBREDDIT:
      return 2;
    case ContextType.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/actor/reddit/context_action.js
function createBaseContextActionAllowedContexts() {
  return { post: false, comment: false, subreddit: false };
}
var ContextActionAllowedContexts = {
  $type: "devvit.actor.reddit.ContextActionAllowedContexts",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    if (message.post === true) {
      writer.uint32(8).bool(message.post);
    }
    if (message.comment === true) {
      writer.uint32(16).bool(message.comment);
    }
    if (message.subreddit === true) {
      writer.uint32(24).bool(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : new import_minimal41.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionAllowedContexts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.post = reader.bool();
          break;
        case 2:
          message.comment = reader.bool();
          break;
        case 3:
          message.subreddit = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      post: isSet39(object.post) ? Boolean(object.post) : false,
      comment: isSet39(object.comment) ? Boolean(object.comment) : false,
      subreddit: isSet39(object.subreddit) ? Boolean(object.subreddit) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.post !== void 0 && (obj.post = message.post);
    message.comment !== void 0 && (obj.comment = message.comment);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseContextActionAllowedContexts();
    message.post = object.post ?? false;
    message.comment = object.comment ?? false;
    message.subreddit = object.subreddit ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.reddit.ContextActionAllowedContexts", ContextActionAllowedContexts);
function createBaseContextActionAllowedUsers() {
  return { moderator: false, member: false, loggedOut: false };
}
var ContextActionAllowedUsers = {
  $type: "devvit.actor.reddit.ContextActionAllowedUsers",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    if (message.moderator === true) {
      writer.uint32(8).bool(message.moderator);
    }
    if (message.member === true) {
      writer.uint32(16).bool(message.member);
    }
    if (message.loggedOut === true) {
      writer.uint32(24).bool(message.loggedOut);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : new import_minimal41.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionAllowedUsers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.moderator = reader.bool();
          break;
        case 2:
          message.member = reader.bool();
          break;
        case 3:
          message.loggedOut = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      moderator: isSet39(object.moderator) ? Boolean(object.moderator) : false,
      member: isSet39(object.member) ? Boolean(object.member) : false,
      loggedOut: isSet39(object.loggedOut) ? Boolean(object.loggedOut) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.moderator !== void 0 && (obj.moderator = message.moderator);
    message.member !== void 0 && (obj.member = message.member);
    message.loggedOut !== void 0 && (obj.loggedOut = message.loggedOut);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseContextActionAllowedUsers();
    message.moderator = object.moderator ?? false;
    message.member = object.member ?? false;
    message.loggedOut = object.loggedOut ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.reddit.ContextActionAllowedUsers", ContextActionAllowedUsers);
function createBaseContextActionDescription() {
  return { actionId: "", name: "", description: "", contexts: void 0, users: void 0, userInput: void 0 };
}
var ContextActionDescription = {
  $type: "devvit.actor.reddit.ContextActionDescription",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    if (message.actionId !== "") {
      writer.uint32(10).string(message.actionId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.contexts !== void 0) {
      ContextActionAllowedContexts.encode(message.contexts, writer.uint32(34).fork()).ldelim();
    }
    if (message.users !== void 0) {
      ContextActionAllowedUsers.encode(message.users, writer.uint32(42).fork()).ldelim();
    }
    if (message.userInput !== void 0) {
      ConfigForm.encode(message.userInput, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : new import_minimal41.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actionId = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          message.contexts = ContextActionAllowedContexts.decode(reader, reader.uint32());
          break;
        case 5:
          message.users = ContextActionAllowedUsers.decode(reader, reader.uint32());
          break;
        case 6:
          message.userInput = ConfigForm.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actionId: isSet39(object.actionId) ? String(object.actionId) : "",
      name: isSet39(object.name) ? String(object.name) : "",
      description: isSet39(object.description) ? String(object.description) : "",
      contexts: isSet39(object.contexts) ? ContextActionAllowedContexts.fromJSON(object.contexts) : void 0,
      users: isSet39(object.users) ? ContextActionAllowedUsers.fromJSON(object.users) : void 0,
      userInput: isSet39(object.userInput) ? ConfigForm.fromJSON(object.userInput) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.actionId !== void 0 && (obj.actionId = message.actionId);
    message.name !== void 0 && (obj.name = message.name);
    message.description !== void 0 && (obj.description = message.description);
    message.contexts !== void 0 && (obj.contexts = message.contexts ? ContextActionAllowedContexts.toJSON(message.contexts) : void 0);
    message.users !== void 0 && (obj.users = message.users ? ContextActionAllowedUsers.toJSON(message.users) : void 0);
    message.userInput !== void 0 && (obj.userInput = message.userInput ? ConfigForm.toJSON(message.userInput) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseContextActionDescription();
    message.actionId = object.actionId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.contexts = object.contexts !== void 0 && object.contexts !== null ? ContextActionAllowedContexts.fromPartial(object.contexts) : void 0;
    message.users = object.users !== void 0 && object.users !== null ? ContextActionAllowedUsers.fromPartial(object.users) : void 0;
    message.userInput = object.userInput !== void 0 && object.userInput !== null ? ConfigForm.fromPartial(object.userInput) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.reddit.ContextActionDescription", ContextActionDescription);
function createBaseContextActionList() {
  return { actions: [] };
}
var ContextActionList = {
  $type: "devvit.actor.reddit.ContextActionList",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    for (const v of message.actions) {
      ContextActionDescription.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : new import_minimal41.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actions.push(ContextActionDescription.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actions: Array.isArray(object?.actions) ? object.actions.map((e) => ContextActionDescription.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actions) {
      obj.actions = message.actions.map((e) => e ? ContextActionDescription.toJSON(e) : void 0);
    } else {
      obj.actions = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseContextActionList();
    message.actions = object.actions?.map((e) => ContextActionDescription.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.reddit.ContextActionList", ContextActionList);
function createBaseContextActionRequest() {
  return { actionId: "", context: 0, post: void 0, comment: void 0, subreddit: void 0, userInput: void 0 };
}
var ContextActionRequest = {
  $type: "devvit.actor.reddit.ContextActionRequest",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    if (message.actionId !== "") {
      writer.uint32(10).string(message.actionId);
    }
    if (message.context !== 0) {
      writer.uint32(16).int32(message.context);
    }
    if (message.post !== void 0) {
      RedditObject.encode(message.post, writer.uint32(26).fork()).ldelim();
    }
    if (message.comment !== void 0) {
      RedditObject.encode(message.comment, writer.uint32(34).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      SubredditObject.encode(message.subreddit, writer.uint32(42).fork()).ldelim();
    }
    if (message.userInput !== void 0) {
      ConfigForm.encode(message.userInput, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : new import_minimal41.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actionId = reader.string();
          break;
        case 2:
          message.context = reader.int32();
          break;
        case 3:
          message.post = RedditObject.decode(reader, reader.uint32());
          break;
        case 4:
          message.comment = RedditObject.decode(reader, reader.uint32());
          break;
        case 5:
          message.subreddit = SubredditObject.decode(reader, reader.uint32());
          break;
        case 6:
          message.userInput = ConfigForm.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actionId: isSet39(object.actionId) ? String(object.actionId) : "",
      context: isSet39(object.context) ? contextTypeFromJSON(object.context) : 0,
      post: isSet39(object.post) ? RedditObject.fromJSON(object.post) : void 0,
      comment: isSet39(object.comment) ? RedditObject.fromJSON(object.comment) : void 0,
      subreddit: isSet39(object.subreddit) ? SubredditObject.fromJSON(object.subreddit) : void 0,
      userInput: isSet39(object.userInput) ? ConfigForm.fromJSON(object.userInput) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.actionId !== void 0 && (obj.actionId = message.actionId);
    message.context !== void 0 && (obj.context = contextTypeToJSON(message.context));
    message.post !== void 0 && (obj.post = message.post ? RedditObject.toJSON(message.post) : void 0);
    message.comment !== void 0 && (obj.comment = message.comment ? RedditObject.toJSON(message.comment) : void 0);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? SubredditObject.toJSON(message.subreddit) : void 0);
    message.userInput !== void 0 && (obj.userInput = message.userInput ? ConfigForm.toJSON(message.userInput) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseContextActionRequest();
    message.actionId = object.actionId ?? "";
    message.context = object.context ?? 0;
    message.post = object.post !== void 0 && object.post !== null ? RedditObject.fromPartial(object.post) : void 0;
    message.comment = object.comment !== void 0 && object.comment !== null ? RedditObject.fromPartial(object.comment) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? SubredditObject.fromPartial(object.subreddit) : void 0;
    message.userInput = object.userInput !== void 0 && object.userInput !== null ? ConfigForm.fromPartial(object.userInput) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.reddit.ContextActionRequest", ContextActionRequest);
function createBaseContextActionResponse() {
  return { success: false, message: "", effects: [] };
}
var ContextActionResponse = {
  $type: "devvit.actor.reddit.ContextActionResponse",
  encode(message, writer = import_minimal41.default.Writer.create()) {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.effects) {
      Effect.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal41.default.Reader ? input : new import_minimal41.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContextActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.success = reader.bool();
          break;
        case 2:
          message.message = reader.string();
          break;
        case 3:
          message.effects.push(Effect.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet39(object.success) ? Boolean(object.success) : false,
      message: isSet39(object.message) ? String(object.message) : "",
      effects: Array.isArray(object?.effects) ? object.effects.map((e) => Effect.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.success !== void 0 && (obj.success = message.success);
    message.message !== void 0 && (obj.message = message.message);
    if (message.effects) {
      obj.effects = message.effects.map((e) => e ? Effect.toJSON(e) : void 0);
    } else {
      obj.effects = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseContextActionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.reddit.ContextActionResponse", ContextActionResponse);
function isSet39(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/reddit/post_filter.js
var import_minimal42 = __toESM(require_minimal2(), 1);
function createBasePostFilterRequest() {
  return { post: void 0 };
}
var PostFilterRequest = {
  $type: "devvit.actor.reddit.PostFilterRequest",
  encode(message, writer = import_minimal42.default.Writer.create()) {
    if (message.post !== void 0) {
      Post.encode(message.post, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal42.default.Reader ? input : new import_minimal42.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostFilterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.post = Post.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { post: isSet40(object.post) ? Post.fromJSON(object.post) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.post !== void 0 && (obj.post = message.post ? Post.toJSON(message.post) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePostFilterRequest();
    message.post = object.post !== void 0 && object.post !== null ? Post.fromPartial(object.post) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.reddit.PostFilterRequest", PostFilterRequest);
function createBaseResponse() {
  return { accepted: false };
}
var Response = {
  $type: "devvit.actor.reddit.Response",
  encode(message, writer = import_minimal42.default.Writer.create()) {
    if (message.accepted === true) {
      writer.uint32(8).bool(message.accepted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal42.default.Reader ? input : new import_minimal42.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accepted = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { accepted: isSet40(object.accepted) ? Boolean(object.accepted) : false };
  },
  toJSON(message) {
    const obj = {};
    message.accepted !== void 0 && (obj.accepted = message.accepted);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseResponse();
    message.accepted = object.accepted ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.reddit.Response", Response);
function isSet40(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/scheduler/action.js
var import_minimal43 = __toESM(require_minimal2(), 1);
function createBaseScheduledAction() {
  return { type: "", data: void 0 };
}
var ScheduledAction = {
  $type: "devvit.actor.scheduler.ScheduledAction",
  encode(message, writer = import_minimal43.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.data !== void 0) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal43.default.Reader ? input : new import_minimal43.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseScheduledAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.string();
          break;
        case 2:
          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet41(object.type) ? String(object.type) : "",
      data: isObject4(object.data) ? object.data : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    message.data !== void 0 && (obj.data = message.data);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseScheduledAction();
    message.type = object.type ?? "";
    message.data = object.data ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.scheduler.ScheduledAction", ScheduledAction);
function isObject4(value) {
  return typeof value === "object" && value !== null;
}
function isSet41(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/scheduler/handler.js
var import_minimal44 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/actor/settings/v1alpha/installation_settings.js
var import_minimal46 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/actor/settings/v1alpha/shared.js
var import_minimal45 = __toESM(require_minimal2(), 1);
function createBaseGetFieldsRequest() {
  return { editing: false };
}
var GetFieldsRequest = {
  $type: "devvit.actor.settings.v1alpha.GetFieldsRequest",
  encode(message, writer = import_minimal45.default.Writer.create()) {
    if (message.editing === true) {
      writer.uint32(8).bool(message.editing);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal45.default.Reader ? input : new import_minimal45.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetFieldsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.editing = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { editing: isSet42(object.editing) ? Boolean(object.editing) : false };
  },
  toJSON(message) {
    const obj = {};
    message.editing !== void 0 && (obj.editing = message.editing);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetFieldsRequest();
    message.editing = object.editing ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.settings.v1alpha.GetFieldsRequest", GetFieldsRequest);
function createBaseGetFieldsResponse() {
  return { fields: void 0 };
}
var GetFieldsResponse = {
  $type: "devvit.actor.settings.v1alpha.GetFieldsResponse",
  encode(message, writer = import_minimal45.default.Writer.create()) {
    if (message.fields !== void 0) {
      Form.encode(message.fields, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal45.default.Reader ? input : new import_minimal45.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetFieldsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fields = Form.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { fields: isSet42(object.fields) ? Form.fromJSON(object.fields) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.fields !== void 0 && (obj.fields = message.fields ? Form.toJSON(message.fields) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetFieldsResponse();
    message.fields = object.fields !== void 0 && object.fields !== null ? Form.fromPartial(object.fields) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.settings.v1alpha.GetFieldsResponse", GetFieldsResponse);
function createBaseValidateFormRequest() {
  return { editing: false, fieldValues: {} };
}
var ValidateFormRequest = {
  $type: "devvit.actor.settings.v1alpha.ValidateFormRequest",
  encode(message, writer = import_minimal45.default.Writer.create()) {
    if (message.editing === true) {
      writer.uint32(8).bool(message.editing);
    }
    Object.entries(message.fieldValues).forEach(([key, value]) => {
      ValidateFormRequest_FieldValuesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal45.default.Reader ? input : new import_minimal45.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateFormRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.editing = reader.bool();
          break;
        case 2:
          const entry2 = ValidateFormRequest_FieldValuesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.fieldValues[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      editing: isSet42(object.editing) ? Boolean(object.editing) : false,
      fieldValues: isObject5(object.fieldValues) ? Object.entries(object.fieldValues).reduce((acc, [key, value]) => {
        acc[key] = FormFieldValue.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.editing !== void 0 && (obj.editing = message.editing);
    obj.fieldValues = {};
    if (message.fieldValues) {
      Object.entries(message.fieldValues).forEach(([k, v]) => {
        obj.fieldValues[k] = FormFieldValue.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseValidateFormRequest();
    message.editing = object.editing ?? false;
    message.fieldValues = Object.entries(object.fieldValues ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = FormFieldValue.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.settings.v1alpha.ValidateFormRequest", ValidateFormRequest);
function createBaseValidateFormRequest_FieldValuesEntry() {
  return { key: "", value: void 0 };
}
var ValidateFormRequest_FieldValuesEntry = {
  $type: "devvit.actor.settings.v1alpha.ValidateFormRequest.FieldValuesEntry",
  encode(message, writer = import_minimal45.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      FormFieldValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal45.default.Reader ? input : new import_minimal45.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateFormRequest_FieldValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = FormFieldValue.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet42(object.key) ? String(object.key) : "",
      value: isSet42(object.value) ? FormFieldValue.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? FormFieldValue.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseValidateFormRequest_FieldValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? FormFieldValue.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.settings.v1alpha.ValidateFormRequest.FieldValuesEntry", ValidateFormRequest_FieldValuesEntry);
function createBaseValidateFormResponse() {
  return { success: false, errors: {} };
}
var ValidateFormResponse = {
  $type: "devvit.actor.settings.v1alpha.ValidateFormResponse",
  encode(message, writer = import_minimal45.default.Writer.create()) {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    Object.entries(message.errors).forEach(([key, value]) => {
      ValidateFormResponse_ErrorsEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal45.default.Reader ? input : new import_minimal45.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateFormResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.success = reader.bool();
          break;
        case 2:
          const entry2 = ValidateFormResponse_ErrorsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.errors[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet42(object.success) ? Boolean(object.success) : false,
      errors: isObject5(object.errors) ? Object.entries(object.errors).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.success !== void 0 && (obj.success = message.success);
    obj.errors = {};
    if (message.errors) {
      Object.entries(message.errors).forEach(([k, v]) => {
        obj.errors[k] = v;
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseValidateFormResponse();
    message.success = object.success ?? false;
    message.errors = Object.entries(object.errors ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.settings.v1alpha.ValidateFormResponse", ValidateFormResponse);
function createBaseValidateFormResponse_ErrorsEntry() {
  return { key: "", value: "" };
}
var ValidateFormResponse_ErrorsEntry = {
  $type: "devvit.actor.settings.v1alpha.ValidateFormResponse.ErrorsEntry",
  encode(message, writer = import_minimal45.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal45.default.Reader ? input : new import_minimal45.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateFormResponse_ErrorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet42(object.key) ? String(object.key) : "", value: isSet42(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseValidateFormResponse_ErrorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.settings.v1alpha.ValidateFormResponse.ErrorsEntry", ValidateFormResponse_ErrorsEntry);
function isObject5(value) {
  return typeof value === "object" && value !== null;
}
function isSet42(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/actor/settings/v1alpha/instance_settings.js
var import_minimal47 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/actor/test/streams.js
var import_minimal48 = __toESM(require_minimal2(), 1);
function createBaseTestMessage() {
  return { number: 0 };
}
var TestMessage = {
  $type: "devvit.actor.test.TestMessage",
  encode(message, writer = import_minimal48.default.Writer.create()) {
    if (message.number !== 0) {
      writer.uint32(8).int32(message.number);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal48.default.Reader ? input : new import_minimal48.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.number = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { number: isSet43(object.number) ? Number(object.number) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.number !== void 0 && (obj.number = Math.round(message.number));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTestMessage();
    message.number = object.number ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.actor.test.TestMessage", TestMessage);
function isSet43(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/data/firehose/v1alpha/firehose.js
var import_minimal51 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/google/protobuf/timestamp.js
var import_long4 = __toESM(require_long(), 1);
var import_minimal49 = __toESM(require_minimal2(), 1);
function createBaseTimestamp() {
  return { seconds: 0, nanos: 0 };
}
var Timestamp = {
  $type: "google.protobuf.Timestamp",
  encode(message, writer = import_minimal49.default.Writer.create()) {
    if (message.seconds !== 0) {
      writer.uint32(8).int64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal49.default.Reader ? input : new import_minimal49.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.seconds = longToNumber4(reader.int64());
          break;
        case 2:
          message.nanos = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      seconds: isSet44(object.seconds) ? Number(object.seconds) : 0,
      nanos: isSet44(object.nanos) ? Number(object.nanos) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.seconds !== void 0 && (obj.seconds = Math.round(message.seconds));
    message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTimestamp();
    message.seconds = object.seconds ?? 0;
    message.nanos = object.nanos ?? 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.Timestamp", Timestamp);
var globalThis6 = (() => {
  if (typeof globalThis6 !== "undefined") {
    return globalThis6;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function longToNumber4(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis6.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal49.default.util.Long !== import_long4.default) {
  import_minimal49.default.util.Long = import_long4.default;
  import_minimal49.default.configure();
}
function isSet44(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/data/triggers/v1alpha/triggers.js
var import_minimal50 = __toESM(require_minimal2(), 1);
function createBaseTriggerEvent() {
  return {
    id: "",
    timestamp: void 0,
    subreddit: "",
    postSubmit: void 0,
    postUpdate: void 0,
    postReport: void 0,
    commentSubmit: void 0,
    commentUpdate: void 0,
    commentReport: void 0,
    subredditSubscribe: void 0,
    appInstall: void 0,
    appUpgrade: void 0
  };
}
var TriggerEvent = {
  $type: "devvit.data.triggers.v1alpha.TriggerEvent",
  encode(message, writer = import_minimal50.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (message.subreddit !== "") {
      writer.uint32(26).string(message.subreddit);
    }
    if (message.postSubmit !== void 0) {
      PostSubmit.encode(message.postSubmit, writer.uint32(802).fork()).ldelim();
    }
    if (message.postUpdate !== void 0) {
      PostUpdate.encode(message.postUpdate, writer.uint32(810).fork()).ldelim();
    }
    if (message.postReport !== void 0) {
      PostReport.encode(message.postReport, writer.uint32(818).fork()).ldelim();
    }
    if (message.commentSubmit !== void 0) {
      CommentSubmit.encode(message.commentSubmit, writer.uint32(826).fork()).ldelim();
    }
    if (message.commentUpdate !== void 0) {
      CommentUpdate.encode(message.commentUpdate, writer.uint32(834).fork()).ldelim();
    }
    if (message.commentReport !== void 0) {
      CommentReport.encode(message.commentReport, writer.uint32(842).fork()).ldelim();
    }
    if (message.subredditSubscribe !== void 0) {
      SubredditSubscribe.encode(message.subredditSubscribe, writer.uint32(850).fork()).ldelim();
    }
    if (message.appInstall !== void 0) {
      AppInstall.encode(message.appInstall, writer.uint32(858).fork()).ldelim();
    }
    if (message.appUpgrade !== void 0) {
      AppUpgrade.encode(message.appUpgrade, writer.uint32(866).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal50.default.Reader ? input : new import_minimal50.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTriggerEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 3:
          message.subreddit = reader.string();
          break;
        case 100:
          message.postSubmit = PostSubmit.decode(reader, reader.uint32());
          break;
        case 101:
          message.postUpdate = PostUpdate.decode(reader, reader.uint32());
          break;
        case 102:
          message.postReport = PostReport.decode(reader, reader.uint32());
          break;
        case 103:
          message.commentSubmit = CommentSubmit.decode(reader, reader.uint32());
          break;
        case 104:
          message.commentUpdate = CommentUpdate.decode(reader, reader.uint32());
          break;
        case 105:
          message.commentReport = CommentReport.decode(reader, reader.uint32());
          break;
        case 106:
          message.subredditSubscribe = SubredditSubscribe.decode(reader, reader.uint32());
          break;
        case 107:
          message.appInstall = AppInstall.decode(reader, reader.uint32());
          break;
        case 108:
          message.appUpgrade = AppUpgrade.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet45(object.id) ? String(object.id) : "",
      timestamp: isSet45(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0,
      subreddit: isSet45(object.subreddit) ? String(object.subreddit) : "",
      postSubmit: isSet45(object.postSubmit) ? PostSubmit.fromJSON(object.postSubmit) : void 0,
      postUpdate: isSet45(object.postUpdate) ? PostUpdate.fromJSON(object.postUpdate) : void 0,
      postReport: isSet45(object.postReport) ? PostReport.fromJSON(object.postReport) : void 0,
      commentSubmit: isSet45(object.commentSubmit) ? CommentSubmit.fromJSON(object.commentSubmit) : void 0,
      commentUpdate: isSet45(object.commentUpdate) ? CommentUpdate.fromJSON(object.commentUpdate) : void 0,
      commentReport: isSet45(object.commentReport) ? CommentReport.fromJSON(object.commentReport) : void 0,
      subredditSubscribe: isSet45(object.subredditSubscribe) ? SubredditSubscribe.fromJSON(object.subredditSubscribe) : void 0,
      appInstall: isSet45(object.appInstall) ? AppInstall.fromJSON(object.appInstall) : void 0,
      appUpgrade: isSet45(object.appUpgrade) ? AppUpgrade.fromJSON(object.appUpgrade) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.postSubmit !== void 0 && (obj.postSubmit = message.postSubmit ? PostSubmit.toJSON(message.postSubmit) : void 0);
    message.postUpdate !== void 0 && (obj.postUpdate = message.postUpdate ? PostUpdate.toJSON(message.postUpdate) : void 0);
    message.postReport !== void 0 && (obj.postReport = message.postReport ? PostReport.toJSON(message.postReport) : void 0);
    message.commentSubmit !== void 0 && (obj.commentSubmit = message.commentSubmit ? CommentSubmit.toJSON(message.commentSubmit) : void 0);
    message.commentUpdate !== void 0 && (obj.commentUpdate = message.commentUpdate ? CommentUpdate.toJSON(message.commentUpdate) : void 0);
    message.commentReport !== void 0 && (obj.commentReport = message.commentReport ? CommentReport.toJSON(message.commentReport) : void 0);
    message.subredditSubscribe !== void 0 && (obj.subredditSubscribe = message.subredditSubscribe ? SubredditSubscribe.toJSON(message.subredditSubscribe) : void 0);
    message.appInstall !== void 0 && (obj.appInstall = message.appInstall ? AppInstall.toJSON(message.appInstall) : void 0);
    message.appUpgrade !== void 0 && (obj.appUpgrade = message.appUpgrade ? AppUpgrade.toJSON(message.appUpgrade) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTriggerEvent();
    message.id = object.id ?? "";
    message.timestamp = object.timestamp ?? void 0;
    message.subreddit = object.subreddit ?? "";
    message.postSubmit = object.postSubmit !== void 0 && object.postSubmit !== null ? PostSubmit.fromPartial(object.postSubmit) : void 0;
    message.postUpdate = object.postUpdate !== void 0 && object.postUpdate !== null ? PostUpdate.fromPartial(object.postUpdate) : void 0;
    message.postReport = object.postReport !== void 0 && object.postReport !== null ? PostReport.fromPartial(object.postReport) : void 0;
    message.commentSubmit = object.commentSubmit !== void 0 && object.commentSubmit !== null ? CommentSubmit.fromPartial(object.commentSubmit) : void 0;
    message.commentUpdate = object.commentUpdate !== void 0 && object.commentUpdate !== null ? CommentUpdate.fromPartial(object.commentUpdate) : void 0;
    message.commentReport = object.commentReport !== void 0 && object.commentReport !== null ? CommentReport.fromPartial(object.commentReport) : void 0;
    message.subredditSubscribe = object.subredditSubscribe !== void 0 && object.subredditSubscribe !== null ? SubredditSubscribe.fromPartial(object.subredditSubscribe) : void 0;
    message.appInstall = object.appInstall !== void 0 && object.appInstall !== null ? AppInstall.fromPartial(object.appInstall) : void 0;
    message.appUpgrade = object.appUpgrade !== void 0 && object.appUpgrade !== null ? AppUpgrade.fromPartial(object.appUpgrade) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.data.triggers.v1alpha.TriggerEvent", TriggerEvent);
function toTimestamp(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}
function isSet45(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/data/firehose/v1alpha/firehose.js
function createBaseFirehoseRequest() {
  return { streamId: "", max: 0, ts: void 0, last: "", events: [], keepAlive: false };
}
var FirehoseRequest = {
  $type: "devvit.data.firehose.v1alpha.FirehoseRequest",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.streamId !== "") {
      writer.uint32(10).string(message.streamId);
    }
    if (message.max !== 0) {
      writer.uint32(16).int32(message.max);
    }
    if (message.ts !== void 0) {
      Timestamp.encode(toTimestamp2(message.ts), writer.uint32(26).fork()).ldelim();
    }
    if (message.last !== "") {
      writer.uint32(34).string(message.last);
    }
    for (const v of message.events) {
      writer.uint32(42).string(v);
    }
    if (message.keepAlive === true) {
      writer.uint32(48).bool(message.keepAlive);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : new import_minimal51.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFirehoseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.streamId = reader.string();
          break;
        case 2:
          message.max = reader.int32();
          break;
        case 3:
          message.ts = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));
          break;
        case 4:
          message.last = reader.string();
          break;
        case 5:
          message.events.push(reader.string());
          break;
        case 6:
          message.keepAlive = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      streamId: isSet46(object.streamId) ? String(object.streamId) : "",
      max: isSet46(object.max) ? Number(object.max) : 0,
      ts: isSet46(object.ts) ? fromJsonTimestamp2(object.ts) : void 0,
      last: isSet46(object.last) ? String(object.last) : "",
      events: Array.isArray(object?.events) ? object.events.map((e) => String(e)) : [],
      keepAlive: isSet46(object.keepAlive) ? Boolean(object.keepAlive) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.streamId !== void 0 && (obj.streamId = message.streamId);
    message.max !== void 0 && (obj.max = Math.round(message.max));
    message.ts !== void 0 && (obj.ts = message.ts.toISOString());
    message.last !== void 0 && (obj.last = message.last);
    if (message.events) {
      obj.events = message.events.map((e) => e);
    } else {
      obj.events = [];
    }
    message.keepAlive !== void 0 && (obj.keepAlive = message.keepAlive);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFirehoseRequest();
    message.streamId = object.streamId ?? "";
    message.max = object.max ?? 0;
    message.ts = object.ts ?? void 0;
    message.last = object.last ?? "";
    message.events = object.events?.map((e) => e) || [];
    message.keepAlive = object.keepAlive ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.data.firehose.v1alpha.FirehoseRequest", FirehoseRequest);
function createBaseFirehoseReply() {
  return { event: void 0 };
}
var FirehoseReply = {
  $type: "devvit.data.firehose.v1alpha.FirehoseReply",
  encode(message, writer = import_minimal51.default.Writer.create()) {
    if (message.event !== void 0) {
      TriggerEvent.encode(message.event, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal51.default.Reader ? input : new import_minimal51.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFirehoseReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.event = TriggerEvent.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { event: isSet46(object.event) ? TriggerEvent.fromJSON(object.event) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.event !== void 0 && (obj.event = message.event ? TriggerEvent.toJSON(message.event) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFirehoseReply();
    message.event = object.event !== void 0 && object.event !== null ? TriggerEvent.fromPartial(object.event) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.data.firehose.v1alpha.FirehoseReply", FirehoseReply);
function toTimestamp2(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp2(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp2(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp2(Timestamp.fromJSON(o));
  }
}
function isSet46(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/actor/actor_type.js
var import_minimal52 = __toESM(require_minimal2(), 1);
function createBaseActorTypeInfo() {
  return { id: "", name: "", isEnabled: false };
}
var ActorTypeInfo = {
  $type: "devvit.dev_portal.actor.ActorTypeInfo",
  encode(message, writer = import_minimal52.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.isEnabled === true) {
      writer.uint32(24).bool(message.isEnabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal52.default.Reader ? input : new import_minimal52.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseActorTypeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.isEnabled = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet47(object.id) ? String(object.id) : "",
      name: isSet47(object.name) ? String(object.name) : "",
      isEnabled: isSet47(object.isEnabled) ? Boolean(object.isEnabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.name !== void 0 && (obj.name = message.name);
    message.isEnabled !== void 0 && (obj.isEnabled = message.isEnabled);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseActorTypeInfo();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.isEnabled = object.isEnabled ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.actor.ActorTypeInfo", ActorTypeInfo);
function isSet47(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/admin/waitlist_admin.js
var import_minimal53 = __toESM(require_minimal2(), 1);
var WaitlistStatus;
(function(WaitlistStatus2) {
  WaitlistStatus2[WaitlistStatus2["PENDING"] = 0] = "PENDING";
  WaitlistStatus2[WaitlistStatus2["ACCEPTED"] = 1] = "ACCEPTED";
  WaitlistStatus2[WaitlistStatus2["REJECTED"] = 2] = "REJECTED";
  WaitlistStatus2[WaitlistStatus2["REVOKED"] = 3] = "REVOKED";
  WaitlistStatus2[WaitlistStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(WaitlistStatus || (WaitlistStatus = {}));
function waitlistStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "PENDING":
      return WaitlistStatus.PENDING;
    case 1:
    case "ACCEPTED":
      return WaitlistStatus.ACCEPTED;
    case 2:
    case "REJECTED":
      return WaitlistStatus.REJECTED;
    case 3:
    case "REVOKED":
      return WaitlistStatus.REVOKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WaitlistStatus.UNRECOGNIZED;
  }
}
function waitlistStatusToJSON(object) {
  switch (object) {
    case WaitlistStatus.PENDING:
      return 0;
    case WaitlistStatus.ACCEPTED:
      return 1;
    case WaitlistStatus.REJECTED:
      return 2;
    case WaitlistStatus.REVOKED:
      return 3;
    case WaitlistStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseSubmission() {
  return {
    id: "",
    userId: "",
    userName: "",
    whatToBuild: "",
    botsBuilt: "",
    createdAt: void 0,
    updatedAt: void 0,
    status: 0,
    acceptedTermsVersion: 0
  };
}
var Submission = {
  $type: "devvit.dev_portal.admin.Submission",
  encode(message, writer = import_minimal53.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(26).string(message.userName);
    }
    if (message.whatToBuild !== "") {
      writer.uint32(34).string(message.whatToBuild);
    }
    if (message.botsBuilt !== "") {
      writer.uint32(42).string(message.botsBuilt);
    }
    if (message.createdAt !== void 0) {
      Timestamp.encode(toTimestamp3(message.createdAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.updatedAt !== void 0) {
      Timestamp.encode(toTimestamp3(message.updatedAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.acceptedTermsVersion !== 0) {
      writer.uint32(72).int32(message.acceptedTermsVersion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal53.default.Reader ? input : new import_minimal53.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.userId = reader.string();
          break;
        case 3:
          message.userName = reader.string();
          break;
        case 4:
          message.whatToBuild = reader.string();
          break;
        case 5:
          message.botsBuilt = reader.string();
          break;
        case 6:
          message.createdAt = fromTimestamp3(Timestamp.decode(reader, reader.uint32()));
          break;
        case 7:
          message.updatedAt = fromTimestamp3(Timestamp.decode(reader, reader.uint32()));
          break;
        case 8:
          message.status = reader.int32();
          break;
        case 9:
          message.acceptedTermsVersion = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet48(object.id) ? String(object.id) : "",
      userId: isSet48(object.userId) ? String(object.userId) : "",
      userName: isSet48(object.userName) ? String(object.userName) : "",
      whatToBuild: isSet48(object.whatToBuild) ? String(object.whatToBuild) : "",
      botsBuilt: isSet48(object.botsBuilt) ? String(object.botsBuilt) : "",
      createdAt: isSet48(object.createdAt) ? fromJsonTimestamp3(object.createdAt) : void 0,
      updatedAt: isSet48(object.updatedAt) ? fromJsonTimestamp3(object.updatedAt) : void 0,
      status: isSet48(object.status) ? waitlistStatusFromJSON(object.status) : 0,
      acceptedTermsVersion: isSet48(object.acceptedTermsVersion) ? Number(object.acceptedTermsVersion) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.userId !== void 0 && (obj.userId = message.userId);
    message.userName !== void 0 && (obj.userName = message.userName);
    message.whatToBuild !== void 0 && (obj.whatToBuild = message.whatToBuild);
    message.botsBuilt !== void 0 && (obj.botsBuilt = message.botsBuilt);
    message.createdAt !== void 0 && (obj.createdAt = message.createdAt.toISOString());
    message.updatedAt !== void 0 && (obj.updatedAt = message.updatedAt.toISOString());
    message.status !== void 0 && (obj.status = waitlistStatusToJSON(message.status));
    message.acceptedTermsVersion !== void 0 && (obj.acceptedTermsVersion = Math.round(message.acceptedTermsVersion));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubmission();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.whatToBuild = object.whatToBuild ?? "";
    message.botsBuilt = object.botsBuilt ?? "";
    message.createdAt = object.createdAt ?? void 0;
    message.updatedAt = object.updatedAt ?? void 0;
    message.status = object.status ?? 0;
    message.acceptedTermsVersion = object.acceptedTermsVersion ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.admin.Submission", Submission);
function createBaseSubmissionsRequest() {
  return { limit: 0, after: void 0, before: void 0, username: void 0 };
}
var SubmissionsRequest = {
  $type: "devvit.dev_portal.admin.SubmissionsRequest",
  encode(message, writer = import_minimal53.default.Writer.create()) {
    if (message.limit !== 0) {
      writer.uint32(8).int32(message.limit);
    }
    if (message.after !== void 0) {
      Timestamp.encode(toTimestamp3(message.after), writer.uint32(18).fork()).ldelim();
    }
    if (message.before !== void 0) {
      Timestamp.encode(toTimestamp3(message.before), writer.uint32(26).fork()).ldelim();
    }
    if (message.username !== void 0) {
      writer.uint32(34).string(message.username);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal53.default.Reader ? input : new import_minimal53.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.limit = reader.int32();
          break;
        case 2:
          message.after = fromTimestamp3(Timestamp.decode(reader, reader.uint32()));
          break;
        case 3:
          message.before = fromTimestamp3(Timestamp.decode(reader, reader.uint32()));
          break;
        case 4:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      limit: isSet48(object.limit) ? Number(object.limit) : 0,
      after: isSet48(object.after) ? fromJsonTimestamp3(object.after) : void 0,
      before: isSet48(object.before) ? fromJsonTimestamp3(object.before) : void 0,
      username: isSet48(object.username) ? String(object.username) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.limit !== void 0 && (obj.limit = Math.round(message.limit));
    message.after !== void 0 && (obj.after = message.after.toISOString());
    message.before !== void 0 && (obj.before = message.before.toISOString());
    message.username !== void 0 && (obj.username = message.username);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubmissionsRequest();
    message.limit = object.limit ?? 0;
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.username = object.username ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.admin.SubmissionsRequest", SubmissionsRequest);
function createBaseSubmissionsResponse() {
  return { submissions: [], totalSubmissions: 0, count: 0, first: void 0, last: void 0 };
}
var SubmissionsResponse = {
  $type: "devvit.dev_portal.admin.SubmissionsResponse",
  encode(message, writer = import_minimal53.default.Writer.create()) {
    for (const v of message.submissions) {
      Submission.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalSubmissions !== 0) {
      writer.uint32(16).int32(message.totalSubmissions);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    if (message.first !== void 0) {
      Timestamp.encode(toTimestamp3(message.first), writer.uint32(34).fork()).ldelim();
    }
    if (message.last !== void 0) {
      Timestamp.encode(toTimestamp3(message.last), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal53.default.Reader ? input : new import_minimal53.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.submissions.push(Submission.decode(reader, reader.uint32()));
          break;
        case 2:
          message.totalSubmissions = reader.int32();
          break;
        case 3:
          message.count = reader.int32();
          break;
        case 4:
          message.first = fromTimestamp3(Timestamp.decode(reader, reader.uint32()));
          break;
        case 5:
          message.last = fromTimestamp3(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      submissions: Array.isArray(object?.submissions) ? object.submissions.map((e) => Submission.fromJSON(e)) : [],
      totalSubmissions: isSet48(object.totalSubmissions) ? Number(object.totalSubmissions) : 0,
      count: isSet48(object.count) ? Number(object.count) : 0,
      first: isSet48(object.first) ? fromJsonTimestamp3(object.first) : void 0,
      last: isSet48(object.last) ? fromJsonTimestamp3(object.last) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.submissions) {
      obj.submissions = message.submissions.map((e) => e ? Submission.toJSON(e) : void 0);
    } else {
      obj.submissions = [];
    }
    message.totalSubmissions !== void 0 && (obj.totalSubmissions = Math.round(message.totalSubmissions));
    message.count !== void 0 && (obj.count = Math.round(message.count));
    message.first !== void 0 && (obj.first = message.first.toISOString());
    message.last !== void 0 && (obj.last = message.last.toISOString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubmissionsResponse();
    message.submissions = object.submissions?.map((e) => Submission.fromPartial(e)) || [];
    message.totalSubmissions = object.totalSubmissions ?? 0;
    message.count = object.count ?? 0;
    message.first = object.first ?? void 0;
    message.last = object.last ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.admin.SubmissionsResponse", SubmissionsResponse);
function createBaseSubmissionUpdateRequest() {
  return { id: "", status: 0 };
}
var SubmissionUpdateRequest = {
  $type: "devvit.dev_portal.admin.SubmissionUpdateRequest",
  encode(message, writer = import_minimal53.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal53.default.Reader ? input : new import_minimal53.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmissionUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.status = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet48(object.id) ? String(object.id) : "",
      status: isSet48(object.status) ? waitlistStatusFromJSON(object.status) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.status !== void 0 && (obj.status = waitlistStatusToJSON(message.status));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubmissionUpdateRequest();
    message.id = object.id ?? "";
    message.status = object.status ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.admin.SubmissionUpdateRequest", SubmissionUpdateRequest);
function createBaseSubmissionUpdateResponse() {
  return { success: false, message: void 0 };
}
var SubmissionUpdateResponse = {
  $type: "devvit.dev_portal.admin.SubmissionUpdateResponse",
  encode(message, writer = import_minimal53.default.Writer.create()) {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal53.default.Reader ? input : new import_minimal53.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmissionUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.success = reader.bool();
          break;
        case 2:
          message.message = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet48(object.success) ? Boolean(object.success) : false,
      message: isSet48(object.message) ? String(object.message) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.success !== void 0 && (obj.success = message.success);
    message.message !== void 0 && (obj.message = message.message);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubmissionUpdateResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.admin.SubmissionUpdateResponse", SubmissionUpdateResponse);
function toTimestamp3(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp3(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp3(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp3(Timestamp.fromJSON(o));
  }
}
function isSet48(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/app_version/app_version.js
var import_minimal62 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/buildpack/buildpack_common.js
var import_minimal57 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/runtime/bundle.js
var import_minimal55 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/runtime/serializable.js
var import_minimal54 = __toESM(require_minimal2(), 1);
function createBaseSerializableServiceDefinition() {
  return { fullName: "", methods: [], name: "", version: "" };
}
var SerializableServiceDefinition = {
  $type: "devvit.runtime.SerializableServiceDefinition",
  encode(message, writer = import_minimal54.default.Writer.create()) {
    if (message.fullName !== "") {
      writer.uint32(10).string(message.fullName);
    }
    for (const v of message.methods) {
      SerializableMethodDefinition.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal54.default.Reader ? input : new import_minimal54.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSerializableServiceDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fullName = reader.string();
          break;
        case 2:
          message.methods.push(SerializableMethodDefinition.decode(reader, reader.uint32()));
          break;
        case 3:
          message.name = reader.string();
          break;
        case 4:
          message.version = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fullName: isSet49(object.fullName) ? String(object.fullName) : "",
      methods: Array.isArray(object?.methods) ? object.methods.map((e) => SerializableMethodDefinition.fromJSON(e)) : [],
      name: isSet49(object.name) ? String(object.name) : "",
      version: isSet49(object.version) ? String(object.version) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.fullName !== void 0 && (obj.fullName = message.fullName);
    if (message.methods) {
      obj.methods = message.methods.map((e) => e ? SerializableMethodDefinition.toJSON(e) : void 0);
    } else {
      obj.methods = [];
    }
    message.name !== void 0 && (obj.name = message.name);
    message.version !== void 0 && (obj.version = message.version);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSerializableServiceDefinition();
    message.fullName = object.fullName ?? "";
    message.methods = object.methods?.map((e) => SerializableMethodDefinition.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.SerializableServiceDefinition", SerializableServiceDefinition);
function createBaseSerializableMethodDefinition() {
  return { fullName: "", name: "", requestStream: false, responseStream: false, requestType: "", responseType: "" };
}
var SerializableMethodDefinition = {
  $type: "devvit.runtime.SerializableMethodDefinition",
  encode(message, writer = import_minimal54.default.Writer.create()) {
    if (message.fullName !== "") {
      writer.uint32(10).string(message.fullName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.requestStream === true) {
      writer.uint32(24).bool(message.requestStream);
    }
    if (message.responseStream === true) {
      writer.uint32(32).bool(message.responseStream);
    }
    if (message.requestType !== "") {
      writer.uint32(42).string(message.requestType);
    }
    if (message.responseType !== "") {
      writer.uint32(50).string(message.responseType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal54.default.Reader ? input : new import_minimal54.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSerializableMethodDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fullName = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.requestStream = reader.bool();
          break;
        case 4:
          message.responseStream = reader.bool();
          break;
        case 5:
          message.requestType = reader.string();
          break;
        case 6:
          message.responseType = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fullName: isSet49(object.fullName) ? String(object.fullName) : "",
      name: isSet49(object.name) ? String(object.name) : "",
      requestStream: isSet49(object.requestStream) ? Boolean(object.requestStream) : false,
      responseStream: isSet49(object.responseStream) ? Boolean(object.responseStream) : false,
      requestType: isSet49(object.requestType) ? String(object.requestType) : "",
      responseType: isSet49(object.responseType) ? String(object.responseType) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.fullName !== void 0 && (obj.fullName = message.fullName);
    message.name !== void 0 && (obj.name = message.name);
    message.requestStream !== void 0 && (obj.requestStream = message.requestStream);
    message.responseStream !== void 0 && (obj.responseStream = message.responseStream);
    message.requestType !== void 0 && (obj.requestType = message.requestType);
    message.responseType !== void 0 && (obj.responseType = message.responseType);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSerializableMethodDefinition();
    message.fullName = object.fullName ?? "";
    message.name = object.name ?? "";
    message.requestStream = object.requestStream ?? false;
    message.responseStream = object.responseStream ?? false;
    message.requestType = object.requestType ?? "";
    message.responseType = object.responseType ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.SerializableMethodDefinition", SerializableMethodDefinition);
function isSet49(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/runtime/bundle.js
var LinkedBundleTargetPlatform;
(function(LinkedBundleTargetPlatform2) {
  LinkedBundleTargetPlatform2[LinkedBundleTargetPlatform2["BROWSER"] = 0] = "BROWSER";
  LinkedBundleTargetPlatform2[LinkedBundleTargetPlatform2["V8"] = 1] = "V8";
  LinkedBundleTargetPlatform2[LinkedBundleTargetPlatform2["SKINNY"] = 2] = "SKINNY";
  LinkedBundleTargetPlatform2[LinkedBundleTargetPlatform2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LinkedBundleTargetPlatform || (LinkedBundleTargetPlatform = {}));
function createBaseActorSpec() {
  return { name: "", owner: "", version: "" };
}
var ActorSpec = {
  $type: "devvit.runtime.ActorSpec",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.owner !== "") {
      writer.uint32(18).string(message.owner);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : new import_minimal55.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseActorSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.owner = reader.string();
          break;
        case 3:
          message.version = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet50(object.name) ? String(object.name) : "",
      owner: isSet50(object.owner) ? String(object.owner) : "",
      version: isSet50(object.version) ? String(object.version) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.owner !== void 0 && (obj.owner = message.owner);
    message.version !== void 0 && (obj.version = message.version);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseActorSpec();
    message.name = object.name ?? "";
    message.owner = object.owner ?? "";
    message.version = object.version ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.ActorSpec", ActorSpec);
function createBaseLocationFilter() {
  return { allow: [], deny: [] };
}
var LocationFilter = {
  $type: "devvit.runtime.LocationFilter",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    for (const v of message.allow) {
      writer.uint32(10).string(v);
    }
    for (const v of message.deny) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : new import_minimal55.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLocationFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.allow.push(reader.string());
          break;
        case 2:
          message.deny.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      allow: Array.isArray(object?.allow) ? object.allow.map((e) => String(e)) : [],
      deny: Array.isArray(object?.deny) ? object.deny.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.allow) {
      obj.allow = message.allow.map((e) => e);
    } else {
      obj.allow = [];
    }
    if (message.deny) {
      obj.deny = message.deny.map((e) => e);
    } else {
      obj.deny = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseLocationFilter();
    message.allow = object.allow?.map((e) => e) || [];
    message.deny = object.deny?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.LocationFilter", LocationFilter);
function createBasePackageSpec() {
  return { actor: void 0, definition: void 0, locations: void 0, partitionsBy: [] };
}
var PackageSpec = {
  $type: "devvit.runtime.PackageSpec",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.actor !== void 0) {
      ActorSpec.encode(message.actor, writer.uint32(10).fork()).ldelim();
    }
    if (message.definition !== void 0) {
      SerializableServiceDefinition.encode(message.definition, writer.uint32(18).fork()).ldelim();
    }
    if (message.locations !== void 0) {
      LocationFilter.encode(message.locations, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.partitionsBy) {
      writer.uint32(34).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : new import_minimal55.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePackageSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actor = ActorSpec.decode(reader, reader.uint32());
          break;
        case 2:
          message.definition = SerializableServiceDefinition.decode(reader, reader.uint32());
          break;
        case 3:
          message.locations = LocationFilter.decode(reader, reader.uint32());
          break;
        case 4:
          message.partitionsBy.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet50(object.actor) ? ActorSpec.fromJSON(object.actor) : void 0,
      definition: isSet50(object.definition) ? SerializableServiceDefinition.fromJSON(object.definition) : void 0,
      locations: isSet50(object.locations) ? LocationFilter.fromJSON(object.locations) : void 0,
      partitionsBy: Array.isArray(object?.partitionsBy) ? object.partitionsBy.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.actor !== void 0 && (obj.actor = message.actor ? ActorSpec.toJSON(message.actor) : void 0);
    message.definition !== void 0 && (obj.definition = message.definition ? SerializableServiceDefinition.toJSON(message.definition) : void 0);
    message.locations !== void 0 && (obj.locations = message.locations ? LocationFilter.toJSON(message.locations) : void 0);
    if (message.partitionsBy) {
      obj.partitionsBy = message.partitionsBy.map((e) => e);
    } else {
      obj.partitionsBy = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBasePackageSpec();
    message.actor = object.actor !== void 0 && object.actor !== null ? ActorSpec.fromPartial(object.actor) : void 0;
    message.definition = object.definition !== void 0 && object.definition !== null ? SerializableServiceDefinition.fromPartial(object.definition) : void 0;
    message.locations = object.locations !== void 0 && object.locations !== null ? LocationFilter.fromPartial(object.locations) : void 0;
    message.partitionsBy = object.partitionsBy?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.PackageSpec", PackageSpec);
function createBasePackageQuery() {
  return { name: void 0, owner: void 0, typeName: "", versions: void 0 };
}
var PackageQuery = {
  $type: "devvit.runtime.PackageQuery",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(10).fork()).ldelim();
    }
    if (message.owner !== void 0) {
      StringValue.encode({ value: message.owner }, writer.uint32(18).fork()).ldelim();
    }
    if (message.typeName !== "") {
      writer.uint32(26).string(message.typeName);
    }
    if (message.versions !== void 0) {
      StringValue.encode({ value: message.versions }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : new import_minimal55.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePackageQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.owner = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.typeName = reader.string();
          break;
        case 4:
          message.versions = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet50(object.name) ? String(object.name) : void 0,
      owner: isSet50(object.owner) ? String(object.owner) : void 0,
      typeName: isSet50(object.typeName) ? String(object.typeName) : "",
      versions: isSet50(object.versions) ? String(object.versions) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.owner !== void 0 && (obj.owner = message.owner);
    message.typeName !== void 0 && (obj.typeName = message.typeName);
    message.versions !== void 0 && (obj.versions = message.versions);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePackageQuery();
    message.name = object.name ?? void 0;
    message.owner = object.owner ?? void 0;
    message.typeName = object.typeName ?? "";
    message.versions = object.versions ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.PackageQuery", PackageQuery);
function createBaseDependencySpec() {
  return { actor: void 0, hostname: "", provides: [], uses: [] };
}
var DependencySpec = {
  $type: "devvit.runtime.DependencySpec",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.actor !== void 0) {
      ActorSpec.encode(message.actor, writer.uint32(10).fork()).ldelim();
    }
    if (message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    for (const v of message.provides) {
      PackageSpec.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.uses) {
      PackageQuery.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : new import_minimal55.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDependencySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actor = ActorSpec.decode(reader, reader.uint32());
          break;
        case 2:
          message.hostname = reader.string();
          break;
        case 3:
          message.provides.push(PackageSpec.decode(reader, reader.uint32()));
          break;
        case 4:
          message.uses.push(PackageQuery.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet50(object.actor) ? ActorSpec.fromJSON(object.actor) : void 0,
      hostname: isSet50(object.hostname) ? String(object.hostname) : "",
      provides: Array.isArray(object?.provides) ? object.provides.map((e) => PackageSpec.fromJSON(e)) : [],
      uses: Array.isArray(object?.uses) ? object.uses.map((e) => PackageQuery.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.actor !== void 0 && (obj.actor = message.actor ? ActorSpec.toJSON(message.actor) : void 0);
    message.hostname !== void 0 && (obj.hostname = message.hostname);
    if (message.provides) {
      obj.provides = message.provides.map((e) => e ? PackageSpec.toJSON(e) : void 0);
    } else {
      obj.provides = [];
    }
    if (message.uses) {
      obj.uses = message.uses.map((e) => e ? PackageQuery.toJSON(e) : void 0);
    } else {
      obj.uses = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDependencySpec();
    message.actor = object.actor !== void 0 && object.actor !== null ? ActorSpec.fromPartial(object.actor) : void 0;
    message.hostname = object.hostname ?? "";
    message.provides = object.provides?.map((e) => PackageSpec.fromPartial(e)) || [];
    message.uses = object.uses?.map((e) => PackageQuery.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.DependencySpec", DependencySpec);
function createBaseLinkedBundle() {
  return {
    actor: void 0,
    code: "",
    hostname: "",
    provides: [],
    uses: [],
    buildInfo: void 0,
    assetsUrl: void 0
  };
}
var LinkedBundle = {
  $type: "devvit.runtime.LinkedBundle",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.actor !== void 0) {
      ActorSpec.encode(message.actor, writer.uint32(10).fork()).ldelim();
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.hostname !== "") {
      writer.uint32(26).string(message.hostname);
    }
    for (const v of message.provides) {
      SerializableServiceDefinition.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.uses) {
      LinkedBundle.encode(v, writer.uint32(42).fork()).ldelim();
    }
    if (message.buildInfo !== void 0) {
      BuildInfo.encode(message.buildInfo, writer.uint32(50).fork()).ldelim();
    }
    if (message.assetsUrl !== void 0) {
      StringValue.encode({ value: message.assetsUrl }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : new import_minimal55.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkedBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actor = ActorSpec.decode(reader, reader.uint32());
          break;
        case 2:
          message.code = reader.string();
          break;
        case 3:
          message.hostname = reader.string();
          break;
        case 4:
          message.provides.push(SerializableServiceDefinition.decode(reader, reader.uint32()));
          break;
        case 5:
          message.uses.push(LinkedBundle.decode(reader, reader.uint32()));
          break;
        case 6:
          message.buildInfo = BuildInfo.decode(reader, reader.uint32());
          break;
        case 7:
          message.assetsUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actor: isSet50(object.actor) ? ActorSpec.fromJSON(object.actor) : void 0,
      code: isSet50(object.code) ? String(object.code) : "",
      hostname: isSet50(object.hostname) ? String(object.hostname) : "",
      provides: Array.isArray(object?.provides) ? object.provides.map((e) => SerializableServiceDefinition.fromJSON(e)) : [],
      uses: Array.isArray(object?.uses) ? object.uses.map((e) => LinkedBundle.fromJSON(e)) : [],
      buildInfo: isSet50(object.buildInfo) ? BuildInfo.fromJSON(object.buildInfo) : void 0,
      assetsUrl: isSet50(object.assetsUrl) ? String(object.assetsUrl) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.actor !== void 0 && (obj.actor = message.actor ? ActorSpec.toJSON(message.actor) : void 0);
    message.code !== void 0 && (obj.code = message.code);
    message.hostname !== void 0 && (obj.hostname = message.hostname);
    if (message.provides) {
      obj.provides = message.provides.map((e) => e ? SerializableServiceDefinition.toJSON(e) : void 0);
    } else {
      obj.provides = [];
    }
    if (message.uses) {
      obj.uses = message.uses.map((e) => e ? LinkedBundle.toJSON(e) : void 0);
    } else {
      obj.uses = [];
    }
    message.buildInfo !== void 0 && (obj.buildInfo = message.buildInfo ? BuildInfo.toJSON(message.buildInfo) : void 0);
    message.assetsUrl !== void 0 && (obj.assetsUrl = message.assetsUrl);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseLinkedBundle();
    message.actor = object.actor !== void 0 && object.actor !== null ? ActorSpec.fromPartial(object.actor) : void 0;
    message.code = object.code ?? "";
    message.hostname = object.hostname ?? "";
    message.provides = object.provides?.map((e) => SerializableServiceDefinition.fromPartial(e)) || [];
    message.uses = object.uses?.map((e) => LinkedBundle.fromPartial(e)) || [];
    message.buildInfo = object.buildInfo !== void 0 && object.buildInfo !== null ? BuildInfo.fromPartial(object.buildInfo) : void 0;
    message.assetsUrl = object.assetsUrl ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.LinkedBundle", LinkedBundle);
function createBaseBuildInfo() {
  return { created: void 0, dependencies: {} };
}
var BuildInfo = {
  $type: "devvit.runtime.BuildInfo",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.created !== void 0) {
      Timestamp.encode(toTimestamp4(message.created), writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.dependencies).forEach(([key, value]) => {
      BuildInfo_DependenciesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : new import_minimal55.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBuildInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.created = fromTimestamp4(Timestamp.decode(reader, reader.uint32()));
          break;
        case 2:
          const entry2 = BuildInfo_DependenciesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.dependencies[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      created: isSet50(object.created) ? fromJsonTimestamp4(object.created) : void 0,
      dependencies: isObject6(object.dependencies) ? Object.entries(object.dependencies).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.created !== void 0 && (obj.created = message.created.toISOString());
    obj.dependencies = {};
    if (message.dependencies) {
      Object.entries(message.dependencies).forEach(([k, v]) => {
        obj.dependencies[k] = v;
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBuildInfo();
    message.created = object.created ?? void 0;
    message.dependencies = Object.entries(object.dependencies ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.BuildInfo", BuildInfo);
function createBaseBuildInfo_DependenciesEntry() {
  return { key: "", value: "" };
}
var BuildInfo_DependenciesEntry = {
  $type: "devvit.runtime.BuildInfo.DependenciesEntry",
  encode(message, writer = import_minimal55.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal55.default.Reader ? input : new import_minimal55.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBuildInfo_DependenciesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet50(object.key) ? String(object.key) : "", value: isSet50(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBuildInfo_DependenciesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.BuildInfo.DependenciesEntry", BuildInfo_DependenciesEntry);
function toTimestamp4(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp4(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp4(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp4(Timestamp.fromJSON(o));
  }
}
function isObject6(value) {
  return typeof value === "object" && value !== null;
}
function isSet50(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/buildpack/filesystem.js
var import_minimal56 = __toESM(require_minimal2(), 1);
function createBaseFile() {
  return { path: "", content: "", isDirectory: false, isBase64: false };
}
var File = {
  $type: "devvit.plugin.buildpack.File",
  encode(message, writer = import_minimal56.default.Writer.create()) {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.isDirectory === true) {
      writer.uint32(24).bool(message.isDirectory);
    }
    if (message.isBase64 === true) {
      writer.uint32(32).bool(message.isBase64);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal56.default.Reader ? input : new import_minimal56.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.path = reader.string();
          break;
        case 2:
          message.content = reader.string();
          break;
        case 3:
          message.isDirectory = reader.bool();
          break;
        case 4:
          message.isBase64 = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet51(object.path) ? String(object.path) : "",
      content: isSet51(object.content) ? String(object.content) : "",
      isDirectory: isSet51(object.isDirectory) ? Boolean(object.isDirectory) : false,
      isBase64: isSet51(object.isBase64) ? Boolean(object.isBase64) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.path !== void 0 && (obj.path = message.path);
    message.content !== void 0 && (obj.content = message.content);
    message.isDirectory !== void 0 && (obj.isDirectory = message.isDirectory);
    message.isBase64 !== void 0 && (obj.isBase64 = message.isBase64);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFile();
    message.path = object.path ?? "";
    message.content = object.content ?? "";
    message.isDirectory = object.isDirectory ?? false;
    message.isBase64 = object.isBase64 ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.buildpack.File", File);
function createBaseFileSystem() {
  return { files: [] };
}
var FileSystem = {
  $type: "devvit.plugin.buildpack.FileSystem",
  encode(message, writer = import_minimal56.default.Writer.create()) {
    for (const v of message.files) {
      File.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal56.default.Reader ? input : new import_minimal56.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileSystem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.files.push(File.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { files: Array.isArray(object?.files) ? object.files.map((e) => File.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.files) {
      obj.files = message.files.map((e) => e ? File.toJSON(e) : void 0);
    } else {
      obj.files = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFileSystem();
    message.files = object.files?.map((e) => File.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.buildpack.FileSystem", FileSystem);
function isSet51(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/buildpack/buildpack_common.js
var Minify;
(function(Minify2) {
  Minify2[Minify2["NONE"] = 0] = "NONE";
  Minify2[Minify2["ALL"] = 1] = "ALL";
  Minify2[Minify2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Minify || (Minify = {}));
function minifyFromJSON(object) {
  switch (object) {
    case 0:
    case "NONE":
      return Minify.NONE;
    case 1:
    case "ALL":
      return Minify.ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Minify.UNRECOGNIZED;
  }
}
function minifyToJSON(object) {
  switch (object) {
    case Minify.NONE:
      return 0;
    case Minify.ALL:
      return 1;
    case Minify.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseBundle() {
  return { code: "", dependencies: void 0, assets: void 0, buildInfo: void 0 };
}
var Bundle = {
  $type: "devvit.plugin.buildpack.Bundle",
  encode(message, writer = import_minimal57.default.Writer.create()) {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.dependencies !== void 0) {
      DependencySpec.encode(message.dependencies, writer.uint32(18).fork()).ldelim();
    }
    if (message.assets !== void 0) {
      FileSystem.encode(message.assets, writer.uint32(34).fork()).ldelim();
    }
    if (message.buildInfo !== void 0) {
      BuildInfo.encode(message.buildInfo, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal57.default.Reader ? input : new import_minimal57.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.code = reader.string();
          break;
        case 2:
          message.dependencies = DependencySpec.decode(reader, reader.uint32());
          break;
        case 4:
          message.assets = FileSystem.decode(reader, reader.uint32());
          break;
        case 3:
          message.buildInfo = BuildInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      code: isSet52(object.code) ? String(object.code) : "",
      dependencies: isSet52(object.dependencies) ? DependencySpec.fromJSON(object.dependencies) : void 0,
      assets: isSet52(object.assets) ? FileSystem.fromJSON(object.assets) : void 0,
      buildInfo: isSet52(object.buildInfo) ? BuildInfo.fromJSON(object.buildInfo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.code !== void 0 && (obj.code = message.code);
    message.dependencies !== void 0 && (obj.dependencies = message.dependencies ? DependencySpec.toJSON(message.dependencies) : void 0);
    message.assets !== void 0 && (obj.assets = message.assets ? FileSystem.toJSON(message.assets) : void 0);
    message.buildInfo !== void 0 && (obj.buildInfo = message.buildInfo ? BuildInfo.toJSON(message.buildInfo) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBundle();
    message.code = object.code ?? "";
    message.dependencies = object.dependencies !== void 0 && object.dependencies !== null ? DependencySpec.fromPartial(object.dependencies) : void 0;
    message.assets = object.assets !== void 0 && object.assets !== null ? FileSystem.fromPartial(object.assets) : void 0;
    message.buildInfo = object.buildInfo !== void 0 && object.buildInfo !== null ? BuildInfo.fromPartial(object.buildInfo) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.buildpack.Bundle", Bundle);
function createBaseCompileParams() {
  return { virtualFileSystem: void 0, filename: void 0, minify: 0, includeAssets: false, info: void 0 };
}
var CompileParams = {
  $type: "devvit.plugin.buildpack.CompileParams",
  encode(message, writer = import_minimal57.default.Writer.create()) {
    if (message.virtualFileSystem !== void 0) {
      FileSystem.encode(message.virtualFileSystem, writer.uint32(10).fork()).ldelim();
    }
    if (message.filename !== void 0) {
      writer.uint32(18).string(message.filename);
    }
    if (message.minify !== 0) {
      writer.uint32(24).int32(message.minify);
    }
    if (message.includeAssets === true) {
      writer.uint32(40).bool(message.includeAssets);
    }
    if (message.info !== void 0) {
      ActorSpec.encode(message.info, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal57.default.Reader ? input : new import_minimal57.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCompileParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.virtualFileSystem = FileSystem.decode(reader, reader.uint32());
          break;
        case 2:
          message.filename = reader.string();
          break;
        case 3:
          message.minify = reader.int32();
          break;
        case 5:
          message.includeAssets = reader.bool();
          break;
        case 4:
          message.info = ActorSpec.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      virtualFileSystem: isSet52(object.virtualFileSystem) ? FileSystem.fromJSON(object.virtualFileSystem) : void 0,
      filename: isSet52(object.filename) ? String(object.filename) : void 0,
      minify: isSet52(object.minify) ? minifyFromJSON(object.minify) : 0,
      includeAssets: isSet52(object.includeAssets) ? Boolean(object.includeAssets) : false,
      info: isSet52(object.info) ? ActorSpec.fromJSON(object.info) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.virtualFileSystem !== void 0 && (obj.virtualFileSystem = message.virtualFileSystem ? FileSystem.toJSON(message.virtualFileSystem) : void 0);
    message.filename !== void 0 && (obj.filename = message.filename);
    message.minify !== void 0 && (obj.minify = minifyToJSON(message.minify));
    message.includeAssets !== void 0 && (obj.includeAssets = message.includeAssets);
    message.info !== void 0 && (obj.info = message.info ? ActorSpec.toJSON(message.info) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCompileParams();
    message.virtualFileSystem = object.virtualFileSystem !== void 0 && object.virtualFileSystem !== null ? FileSystem.fromPartial(object.virtualFileSystem) : void 0;
    message.filename = object.filename ?? void 0;
    message.minify = object.minify ?? 0;
    message.includeAssets = object.includeAssets ?? false;
    message.info = object.info !== void 0 && object.info !== null ? ActorSpec.fromPartial(object.info) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.buildpack.CompileParams", CompileParams);
function createBaseCompileLog() {
  return { detail: void 0, text: "" };
}
var CompileLog = {
  $type: "devvit.plugin.buildpack.CompileLog",
  encode(message, writer = import_minimal57.default.Writer.create()) {
    if (message.detail !== void 0) {
      CompileLogLineDetail.encode(message.detail, writer.uint32(10).fork()).ldelim();
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal57.default.Reader ? input : new import_minimal57.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCompileLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.detail = CompileLogLineDetail.decode(reader, reader.uint32());
          break;
        case 2:
          message.text = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      detail: isSet52(object.detail) ? CompileLogLineDetail.fromJSON(object.detail) : void 0,
      text: isSet52(object.text) ? String(object.text) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.detail !== void 0 && (obj.detail = message.detail ? CompileLogLineDetail.toJSON(message.detail) : void 0);
    message.text !== void 0 && (obj.text = message.text);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCompileLog();
    message.detail = object.detail !== void 0 && object.detail !== null ? CompileLogLineDetail.fromPartial(object.detail) : void 0;
    message.text = object.text ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.buildpack.CompileLog", CompileLog);
function createBaseCompileLogLineDetail() {
  return { column: 0, filename: "", line: 0, suggestion: "", text: "" };
}
var CompileLogLineDetail = {
  $type: "devvit.plugin.buildpack.CompileLogLineDetail",
  encode(message, writer = import_minimal57.default.Writer.create()) {
    if (message.column !== 0) {
      writer.uint32(8).uint32(message.column);
    }
    if (message.filename !== "") {
      writer.uint32(18).string(message.filename);
    }
    if (message.line !== 0) {
      writer.uint32(24).uint32(message.line);
    }
    if (message.suggestion !== "") {
      writer.uint32(34).string(message.suggestion);
    }
    if (message.text !== "") {
      writer.uint32(42).string(message.text);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal57.default.Reader ? input : new import_minimal57.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCompileLogLineDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.column = reader.uint32();
          break;
        case 2:
          message.filename = reader.string();
          break;
        case 3:
          message.line = reader.uint32();
          break;
        case 4:
          message.suggestion = reader.string();
          break;
        case 5:
          message.text = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      column: isSet52(object.column) ? Number(object.column) : 0,
      filename: isSet52(object.filename) ? String(object.filename) : "",
      line: isSet52(object.line) ? Number(object.line) : 0,
      suggestion: isSet52(object.suggestion) ? String(object.suggestion) : "",
      text: isSet52(object.text) ? String(object.text) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.column !== void 0 && (obj.column = Math.round(message.column));
    message.filename !== void 0 && (obj.filename = message.filename);
    message.line !== void 0 && (obj.line = Math.round(message.line));
    message.suggestion !== void 0 && (obj.suggestion = message.suggestion);
    message.text !== void 0 && (obj.text = message.text);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCompileLogLineDetail();
    message.column = object.column ?? 0;
    message.filename = object.filename ?? "";
    message.line = object.line ?? 0;
    message.suggestion = object.suggestion ?? "";
    message.text = object.text ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.buildpack.CompileLogLineDetail", CompileLogLineDetail);
function createBaseCompileResponse() {
  return { bundle: void 0, errors: [], warnings: [] };
}
var CompileResponse = {
  $type: "devvit.plugin.buildpack.CompileResponse",
  encode(message, writer = import_minimal57.default.Writer.create()) {
    if (message.bundle !== void 0) {
      Bundle.encode(message.bundle, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.errors) {
      CompileLog.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.warnings) {
      CompileLog.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal57.default.Reader ? input : new import_minimal57.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCompileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bundle = Bundle.decode(reader, reader.uint32());
          break;
        case 2:
          message.errors.push(CompileLog.decode(reader, reader.uint32()));
          break;
        case 3:
          message.warnings.push(CompileLog.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      bundle: isSet52(object.bundle) ? Bundle.fromJSON(object.bundle) : void 0,
      errors: Array.isArray(object?.errors) ? object.errors.map((e) => CompileLog.fromJSON(e)) : [],
      warnings: Array.isArray(object?.warnings) ? object.warnings.map((e) => CompileLog.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.bundle !== void 0 && (obj.bundle = message.bundle ? Bundle.toJSON(message.bundle) : void 0);
    if (message.errors) {
      obj.errors = message.errors.map((e) => e ? CompileLog.toJSON(e) : void 0);
    } else {
      obj.errors = [];
    }
    if (message.warnings) {
      obj.warnings = message.warnings.map((e) => e ? CompileLog.toJSON(e) : void 0);
    } else {
      obj.warnings = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCompileResponse();
    message.bundle = object.bundle !== void 0 && object.bundle !== null ? Bundle.fromPartial(object.bundle) : void 0;
    message.errors = object.errors?.map((e) => CompileLog.fromPartial(e)) || [];
    message.warnings = object.warnings?.map((e) => CompileLog.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.buildpack.CompileResponse", CompileResponse);
function isSet52(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/app/info/app_info.js
var import_minimal59 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/dev_portal/reddit/redditor.js
var import_minimal58 = __toESM(require_minimal2(), 1);
function createBaseRedditor() {
  return { id: "", displayName: "", snoovatarIconUrl: "" };
}
var Redditor = {
  $type: "devvit.dev_portal.reddit.Redditor",
  encode(message, writer = import_minimal58.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.snoovatarIconUrl !== "") {
      writer.uint32(26).string(message.snoovatarIconUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal58.default.Reader ? input : new import_minimal58.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRedditor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.displayName = reader.string();
          break;
        case 3:
          message.snoovatarIconUrl = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet53(object.id) ? String(object.id) : "",
      displayName: isSet53(object.displayName) ? String(object.displayName) : "",
      snoovatarIconUrl: isSet53(object.snoovatarIconUrl) ? String(object.snoovatarIconUrl) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    message.snoovatarIconUrl !== void 0 && (obj.snoovatarIconUrl = message.snoovatarIconUrl);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRedditor();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.snoovatarIconUrl = object.snoovatarIconUrl ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.reddit.Redditor", Redditor);
function isSet53(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/app/categories/categories.js
var Categories;
(function(Categories2) {
  Categories2[Categories2["MODERATION"] = 0] = "MODERATION";
  Categories2[Categories2["CUSTOM_POSTS"] = 1] = "CUSTOM_POSTS";
  Categories2[Categories2["UTILITIES"] = 2] = "UTILITIES";
  Categories2[Categories2["OTHER_SITES"] = 3] = "OTHER_SITES";
  Categories2[Categories2["FUNNY"] = 4] = "FUNNY";
  Categories2[Categories2["WEIRD"] = 5] = "WEIRD";
  Categories2[Categories2["AWW"] = 6] = "AWW";
  Categories2[Categories2["LEARNING"] = 7] = "LEARNING";
  Categories2[Categories2["FINANCIAL"] = 8] = "FINANCIAL";
  Categories2[Categories2["SPORTS"] = 9] = "SPORTS";
  Categories2[Categories2["GAMES"] = 10] = "GAMES";
  Categories2[Categories2["MOVIES"] = 11] = "MOVIES";
  Categories2[Categories2["MUSIC"] = 12] = "MUSIC";
  Categories2[Categories2["TV"] = 13] = "TV";
  Categories2[Categories2["BOOKS"] = 14] = "BOOKS";
  Categories2[Categories2["ANIME"] = 15] = "ANIME";
  Categories2[Categories2["PROGRAMMING"] = 16] = "PROGRAMMING";
  Categories2[Categories2["COOKING"] = 17] = "COOKING";
  Categories2[Categories2["FITNESS"] = 18] = "FITNESS";
  Categories2[Categories2["TRAVEL"] = 19] = "TRAVEL";
  Categories2[Categories2["CONTEXT_MENU"] = 20] = "CONTEXT_MENU";
  Categories2[Categories2["MOD_CONTEXT"] = 21] = "MOD_CONTEXT";
  Categories2[Categories2["FILTER"] = 22] = "FILTER";
  Categories2[Categories2["POST_FILTER"] = 23] = "POST_FILTER";
  Categories2[Categories2["COMMENT_FILTER"] = 24] = "COMMENT_FILTER";
  Categories2[Categories2["ANTI_SPAM"] = 25] = "ANTI_SPAM";
  Categories2[Categories2["ANTI_HARASSMENT"] = 26] = "ANTI_HARASSMENT";
  Categories2[Categories2["NSFW_FILTER"] = 27] = "NSFW_FILTER";
  Categories2[Categories2["CITIZEN_FILTER"] = 28] = "CITIZEN_FILTER";
  Categories2[Categories2["POST_FLAIR"] = 29] = "POST_FLAIR";
  Categories2[Categories2["COMMENT_FLAIR"] = 30] = "COMMENT_FLAIR";
  Categories2[Categories2["USER_FLAIR"] = 31] = "USER_FLAIR";
  Categories2[Categories2["MESSAGING"] = 32] = "MESSAGING";
  Categories2[Categories2["MISCHIEF"] = 420] = "MISCHIEF";
  Categories2[Categories2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Categories || (Categories = {}));
function categoriesFromJSON(object) {
  switch (object) {
    case 0:
    case "MODERATION":
      return Categories.MODERATION;
    case 1:
    case "CUSTOM_POSTS":
      return Categories.CUSTOM_POSTS;
    case 2:
    case "UTILITIES":
      return Categories.UTILITIES;
    case 3:
    case "OTHER_SITES":
      return Categories.OTHER_SITES;
    case 4:
    case "FUNNY":
      return Categories.FUNNY;
    case 5:
    case "WEIRD":
      return Categories.WEIRD;
    case 6:
    case "AWW":
      return Categories.AWW;
    case 7:
    case "LEARNING":
      return Categories.LEARNING;
    case 8:
    case "FINANCIAL":
      return Categories.FINANCIAL;
    case 9:
    case "SPORTS":
      return Categories.SPORTS;
    case 10:
    case "GAMES":
      return Categories.GAMES;
    case 11:
    case "MOVIES":
      return Categories.MOVIES;
    case 12:
    case "MUSIC":
      return Categories.MUSIC;
    case 13:
    case "TV":
      return Categories.TV;
    case 14:
    case "BOOKS":
      return Categories.BOOKS;
    case 15:
    case "ANIME":
      return Categories.ANIME;
    case 16:
    case "PROGRAMMING":
      return Categories.PROGRAMMING;
    case 17:
    case "COOKING":
      return Categories.COOKING;
    case 18:
    case "FITNESS":
      return Categories.FITNESS;
    case 19:
    case "TRAVEL":
      return Categories.TRAVEL;
    case 20:
    case "CONTEXT_MENU":
      return Categories.CONTEXT_MENU;
    case 21:
    case "MOD_CONTEXT":
      return Categories.MOD_CONTEXT;
    case 22:
    case "FILTER":
      return Categories.FILTER;
    case 23:
    case "POST_FILTER":
      return Categories.POST_FILTER;
    case 24:
    case "COMMENT_FILTER":
      return Categories.COMMENT_FILTER;
    case 25:
    case "ANTI_SPAM":
      return Categories.ANTI_SPAM;
    case 26:
    case "ANTI_HARASSMENT":
      return Categories.ANTI_HARASSMENT;
    case 27:
    case "NSFW_FILTER":
      return Categories.NSFW_FILTER;
    case 28:
    case "CITIZEN_FILTER":
      return Categories.CITIZEN_FILTER;
    case 29:
    case "POST_FLAIR":
      return Categories.POST_FLAIR;
    case 30:
    case "COMMENT_FLAIR":
      return Categories.COMMENT_FLAIR;
    case 31:
    case "USER_FLAIR":
      return Categories.USER_FLAIR;
    case 32:
    case "MESSAGING":
      return Categories.MESSAGING;
    case 420:
    case "MISCHIEF":
      return Categories.MISCHIEF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Categories.UNRECOGNIZED;
  }
}
function categoriesToJSON(object) {
  switch (object) {
    case Categories.MODERATION:
      return 0;
    case Categories.CUSTOM_POSTS:
      return 1;
    case Categories.UTILITIES:
      return 2;
    case Categories.OTHER_SITES:
      return 3;
    case Categories.FUNNY:
      return 4;
    case Categories.WEIRD:
      return 5;
    case Categories.AWW:
      return 6;
    case Categories.LEARNING:
      return 7;
    case Categories.FINANCIAL:
      return 8;
    case Categories.SPORTS:
      return 9;
    case Categories.GAMES:
      return 10;
    case Categories.MOVIES:
      return 11;
    case Categories.MUSIC:
      return 12;
    case Categories.TV:
      return 13;
    case Categories.BOOKS:
      return 14;
    case Categories.ANIME:
      return 15;
    case Categories.PROGRAMMING:
      return 16;
    case Categories.COOKING:
      return 17;
    case Categories.FITNESS:
      return 18;
    case Categories.TRAVEL:
      return 19;
    case Categories.CONTEXT_MENU:
      return 20;
    case Categories.MOD_CONTEXT:
      return 21;
    case Categories.FILTER:
      return 22;
    case Categories.POST_FILTER:
      return 23;
    case Categories.COMMENT_FILTER:
      return 24;
    case Categories.ANTI_SPAM:
      return 25;
    case Categories.ANTI_HARASSMENT:
      return 26;
    case Categories.NSFW_FILTER:
      return 27;
    case Categories.CITIZEN_FILTER:
      return 28;
    case Categories.POST_FLAIR:
      return 29;
    case Categories.COMMENT_FLAIR:
      return 30;
    case Categories.USER_FLAIR:
      return 31;
    case Categories.MESSAGING:
      return 32;
    case Categories.MISCHIEF:
      return 420;
    case Categories.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/dev_portal/app/info/app_info.js
function createBaseAppInfo() {
  return {
    id: "",
    slug: "",
    name: "",
    description: "",
    isNsfw: false,
    isDelisted: false,
    isFirstParty: false,
    isArchived: false,
    createdAt: void 0,
    owner: void 0,
    categories: [],
    stats: void 0,
    termsAndConditions: "",
    privacyPolicy: ""
  };
}
var AppInfo = {
  $type: "devvit.dev_portal.app.info.AppInfo",
  encode(message, writer = import_minimal59.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.slug !== "") {
      writer.uint32(18).string(message.slug);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.isNsfw === true) {
      writer.uint32(40).bool(message.isNsfw);
    }
    if (message.isDelisted === true) {
      writer.uint32(48).bool(message.isDelisted);
    }
    if (message.isFirstParty === true) {
      writer.uint32(104).bool(message.isFirstParty);
    }
    if (message.isArchived === true) {
      writer.uint32(112).bool(message.isArchived);
    }
    if (message.createdAt !== void 0) {
      Timestamp.encode(toTimestamp5(message.createdAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.owner !== void 0) {
      Redditor.encode(message.owner, writer.uint32(66).fork()).ldelim();
    }
    writer.uint32(74).fork();
    for (const v of message.categories) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.stats !== void 0) {
      AppStats.encode(message.stats, writer.uint32(82).fork()).ldelim();
    }
    if (message.termsAndConditions !== "") {
      writer.uint32(90).string(message.termsAndConditions);
    }
    if (message.privacyPolicy !== "") {
      writer.uint32(98).string(message.privacyPolicy);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal59.default.Reader ? input : new import_minimal59.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.slug = reader.string();
          break;
        case 3:
          message.name = reader.string();
          break;
        case 4:
          message.description = reader.string();
          break;
        case 5:
          message.isNsfw = reader.bool();
          break;
        case 6:
          message.isDelisted = reader.bool();
          break;
        case 13:
          message.isFirstParty = reader.bool();
          break;
        case 14:
          message.isArchived = reader.bool();
          break;
        case 7:
          message.createdAt = fromTimestamp5(Timestamp.decode(reader, reader.uint32()));
          break;
        case 8:
          message.owner = Redditor.decode(reader, reader.uint32());
          break;
        case 9:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.categories.push(reader.int32());
            }
          } else {
            message.categories.push(reader.int32());
          }
          break;
        case 10:
          message.stats = AppStats.decode(reader, reader.uint32());
          break;
        case 11:
          message.termsAndConditions = reader.string();
          break;
        case 12:
          message.privacyPolicy = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet54(object.id) ? String(object.id) : "",
      slug: isSet54(object.slug) ? String(object.slug) : "",
      name: isSet54(object.name) ? String(object.name) : "",
      description: isSet54(object.description) ? String(object.description) : "",
      isNsfw: isSet54(object.isNsfw) ? Boolean(object.isNsfw) : false,
      isDelisted: isSet54(object.isDelisted) ? Boolean(object.isDelisted) : false,
      isFirstParty: isSet54(object.isFirstParty) ? Boolean(object.isFirstParty) : false,
      isArchived: isSet54(object.isArchived) ? Boolean(object.isArchived) : false,
      createdAt: isSet54(object.createdAt) ? fromJsonTimestamp5(object.createdAt) : void 0,
      owner: isSet54(object.owner) ? Redditor.fromJSON(object.owner) : void 0,
      categories: Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
      stats: isSet54(object.stats) ? AppStats.fromJSON(object.stats) : void 0,
      termsAndConditions: isSet54(object.termsAndConditions) ? String(object.termsAndConditions) : "",
      privacyPolicy: isSet54(object.privacyPolicy) ? String(object.privacyPolicy) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.slug !== void 0 && (obj.slug = message.slug);
    message.name !== void 0 && (obj.name = message.name);
    message.description !== void 0 && (obj.description = message.description);
    message.isNsfw !== void 0 && (obj.isNsfw = message.isNsfw);
    message.isDelisted !== void 0 && (obj.isDelisted = message.isDelisted);
    message.isFirstParty !== void 0 && (obj.isFirstParty = message.isFirstParty);
    message.isArchived !== void 0 && (obj.isArchived = message.isArchived);
    message.createdAt !== void 0 && (obj.createdAt = message.createdAt.toISOString());
    message.owner !== void 0 && (obj.owner = message.owner ? Redditor.toJSON(message.owner) : void 0);
    if (message.categories) {
      obj.categories = message.categories.map((e) => categoriesToJSON(e));
    } else {
      obj.categories = [];
    }
    message.stats !== void 0 && (obj.stats = message.stats ? AppStats.toJSON(message.stats) : void 0);
    message.termsAndConditions !== void 0 && (obj.termsAndConditions = message.termsAndConditions);
    message.privacyPolicy !== void 0 && (obj.privacyPolicy = message.privacyPolicy);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppInfo();
    message.id = object.id ?? "";
    message.slug = object.slug ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.isNsfw = object.isNsfw ?? false;
    message.isDelisted = object.isDelisted ?? false;
    message.isFirstParty = object.isFirstParty ?? false;
    message.isArchived = object.isArchived ?? false;
    message.createdAt = object.createdAt ?? void 0;
    message.owner = object.owner !== void 0 && object.owner !== null ? Redditor.fromPartial(object.owner) : void 0;
    message.categories = object.categories?.map((e) => e) || [];
    message.stats = object.stats !== void 0 && object.stats !== null ? AppStats.fromPartial(object.stats) : void 0;
    message.termsAndConditions = object.termsAndConditions ?? "";
    message.privacyPolicy = object.privacyPolicy ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.info.AppInfo", AppInfo);
function createBaseMultipleAppInfos() {
  return { apps: [] };
}
var MultipleAppInfos = {
  $type: "devvit.dev_portal.app.info.MultipleAppInfos",
  encode(message, writer = import_minimal59.default.Writer.create()) {
    for (const v of message.apps) {
      AppInfo.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal59.default.Reader ? input : new import_minimal59.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMultipleAppInfos();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.apps.push(AppInfo.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { apps: Array.isArray(object?.apps) ? object.apps.map((e) => AppInfo.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.apps) {
      obj.apps = message.apps.map((e) => e ? AppInfo.toJSON(e) : void 0);
    } else {
      obj.apps = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMultipleAppInfos();
    message.apps = object.apps?.map((e) => AppInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.info.MultipleAppInfos", MultipleAppInfos);
function createBaseAppStats() {
  return { installCount: 0 };
}
var AppStats = {
  $type: "devvit.dev_portal.app.info.AppStats",
  encode(message, writer = import_minimal59.default.Writer.create()) {
    if (message.installCount !== 0) {
      writer.uint32(8).int32(message.installCount);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal59.default.Reader ? input : new import_minimal59.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installCount = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { installCount: isSet54(object.installCount) ? Number(object.installCount) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.installCount !== void 0 && (obj.installCount = Math.round(message.installCount));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppStats();
    message.installCount = object.installCount ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.info.AppStats", AppStats);
function toTimestamp5(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp5(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp5(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp5(Timestamp.fromJSON(o));
  }
}
function isSet54(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/installation/installation.js
var import_minimal61 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/reddit/thing_type.js
var ThingType;
(function(ThingType2) {
  ThingType2[ThingType2["UNKNOWN"] = 0] = "UNKNOWN";
  ThingType2[ThingType2["COMMENT"] = 1] = "COMMENT";
  ThingType2[ThingType2["ACCOUNT"] = 2] = "ACCOUNT";
  ThingType2[ThingType2["POST"] = 3] = "POST";
  ThingType2[ThingType2["MESSAGE"] = 4] = "MESSAGE";
  ThingType2[ThingType2["SUBREDDIT"] = 5] = "SUBREDDIT";
  ThingType2[ThingType2["AWARD"] = 6] = "AWARD";
  ThingType2[ThingType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ThingType || (ThingType = {}));
function thingTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return ThingType.UNKNOWN;
    case 1:
    case "COMMENT":
      return ThingType.COMMENT;
    case 2:
    case "ACCOUNT":
      return ThingType.ACCOUNT;
    case 3:
    case "POST":
      return ThingType.POST;
    case 4:
    case "MESSAGE":
      return ThingType.MESSAGE;
    case 5:
    case "SUBREDDIT":
      return ThingType.SUBREDDIT;
    case 6:
    case "AWARD":
      return ThingType.AWARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ThingType.UNRECOGNIZED;
  }
}
function thingTypeToJSON(object) {
  switch (object) {
    case ThingType.UNKNOWN:
      return 0;
    case ThingType.COMMENT:
      return 1;
    case ThingType.ACCOUNT:
      return 2;
    case ThingType.POST:
      return 3;
    case ThingType.MESSAGE:
      return 4;
    case ThingType.SUBREDDIT:
      return 5;
    case ThingType.AWARD:
      return 6;
    case ThingType.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/dev_portal/app_version/info/app_version_info.js
var import_minimal60 = __toESM(require_minimal2(), 1);
var VersionVisibility;
(function(VersionVisibility2) {
  VersionVisibility2[VersionVisibility2["PUBLIC"] = 0] = "PUBLIC";
  VersionVisibility2[VersionVisibility2["PRIVATE"] = 1] = "PRIVATE";
  VersionVisibility2[VersionVisibility2["UNLISTED"] = 2] = "UNLISTED";
  VersionVisibility2[VersionVisibility2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VersionVisibility || (VersionVisibility = {}));
function versionVisibilityFromJSON(object) {
  switch (object) {
    case 0:
    case "PUBLIC":
      return VersionVisibility.PUBLIC;
    case 1:
    case "PRIVATE":
      return VersionVisibility.PRIVATE;
    case 2:
    case "UNLISTED":
      return VersionVisibility.UNLISTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VersionVisibility.UNRECOGNIZED;
  }
}
function versionVisibilityToJSON(object) {
  switch (object) {
    case VersionVisibility.PUBLIC:
      return 0;
    case VersionVisibility.PRIVATE:
      return 1;
    case VersionVisibility.UNLISTED:
      return 2;
    case VersionVisibility.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BuildStatus;
(function(BuildStatus2) {
  BuildStatus2[BuildStatus2["BUILDING"] = 0] = "BUILDING";
  BuildStatus2[BuildStatus2["READY"] = 1] = "READY";
  BuildStatus2[BuildStatus2["FAILED"] = 2] = "FAILED";
  BuildStatus2[BuildStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BuildStatus || (BuildStatus = {}));
function buildStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "BUILDING":
      return BuildStatus.BUILDING;
    case 1:
    case "READY":
      return BuildStatus.READY;
    case 2:
    case "FAILED":
      return BuildStatus.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BuildStatus.UNRECOGNIZED;
  }
}
function buildStatusToJSON(object) {
  switch (object) {
    case BuildStatus.BUILDING:
      return 0;
    case BuildStatus.READY:
      return 1;
    case BuildStatus.FAILED:
      return 2;
    case BuildStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}
var InstallationType;
(function(InstallationType2) {
  InstallationType2[InstallationType2["USER"] = 0] = "USER";
  InstallationType2[InstallationType2["SUBREDDIT"] = 1] = "SUBREDDIT";
  InstallationType2[InstallationType2["SUBREDDIT_GLOBAL"] = 2] = "SUBREDDIT_GLOBAL";
  InstallationType2[InstallationType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(InstallationType || (InstallationType = {}));
function installationTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "USER":
      return InstallationType.USER;
    case 1:
    case "SUBREDDIT":
      return InstallationType.SUBREDDIT;
    case 2:
    case "SUBREDDIT_GLOBAL":
      return InstallationType.SUBREDDIT_GLOBAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InstallationType.UNRECOGNIZED;
  }
}
function installationTypeToJSON(object) {
  switch (object) {
    case InstallationType.USER:
      return 0;
    case InstallationType.SUBREDDIT:
      return 1;
    case InstallationType.SUBREDDIT_GLOBAL:
      return 2;
    case InstallationType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseOptionalVersionVisibility() {
  return { value: 0 };
}
var OptionalVersionVisibility = {
  $type: "devvit.dev_portal.app_version.info.OptionalVersionVisibility",
  encode(message, writer = import_minimal60.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal60.default.Reader ? input : new import_minimal60.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOptionalVersionVisibility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet55(object.value) ? versionVisibilityFromJSON(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.value !== void 0 && (obj.value = versionVisibilityToJSON(message.value));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseOptionalVersionVisibility();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app_version.info.OptionalVersionVisibility", OptionalVersionVisibility);
function createBaseAppVersionInfo() {
  return {
    id: "",
    visibility: 0,
    isTrusted: false,
    validInstallTypes: [],
    majorVersion: 0,
    minorVersion: 0,
    patchVersion: 0,
    prereleaseVersion: void 0,
    uploadedAt: void 0,
    buildStatus: 0,
    builtAt: void 0,
    about: ""
  };
}
var AppVersionInfo = {
  $type: "devvit.dev_portal.app_version.info.AppVersionInfo",
  encode(message, writer = import_minimal60.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.visibility !== 0) {
      writer.uint32(16).int32(message.visibility);
    }
    if (message.isTrusted === true) {
      writer.uint32(24).bool(message.isTrusted);
    }
    writer.uint32(34).fork();
    for (const v of message.validInstallTypes) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.majorVersion !== 0) {
      writer.uint32(40).int32(message.majorVersion);
    }
    if (message.minorVersion !== 0) {
      writer.uint32(48).int32(message.minorVersion);
    }
    if (message.patchVersion !== 0) {
      writer.uint32(56).int32(message.patchVersion);
    }
    if (message.prereleaseVersion !== void 0) {
      Int32Value.encode({ value: message.prereleaseVersion }, writer.uint32(66).fork()).ldelim();
    }
    if (message.uploadedAt !== void 0) {
      Timestamp.encode(toTimestamp6(message.uploadedAt), writer.uint32(74).fork()).ldelim();
    }
    if (message.buildStatus !== 0) {
      writer.uint32(80).int32(message.buildStatus);
    }
    if (message.builtAt !== void 0) {
      Timestamp.encode(toTimestamp6(message.builtAt), writer.uint32(90).fork()).ldelim();
    }
    if (message.about !== "") {
      writer.uint32(98).string(message.about);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal60.default.Reader ? input : new import_minimal60.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.visibility = reader.int32();
          break;
        case 3:
          message.isTrusted = reader.bool();
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.validInstallTypes.push(reader.int32());
            }
          } else {
            message.validInstallTypes.push(reader.int32());
          }
          break;
        case 5:
          message.majorVersion = reader.int32();
          break;
        case 6:
          message.minorVersion = reader.int32();
          break;
        case 7:
          message.patchVersion = reader.int32();
          break;
        case 8:
          message.prereleaseVersion = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.uploadedAt = fromTimestamp6(Timestamp.decode(reader, reader.uint32()));
          break;
        case 10:
          message.buildStatus = reader.int32();
          break;
        case 11:
          message.builtAt = fromTimestamp6(Timestamp.decode(reader, reader.uint32()));
          break;
        case 12:
          message.about = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet55(object.id) ? String(object.id) : "",
      visibility: isSet55(object.visibility) ? versionVisibilityFromJSON(object.visibility) : 0,
      isTrusted: isSet55(object.isTrusted) ? Boolean(object.isTrusted) : false,
      validInstallTypes: Array.isArray(object?.validInstallTypes) ? object.validInstallTypes.map((e) => installationTypeFromJSON(e)) : [],
      majorVersion: isSet55(object.majorVersion) ? Number(object.majorVersion) : 0,
      minorVersion: isSet55(object.minorVersion) ? Number(object.minorVersion) : 0,
      patchVersion: isSet55(object.patchVersion) ? Number(object.patchVersion) : 0,
      prereleaseVersion: isSet55(object.prereleaseVersion) ? Number(object.prereleaseVersion) : void 0,
      uploadedAt: isSet55(object.uploadedAt) ? fromJsonTimestamp6(object.uploadedAt) : void 0,
      buildStatus: isSet55(object.buildStatus) ? buildStatusFromJSON(object.buildStatus) : 0,
      builtAt: isSet55(object.builtAt) ? fromJsonTimestamp6(object.builtAt) : void 0,
      about: isSet55(object.about) ? String(object.about) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.visibility !== void 0 && (obj.visibility = versionVisibilityToJSON(message.visibility));
    message.isTrusted !== void 0 && (obj.isTrusted = message.isTrusted);
    if (message.validInstallTypes) {
      obj.validInstallTypes = message.validInstallTypes.map((e) => installationTypeToJSON(e));
    } else {
      obj.validInstallTypes = [];
    }
    message.majorVersion !== void 0 && (obj.majorVersion = Math.round(message.majorVersion));
    message.minorVersion !== void 0 && (obj.minorVersion = Math.round(message.minorVersion));
    message.patchVersion !== void 0 && (obj.patchVersion = Math.round(message.patchVersion));
    message.prereleaseVersion !== void 0 && (obj.prereleaseVersion = message.prereleaseVersion);
    message.uploadedAt !== void 0 && (obj.uploadedAt = message.uploadedAt.toISOString());
    message.buildStatus !== void 0 && (obj.buildStatus = buildStatusToJSON(message.buildStatus));
    message.builtAt !== void 0 && (obj.builtAt = message.builtAt.toISOString());
    message.about !== void 0 && (obj.about = message.about);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppVersionInfo();
    message.id = object.id ?? "";
    message.visibility = object.visibility ?? 0;
    message.isTrusted = object.isTrusted ?? false;
    message.validInstallTypes = object.validInstallTypes?.map((e) => e) || [];
    message.majorVersion = object.majorVersion ?? 0;
    message.minorVersion = object.minorVersion ?? 0;
    message.patchVersion = object.patchVersion ?? 0;
    message.prereleaseVersion = object.prereleaseVersion ?? void 0;
    message.uploadedAt = object.uploadedAt ?? void 0;
    message.buildStatus = object.buildStatus ?? 0;
    message.builtAt = object.builtAt ?? void 0;
    message.about = object.about ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app_version.info.AppVersionInfo", AppVersionInfo);
function toTimestamp6(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp6(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp6(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp6(Timestamp.fromJSON(o));
  }
}
function isSet55(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/installation/installation.js
var UpgradeStrategy;
(function(UpgradeStrategy2) {
  UpgradeStrategy2[UpgradeStrategy2["MANUAL"] = 0] = "MANUAL";
  UpgradeStrategy2[UpgradeStrategy2["AUTOMATIC"] = 1] = "AUTOMATIC";
  UpgradeStrategy2[UpgradeStrategy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(UpgradeStrategy || (UpgradeStrategy = {}));
function upgradeStrategyFromJSON(object) {
  switch (object) {
    case 0:
    case "MANUAL":
      return UpgradeStrategy.MANUAL;
    case 1:
    case "AUTOMATIC":
      return UpgradeStrategy.AUTOMATIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UpgradeStrategy.UNRECOGNIZED;
  }
}
function upgradeStrategyToJSON(object) {
  switch (object) {
    case UpgradeStrategy.MANUAL:
      return 0;
    case UpgradeStrategy.AUTOMATIC:
      return 1;
    case UpgradeStrategy.UNRECOGNIZED:
    default:
      return -1;
  }
}
var InstallationHistoryEventName;
(function(InstallationHistoryEventName2) {
  InstallationHistoryEventName2[InstallationHistoryEventName2["INSTALLED"] = 0] = "INSTALLED";
  InstallationHistoryEventName2[InstallationHistoryEventName2["UNINSTALLED"] = 1] = "UNINSTALLED";
  InstallationHistoryEventName2[InstallationHistoryEventName2["UPGRADED"] = 2] = "UPGRADED";
  InstallationHistoryEventName2[InstallationHistoryEventName2["UPDATED"] = 3] = "UPDATED";
  InstallationHistoryEventName2[InstallationHistoryEventName2["BANNED"] = 4] = "BANNED";
  InstallationHistoryEventName2[InstallationHistoryEventName2["UNBANNED"] = 5] = "UNBANNED";
  InstallationHistoryEventName2[InstallationHistoryEventName2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(InstallationHistoryEventName || (InstallationHistoryEventName = {}));
function installationHistoryEventNameFromJSON(object) {
  switch (object) {
    case 0:
    case "INSTALLED":
      return InstallationHistoryEventName.INSTALLED;
    case 1:
    case "UNINSTALLED":
      return InstallationHistoryEventName.UNINSTALLED;
    case 2:
    case "UPGRADED":
      return InstallationHistoryEventName.UPGRADED;
    case 3:
    case "UPDATED":
      return InstallationHistoryEventName.UPDATED;
    case 4:
    case "BANNED":
      return InstallationHistoryEventName.BANNED;
    case 5:
    case "UNBANNED":
      return InstallationHistoryEventName.UNBANNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InstallationHistoryEventName.UNRECOGNIZED;
  }
}
function installationHistoryEventNameToJSON(object) {
  switch (object) {
    case InstallationHistoryEventName.INSTALLED:
      return 0;
    case InstallationHistoryEventName.UNINSTALLED:
      return 1;
    case InstallationHistoryEventName.UPGRADED:
      return 2;
    case InstallationHistoryEventName.UPDATED:
      return 3;
    case InstallationHistoryEventName.BANNED:
      return 4;
    case InstallationHistoryEventName.UNBANNED:
      return 5;
    case InstallationHistoryEventName.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseOptionalUpgradeStrategy() {
  return { value: 0 };
}
var OptionalUpgradeStrategy = {
  $type: "devvit.dev_portal.installation.OptionalUpgradeStrategy",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOptionalUpgradeStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet56(object.value) ? upgradeStrategyFromJSON(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.value !== void 0 && (obj.value = upgradeStrategyToJSON(message.value));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseOptionalUpgradeStrategy();
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.OptionalUpgradeStrategy", OptionalUpgradeStrategy);
function createBaseInstallationCreationRequest() {
  return {
    appVersionId: "",
    runAs: void 0,
    type: 0,
    location: "",
    upgradeStrategy: 0,
    upgradeStrategyConfig: void 0
  };
}
var InstallationCreationRequest = {
  $type: "devvit.dev_portal.installation.InstallationCreationRequest",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.appVersionId !== "") {
      writer.uint32(10).string(message.appVersionId);
    }
    if (message.runAs !== void 0) {
      StringValue.encode({ value: message.runAs }, writer.uint32(26).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.location !== "") {
      writer.uint32(42).string(message.location);
    }
    if (message.upgradeStrategy !== 0) {
      writer.uint32(48).int32(message.upgradeStrategy);
    }
    if (message.upgradeStrategyConfig !== void 0) {
      Struct.encode(Struct.wrap(message.upgradeStrategyConfig), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationCreationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.appVersionId = reader.string();
          break;
        case 3:
          message.runAs = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.type = reader.int32();
          break;
        case 5:
          message.location = reader.string();
          break;
        case 6:
          message.upgradeStrategy = reader.int32();
          break;
        case 7:
          message.upgradeStrategyConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      appVersionId: isSet56(object.appVersionId) ? String(object.appVersionId) : "",
      runAs: isSet56(object.runAs) ? String(object.runAs) : void 0,
      type: isSet56(object.type) ? installationTypeFromJSON(object.type) : 0,
      location: isSet56(object.location) ? String(object.location) : "",
      upgradeStrategy: isSet56(object.upgradeStrategy) ? upgradeStrategyFromJSON(object.upgradeStrategy) : 0,
      upgradeStrategyConfig: isObject7(object.upgradeStrategyConfig) ? object.upgradeStrategyConfig : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.appVersionId !== void 0 && (obj.appVersionId = message.appVersionId);
    message.runAs !== void 0 && (obj.runAs = message.runAs);
    message.type !== void 0 && (obj.type = installationTypeToJSON(message.type));
    message.location !== void 0 && (obj.location = message.location);
    message.upgradeStrategy !== void 0 && (obj.upgradeStrategy = upgradeStrategyToJSON(message.upgradeStrategy));
    message.upgradeStrategyConfig !== void 0 && (obj.upgradeStrategyConfig = message.upgradeStrategyConfig);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallationCreationRequest();
    message.appVersionId = object.appVersionId ?? "";
    message.runAs = object.runAs ?? void 0;
    message.type = object.type ?? 0;
    message.location = object.location ?? "";
    message.upgradeStrategy = object.upgradeStrategy ?? 0;
    message.upgradeStrategyConfig = object.upgradeStrategyConfig ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationCreationRequest", InstallationCreationRequest);
function createBaseInstallationUpdateRequest() {
  return {
    id: "",
    runAs: void 0,
    upgradeStrategy: void 0,
    upgradeStrategyConfig: void 0,
    isEnabled: void 0
  };
}
var InstallationUpdateRequest = {
  $type: "devvit.dev_portal.installation.InstallationUpdateRequest",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.runAs !== void 0) {
      StringValue.encode({ value: message.runAs }, writer.uint32(26).fork()).ldelim();
    }
    if (message.upgradeStrategy !== void 0) {
      OptionalUpgradeStrategy.encode(message.upgradeStrategy, writer.uint32(34).fork()).ldelim();
    }
    if (message.upgradeStrategyConfig !== void 0) {
      Struct.encode(Struct.wrap(message.upgradeStrategyConfig), writer.uint32(42).fork()).ldelim();
    }
    if (message.isEnabled !== void 0) {
      BoolValue.encode({ value: message.isEnabled }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 3:
          message.runAs = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.upgradeStrategy = OptionalUpgradeStrategy.decode(reader, reader.uint32());
          break;
        case 5:
          message.upgradeStrategyConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        case 6:
          message.isEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet56(object.id) ? String(object.id) : "",
      runAs: isSet56(object.runAs) ? String(object.runAs) : void 0,
      upgradeStrategy: isSet56(object.upgradeStrategy) ? OptionalUpgradeStrategy.fromJSON(object.upgradeStrategy) : void 0,
      upgradeStrategyConfig: isObject7(object.upgradeStrategyConfig) ? object.upgradeStrategyConfig : void 0,
      isEnabled: isSet56(object.isEnabled) ? Boolean(object.isEnabled) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.runAs !== void 0 && (obj.runAs = message.runAs);
    message.upgradeStrategy !== void 0 && (obj.upgradeStrategy = message.upgradeStrategy ? OptionalUpgradeStrategy.toJSON(message.upgradeStrategy) : void 0);
    message.upgradeStrategyConfig !== void 0 && (obj.upgradeStrategyConfig = message.upgradeStrategyConfig);
    message.isEnabled !== void 0 && (obj.isEnabled = message.isEnabled);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallationUpdateRequest();
    message.id = object.id ?? "";
    message.runAs = object.runAs ?? void 0;
    message.upgradeStrategy = object.upgradeStrategy !== void 0 && object.upgradeStrategy !== null ? OptionalUpgradeStrategy.fromPartial(object.upgradeStrategy) : void 0;
    message.upgradeStrategyConfig = object.upgradeStrategyConfig ?? void 0;
    message.isEnabled = object.isEnabled ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationUpdateRequest", InstallationUpdateRequest);
function createBaseInstallationUpgradeRequest() {
  return { id: "", appVersionId: void 0 };
}
var InstallationUpgradeRequest = {
  $type: "devvit.dev_portal.installation.InstallationUpgradeRequest",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.appVersionId !== void 0) {
      StringValue.encode({ value: message.appVersionId }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationUpgradeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.appVersionId = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet56(object.id) ? String(object.id) : "",
      appVersionId: isSet56(object.appVersionId) ? String(object.appVersionId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.appVersionId !== void 0 && (obj.appVersionId = message.appVersionId);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallationUpgradeRequest();
    message.id = object.id ?? "";
    message.appVersionId = object.appVersionId ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationUpgradeRequest", InstallationUpgradeRequest);
function createBaseGetByAppNameAndInstallLocationRequest() {
  return { slug: "", type: 0, location: "" };
}
var GetByAppNameAndInstallLocationRequest = {
  $type: "devvit.dev_portal.installation.GetByAppNameAndInstallLocationRequest",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.slug !== "") {
      writer.uint32(10).string(message.slug);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.location !== "") {
      writer.uint32(26).string(message.location);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetByAppNameAndInstallLocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.slug = reader.string();
          break;
        case 2:
          message.type = reader.int32();
          break;
        case 3:
          message.location = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      slug: isSet56(object.slug) ? String(object.slug) : "",
      type: isSet56(object.type) ? installationTypeFromJSON(object.type) : 0,
      location: isSet56(object.location) ? String(object.location) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.slug !== void 0 && (obj.slug = message.slug);
    message.type !== void 0 && (obj.type = installationTypeToJSON(message.type));
    message.location !== void 0 && (obj.location = message.location);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetByAppNameAndInstallLocationRequest();
    message.slug = object.slug ?? "";
    message.type = object.type ?? 0;
    message.location = object.location ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.GetByAppNameAndInstallLocationRequest", GetByAppNameAndInstallLocationRequest);
function createBaseGetAllWithInstallLocationRequest() {
  return { type: 0, location: "" };
}
var GetAllWithInstallLocationRequest = {
  $type: "devvit.dev_portal.installation.GetAllWithInstallLocationRequest",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAllWithInstallLocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;
        case 2:
          message.location = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet56(object.type) ? installationTypeFromJSON(object.type) : 0,
      location: isSet56(object.location) ? String(object.location) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = installationTypeToJSON(message.type));
    message.location !== void 0 && (obj.location = message.location);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetAllWithInstallLocationRequest();
    message.type = object.type ?? 0;
    message.location = object.location ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.GetAllWithInstallLocationRequest", GetAllWithInstallLocationRequest);
function createBaseGetAllWithInstallerRequest() {
  return { installedBy: "" };
}
var GetAllWithInstallerRequest = {
  $type: "devvit.dev_portal.installation.GetAllWithInstallerRequest",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.installedBy !== "") {
      writer.uint32(10).string(message.installedBy);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAllWithInstallerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installedBy = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { installedBy: isSet56(object.installedBy) ? String(object.installedBy) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.installedBy !== void 0 && (obj.installedBy = message.installedBy);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetAllWithInstallerRequest();
    message.installedBy = object.installedBy ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.GetAllWithInstallerRequest", GetAllWithInstallerRequest);
function createBaseGetInstallationHistoryRequest() {
  return { type: 0, location: "", slug: "", from: void 0, to: void 0, take: void 0, desc: void 0 };
}
var GetInstallationHistoryRequest = {
  $type: "devvit.dev_portal.installation.GetInstallationHistoryRequest",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.slug !== "") {
      writer.uint32(26).string(message.slug);
    }
    if (message.from !== void 0) {
      Timestamp.encode(toTimestamp7(message.from), writer.uint32(34).fork()).ldelim();
    }
    if (message.to !== void 0) {
      Timestamp.encode(toTimestamp7(message.to), writer.uint32(42).fork()).ldelim();
    }
    if (message.take !== void 0) {
      writer.uint32(48).uint32(message.take);
    }
    if (message.desc !== void 0) {
      writer.uint32(56).bool(message.desc);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;
        case 2:
          message.location = reader.string();
          break;
        case 3:
          message.slug = reader.string();
          break;
        case 4:
          message.from = fromTimestamp7(Timestamp.decode(reader, reader.uint32()));
          break;
        case 5:
          message.to = fromTimestamp7(Timestamp.decode(reader, reader.uint32()));
          break;
        case 6:
          message.take = reader.uint32();
          break;
        case 7:
          message.desc = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet56(object.type) ? installationTypeFromJSON(object.type) : 0,
      location: isSet56(object.location) ? String(object.location) : "",
      slug: isSet56(object.slug) ? String(object.slug) : "",
      from: isSet56(object.from) ? fromJsonTimestamp7(object.from) : void 0,
      to: isSet56(object.to) ? fromJsonTimestamp7(object.to) : void 0,
      take: isSet56(object.take) ? Number(object.take) : void 0,
      desc: isSet56(object.desc) ? Boolean(object.desc) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = installationTypeToJSON(message.type));
    message.location !== void 0 && (obj.location = message.location);
    message.slug !== void 0 && (obj.slug = message.slug);
    message.from !== void 0 && (obj.from = message.from.toISOString());
    message.to !== void 0 && (obj.to = message.to.toISOString());
    message.take !== void 0 && (obj.take = Math.round(message.take));
    message.desc !== void 0 && (obj.desc = message.desc);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetInstallationHistoryRequest();
    message.type = object.type ?? 0;
    message.location = object.location ?? "";
    message.slug = object.slug ?? "";
    message.from = object.from ?? void 0;
    message.to = object.to ?? void 0;
    message.take = object.take ?? void 0;
    message.desc = object.desc ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.GetInstallationHistoryRequest", GetInstallationHistoryRequest);
function createBaseInstallationInfo() {
  return {
    id: "",
    upgradeStrategy: 0,
    upgradeStrategyConfig: void 0,
    runAs: void 0,
    type: 0,
    location: void 0,
    isEnabled: false
  };
}
var InstallationInfo = {
  $type: "devvit.dev_portal.installation.InstallationInfo",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.upgradeStrategy !== 0) {
      writer.uint32(24).int32(message.upgradeStrategy);
    }
    if (message.upgradeStrategyConfig !== void 0) {
      Struct.encode(Struct.wrap(message.upgradeStrategyConfig), writer.uint32(34).fork()).ldelim();
    }
    if (message.runAs !== void 0) {
      StringValue.encode({ value: message.runAs }, writer.uint32(50).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    if (message.location !== void 0) {
      InstallationLocationInfo.encode(message.location, writer.uint32(66).fork()).ldelim();
    }
    if (message.isEnabled === true) {
      writer.uint32(72).bool(message.isEnabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 3:
          message.upgradeStrategy = reader.int32();
          break;
        case 4:
          message.upgradeStrategyConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        case 6:
          message.runAs = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.type = reader.int32();
          break;
        case 8:
          message.location = InstallationLocationInfo.decode(reader, reader.uint32());
          break;
        case 9:
          message.isEnabled = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet56(object.id) ? String(object.id) : "",
      upgradeStrategy: isSet56(object.upgradeStrategy) ? upgradeStrategyFromJSON(object.upgradeStrategy) : 0,
      upgradeStrategyConfig: isObject7(object.upgradeStrategyConfig) ? object.upgradeStrategyConfig : void 0,
      runAs: isSet56(object.runAs) ? String(object.runAs) : void 0,
      type: isSet56(object.type) ? installationTypeFromJSON(object.type) : 0,
      location: isSet56(object.location) ? InstallationLocationInfo.fromJSON(object.location) : void 0,
      isEnabled: isSet56(object.isEnabled) ? Boolean(object.isEnabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.upgradeStrategy !== void 0 && (obj.upgradeStrategy = upgradeStrategyToJSON(message.upgradeStrategy));
    message.upgradeStrategyConfig !== void 0 && (obj.upgradeStrategyConfig = message.upgradeStrategyConfig);
    message.runAs !== void 0 && (obj.runAs = message.runAs);
    message.type !== void 0 && (obj.type = installationTypeToJSON(message.type));
    message.location !== void 0 && (obj.location = message.location ? InstallationLocationInfo.toJSON(message.location) : void 0);
    message.isEnabled !== void 0 && (obj.isEnabled = message.isEnabled);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallationInfo();
    message.id = object.id ?? "";
    message.upgradeStrategy = object.upgradeStrategy ?? 0;
    message.upgradeStrategyConfig = object.upgradeStrategyConfig ?? void 0;
    message.runAs = object.runAs ?? void 0;
    message.type = object.type ?? 0;
    message.location = object.location !== void 0 && object.location !== null ? InstallationLocationInfo.fromPartial(object.location) : void 0;
    message.isEnabled = object.isEnabled ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationInfo", InstallationInfo);
function createBaseInstallationLocationInfo() {
  return { id: "", name: "", type: 0, icon: void 0 };
}
var InstallationLocationInfo = {
  $type: "devvit.dev_portal.installation.InstallationLocationInfo",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.icon !== void 0) {
      StringValue.encode({ value: message.icon }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationLocationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.type = reader.int32();
          break;
        case 4:
          message.icon = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet56(object.id) ? String(object.id) : "",
      name: isSet56(object.name) ? String(object.name) : "",
      type: isSet56(object.type) ? thingTypeFromJSON(object.type) : 0,
      icon: isSet56(object.icon) ? String(object.icon) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.name !== void 0 && (obj.name = message.name);
    message.type !== void 0 && (obj.type = thingTypeToJSON(message.type));
    message.icon !== void 0 && (obj.icon = message.icon);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallationLocationInfo();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.icon = object.icon ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationLocationInfo", InstallationLocationInfo);
function createBaseFullInstallationInfo() {
  return { installation: void 0, appVersion: void 0, app: void 0 };
}
var FullInstallationInfo = {
  $type: "devvit.dev_portal.installation.FullInstallationInfo",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.installation !== void 0) {
      InstallationInfo.encode(message.installation, writer.uint32(10).fork()).ldelim();
    }
    if (message.appVersion !== void 0) {
      AppVersionInfo.encode(message.appVersion, writer.uint32(18).fork()).ldelim();
    }
    if (message.app !== void 0) {
      AppInfo.encode(message.app, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFullInstallationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installation = InstallationInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.appVersion = AppVersionInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.app = AppInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      installation: isSet56(object.installation) ? InstallationInfo.fromJSON(object.installation) : void 0,
      appVersion: isSet56(object.appVersion) ? AppVersionInfo.fromJSON(object.appVersion) : void 0,
      app: isSet56(object.app) ? AppInfo.fromJSON(object.app) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.installation !== void 0 && (obj.installation = message.installation ? InstallationInfo.toJSON(message.installation) : void 0);
    message.appVersion !== void 0 && (obj.appVersion = message.appVersion ? AppVersionInfo.toJSON(message.appVersion) : void 0);
    message.app !== void 0 && (obj.app = message.app ? AppInfo.toJSON(message.app) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFullInstallationInfo();
    message.installation = object.installation !== void 0 && object.installation !== null ? InstallationInfo.fromPartial(object.installation) : void 0;
    message.appVersion = object.appVersion !== void 0 && object.appVersion !== null ? AppVersionInfo.fromPartial(object.appVersion) : void 0;
    message.app = object.app !== void 0 && object.app !== null ? AppInfo.fromPartial(object.app) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.FullInstallationInfo", FullInstallationInfo);
function createBaseMultipleInstallationsResponse() {
  return { installations: [] };
}
var MultipleInstallationsResponse = {
  $type: "devvit.dev_portal.installation.MultipleInstallationsResponse",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    for (const v of message.installations) {
      InstallationInfo.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMultipleInstallationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installations.push(InstallationInfo.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      installations: Array.isArray(object?.installations) ? object.installations.map((e) => InstallationInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installations) {
      obj.installations = message.installations.map((e) => e ? InstallationInfo.toJSON(e) : void 0);
    } else {
      obj.installations = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMultipleInstallationsResponse();
    message.installations = object.installations?.map((e) => InstallationInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.MultipleInstallationsResponse", MultipleInstallationsResponse);
function createBaseGetAllWithAppResponse() {
  return { installations: [] };
}
var GetAllWithAppResponse = {
  $type: "devvit.dev_portal.installation.GetAllWithAppResponse",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    for (const v of message.installations) {
      InstallationWithAppVersion.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAllWithAppResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installations.push(InstallationWithAppVersion.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      installations: Array.isArray(object?.installations) ? object.installations.map((e) => InstallationWithAppVersion.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installations) {
      obj.installations = message.installations.map((e) => e ? InstallationWithAppVersion.toJSON(e) : void 0);
    } else {
      obj.installations = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetAllWithAppResponse();
    message.installations = object.installations?.map((e) => InstallationWithAppVersion.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.GetAllWithAppResponse", GetAllWithAppResponse);
function createBaseInstallationWithAppVersion() {
  return { installation: void 0, appVersion: void 0 };
}
var InstallationWithAppVersion = {
  $type: "devvit.dev_portal.installation.InstallationWithAppVersion",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.installation !== void 0) {
      InstallationInfo.encode(message.installation, writer.uint32(10).fork()).ldelim();
    }
    if (message.appVersion !== void 0) {
      AppVersionInfo.encode(message.appVersion, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationWithAppVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installation = InstallationInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.appVersion = AppVersionInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      installation: isSet56(object.installation) ? InstallationInfo.fromJSON(object.installation) : void 0,
      appVersion: isSet56(object.appVersion) ? AppVersionInfo.fromJSON(object.appVersion) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.installation !== void 0 && (obj.installation = message.installation ? InstallationInfo.toJSON(message.installation) : void 0);
    message.appVersion !== void 0 && (obj.appVersion = message.appVersion ? AppVersionInfo.toJSON(message.appVersion) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallationWithAppVersion();
    message.installation = object.installation !== void 0 && object.installation !== null ? InstallationInfo.fromPartial(object.installation) : void 0;
    message.appVersion = object.appVersion !== void 0 && object.appVersion !== null ? AppVersionInfo.fromPartial(object.appVersion) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationWithAppVersion", InstallationWithAppVersion);
function createBaseInstallationLocationDetails() {
  return { type: 0, thingId: "", name: "" };
}
var InstallationLocationDetails = {
  $type: "devvit.dev_portal.installation.InstallationLocationDetails",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.thingId !== "") {
      writer.uint32(18).string(message.thingId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationLocationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;
        case 2:
          message.thingId = reader.string();
          break;
        case 3:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet56(object.type) ? installationTypeFromJSON(object.type) : 0,
      thingId: isSet56(object.thingId) ? String(object.thingId) : "",
      name: isSet56(object.name) ? String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = installationTypeToJSON(message.type));
    message.thingId !== void 0 && (obj.thingId = message.thingId);
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallationLocationDetails();
    message.type = object.type ?? 0;
    message.thingId = object.thingId ?? "";
    message.name = object.name ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationLocationDetails", InstallationLocationDetails);
function createBaseInstallationHistoryEvent() {
  return { userId: "", name: 0, details: {}, createdAt: void 0 };
}
var InstallationHistoryEvent = {
  $type: "devvit.dev_portal.installation.InstallationHistoryEvent",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.name !== 0) {
      writer.uint32(16).int32(message.name);
    }
    Object.entries(message.details).forEach(([key, value]) => {
      InstallationHistoryEvent_DetailsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.createdAt !== void 0) {
      Timestamp.encode(toTimestamp7(message.createdAt), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationHistoryEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.userId = reader.string();
          break;
        case 2:
          message.name = reader.int32();
          break;
        case 3:
          const entry3 = InstallationHistoryEvent_DetailsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.details[entry3.key] = entry3.value;
          }
          break;
        case 4:
          message.createdAt = fromTimestamp7(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet56(object.userId) ? String(object.userId) : "",
      name: isSet56(object.name) ? installationHistoryEventNameFromJSON(object.name) : 0,
      details: isObject7(object.details) ? Object.entries(object.details).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      createdAt: isSet56(object.createdAt) ? fromJsonTimestamp7(object.createdAt) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.userId !== void 0 && (obj.userId = message.userId);
    message.name !== void 0 && (obj.name = installationHistoryEventNameToJSON(message.name));
    obj.details = {};
    if (message.details) {
      Object.entries(message.details).forEach(([k, v]) => {
        obj.details[k] = v;
      });
    }
    message.createdAt !== void 0 && (obj.createdAt = message.createdAt.toISOString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallationHistoryEvent();
    message.userId = object.userId ?? "";
    message.name = object.name ?? 0;
    message.details = Object.entries(object.details ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.createdAt = object.createdAt ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationHistoryEvent", InstallationHistoryEvent);
function createBaseInstallationHistoryEvent_DetailsEntry() {
  return { key: "", value: "" };
}
var InstallationHistoryEvent_DetailsEntry = {
  $type: "devvit.dev_portal.installation.InstallationHistoryEvent.DetailsEntry",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationHistoryEvent_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet56(object.key) ? String(object.key) : "", value: isSet56(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallationHistoryEvent_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.InstallationHistoryEvent.DetailsEntry", InstallationHistoryEvent_DetailsEntry);
function createBaseGetInstallationHistoryResponse() {
  return { events: [], totalEvents: 0 };
}
var GetInstallationHistoryResponse = {
  $type: "devvit.dev_portal.installation.GetInstallationHistoryResponse",
  encode(message, writer = import_minimal61.default.Writer.create()) {
    for (const v of message.events) {
      InstallationHistoryEvent.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalEvents !== 0) {
      writer.uint32(64).uint32(message.totalEvents);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal61.default.Reader ? input : new import_minimal61.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.events.push(InstallationHistoryEvent.decode(reader, reader.uint32()));
          break;
        case 8:
          message.totalEvents = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      events: Array.isArray(object?.events) ? object.events.map((e) => InstallationHistoryEvent.fromJSON(e)) : [],
      totalEvents: isSet56(object.totalEvents) ? Number(object.totalEvents) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.events) {
      obj.events = message.events.map((e) => e ? InstallationHistoryEvent.toJSON(e) : void 0);
    } else {
      obj.events = [];
    }
    message.totalEvents !== void 0 && (obj.totalEvents = Math.round(message.totalEvents));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetInstallationHistoryResponse();
    message.events = object.events?.map((e) => InstallationHistoryEvent.fromPartial(e)) || [];
    message.totalEvents = object.totalEvents ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation.GetInstallationHistoryResponse", GetInstallationHistoryResponse);
function toTimestamp7(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp7(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp7(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp7(Timestamp.fromJSON(o));
  }
}
function isObject7(value) {
  return typeof value === "object" && value !== null;
}
function isSet56(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/app_version/app_version.js
function createBaseAppVersionCreationRequest() {
  return {
    appId: "",
    visibility: 0,
    validInstallTypes: [],
    majorVersion: 0,
    minorVersion: 0,
    patchVersion: 0,
    prereleaseVersion: void 0,
    actorBundles: [],
    about: ""
  };
}
var AppVersionCreationRequest = {
  $type: "devvit.dev_portal.app_version.AppVersionCreationRequest",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.visibility !== 0) {
      writer.uint32(16).int32(message.visibility);
    }
    writer.uint32(26).fork();
    for (const v of message.validInstallTypes) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.majorVersion !== 0) {
      writer.uint32(32).int32(message.majorVersion);
    }
    if (message.minorVersion !== 0) {
      writer.uint32(40).int32(message.minorVersion);
    }
    if (message.patchVersion !== 0) {
      writer.uint32(48).int32(message.patchVersion);
    }
    if (message.prereleaseVersion !== void 0) {
      Int32Value.encode({ value: message.prereleaseVersion }, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.actorBundles) {
      Bundle.encode(v, writer.uint32(66).fork()).ldelim();
    }
    if (message.about !== "") {
      writer.uint32(74).string(message.about);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : new import_minimal62.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppVersionCreationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.appId = reader.string();
          break;
        case 2:
          message.visibility = reader.int32();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.validInstallTypes.push(reader.int32());
            }
          } else {
            message.validInstallTypes.push(reader.int32());
          }
          break;
        case 4:
          message.majorVersion = reader.int32();
          break;
        case 5:
          message.minorVersion = reader.int32();
          break;
        case 6:
          message.patchVersion = reader.int32();
          break;
        case 7:
          message.prereleaseVersion = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.actorBundles.push(Bundle.decode(reader, reader.uint32()));
          break;
        case 9:
          message.about = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet57(object.appId) ? String(object.appId) : "",
      visibility: isSet57(object.visibility) ? versionVisibilityFromJSON(object.visibility) : 0,
      validInstallTypes: Array.isArray(object?.validInstallTypes) ? object.validInstallTypes.map((e) => installationTypeFromJSON(e)) : [],
      majorVersion: isSet57(object.majorVersion) ? Number(object.majorVersion) : 0,
      minorVersion: isSet57(object.minorVersion) ? Number(object.minorVersion) : 0,
      patchVersion: isSet57(object.patchVersion) ? Number(object.patchVersion) : 0,
      prereleaseVersion: isSet57(object.prereleaseVersion) ? Number(object.prereleaseVersion) : void 0,
      actorBundles: Array.isArray(object?.actorBundles) ? object.actorBundles.map((e) => Bundle.fromJSON(e)) : [],
      about: isSet57(object.about) ? String(object.about) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.appId !== void 0 && (obj.appId = message.appId);
    message.visibility !== void 0 && (obj.visibility = versionVisibilityToJSON(message.visibility));
    if (message.validInstallTypes) {
      obj.validInstallTypes = message.validInstallTypes.map((e) => installationTypeToJSON(e));
    } else {
      obj.validInstallTypes = [];
    }
    message.majorVersion !== void 0 && (obj.majorVersion = Math.round(message.majorVersion));
    message.minorVersion !== void 0 && (obj.minorVersion = Math.round(message.minorVersion));
    message.patchVersion !== void 0 && (obj.patchVersion = Math.round(message.patchVersion));
    message.prereleaseVersion !== void 0 && (obj.prereleaseVersion = message.prereleaseVersion);
    if (message.actorBundles) {
      obj.actorBundles = message.actorBundles.map((e) => e ? Bundle.toJSON(e) : void 0);
    } else {
      obj.actorBundles = [];
    }
    message.about !== void 0 && (obj.about = message.about);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppVersionCreationRequest();
    message.appId = object.appId ?? "";
    message.visibility = object.visibility ?? 0;
    message.validInstallTypes = object.validInstallTypes?.map((e) => e) || [];
    message.majorVersion = object.majorVersion ?? 0;
    message.minorVersion = object.minorVersion ?? 0;
    message.patchVersion = object.patchVersion ?? 0;
    message.prereleaseVersion = object.prereleaseVersion ?? void 0;
    message.actorBundles = object.actorBundles?.map((e) => Bundle.fromPartial(e)) || [];
    message.about = object.about ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app_version.AppVersionCreationRequest", AppVersionCreationRequest);
function createBaseAppSlugAndVersion() {
  return { slug: "", version: "" };
}
var AppSlugAndVersion = {
  $type: "devvit.dev_portal.app_version.AppSlugAndVersion",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    if (message.slug !== "") {
      writer.uint32(10).string(message.slug);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : new import_minimal62.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppSlugAndVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.slug = reader.string();
          break;
        case 2:
          message.version = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      slug: isSet57(object.slug) ? String(object.slug) : "",
      version: isSet57(object.version) ? String(object.version) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.slug !== void 0 && (obj.slug = message.slug);
    message.version !== void 0 && (obj.version = message.version);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppSlugAndVersion();
    message.slug = object.slug ?? "";
    message.version = object.version ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app_version.AppSlugAndVersion", AppSlugAndVersion);
function createBaseAppVersionUpdateRequest() {
  return { id: "", visibility: void 0, isTrusted: void 0, validInstallTypes: [], about: void 0 };
}
var AppVersionUpdateRequest = {
  $type: "devvit.dev_portal.app_version.AppVersionUpdateRequest",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.visibility !== void 0) {
      OptionalVersionVisibility.encode(message.visibility, writer.uint32(18).fork()).ldelim();
    }
    if (message.isTrusted !== void 0) {
      BoolValue.encode({ value: message.isTrusted }, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).fork();
    for (const v of message.validInstallTypes) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.about !== void 0) {
      StringValue.encode({ value: message.about }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : new import_minimal62.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppVersionUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.visibility = OptionalVersionVisibility.decode(reader, reader.uint32());
          break;
        case 3:
          message.isTrusted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.validInstallTypes.push(reader.int32());
            }
          } else {
            message.validInstallTypes.push(reader.int32());
          }
          break;
        case 5:
          message.about = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet57(object.id) ? String(object.id) : "",
      visibility: isSet57(object.visibility) ? OptionalVersionVisibility.fromJSON(object.visibility) : void 0,
      isTrusted: isSet57(object.isTrusted) ? Boolean(object.isTrusted) : void 0,
      validInstallTypes: Array.isArray(object?.validInstallTypes) ? object.validInstallTypes.map((e) => installationTypeFromJSON(e)) : [],
      about: isSet57(object.about) ? String(object.about) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.visibility !== void 0 && (obj.visibility = message.visibility ? OptionalVersionVisibility.toJSON(message.visibility) : void 0);
    message.isTrusted !== void 0 && (obj.isTrusted = message.isTrusted);
    if (message.validInstallTypes) {
      obj.validInstallTypes = message.validInstallTypes.map((e) => installationTypeToJSON(e));
    } else {
      obj.validInstallTypes = [];
    }
    message.about !== void 0 && (obj.about = message.about);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppVersionUpdateRequest();
    message.id = object.id ?? "";
    message.visibility = object.visibility !== void 0 && object.visibility !== null ? OptionalVersionVisibility.fromPartial(object.visibility) : void 0;
    message.isTrusted = object.isTrusted ?? void 0;
    message.validInstallTypes = object.validInstallTypes?.map((e) => e) || [];
    message.about = object.about ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app_version.AppVersionUpdateRequest", AppVersionUpdateRequest);
function createBaseInstallLocationPageInfo() {
  return { type: 0, before: void 0, after: void 0 };
}
var InstallLocationPageInfo = {
  $type: "devvit.dev_portal.app_version.InstallLocationPageInfo",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : new import_minimal62.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallLocationPageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet57(object.type) ? installationTypeFromJSON(object.type) : 0,
      before: isSet57(object.before) ? String(object.before) : void 0,
      after: isSet57(object.after) ? String(object.after) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = installationTypeToJSON(message.type));
    message.before !== void 0 && (obj.before = message.before);
    message.after !== void 0 && (obj.after = message.after);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallLocationPageInfo();
    message.type = object.type ?? 0;
    message.before = object.before ?? void 0;
    message.after = object.after ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app_version.InstallLocationPageInfo", InstallLocationPageInfo);
function createBaseFullAppVersionInfo() {
  return { appVersion: void 0, app: void 0, actorTypes: [], installations: [] };
}
var FullAppVersionInfo = {
  $type: "devvit.dev_portal.app_version.FullAppVersionInfo",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    if (message.appVersion !== void 0) {
      AppVersionInfo.encode(message.appVersion, writer.uint32(10).fork()).ldelim();
    }
    if (message.app !== void 0) {
      AppInfo.encode(message.app, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.actorTypes) {
      ActorTypeInfo.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.installations) {
      InstallationInfo.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : new import_minimal62.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFullAppVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.appVersion = AppVersionInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.app = AppInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.actorTypes.push(ActorTypeInfo.decode(reader, reader.uint32()));
          break;
        case 4:
          message.installations.push(InstallationInfo.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      appVersion: isSet57(object.appVersion) ? AppVersionInfo.fromJSON(object.appVersion) : void 0,
      app: isSet57(object.app) ? AppInfo.fromJSON(object.app) : void 0,
      actorTypes: Array.isArray(object?.actorTypes) ? object.actorTypes.map((e) => ActorTypeInfo.fromJSON(e)) : [],
      installations: Array.isArray(object?.installations) ? object.installations.map((e) => InstallationInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.appVersion !== void 0 && (obj.appVersion = message.appVersion ? AppVersionInfo.toJSON(message.appVersion) : void 0);
    message.app !== void 0 && (obj.app = message.app ? AppInfo.toJSON(message.app) : void 0);
    if (message.actorTypes) {
      obj.actorTypes = message.actorTypes.map((e) => e ? ActorTypeInfo.toJSON(e) : void 0);
    } else {
      obj.actorTypes = [];
    }
    if (message.installations) {
      obj.installations = message.installations.map((e) => e ? InstallationInfo.toJSON(e) : void 0);
    } else {
      obj.installations = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFullAppVersionInfo();
    message.appVersion = object.appVersion !== void 0 && object.appVersion !== null ? AppVersionInfo.fromPartial(object.appVersion) : void 0;
    message.app = object.app !== void 0 && object.app !== null ? AppInfo.fromPartial(object.app) : void 0;
    message.actorTypes = object.actorTypes?.map((e) => ActorTypeInfo.fromPartial(e)) || [];
    message.installations = object.installations?.map((e) => InstallationInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app_version.FullAppVersionInfo", FullAppVersionInfo);
function createBaseValidInstallLocationsResponse() {
  return { locations: [] };
}
var ValidInstallLocationsResponse = {
  $type: "devvit.dev_portal.app_version.ValidInstallLocationsResponse",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    for (const v of message.locations) {
      InstallLocationInfo.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : new import_minimal62.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidInstallLocationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.locations.push(InstallLocationInfo.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      locations: Array.isArray(object?.locations) ? object.locations.map((e) => InstallLocationInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.locations) {
      obj.locations = message.locations.map((e) => e ? InstallLocationInfo.toJSON(e) : void 0);
    } else {
      obj.locations = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseValidInstallLocationsResponse();
    message.locations = object.locations?.map((e) => InstallLocationInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app_version.ValidInstallLocationsResponse", ValidInstallLocationsResponse);
function createBaseInstallLocationInfo() {
  return { type: 0, locations: [] };
}
var InstallLocationInfo = {
  $type: "devvit.dev_portal.app_version.InstallLocationInfo",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.locations) {
      InstallLocationDetails.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : new import_minimal62.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallLocationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;
        case 2:
          message.locations.push(InstallLocationDetails.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet57(object.type) ? installationTypeFromJSON(object.type) : 0,
      locations: Array.isArray(object?.locations) ? object.locations.map((e) => InstallLocationDetails.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = installationTypeToJSON(message.type));
    if (message.locations) {
      obj.locations = message.locations.map((e) => e ? InstallLocationDetails.toJSON(e) : void 0);
    } else {
      obj.locations = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallLocationInfo();
    message.type = object.type ?? 0;
    message.locations = object.locations?.map((e) => InstallLocationDetails.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app_version.InstallLocationInfo", InstallLocationInfo);
function createBaseInstallLocationDetails() {
  return { thingId: "", name: "", existingInstallId: void 0, icon: void 0 };
}
var InstallLocationDetails = {
  $type: "devvit.dev_portal.app_version.InstallLocationDetails",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    if (message.thingId !== "") {
      writer.uint32(10).string(message.thingId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.existingInstallId !== void 0) {
      StringValue.encode({ value: message.existingInstallId }, writer.uint32(26).fork()).ldelim();
    }
    if (message.icon !== void 0) {
      StringValue.encode({ value: message.icon }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : new import_minimal62.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallLocationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.thingId = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.existingInstallId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.icon = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      thingId: isSet57(object.thingId) ? String(object.thingId) : "",
      name: isSet57(object.name) ? String(object.name) : "",
      existingInstallId: isSet57(object.existingInstallId) ? String(object.existingInstallId) : void 0,
      icon: isSet57(object.icon) ? String(object.icon) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.thingId !== void 0 && (obj.thingId = message.thingId);
    message.name !== void 0 && (obj.name = message.name);
    message.existingInstallId !== void 0 && (obj.existingInstallId = message.existingInstallId);
    message.icon !== void 0 && (obj.icon = message.icon);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallLocationDetails();
    message.thingId = object.thingId ?? "";
    message.name = object.name ?? "";
    message.existingInstallId = object.existingInstallId ?? void 0;
    message.icon = object.icon ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app_version.InstallLocationDetails", InstallLocationDetails);
function createBasePageInfo() {
  return { hasNextPage: false, hasPreviousPage: false, startCursor: "", endCursor: "" };
}
var PageInfo = {
  $type: "devvit.dev_portal.app_version.PageInfo",
  encode(message, writer = import_minimal62.default.Writer.create()) {
    if (message.hasNextPage === true) {
      writer.uint32(8).bool(message.hasNextPage);
    }
    if (message.hasPreviousPage === true) {
      writer.uint32(16).bool(message.hasPreviousPage);
    }
    if (message.startCursor !== "") {
      writer.uint32(26).string(message.startCursor);
    }
    if (message.endCursor !== "") {
      writer.uint32(34).string(message.endCursor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal62.default.Reader ? input : new import_minimal62.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hasNextPage = reader.bool();
          break;
        case 2:
          message.hasPreviousPage = reader.bool();
          break;
        case 3:
          message.startCursor = reader.string();
          break;
        case 4:
          message.endCursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      hasNextPage: isSet57(object.hasNextPage) ? Boolean(object.hasNextPage) : false,
      hasPreviousPage: isSet57(object.hasPreviousPage) ? Boolean(object.hasPreviousPage) : false,
      startCursor: isSet57(object.startCursor) ? String(object.startCursor) : "",
      endCursor: isSet57(object.endCursor) ? String(object.endCursor) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.hasNextPage !== void 0 && (obj.hasNextPage = message.hasNextPage);
    message.hasPreviousPage !== void 0 && (obj.hasPreviousPage = message.hasPreviousPage);
    message.startCursor !== void 0 && (obj.startCursor = message.startCursor);
    message.endCursor !== void 0 && (obj.endCursor = message.endCursor);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePageInfo();
    message.hasNextPage = object.hasNextPage ?? false;
    message.hasPreviousPage = object.hasPreviousPage ?? false;
    message.startCursor = object.startCursor ?? "";
    message.endCursor = object.endCursor ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app_version.PageInfo", PageInfo);
function isSet57(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/app/app.js
var import_minimal63 = __toESM(require_minimal2(), 1);
var OrderBy;
(function(OrderBy2) {
  OrderBy2[OrderBy2["DATE_CREATED"] = 0] = "DATE_CREATED";
  OrderBy2[OrderBy2["NAME"] = 1] = "NAME";
  OrderBy2[OrderBy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OrderBy || (OrderBy = {}));
function orderByFromJSON(object) {
  switch (object) {
    case 0:
    case "DATE_CREATED":
      return OrderBy.DATE_CREATED;
    case 1:
    case "NAME":
      return OrderBy.NAME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderBy.UNRECOGNIZED;
  }
}
function orderByToJSON(object) {
  switch (object) {
    case OrderBy.DATE_CREATED:
      return 0;
    case OrderBy.NAME:
      return 1;
    case OrderBy.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseAppSearchRequest() {
  return {
    searchTerm: void 0,
    categories: [],
    page: void 0,
    pageSize: void 0,
    orderBy: 0,
    isAscending: void 0
  };
}
var AppSearchRequest = {
  $type: "devvit.dev_portal.app.AppSearchRequest",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.searchTerm !== void 0) {
      StringValue.encode({ value: message.searchTerm }, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).fork();
    for (const v of message.categories) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.page !== void 0) {
      Int32Value.encode({ value: message.page }, writer.uint32(26).fork()).ldelim();
    }
    if (message.pageSize !== void 0) {
      Int32Value.encode({ value: message.pageSize }, writer.uint32(34).fork()).ldelim();
    }
    if (message.orderBy !== 0) {
      writer.uint32(40).int32(message.orderBy);
    }
    if (message.isAscending !== void 0) {
      BoolValue.encode({ value: message.isAscending }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.searchTerm = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.categories.push(reader.int32());
            }
          } else {
            message.categories.push(reader.int32());
          }
          break;
        case 3:
          message.page = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.pageSize = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.orderBy = reader.int32();
          break;
        case 6:
          message.isAscending = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      searchTerm: isSet58(object.searchTerm) ? String(object.searchTerm) : void 0,
      categories: Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
      page: isSet58(object.page) ? Number(object.page) : void 0,
      pageSize: isSet58(object.pageSize) ? Number(object.pageSize) : void 0,
      orderBy: isSet58(object.orderBy) ? orderByFromJSON(object.orderBy) : 0,
      isAscending: isSet58(object.isAscending) ? Boolean(object.isAscending) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.searchTerm !== void 0 && (obj.searchTerm = message.searchTerm);
    if (message.categories) {
      obj.categories = message.categories.map((e) => categoriesToJSON(e));
    } else {
      obj.categories = [];
    }
    message.page !== void 0 && (obj.page = message.page);
    message.pageSize !== void 0 && (obj.pageSize = message.pageSize);
    message.orderBy !== void 0 && (obj.orderBy = orderByToJSON(message.orderBy));
    message.isAscending !== void 0 && (obj.isAscending = message.isAscending);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppSearchRequest();
    message.searchTerm = object.searchTerm ?? void 0;
    message.categories = object.categories?.map((e) => e) || [];
    message.page = object.page ?? void 0;
    message.pageSize = object.pageSize ?? void 0;
    message.orderBy = object.orderBy ?? 0;
    message.isAscending = object.isAscending ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.AppSearchRequest", AppSearchRequest);
function createBaseGetAppBySlugRequest() {
  return { slug: "" };
}
var GetAppBySlugRequest = {
  $type: "devvit.dev_portal.app.GetAppBySlugRequest",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.slug !== "") {
      writer.uint32(10).string(message.slug);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAppBySlugRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.slug = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { slug: isSet58(object.slug) ? String(object.slug) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.slug !== void 0 && (obj.slug = message.slug);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetAppBySlugRequest();
    message.slug = object.slug ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.GetAppBySlugRequest", GetAppBySlugRequest);
function createBaseGetAllWithOwnerRequest() {
  return { owner: "" };
}
var GetAllWithOwnerRequest = {
  $type: "devvit.dev_portal.app.GetAllWithOwnerRequest",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAllWithOwnerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.owner = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { owner: isSet58(object.owner) ? String(object.owner) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.owner !== void 0 && (obj.owner = message.owner);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetAllWithOwnerRequest();
    message.owner = object.owner ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.GetAllWithOwnerRequest", GetAllWithOwnerRequest);
function createBaseAppCreationRequest() {
  return { name: "", description: "", isNsfw: false, categories: [], autogenerateName: false };
}
var AppCreationRequest = {
  $type: "devvit.dev_portal.app.AppCreationRequest",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.isNsfw === true) {
      writer.uint32(24).bool(message.isNsfw);
    }
    writer.uint32(34).fork();
    for (const v of message.categories) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.autogenerateName === true) {
      writer.uint32(40).bool(message.autogenerateName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppCreationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.isNsfw = reader.bool();
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.categories.push(reader.int32());
            }
          } else {
            message.categories.push(reader.int32());
          }
          break;
        case 5:
          message.autogenerateName = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet58(object.name) ? String(object.name) : "",
      description: isSet58(object.description) ? String(object.description) : "",
      isNsfw: isSet58(object.isNsfw) ? Boolean(object.isNsfw) : false,
      categories: Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
      autogenerateName: isSet58(object.autogenerateName) ? Boolean(object.autogenerateName) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.description !== void 0 && (obj.description = message.description);
    message.isNsfw !== void 0 && (obj.isNsfw = message.isNsfw);
    if (message.categories) {
      obj.categories = message.categories.map((e) => categoriesToJSON(e));
    } else {
      obj.categories = [];
    }
    message.autogenerateName !== void 0 && (obj.autogenerateName = message.autogenerateName);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppCreationRequest();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.isNsfw = object.isNsfw ?? false;
    message.categories = object.categories?.map((e) => e) || [];
    message.autogenerateName = object.autogenerateName ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.AppCreationRequest", AppCreationRequest);
function createBaseGetPopularAppsRequest() {
  return { limit: 0 };
}
var GetPopularAppsRequest = {
  $type: "devvit.dev_portal.app.GetPopularAppsRequest",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.limit !== 0) {
      writer.uint32(8).int32(message.limit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetPopularAppsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.limit = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { limit: isSet58(object.limit) ? Number(object.limit) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.limit !== void 0 && (obj.limit = Math.round(message.limit));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetPopularAppsRequest();
    message.limit = object.limit ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.GetPopularAppsRequest", GetPopularAppsRequest);
function createBaseAppUpdateRequest() {
  return {
    id: "",
    slug: void 0,
    name: void 0,
    description: void 0,
    isNsfw: void 0,
    isDelisted: void 0,
    categories: [],
    termsAndConditions: void 0,
    privacyPolicy: void 0
  };
}
var AppUpdateRequest = {
  $type: "devvit.dev_portal.app.AppUpdateRequest",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.slug !== void 0) {
      StringValue.encode({ value: message.slug }, writer.uint32(18).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(34).fork()).ldelim();
    }
    if (message.isNsfw !== void 0) {
      BoolValue.encode({ value: message.isNsfw }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isDelisted !== void 0) {
      BoolValue.encode({ value: message.isDelisted }, writer.uint32(50).fork()).ldelim();
    }
    writer.uint32(58).fork();
    for (const v of message.categories) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.termsAndConditions !== void 0) {
      StringValue.encode({ value: message.termsAndConditions }, writer.uint32(66).fork()).ldelim();
    }
    if (message.privacyPolicy !== void 0) {
      StringValue.encode({ value: message.privacyPolicy }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.slug = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.isNsfw = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.isDelisted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.categories.push(reader.int32());
            }
          } else {
            message.categories.push(reader.int32());
          }
          break;
        case 8:
          message.termsAndConditions = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.privacyPolicy = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet58(object.id) ? String(object.id) : "",
      slug: isSet58(object.slug) ? String(object.slug) : void 0,
      name: isSet58(object.name) ? String(object.name) : void 0,
      description: isSet58(object.description) ? String(object.description) : void 0,
      isNsfw: isSet58(object.isNsfw) ? Boolean(object.isNsfw) : void 0,
      isDelisted: isSet58(object.isDelisted) ? Boolean(object.isDelisted) : void 0,
      categories: Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
      termsAndConditions: isSet58(object.termsAndConditions) ? String(object.termsAndConditions) : void 0,
      privacyPolicy: isSet58(object.privacyPolicy) ? String(object.privacyPolicy) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.slug !== void 0 && (obj.slug = message.slug);
    message.name !== void 0 && (obj.name = message.name);
    message.description !== void 0 && (obj.description = message.description);
    message.isNsfw !== void 0 && (obj.isNsfw = message.isNsfw);
    message.isDelisted !== void 0 && (obj.isDelisted = message.isDelisted);
    if (message.categories) {
      obj.categories = message.categories.map((e) => categoriesToJSON(e));
    } else {
      obj.categories = [];
    }
    message.termsAndConditions !== void 0 && (obj.termsAndConditions = message.termsAndConditions);
    message.privacyPolicy !== void 0 && (obj.privacyPolicy = message.privacyPolicy);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppUpdateRequest();
    message.id = object.id ?? "";
    message.slug = object.slug ?? void 0;
    message.name = object.name ?? void 0;
    message.description = object.description ?? void 0;
    message.isNsfw = object.isNsfw ?? void 0;
    message.isDelisted = object.isDelisted ?? void 0;
    message.categories = object.categories?.map((e) => e) || [];
    message.termsAndConditions = object.termsAndConditions ?? void 0;
    message.privacyPolicy = object.privacyPolicy ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.AppUpdateRequest", AppUpdateRequest);
function createBaseFullAppInfo() {
  return { app: void 0, versions: [] };
}
var FullAppInfo = {
  $type: "devvit.dev_portal.app.FullAppInfo",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.app !== void 0) {
      AppInfo.encode(message.app, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.versions) {
      AppVersionInfo.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFullAppInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.app = AppInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.versions.push(AppVersionInfo.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      app: isSet58(object.app) ? AppInfo.fromJSON(object.app) : void 0,
      versions: Array.isArray(object?.versions) ? object.versions.map((e) => AppVersionInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.app !== void 0 && (obj.app = message.app ? AppInfo.toJSON(message.app) : void 0);
    if (message.versions) {
      obj.versions = message.versions.map((e) => e ? AppVersionInfo.toJSON(e) : void 0);
    } else {
      obj.versions = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFullAppInfo();
    message.app = object.app !== void 0 && object.app !== null ? AppInfo.fromPartial(object.app) : void 0;
    message.versions = object.versions?.map((e) => AppVersionInfo.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.FullAppInfo", FullAppInfo);
function createBaseAppSearchResponse() {
  return { apps: [], totalResults: 0, pageNumber: 0, pageSize: 0 };
}
var AppSearchResponse = {
  $type: "devvit.dev_portal.app.AppSearchResponse",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    for (const v of message.apps) {
      AppInfo.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalResults !== 0) {
      writer.uint32(16).int32(message.totalResults);
    }
    if (message.pageNumber !== 0) {
      writer.uint32(24).int32(message.pageNumber);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.apps.push(AppInfo.decode(reader, reader.uint32()));
          break;
        case 2:
          message.totalResults = reader.int32();
          break;
        case 3:
          message.pageNumber = reader.int32();
          break;
        case 4:
          message.pageSize = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      apps: Array.isArray(object?.apps) ? object.apps.map((e) => AppInfo.fromJSON(e)) : [],
      totalResults: isSet58(object.totalResults) ? Number(object.totalResults) : 0,
      pageNumber: isSet58(object.pageNumber) ? Number(object.pageNumber) : 0,
      pageSize: isSet58(object.pageSize) ? Number(object.pageSize) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.apps) {
      obj.apps = message.apps.map((e) => e ? AppInfo.toJSON(e) : void 0);
    } else {
      obj.apps = [];
    }
    message.totalResults !== void 0 && (obj.totalResults = Math.round(message.totalResults));
    message.pageNumber !== void 0 && (obj.pageNumber = Math.round(message.pageNumber));
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppSearchResponse();
    message.apps = object.apps?.map((e) => AppInfo.fromPartial(e)) || [];
    message.totalResults = object.totalResults ?? 0;
    message.pageNumber = object.pageNumber ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.AppSearchResponse", AppSearchResponse);
function createBaseUnpublishAppRequest() {
  return { slug: void 0, shouldDelist: false };
}
var UnpublishAppRequest = {
  $type: "devvit.dev_portal.app.UnpublishAppRequest",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.slug !== void 0) {
      StringValue.encode({ value: message.slug }, writer.uint32(10).fork()).ldelim();
    }
    if (message.shouldDelist === true) {
      writer.uint32(16).bool(message.shouldDelist);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnpublishAppRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.slug = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.shouldDelist = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      slug: isSet58(object.slug) ? String(object.slug) : void 0,
      shouldDelist: isSet58(object.shouldDelist) ? Boolean(object.shouldDelist) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.slug !== void 0 && (obj.slug = message.slug);
    message.shouldDelist !== void 0 && (obj.shouldDelist = message.shouldDelist);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUnpublishAppRequest();
    message.slug = object.slug ?? void 0;
    message.shouldDelist = object.shouldDelist ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.UnpublishAppRequest", UnpublishAppRequest);
function createBaseAppExistsRequest() {
  return { slug: void 0 };
}
var AppExistsRequest = {
  $type: "devvit.dev_portal.app.AppExistsRequest",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.slug !== void 0) {
      StringValue.encode({ value: message.slug }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppExistsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.slug = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { slug: isSet58(object.slug) ? String(object.slug) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.slug !== void 0 && (obj.slug = message.slug);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppExistsRequest();
    message.slug = object.slug ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.AppExistsRequest", AppExistsRequest);
function createBaseAppExistsResponse() {
  return { exists: false };
}
var AppExistsResponse = {
  $type: "devvit.dev_portal.app.AppExistsResponse",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.exists === true) {
      writer.uint32(8).bool(message.exists);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppExistsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.exists = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { exists: isSet58(object.exists) ? Boolean(object.exists) : false };
  },
  toJSON(message) {
    const obj = {};
    message.exists !== void 0 && (obj.exists = message.exists);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppExistsResponse();
    message.exists = object.exists ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.AppExistsResponse", AppExistsResponse);
function createBaseAppAccountExistsRequest() {
  return { accountName: "" };
}
var AppAccountExistsRequest = {
  $type: "devvit.dev_portal.app.AppAccountExistsRequest",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.accountName !== "") {
      writer.uint32(10).string(message.accountName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppAccountExistsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { accountName: isSet58(object.accountName) ? String(object.accountName) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.accountName !== void 0 && (obj.accountName = message.accountName);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppAccountExistsRequest();
    message.accountName = object.accountName ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.AppAccountExistsRequest", AppAccountExistsRequest);
function createBaseAppAccountExistsResponse() {
  return { exists: false };
}
var AppAccountExistsResponse = {
  $type: "devvit.dev_portal.app.AppAccountExistsResponse",
  encode(message, writer = import_minimal63.default.Writer.create()) {
    if (message.exists === true) {
      writer.uint32(8).bool(message.exists);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal63.default.Reader ? input : new import_minimal63.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppAccountExistsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.exists = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { exists: isSet58(object.exists) ? Boolean(object.exists) : false };
  },
  toJSON(message) {
    const obj = {};
    message.exists !== void 0 && (obj.exists = message.exists);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAppAccountExistsResponse();
    message.exists = object.exists ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.app.AppAccountExistsResponse", AppAccountExistsResponse);
function isSet58(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/dev_portal.js
var import_minimal68 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/uuid.js
var import_minimal64 = __toESM(require_minimal2(), 1);
function createBaseUUID() {
  return { id: "" };
}
var UUID = {
  $type: "devvit.UUID",
  encode(message, writer = import_minimal64.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal64.default.Reader ? input : new import_minimal64.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUUID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet59(object.id) ? String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUUID();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.UUID", UUID);
function isSet59(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/feedback/feedback.js
var import_minimal65 = __toESM(require_minimal2(), 1);
function createBaseCreateFeedbackRequest() {
  return { content: "" };
}
var CreateFeedbackRequest = {
  $type: "devvit.dev_portal.feedback.CreateFeedbackRequest",
  encode(message, writer = import_minimal65.default.Writer.create()) {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal65.default.Reader ? input : new import_minimal65.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateFeedbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.content = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { content: isSet60(object.content) ? String(object.content) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.content !== void 0 && (obj.content = message.content);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCreateFeedbackRequest();
    message.content = object.content ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.feedback.CreateFeedbackRequest", CreateFeedbackRequest);
function isSet60(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/installation_settings/installation_settings.js
var import_minimal67 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/settings/v1alpha/settings.js
var import_minimal66 = __toESM(require_minimal2(), 1);
function createBaseSettingsValues() {
  return { version: "", settings: {}, timestamp: void 0 };
}
var SettingsValues = {
  $type: "devvit.plugin.settings.v1alpha.SettingsValues",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    Object.entries(message.settings).forEach(([key, value]) => {
      SettingsValues_SettingsEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp8(message.timestamp), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : new import_minimal66.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSettingsValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.version = reader.string();
          break;
        case 2:
          const entry2 = SettingsValues_SettingsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.settings[entry2.key] = entry2.value;
          }
          break;
        case 3:
          message.timestamp = fromTimestamp8(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      version: isSet61(object.version) ? String(object.version) : "",
      settings: isObject8(object.settings) ? Object.entries(object.settings).reduce((acc, [key, value]) => {
        acc[key] = FormFieldValue.fromJSON(value);
        return acc;
      }, {}) : {},
      timestamp: isSet61(object.timestamp) ? fromJsonTimestamp8(object.timestamp) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.version !== void 0 && (obj.version = message.version);
    obj.settings = {};
    if (message.settings) {
      Object.entries(message.settings).forEach(([k, v]) => {
        obj.settings[k] = FormFieldValue.toJSON(v);
      });
    }
    message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSettingsValues();
    message.version = object.version ?? "";
    message.settings = Object.entries(object.settings ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = FormFieldValue.fromPartial(value);
      }
      return acc;
    }, {});
    message.timestamp = object.timestamp ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.settings.v1alpha.SettingsValues", SettingsValues);
function createBaseSettingsValues_SettingsEntry() {
  return { key: "", value: void 0 };
}
var SettingsValues_SettingsEntry = {
  $type: "devvit.plugin.settings.v1alpha.SettingsValues.SettingsEntry",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      FormFieldValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : new import_minimal66.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSettingsValues_SettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = FormFieldValue.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet61(object.key) ? String(object.key) : "",
      value: isSet61(object.value) ? FormFieldValue.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? FormFieldValue.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSettingsValues_SettingsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? FormFieldValue.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.settings.v1alpha.SettingsValues.SettingsEntry", SettingsValues_SettingsEntry);
function createBaseSettingsRequest() {
  return {};
}
var SettingsRequest = {
  $type: "devvit.plugin.settings.v1alpha.SettingsRequest",
  encode(_, writer = import_minimal66.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : new import_minimal66.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseSettingsRequest();
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.settings.v1alpha.SettingsRequest", SettingsRequest);
function createBaseSettingsResponse() {
  return { installationSettings: void 0, instanceSettings: void 0 };
}
var SettingsResponse = {
  $type: "devvit.plugin.settings.v1alpha.SettingsResponse",
  encode(message, writer = import_minimal66.default.Writer.create()) {
    if (message.installationSettings !== void 0) {
      SettingsValues.encode(message.installationSettings, writer.uint32(10).fork()).ldelim();
    }
    if (message.instanceSettings !== void 0) {
      SettingsValues.encode(message.instanceSettings, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal66.default.Reader ? input : new import_minimal66.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installationSettings = SettingsValues.decode(reader, reader.uint32());
          break;
        case 2:
          message.instanceSettings = SettingsValues.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      installationSettings: isSet61(object.installationSettings) ? SettingsValues.fromJSON(object.installationSettings) : void 0,
      instanceSettings: isSet61(object.instanceSettings) ? SettingsValues.fromJSON(object.instanceSettings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.installationSettings !== void 0 && (obj.installationSettings = message.installationSettings ? SettingsValues.toJSON(message.installationSettings) : void 0);
    message.instanceSettings !== void 0 && (obj.instanceSettings = message.instanceSettings ? SettingsValues.toJSON(message.instanceSettings) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSettingsResponse();
    message.installationSettings = object.installationSettings !== void 0 && object.installationSettings !== null ? SettingsValues.fromPartial(object.installationSettings) : void 0;
    message.instanceSettings = object.instanceSettings !== void 0 && object.instanceSettings !== null ? SettingsValues.fromPartial(object.instanceSettings) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.settings.v1alpha.SettingsResponse", SettingsResponse);
function toTimestamp8(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp8(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp8(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp8(Timestamp.fromJSON(o));
  }
}
function isObject8(value) {
  return typeof value === "object" && value !== null;
}
function isSet61(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/installation_settings/installation_settings.js
function createBaseGetInstallationSettingsFormRequest() {
  return { installationId: "" };
}
var GetInstallationSettingsFormRequest = {
  $type: "devvit.dev_portal.installation_settings.GetInstallationSettingsFormRequest",
  encode(message, writer = import_minimal67.default.Writer.create()) {
    if (message.installationId !== "") {
      writer.uint32(10).string(message.installationId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal67.default.Reader ? input : new import_minimal67.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationSettingsFormRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installationId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { installationId: isSet62(object.installationId) ? String(object.installationId) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.installationId !== void 0 && (obj.installationId = message.installationId);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetInstallationSettingsFormRequest();
    message.installationId = object.installationId ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation_settings.GetInstallationSettingsFormRequest", GetInstallationSettingsFormRequest);
function createBaseGetInstallationSettingsFormResponse() {
  return { form: {} };
}
var GetInstallationSettingsFormResponse = {
  $type: "devvit.dev_portal.installation_settings.GetInstallationSettingsFormResponse",
  encode(message, writer = import_minimal67.default.Writer.create()) {
    Object.entries(message.form).forEach(([key, value]) => {
      GetInstallationSettingsFormResponse_FormEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal67.default.Reader ? input : new import_minimal67.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationSettingsFormResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = GetInstallationSettingsFormResponse_FormEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.form[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      form: isObject9(object.form) ? Object.entries(object.form).reduce((acc, [key, value]) => {
        acc[key] = Form.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    obj.form = {};
    if (message.form) {
      Object.entries(message.form).forEach(([k, v]) => {
        obj.form[k] = Form.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetInstallationSettingsFormResponse();
    message.form = Object.entries(object.form ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = Form.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation_settings.GetInstallationSettingsFormResponse", GetInstallationSettingsFormResponse);
function createBaseGetInstallationSettingsFormResponse_FormEntry() {
  return { key: "", value: void 0 };
}
var GetInstallationSettingsFormResponse_FormEntry = {
  $type: "devvit.dev_portal.installation_settings.GetInstallationSettingsFormResponse.FormEntry",
  encode(message, writer = import_minimal67.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Form.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal67.default.Reader ? input : new import_minimal67.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationSettingsFormResponse_FormEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Form.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet62(object.key) ? String(object.key) : "",
      value: isSet62(object.value) ? Form.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? Form.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetInstallationSettingsFormResponse_FormEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? Form.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation_settings.GetInstallationSettingsFormResponse.FormEntry", GetInstallationSettingsFormResponse_FormEntry);
function createBaseValidateInstallationSettingsFormRequest() {
  return { installationId: "", settings: void 0 };
}
var ValidateInstallationSettingsFormRequest = {
  $type: "devvit.dev_portal.installation_settings.ValidateInstallationSettingsFormRequest",
  encode(message, writer = import_minimal67.default.Writer.create()) {
    if (message.installationId !== "") {
      writer.uint32(10).string(message.installationId);
    }
    if (message.settings !== void 0) {
      SettingsValues.encode(message.settings, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal67.default.Reader ? input : new import_minimal67.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateInstallationSettingsFormRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installationId = reader.string();
          break;
        case 2:
          message.settings = SettingsValues.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      installationId: isSet62(object.installationId) ? String(object.installationId) : "",
      settings: isSet62(object.settings) ? SettingsValues.fromJSON(object.settings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.installationId !== void 0 && (obj.installationId = message.installationId);
    message.settings !== void 0 && (obj.settings = message.settings ? SettingsValues.toJSON(message.settings) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseValidateInstallationSettingsFormRequest();
    message.installationId = object.installationId ?? "";
    message.settings = object.settings !== void 0 && object.settings !== null ? SettingsValues.fromPartial(object.settings) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation_settings.ValidateInstallationSettingsFormRequest", ValidateInstallationSettingsFormRequest);
function createBaseValidateInstallationSettingsFormResponse() {
  return { success: false, errors: {} };
}
var ValidateInstallationSettingsFormResponse = {
  $type: "devvit.dev_portal.installation_settings.ValidateInstallationSettingsFormResponse",
  encode(message, writer = import_minimal67.default.Writer.create()) {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    Object.entries(message.errors).forEach(([key, value]) => {
      ValidateInstallationSettingsFormResponse_ErrorsEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal67.default.Reader ? input : new import_minimal67.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateInstallationSettingsFormResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.success = reader.bool();
          break;
        case 2:
          const entry2 = ValidateInstallationSettingsFormResponse_ErrorsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.errors[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet62(object.success) ? Boolean(object.success) : false,
      errors: isObject9(object.errors) ? Object.entries(object.errors).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.success !== void 0 && (obj.success = message.success);
    obj.errors = {};
    if (message.errors) {
      Object.entries(message.errors).forEach(([k, v]) => {
        obj.errors[k] = v;
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseValidateInstallationSettingsFormResponse();
    message.success = object.success ?? false;
    message.errors = Object.entries(object.errors ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation_settings.ValidateInstallationSettingsFormResponse", ValidateInstallationSettingsFormResponse);
function createBaseValidateInstallationSettingsFormResponse_ErrorsEntry() {
  return { key: "", value: "" };
}
var ValidateInstallationSettingsFormResponse_ErrorsEntry = {
  $type: "devvit.dev_portal.installation_settings.ValidateInstallationSettingsFormResponse.ErrorsEntry",
  encode(message, writer = import_minimal67.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal67.default.Reader ? input : new import_minimal67.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateInstallationSettingsFormResponse_ErrorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet62(object.key) ? String(object.key) : "", value: isSet62(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseValidateInstallationSettingsFormResponse_ErrorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation_settings.ValidateInstallationSettingsFormResponse.ErrorsEntry", ValidateInstallationSettingsFormResponse_ErrorsEntry);
function createBaseGetInstallationSettingsRequest() {
  return { installationId: "" };
}
var GetInstallationSettingsRequest = {
  $type: "devvit.dev_portal.installation_settings.GetInstallationSettingsRequest",
  encode(message, writer = import_minimal67.default.Writer.create()) {
    if (message.installationId !== "") {
      writer.uint32(10).string(message.installationId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal67.default.Reader ? input : new import_minimal67.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installationId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { installationId: isSet62(object.installationId) ? String(object.installationId) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.installationId !== void 0 && (obj.installationId = message.installationId);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetInstallationSettingsRequest();
    message.installationId = object.installationId ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation_settings.GetInstallationSettingsRequest", GetInstallationSettingsRequest);
function createBaseGetInstallationSettingsResponse() {
  return { settings: void 0 };
}
var GetInstallationSettingsResponse = {
  $type: "devvit.dev_portal.installation_settings.GetInstallationSettingsResponse",
  encode(message, writer = import_minimal67.default.Writer.create()) {
    if (message.settings !== void 0) {
      SettingsValues.encode(message.settings, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal67.default.Reader ? input : new import_minimal67.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInstallationSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.settings = SettingsValues.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { settings: isSet62(object.settings) ? SettingsValues.fromJSON(object.settings) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.settings !== void 0 && (obj.settings = message.settings ? SettingsValues.toJSON(message.settings) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetInstallationSettingsResponse();
    message.settings = object.settings !== void 0 && object.settings !== null ? SettingsValues.fromPartial(object.settings) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation_settings.GetInstallationSettingsResponse", GetInstallationSettingsResponse);
function createBaseUpdateInstallationSettingsRequest() {
  return { installationId: "", settings: void 0 };
}
var UpdateInstallationSettingsRequest = {
  $type: "devvit.dev_portal.installation_settings.UpdateInstallationSettingsRequest",
  encode(message, writer = import_minimal67.default.Writer.create()) {
    if (message.installationId !== "") {
      writer.uint32(10).string(message.installationId);
    }
    if (message.settings !== void 0) {
      SettingsValues.encode(message.settings, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal67.default.Reader ? input : new import_minimal67.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstallationSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installationId = reader.string();
          break;
        case 2:
          message.settings = SettingsValues.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      installationId: isSet62(object.installationId) ? String(object.installationId) : "",
      settings: isSet62(object.settings) ? SettingsValues.fromJSON(object.settings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.installationId !== void 0 && (obj.installationId = message.installationId);
    message.settings !== void 0 && (obj.settings = message.settings ? SettingsValues.toJSON(message.settings) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateInstallationSettingsRequest();
    message.installationId = object.installationId ?? "";
    message.settings = object.settings !== void 0 && object.settings !== null ? SettingsValues.fromPartial(object.settings) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation_settings.UpdateInstallationSettingsRequest", UpdateInstallationSettingsRequest);
function createBaseUpdateInstallationSettingsResponse() {
  return { success: false, errors: {} };
}
var UpdateInstallationSettingsResponse = {
  $type: "devvit.dev_portal.installation_settings.UpdateInstallationSettingsResponse",
  encode(message, writer = import_minimal67.default.Writer.create()) {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    Object.entries(message.errors).forEach(([key, value]) => {
      UpdateInstallationSettingsResponse_ErrorsEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal67.default.Reader ? input : new import_minimal67.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstallationSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.success = reader.bool();
          break;
        case 2:
          const entry2 = UpdateInstallationSettingsResponse_ErrorsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.errors[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet62(object.success) ? Boolean(object.success) : false,
      errors: isObject9(object.errors) ? Object.entries(object.errors).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.success !== void 0 && (obj.success = message.success);
    obj.errors = {};
    if (message.errors) {
      Object.entries(message.errors).forEach(([k, v]) => {
        obj.errors[k] = v;
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateInstallationSettingsResponse();
    message.success = object.success ?? false;
    message.errors = Object.entries(object.errors ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation_settings.UpdateInstallationSettingsResponse", UpdateInstallationSettingsResponse);
function createBaseUpdateInstallationSettingsResponse_ErrorsEntry() {
  return { key: "", value: "" };
}
var UpdateInstallationSettingsResponse_ErrorsEntry = {
  $type: "devvit.dev_portal.installation_settings.UpdateInstallationSettingsResponse.ErrorsEntry",
  encode(message, writer = import_minimal67.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal67.default.Reader ? input : new import_minimal67.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstallationSettingsResponse_ErrorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet62(object.key) ? String(object.key) : "", value: isSet62(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateInstallationSettingsResponse_ErrorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.installation_settings.UpdateInstallationSettingsResponse.ErrorsEntry", UpdateInstallationSettingsResponse_ErrorsEntry);
function isObject9(value) {
  return typeof value === "object" && value !== null;
}
function isSet62(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/internal/authorization/v1alpha/authorization.js
var import_minimal71 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/remote_logger/remote_logger.js
var import_minimal70 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/logger/logger.js
var import_minimal69 = __toESM(require_minimal2(), 1);
var Severity;
(function(Severity2) {
  Severity2[Severity2["DEBUG"] = 0] = "DEBUG";
  Severity2[Severity2["INFO"] = 1] = "INFO";
  Severity2[Severity2["WARN"] = 2] = "WARN";
  Severity2[Severity2["ERROR"] = 3] = "ERROR";
  Severity2[Severity2["VERBOSE"] = 4] = "VERBOSE";
  Severity2[Severity2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Severity || (Severity = {}));
function severityFromJSON(object) {
  switch (object) {
    case 0:
    case "DEBUG":
      return Severity.DEBUG;
    case 1:
    case "INFO":
      return Severity.INFO;
    case 2:
    case "WARN":
      return Severity.WARN;
    case 3:
    case "ERROR":
      return Severity.ERROR;
    case 4:
    case "VERBOSE":
      return Severity.VERBOSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Severity.UNRECOGNIZED;
  }
}
function severityToJSON(object) {
  switch (object) {
    case Severity.DEBUG:
      return 0;
    case Severity.INFO:
      return 1;
    case Severity.WARN:
      return 2;
    case Severity.ERROR:
      return 3;
    case Severity.VERBOSE:
      return 4;
    case Severity.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseLogErrorMessage() {
  return {
    message: "",
    name: "",
    fileName: void 0,
    lineNumber: void 0,
    columnNumber: void 0,
    stack: void 0,
    timestamp: void 0,
    tags: []
  };
}
var LogErrorMessage = {
  $type: "devvit.plugin.logger.LogErrorMessage",
  encode(message, writer = import_minimal69.default.Writer.create()) {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.fileName !== void 0) {
      StringValue.encode({ value: message.fileName }, writer.uint32(26).fork()).ldelim();
    }
    if (message.lineNumber !== void 0) {
      UInt32Value.encode({ value: message.lineNumber }, writer.uint32(34).fork()).ldelim();
    }
    if (message.columnNumber !== void 0) {
      UInt32Value.encode({ value: message.columnNumber }, writer.uint32(42).fork()).ldelim();
    }
    if (message.stack !== void 0) {
      StringValue.encode({ value: message.stack }, writer.uint32(50).fork()).ldelim();
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp9(message.timestamp), writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal69.default.Reader ? input : new import_minimal69.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogErrorMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.fileName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.lineNumber = UInt32Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.columnNumber = UInt32Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.stack = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.timestamp = fromTimestamp9(Timestamp.decode(reader, reader.uint32()));
          break;
        case 8:
          message.tags.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet63(object.message) ? String(object.message) : "",
      name: isSet63(object.name) ? String(object.name) : "",
      fileName: isSet63(object.fileName) ? String(object.fileName) : void 0,
      lineNumber: isSet63(object.lineNumber) ? Number(object.lineNumber) : void 0,
      columnNumber: isSet63(object.columnNumber) ? Number(object.columnNumber) : void 0,
      stack: isSet63(object.stack) ? String(object.stack) : void 0,
      timestamp: isSet63(object.timestamp) ? fromJsonTimestamp9(object.timestamp) : void 0,
      tags: Array.isArray(object?.tags) ? object.tags.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message);
    message.name !== void 0 && (obj.name = message.name);
    message.fileName !== void 0 && (obj.fileName = message.fileName);
    message.lineNumber !== void 0 && (obj.lineNumber = message.lineNumber);
    message.columnNumber !== void 0 && (obj.columnNumber = message.columnNumber);
    message.stack !== void 0 && (obj.stack = message.stack);
    message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
    if (message.tags) {
      obj.tags = message.tags.map((e) => e);
    } else {
      obj.tags = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseLogErrorMessage();
    message.message = object.message ?? "";
    message.name = object.name ?? "";
    message.fileName = object.fileName ?? void 0;
    message.lineNumber = object.lineNumber ?? void 0;
    message.columnNumber = object.columnNumber ?? void 0;
    message.stack = object.stack ?? void 0;
    message.timestamp = object.timestamp ?? void 0;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.logger.LogErrorMessage", LogErrorMessage);
function createBaseLogEventMessage() {
  return { type: "", timestamp: void 0, labels: {}, data: {} };
}
var LogEventMessage = {
  $type: "devvit.plugin.logger.LogEventMessage",
  encode(message, writer = import_minimal69.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp9(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      LogEventMessage_LabelsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    Object.entries(message.data).forEach(([key, value]) => {
      LogEventMessage_DataEntry.encode({ key, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal69.default.Reader ? input : new import_minimal69.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogEventMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.string();
          break;
        case 2:
          message.timestamp = fromTimestamp9(Timestamp.decode(reader, reader.uint32()));
          break;
        case 3:
          const entry3 = LogEventMessage_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.labels[entry3.key] = entry3.value;
          }
          break;
        case 4:
          const entry4 = LogEventMessage_DataEntry.decode(reader, reader.uint32());
          if (entry4.value !== void 0) {
            message.data[entry4.key] = entry4.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet63(object.type) ? String(object.type) : "",
      timestamp: isSet63(object.timestamp) ? fromJsonTimestamp9(object.timestamp) : void 0,
      labels: isObject10(object.labels) ? Object.entries(object.labels).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      data: isObject10(object.data) ? Object.entries(object.data).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
    obj.labels = {};
    if (message.labels) {
      Object.entries(message.labels).forEach(([k, v]) => {
        obj.labels[k] = v;
      });
    }
    obj.data = {};
    if (message.data) {
      Object.entries(message.data).forEach(([k, v]) => {
        obj.data[k] = v;
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseLogEventMessage();
    message.type = object.type ?? "";
    message.timestamp = object.timestamp ?? void 0;
    message.labels = Object.entries(object.labels ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.data = Object.entries(object.data ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.logger.LogEventMessage", LogEventMessage);
function createBaseLogEventMessage_LabelsEntry() {
  return { key: "", value: "" };
}
var LogEventMessage_LabelsEntry = {
  $type: "devvit.plugin.logger.LogEventMessage.LabelsEntry",
  encode(message, writer = import_minimal69.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal69.default.Reader ? input : new import_minimal69.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogEventMessage_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet63(object.key) ? String(object.key) : "", value: isSet63(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseLogEventMessage_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.logger.LogEventMessage.LabelsEntry", LogEventMessage_LabelsEntry);
function createBaseLogEventMessage_DataEntry() {
  return { key: "", value: "" };
}
var LogEventMessage_DataEntry = {
  $type: "devvit.plugin.logger.LogEventMessage.DataEntry",
  encode(message, writer = import_minimal69.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal69.default.Reader ? input : new import_minimal69.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogEventMessage_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet63(object.key) ? String(object.key) : "", value: isSet63(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseLogEventMessage_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.logger.LogEventMessage.DataEntry", LogEventMessage_DataEntry);
function createBaseLogMessage() {
  return { severity: 0, message: "", timestamp: void 0, tags: [] };
}
var LogMessage = {
  $type: "devvit.plugin.logger.LogMessage",
  encode(message, writer = import_minimal69.default.Writer.create()) {
    if (message.severity !== 0) {
      writer.uint32(8).int32(message.severity);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp9(message.timestamp), writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal69.default.Reader ? input : new import_minimal69.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.severity = reader.int32();
          break;
        case 2:
          message.message = reader.string();
          break;
        case 3:
          message.timestamp = fromTimestamp9(Timestamp.decode(reader, reader.uint32()));
          break;
        case 4:
          message.tags.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      severity: isSet63(object.severity) ? severityFromJSON(object.severity) : 0,
      message: isSet63(object.message) ? String(object.message) : "",
      timestamp: isSet63(object.timestamp) ? fromJsonTimestamp9(object.timestamp) : void 0,
      tags: Array.isArray(object?.tags) ? object.tags.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.severity !== void 0 && (obj.severity = severityToJSON(message.severity));
    message.message !== void 0 && (obj.message = message.message);
    message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
    if (message.tags) {
      obj.tags = message.tags.map((e) => e);
    } else {
      obj.tags = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseLogMessage();
    message.severity = object.severity ?? 0;
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? void 0;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.logger.LogMessage", LogMessage);
function createBaseLogErrorResponse() {
  return {};
}
var LogErrorResponse = {
  $type: "devvit.plugin.logger.LogErrorResponse",
  encode(_, writer = import_minimal69.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal69.default.Reader ? input : new import_minimal69.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogErrorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseLogErrorResponse();
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.logger.LogErrorResponse", LogErrorResponse);
function createBaseLogEventResponse() {
  return {};
}
var LogEventResponse = {
  $type: "devvit.plugin.logger.LogEventResponse",
  encode(_, writer = import_minimal69.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal69.default.Reader ? input : new import_minimal69.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseLogEventResponse();
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.logger.LogEventResponse", LogEventResponse);
function createBaseLogResponse() {
  return {};
}
var LogResponse = {
  $type: "devvit.plugin.logger.LogResponse",
  encode(_, writer = import_minimal69.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal69.default.Reader ? input : new import_minimal69.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLogResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseLogResponse();
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.logger.LogResponse", LogResponse);
var LoggerDefinition = {
  name: "Logger",
  fullName: "devvit.plugin.logger.Logger",
  methods: {
    error: {
      name: "Error",
      requestType: LogErrorMessage,
      requestStream: false,
      responseType: LogErrorResponse,
      responseStream: false,
      options: {}
    },
    /**
     * Record a notable event or historical record for analytics and security.
     *
     * @internal
     */
    event: {
      name: "Event",
      requestType: LogEventMessage,
      requestStream: false,
      responseType: LogEventResponse,
      responseStream: false,
      options: {}
    },
    log: {
      name: "Log",
      requestType: LogMessage,
      requestStream: false,
      responseType: LogResponse,
      responseStream: false,
      options: {}
    }
  }
};
function toTimestamp9(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp9(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp9(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp9(Timestamp.fromJSON(o));
  }
}
function isObject10(value) {
  return typeof value === "object" && value !== null;
}
function isSet63(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/remote_logger/remote_logger.js
var RemoteLogType;
(function(RemoteLogType2) {
  RemoteLogType2[RemoteLogType2["LOG"] = 0] = "LOG";
  RemoteLogType2[RemoteLogType2["ERROR"] = 1] = "ERROR";
  RemoteLogType2[RemoteLogType2["EVENT"] = 2] = "EVENT";
  RemoteLogType2[RemoteLogType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RemoteLogType || (RemoteLogType = {}));
function remoteLogTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "LOG":
      return RemoteLogType.LOG;
    case 1:
    case "ERROR":
      return RemoteLogType.ERROR;
    case 2:
    case "EVENT":
      return RemoteLogType.EVENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RemoteLogType.UNRECOGNIZED;
  }
}
function remoteLogTypeToJSON(object) {
  switch (object) {
    case RemoteLogType.LOG:
      return 0;
    case RemoteLogType.ERROR:
      return 1;
    case RemoteLogType.EVENT:
      return 2;
    case RemoteLogType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseRemoteLogPutResponse() {
  return {};
}
var RemoteLogPutResponse = {
  $type: "devvit.remote_logger.RemoteLogPutResponse",
  encode(_, writer = import_minimal70.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal70.default.Reader ? input : new import_minimal70.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteLogPutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseRemoteLogPutResponse();
    return message;
  }
};
messageTypeRegistry.set("devvit.remote_logger.RemoteLogPutResponse", RemoteLogPutResponse);
function createBaseKeepAliveMessage() {
  return { timestamp: void 0 };
}
var KeepAliveMessage = {
  $type: "devvit.remote_logger.KeepAliveMessage",
  encode(message, writer = import_minimal70.default.Writer.create()) {
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp10(message.timestamp), writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal70.default.Reader ? input : new import_minimal70.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseKeepAliveMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.timestamp = fromTimestamp10(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { timestamp: isSet64(object.timestamp) ? fromJsonTimestamp10(object.timestamp) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseKeepAliveMessage();
    message.timestamp = object.timestamp ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.remote_logger.KeepAliveMessage", KeepAliveMessage);
function createBaseRemoteLogMessage() {
  return { log: void 0, error: void 0, keepalive: void 0, event: void 0 };
}
var RemoteLogMessage = {
  $type: "devvit.remote_logger.RemoteLogMessage",
  encode(message, writer = import_minimal70.default.Writer.create()) {
    if (message.log !== void 0) {
      LogMessage.encode(message.log, writer.uint32(10).fork()).ldelim();
    }
    if (message.error !== void 0) {
      LogErrorMessage.encode(message.error, writer.uint32(18).fork()).ldelim();
    }
    if (message.keepalive !== void 0) {
      KeepAliveMessage.encode(message.keepalive, writer.uint32(26).fork()).ldelim();
    }
    if (message.event !== void 0) {
      LogEventMessage.encode(message.event, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal70.default.Reader ? input : new import_minimal70.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteLogMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.log = LogMessage.decode(reader, reader.uint32());
          break;
        case 2:
          message.error = LogErrorMessage.decode(reader, reader.uint32());
          break;
        case 3:
          message.keepalive = KeepAliveMessage.decode(reader, reader.uint32());
          break;
        case 4:
          message.event = LogEventMessage.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      log: isSet64(object.log) ? LogMessage.fromJSON(object.log) : void 0,
      error: isSet64(object.error) ? LogErrorMessage.fromJSON(object.error) : void 0,
      keepalive: isSet64(object.keepalive) ? KeepAliveMessage.fromJSON(object.keepalive) : void 0,
      event: isSet64(object.event) ? LogEventMessage.fromJSON(object.event) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.log !== void 0 && (obj.log = message.log ? LogMessage.toJSON(message.log) : void 0);
    message.error !== void 0 && (obj.error = message.error ? LogErrorMessage.toJSON(message.error) : void 0);
    message.keepalive !== void 0 && (obj.keepalive = message.keepalive ? KeepAliveMessage.toJSON(message.keepalive) : void 0);
    message.event !== void 0 && (obj.event = message.event ? LogEventMessage.toJSON(message.event) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRemoteLogMessage();
    message.log = object.log !== void 0 && object.log !== null ? LogMessage.fromPartial(object.log) : void 0;
    message.error = object.error !== void 0 && object.error !== null ? LogErrorMessage.fromPartial(object.error) : void 0;
    message.keepalive = object.keepalive !== void 0 && object.keepalive !== null ? KeepAliveMessage.fromPartial(object.keepalive) : void 0;
    message.event = object.event !== void 0 && object.event !== null ? LogEventMessage.fromPartial(object.event) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.remote_logger.RemoteLogMessage", RemoteLogMessage);
function createBaseRemoteLogInstallationFilter() {
  return { installationId: "" };
}
var RemoteLogInstallationFilter = {
  $type: "devvit.remote_logger.RemoteLogInstallationFilter",
  encode(message, writer = import_minimal70.default.Writer.create()) {
    if (message.installationId !== "") {
      writer.uint32(10).string(message.installationId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal70.default.Reader ? input : new import_minimal70.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteLogInstallationFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installationId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { installationId: isSet64(object.installationId) ? String(object.installationId) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.installationId !== void 0 && (obj.installationId = message.installationId);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRemoteLogInstallationFilter();
    message.installationId = object.installationId ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.remote_logger.RemoteLogInstallationFilter", RemoteLogInstallationFilter);
function createBaseRemoteLogSubredditAppNameFilter() {
  return { subreddit: "", appName: "" };
}
var RemoteLogSubredditAppNameFilter = {
  $type: "devvit.remote_logger.RemoteLogSubredditAppNameFilter",
  encode(message, writer = import_minimal70.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(18).string(message.subreddit);
    }
    if (message.appName !== "") {
      writer.uint32(26).string(message.appName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal70.default.Reader ? input : new import_minimal70.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteLogSubredditAppNameFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.subreddit = reader.string();
          break;
        case 3:
          message.appName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet64(object.subreddit) ? String(object.subreddit) : "",
      appName: isSet64(object.appName) ? String(object.appName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.appName !== void 0 && (obj.appName = message.appName);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRemoteLogSubredditAppNameFilter();
    message.subreddit = object.subreddit ?? "";
    message.appName = object.appName ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.remote_logger.RemoteLogSubredditAppNameFilter", RemoteLogSubredditAppNameFilter);
function createBaseRemoteLogQuery() {
  return { installation: void 0, subredditAppName: void 0, type: 0, since: void 0 };
}
var RemoteLogQuery = {
  $type: "devvit.remote_logger.RemoteLogQuery",
  encode(message, writer = import_minimal70.default.Writer.create()) {
    if (message.installation !== void 0) {
      RemoteLogInstallationFilter.encode(message.installation, writer.uint32(10).fork()).ldelim();
    }
    if (message.subredditAppName !== void 0) {
      RemoteLogSubredditAppNameFilter.encode(message.subredditAppName, writer.uint32(18).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.since !== void 0) {
      Timestamp.encode(toTimestamp10(message.since), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal70.default.Reader ? input : new import_minimal70.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteLogQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installation = RemoteLogInstallationFilter.decode(reader, reader.uint32());
          break;
        case 2:
          message.subredditAppName = RemoteLogSubredditAppNameFilter.decode(reader, reader.uint32());
          break;
        case 3:
          message.type = reader.int32();
          break;
        case 4:
          message.since = fromTimestamp10(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      installation: isSet64(object.installation) ? RemoteLogInstallationFilter.fromJSON(object.installation) : void 0,
      subredditAppName: isSet64(object.subredditAppName) ? RemoteLogSubredditAppNameFilter.fromJSON(object.subredditAppName) : void 0,
      type: isSet64(object.type) ? remoteLogTypeFromJSON(object.type) : 0,
      since: isSet64(object.since) ? fromJsonTimestamp10(object.since) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.installation !== void 0 && (obj.installation = message.installation ? RemoteLogInstallationFilter.toJSON(message.installation) : void 0);
    message.subredditAppName !== void 0 && (obj.subredditAppName = message.subredditAppName ? RemoteLogSubredditAppNameFilter.toJSON(message.subredditAppName) : void 0);
    message.type !== void 0 && (obj.type = remoteLogTypeToJSON(message.type));
    message.since !== void 0 && (obj.since = message.since.toISOString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRemoteLogQuery();
    message.installation = object.installation !== void 0 && object.installation !== null ? RemoteLogInstallationFilter.fromPartial(object.installation) : void 0;
    message.subredditAppName = object.subredditAppName !== void 0 && object.subredditAppName !== null ? RemoteLogSubredditAppNameFilter.fromPartial(object.subredditAppName) : void 0;
    message.type = object.type ?? 0;
    message.since = object.since ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.remote_logger.RemoteLogQuery", RemoteLogQuery);
function toTimestamp10(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp10(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp10(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp10(Timestamp.fromJSON(o));
  }
}
function isSet64(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/internal/authorization/v1alpha/authorization.js
function createBaseDevPortalAuthInstalledAppResource() {
  return { app: void 0, location: void 0 };
}
var DevPortalAuthInstalledAppResource = {
  $type: "devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthInstalledAppResource",
  encode(message, writer = import_minimal71.default.Writer.create()) {
    if (message.app !== void 0) {
      DevPortalAuthAppVersionResource.encode(message.app, writer.uint32(10).fork()).ldelim();
    }
    if (message.location !== void 0) {
      DevPortalAuthLocationResource.encode(message.location, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal71.default.Reader ? input : new import_minimal71.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevPortalAuthInstalledAppResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.app = DevPortalAuthAppVersionResource.decode(reader, reader.uint32());
          break;
        case 2:
          message.location = DevPortalAuthLocationResource.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      app: isSet65(object.app) ? DevPortalAuthAppVersionResource.fromJSON(object.app) : void 0,
      location: isSet65(object.location) ? DevPortalAuthLocationResource.fromJSON(object.location) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.app !== void 0 && (obj.app = message.app ? DevPortalAuthAppVersionResource.toJSON(message.app) : void 0);
    message.location !== void 0 && (obj.location = message.location ? DevPortalAuthLocationResource.toJSON(message.location) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDevPortalAuthInstalledAppResource();
    message.app = object.app !== void 0 && object.app !== null ? DevPortalAuthAppVersionResource.fromPartial(object.app) : void 0;
    message.location = object.location !== void 0 && object.location !== null ? DevPortalAuthLocationResource.fromPartial(object.location) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthInstalledAppResource", DevPortalAuthInstalledAppResource);
function createBaseDevPortalAuthAppVersionResource() {
  return { name: "", version: "" };
}
var DevPortalAuthAppVersionResource = {
  $type: "devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthAppVersionResource",
  encode(message, writer = import_minimal71.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal71.default.Reader ? input : new import_minimal71.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevPortalAuthAppVersionResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.version = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet65(object.name) ? String(object.name) : "",
      version: isSet65(object.version) ? String(object.version) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.version !== void 0 && (obj.version = message.version);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDevPortalAuthAppVersionResource();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthAppVersionResource", DevPortalAuthAppVersionResource);
function createBaseDevPortalAuthLocationResource() {
  return { id: "" };
}
var DevPortalAuthLocationResource = {
  $type: "devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthLocationResource",
  encode(message, writer = import_minimal71.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal71.default.Reader ? input : new import_minimal71.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevPortalAuthLocationResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet65(object.id) ? String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDevPortalAuthLocationResource();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthLocationResource", DevPortalAuthLocationResource);
function createBaseDevPortalAuthCanViewLogsRequest() {
  return { userId: "", id: void 0, app: void 0, type: 0 };
}
var DevPortalAuthCanViewLogsRequest = {
  $type: "devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthCanViewLogsRequest",
  encode(message, writer = import_minimal71.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.id !== void 0) {
      writer.uint32(18).string(message.id);
    }
    if (message.app !== void 0) {
      DevPortalAuthInstalledAppResource.encode(message.app, writer.uint32(26).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal71.default.Reader ? input : new import_minimal71.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevPortalAuthCanViewLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.userId = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.app = DevPortalAuthInstalledAppResource.decode(reader, reader.uint32());
          break;
        case 4:
          message.type = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet65(object.userId) ? String(object.userId) : "",
      id: isSet65(object.id) ? String(object.id) : void 0,
      app: isSet65(object.app) ? DevPortalAuthInstalledAppResource.fromJSON(object.app) : void 0,
      type: isSet65(object.type) ? remoteLogTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.userId !== void 0 && (obj.userId = message.userId);
    message.id !== void 0 && (obj.id = message.id);
    message.app !== void 0 && (obj.app = message.app ? DevPortalAuthInstalledAppResource.toJSON(message.app) : void 0);
    message.type !== void 0 && (obj.type = remoteLogTypeToJSON(message.type));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDevPortalAuthCanViewLogsRequest();
    message.userId = object.userId ?? "";
    message.id = object.id ?? void 0;
    message.app = object.app !== void 0 && object.app !== null ? DevPortalAuthInstalledAppResource.fromPartial(object.app) : void 0;
    message.type = object.type ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthCanViewLogsRequest", DevPortalAuthCanViewLogsRequest);
function createBaseDevPortalAuthorizationResponse() {
  return { allowed: false, reason: "" };
}
var DevPortalAuthorizationResponse = {
  $type: "devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthorizationResponse",
  encode(message, writer = import_minimal71.default.Writer.create()) {
    if (message.allowed === true) {
      writer.uint32(8).bool(message.allowed);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal71.default.Reader ? input : new import_minimal71.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevPortalAuthorizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.allowed = reader.bool();
          break;
        case 2:
          message.reason = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      allowed: isSet65(object.allowed) ? Boolean(object.allowed) : false,
      reason: isSet65(object.reason) ? String(object.reason) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.allowed !== void 0 && (obj.allowed = message.allowed);
    message.reason !== void 0 && (obj.reason = message.reason);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDevPortalAuthorizationResponse();
    message.allowed = object.allowed ?? false;
    message.reason = object.reason ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.internal.authorization.v1alpha.DevPortalAuthorizationResponse", DevPortalAuthorizationResponse);
function isSet65(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/dev_portal/waitlist/waitlist.js
var import_minimal72 = __toESM(require_minimal2(), 1);
var ProgrammingExperienceLevel;
(function(ProgrammingExperienceLevel2) {
  ProgrammingExperienceLevel2[ProgrammingExperienceLevel2["BEGINNER"] = 0] = "BEGINNER";
  ProgrammingExperienceLevel2[ProgrammingExperienceLevel2["PROFICIENT"] = 1] = "PROFICIENT";
  ProgrammingExperienceLevel2[ProgrammingExperienceLevel2["EXPERT"] = 2] = "EXPERT";
  ProgrammingExperienceLevel2[ProgrammingExperienceLevel2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ProgrammingExperienceLevel || (ProgrammingExperienceLevel = {}));
function programmingExperienceLevelFromJSON(object) {
  switch (object) {
    case 0:
    case "BEGINNER":
      return ProgrammingExperienceLevel.BEGINNER;
    case 1:
    case "PROFICIENT":
      return ProgrammingExperienceLevel.PROFICIENT;
    case 2:
    case "EXPERT":
      return ProgrammingExperienceLevel.EXPERT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProgrammingExperienceLevel.UNRECOGNIZED;
  }
}
function programmingExperienceLevelToJSON(object) {
  switch (object) {
    case ProgrammingExperienceLevel.BEGINNER:
      return 0;
    case ProgrammingExperienceLevel.PROFICIENT:
      return 1;
    case ProgrammingExperienceLevel.EXPERT:
      return 2;
    case ProgrammingExperienceLevel.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseIsCurrentUserRegisteredResponse() {
  return { isRegistered: false, response: void 0, waitlistStatus: 0 };
}
var IsCurrentUserRegisteredResponse = {
  $type: "devvit.dev_portal.waitlist.IsCurrentUserRegisteredResponse",
  encode(message, writer = import_minimal72.default.Writer.create()) {
    if (message.isRegistered === true) {
      writer.uint32(8).bool(message.isRegistered);
    }
    if (message.response !== void 0) {
      WaitlistRegisterUserRequest.encode(message.response, writer.uint32(18).fork()).ldelim();
    }
    if (message.waitlistStatus !== 0) {
      writer.uint32(24).int32(message.waitlistStatus);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal72.default.Reader ? input : new import_minimal72.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIsCurrentUserRegisteredResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isRegistered = reader.bool();
          break;
        case 2:
          message.response = WaitlistRegisterUserRequest.decode(reader, reader.uint32());
          break;
        case 3:
          message.waitlistStatus = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      isRegistered: isSet66(object.isRegistered) ? Boolean(object.isRegistered) : false,
      response: isSet66(object.response) ? WaitlistRegisterUserRequest.fromJSON(object.response) : void 0,
      waitlistStatus: isSet66(object.waitlistStatus) ? waitlistStatusFromJSON(object.waitlistStatus) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.isRegistered !== void 0 && (obj.isRegistered = message.isRegistered);
    message.response !== void 0 && (obj.response = message.response ? WaitlistRegisterUserRequest.toJSON(message.response) : void 0);
    message.waitlistStatus !== void 0 && (obj.waitlistStatus = waitlistStatusToJSON(message.waitlistStatus));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseIsCurrentUserRegisteredResponse();
    message.isRegistered = object.isRegistered ?? false;
    message.response = object.response !== void 0 && object.response !== null ? WaitlistRegisterUserRequest.fromPartial(object.response) : void 0;
    message.waitlistStatus = object.waitlistStatus ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.waitlist.IsCurrentUserRegisteredResponse", IsCurrentUserRegisteredResponse);
function createBaseWaitlistRegisterUserRequest() {
  return { userId: "", userName: "", whatToBuild: "", botsBuilt: void 0, programmingExperience: {}, appsWanted: "" };
}
var WaitlistRegisterUserRequest = {
  $type: "devvit.dev_portal.waitlist.WaitlistRegisterUserRequest",
  encode(message, writer = import_minimal72.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(18).string(message.userName);
    }
    if (message.whatToBuild !== "") {
      writer.uint32(26).string(message.whatToBuild);
    }
    if (message.botsBuilt !== void 0) {
      StringValue.encode({ value: message.botsBuilt }, writer.uint32(42).fork()).ldelim();
    }
    Object.entries(message.programmingExperience).forEach(([key, value]) => {
      WaitlistRegisterUserRequest_ProgrammingExperienceEntry.encode({ key, value }, writer.uint32(50).fork()).ldelim();
    });
    if (message.appsWanted !== "") {
      writer.uint32(58).string(message.appsWanted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal72.default.Reader ? input : new import_minimal72.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWaitlistRegisterUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.userId = reader.string();
          break;
        case 2:
          message.userName = reader.string();
          break;
        case 3:
          message.whatToBuild = reader.string();
          break;
        case 5:
          message.botsBuilt = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          const entry6 = WaitlistRegisterUserRequest_ProgrammingExperienceEntry.decode(reader, reader.uint32());
          if (entry6.value !== void 0) {
            message.programmingExperience[entry6.key] = entry6.value;
          }
          break;
        case 7:
          message.appsWanted = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet66(object.userId) ? String(object.userId) : "",
      userName: isSet66(object.userName) ? String(object.userName) : "",
      whatToBuild: isSet66(object.whatToBuild) ? String(object.whatToBuild) : "",
      botsBuilt: isSet66(object.botsBuilt) ? String(object.botsBuilt) : void 0,
      programmingExperience: isObject11(object.programmingExperience) ? Object.entries(object.programmingExperience).reduce((acc, [key, value]) => {
        acc[key] = programmingExperienceLevelFromJSON(value);
        return acc;
      }, {}) : {},
      appsWanted: isSet66(object.appsWanted) ? String(object.appsWanted) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.userId !== void 0 && (obj.userId = message.userId);
    message.userName !== void 0 && (obj.userName = message.userName);
    message.whatToBuild !== void 0 && (obj.whatToBuild = message.whatToBuild);
    message.botsBuilt !== void 0 && (obj.botsBuilt = message.botsBuilt);
    obj.programmingExperience = {};
    if (message.programmingExperience) {
      Object.entries(message.programmingExperience).forEach(([k, v]) => {
        obj.programmingExperience[k] = programmingExperienceLevelToJSON(v);
      });
    }
    message.appsWanted !== void 0 && (obj.appsWanted = message.appsWanted);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWaitlistRegisterUserRequest();
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.whatToBuild = object.whatToBuild ?? "";
    message.botsBuilt = object.botsBuilt ?? void 0;
    message.programmingExperience = Object.entries(object.programmingExperience ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.appsWanted = object.appsWanted ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.waitlist.WaitlistRegisterUserRequest", WaitlistRegisterUserRequest);
function createBaseWaitlistRegisterUserRequest_ProgrammingExperienceEntry() {
  return { key: "", value: 0 };
}
var WaitlistRegisterUserRequest_ProgrammingExperienceEntry = {
  $type: "devvit.dev_portal.waitlist.WaitlistRegisterUserRequest.ProgrammingExperienceEntry",
  encode(message, writer = import_minimal72.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal72.default.Reader ? input : new import_minimal72.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWaitlistRegisterUserRequest_ProgrammingExperienceEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet66(object.key) ? String(object.key) : "",
      value: isSet66(object.value) ? programmingExperienceLevelFromJSON(object.value) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = programmingExperienceLevelToJSON(message.value));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWaitlistRegisterUserRequest_ProgrammingExperienceEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.waitlist.WaitlistRegisterUserRequest.ProgrammingExperienceEntry", WaitlistRegisterUserRequest_ProgrammingExperienceEntry);
function createBaseWaitlistRegisterUserResponse() {
  return { success: false, message: void 0 };
}
var WaitlistRegisterUserResponse = {
  $type: "devvit.dev_portal.waitlist.WaitlistRegisterUserResponse",
  encode(message, writer = import_minimal72.default.Writer.create()) {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal72.default.Reader ? input : new import_minimal72.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWaitlistRegisterUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.success = reader.bool();
          break;
        case 2:
          message.message = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet66(object.success) ? Boolean(object.success) : false,
      message: isSet66(object.message) ? String(object.message) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.success !== void 0 && (obj.success = message.success);
    message.message !== void 0 && (obj.message = message.message);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWaitlistRegisterUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.waitlist.WaitlistRegisterUserResponse", WaitlistRegisterUserResponse);
function createBaseGetCurrentUserStatusResponse() {
  return { waitlistStatus: 0, acceptedTermsVersion: 0, currentTermsVersion: 0 };
}
var GetCurrentUserStatusResponse = {
  $type: "devvit.dev_portal.waitlist.GetCurrentUserStatusResponse",
  encode(message, writer = import_minimal72.default.Writer.create()) {
    if (message.waitlistStatus !== 0) {
      writer.uint32(8).int32(message.waitlistStatus);
    }
    if (message.acceptedTermsVersion !== 0) {
      writer.uint32(16).int32(message.acceptedTermsVersion);
    }
    if (message.currentTermsVersion !== 0) {
      writer.uint32(24).int32(message.currentTermsVersion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal72.default.Reader ? input : new import_minimal72.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentUserStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.waitlistStatus = reader.int32();
          break;
        case 2:
          message.acceptedTermsVersion = reader.int32();
          break;
        case 3:
          message.currentTermsVersion = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      waitlistStatus: isSet66(object.waitlistStatus) ? waitlistStatusFromJSON(object.waitlistStatus) : 0,
      acceptedTermsVersion: isSet66(object.acceptedTermsVersion) ? Number(object.acceptedTermsVersion) : 0,
      currentTermsVersion: isSet66(object.currentTermsVersion) ? Number(object.currentTermsVersion) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.waitlistStatus !== void 0 && (obj.waitlistStatus = waitlistStatusToJSON(message.waitlistStatus));
    message.acceptedTermsVersion !== void 0 && (obj.acceptedTermsVersion = Math.round(message.acceptedTermsVersion));
    message.currentTermsVersion !== void 0 && (obj.currentTermsVersion = Math.round(message.currentTermsVersion));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetCurrentUserStatusResponse();
    message.waitlistStatus = object.waitlistStatus ?? 0;
    message.acceptedTermsVersion = object.acceptedTermsVersion ?? 0;
    message.currentTermsVersion = object.currentTermsVersion ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.dev_portal.waitlist.GetCurrentUserStatusResponse", GetCurrentUserStatusResponse);
function isObject11(value) {
  return typeof value === "object" && value !== null;
}
function isSet66(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gateway/automod.js
var import_minimal73 = __toESM(require_minimal2(), 1);
function createBaseAutomodInvocation() {
  return {
    yamlText: void 0,
    comment: void 0,
    post: void 0,
    author: void 0,
    parentPost: void 0,
    subreddit: void 0,
    crosspost: void 0,
    crosspostSubreddit: void 0,
    crosspostAuthor: void 0,
    poll: void 0
  };
}
var AutomodInvocation = {
  $type: "devvit.gateway.AutomodInvocation",
  encode(message, writer = import_minimal73.default.Writer.create()) {
    if (message.yamlText !== void 0) {
      StringValue.encode({ value: message.yamlText }, writer.uint32(10).fork()).ldelim();
    }
    if (message.comment !== void 0) {
      Comment.encode(message.comment, writer.uint32(18).fork()).ldelim();
    }
    if (message.post !== void 0) {
      Post.encode(message.post, writer.uint32(26).fork()).ldelim();
    }
    if (message.author !== void 0) {
      User.encode(message.author, writer.uint32(34).fork()).ldelim();
    }
    if (message.parentPost !== void 0) {
      Post.encode(message.parentPost, writer.uint32(42).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      Subreddit.encode(message.subreddit, writer.uint32(50).fork()).ldelim();
    }
    if (message.crosspost !== void 0) {
      Post.encode(message.crosspost, writer.uint32(58).fork()).ldelim();
    }
    if (message.crosspostSubreddit !== void 0) {
      Subreddit.encode(message.crosspostSubreddit, writer.uint32(66).fork()).ldelim();
    }
    if (message.crosspostAuthor !== void 0) {
      User.encode(message.crosspostAuthor, writer.uint32(74).fork()).ldelim();
    }
    if (message.poll !== void 0) {
      Poll.encode(message.poll, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal73.default.Reader ? input : new import_minimal73.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomodInvocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.yamlText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.comment = Comment.decode(reader, reader.uint32());
          break;
        case 3:
          message.post = Post.decode(reader, reader.uint32());
          break;
        case 4:
          message.author = User.decode(reader, reader.uint32());
          break;
        case 5:
          message.parentPost = Post.decode(reader, reader.uint32());
          break;
        case 6:
          message.subreddit = Subreddit.decode(reader, reader.uint32());
          break;
        case 7:
          message.crosspost = Post.decode(reader, reader.uint32());
          break;
        case 8:
          message.crosspostSubreddit = Subreddit.decode(reader, reader.uint32());
          break;
        case 9:
          message.crosspostAuthor = User.decode(reader, reader.uint32());
          break;
        case 10:
          message.poll = Poll.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      yamlText: isSet67(object.yamlText) ? String(object.yamlText) : void 0,
      comment: isSet67(object.comment) ? Comment.fromJSON(object.comment) : void 0,
      post: isSet67(object.post) ? Post.fromJSON(object.post) : void 0,
      author: isSet67(object.author) ? User.fromJSON(object.author) : void 0,
      parentPost: isSet67(object.parentPost) ? Post.fromJSON(object.parentPost) : void 0,
      subreddit: isSet67(object.subreddit) ? Subreddit.fromJSON(object.subreddit) : void 0,
      crosspost: isSet67(object.crosspost) ? Post.fromJSON(object.crosspost) : void 0,
      crosspostSubreddit: isSet67(object.crosspostSubreddit) ? Subreddit.fromJSON(object.crosspostSubreddit) : void 0,
      crosspostAuthor: isSet67(object.crosspostAuthor) ? User.fromJSON(object.crosspostAuthor) : void 0,
      poll: isSet67(object.poll) ? Poll.fromJSON(object.poll) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.yamlText !== void 0 && (obj.yamlText = message.yamlText);
    message.comment !== void 0 && (obj.comment = message.comment ? Comment.toJSON(message.comment) : void 0);
    message.post !== void 0 && (obj.post = message.post ? Post.toJSON(message.post) : void 0);
    message.author !== void 0 && (obj.author = message.author ? User.toJSON(message.author) : void 0);
    message.parentPost !== void 0 && (obj.parentPost = message.parentPost ? Post.toJSON(message.parentPost) : void 0);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? Subreddit.toJSON(message.subreddit) : void 0);
    message.crosspost !== void 0 && (obj.crosspost = message.crosspost ? Post.toJSON(message.crosspost) : void 0);
    message.crosspostSubreddit !== void 0 && (obj.crosspostSubreddit = message.crosspostSubreddit ? Subreddit.toJSON(message.crosspostSubreddit) : void 0);
    message.crosspostAuthor !== void 0 && (obj.crosspostAuthor = message.crosspostAuthor ? User.toJSON(message.crosspostAuthor) : void 0);
    message.poll !== void 0 && (obj.poll = message.poll ? Poll.toJSON(message.poll) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomodInvocation();
    message.yamlText = object.yamlText ?? void 0;
    message.comment = object.comment !== void 0 && object.comment !== null ? Comment.fromPartial(object.comment) : void 0;
    message.post = object.post !== void 0 && object.post !== null ? Post.fromPartial(object.post) : void 0;
    message.author = object.author !== void 0 && object.author !== null ? User.fromPartial(object.author) : void 0;
    message.parentPost = object.parentPost !== void 0 && object.parentPost !== null ? Post.fromPartial(object.parentPost) : void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? Subreddit.fromPartial(object.subreddit) : void 0;
    message.crosspost = object.crosspost !== void 0 && object.crosspost !== null ? Post.fromPartial(object.crosspost) : void 0;
    message.crosspostSubreddit = object.crosspostSubreddit !== void 0 && object.crosspostSubreddit !== null ? Subreddit.fromPartial(object.crosspostSubreddit) : void 0;
    message.crosspostAuthor = object.crosspostAuthor !== void 0 && object.crosspostAuthor !== null ? User.fromPartial(object.crosspostAuthor) : void 0;
    message.poll = object.poll !== void 0 && object.poll !== null ? Poll.fromPartial(object.poll) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.gateway.AutomodInvocation", AutomodInvocation);
function createBasePoll() {
  return {
    isPrediction: void 0,
    options: [],
    predictionStatus: void 0,
    resolvedOptionId: void 0,
    totalStakeAmount: void 0,
    totalVoteCount: void 0,
    tournamentId: void 0,
    userSelection: void 0,
    userWonAmount: void 0,
    voteUpdatesRemained: void 0,
    votingEndTimestamp: void 0
  };
}
var Poll = {
  $type: "devvit.gateway.Poll",
  encode(message, writer = import_minimal73.default.Writer.create()) {
    if (message.isPrediction !== void 0) {
      BoolValue.encode({ value: message.isPrediction }, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.options) {
      Struct.encode(Struct.wrap(v), writer.uint32(18).fork()).ldelim();
    }
    if (message.predictionStatus !== void 0) {
      StringValue.encode({ value: message.predictionStatus }, writer.uint32(26).fork()).ldelim();
    }
    if (message.resolvedOptionId !== void 0) {
      StringValue.encode({ value: message.resolvedOptionId }, writer.uint32(34).fork()).ldelim();
    }
    if (message.totalStakeAmount !== void 0) {
      Int32Value.encode({ value: message.totalStakeAmount }, writer.uint32(42).fork()).ldelim();
    }
    if (message.totalVoteCount !== void 0) {
      Int32Value.encode({ value: message.totalVoteCount }, writer.uint32(50).fork()).ldelim();
    }
    if (message.tournamentId !== void 0) {
      StringValue.encode({ value: message.tournamentId }, writer.uint32(58).fork()).ldelim();
    }
    if (message.userSelection !== void 0) {
      StringValue.encode({ value: message.userSelection }, writer.uint32(66).fork()).ldelim();
    }
    if (message.userWonAmount !== void 0) {
      Int32Value.encode({ value: message.userWonAmount }, writer.uint32(74).fork()).ldelim();
    }
    if (message.voteUpdatesRemained !== void 0) {
      Int32Value.encode({ value: message.voteUpdatesRemained }, writer.uint32(82).fork()).ldelim();
    }
    if (message.votingEndTimestamp !== void 0) {
      Int32Value.encode({ value: message.votingEndTimestamp }, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal73.default.Reader ? input : new import_minimal73.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePoll();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isPrediction = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.options.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          break;
        case 3:
          message.predictionStatus = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.resolvedOptionId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.totalStakeAmount = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.totalVoteCount = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.tournamentId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.userSelection = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.userWonAmount = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.voteUpdatesRemained = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.votingEndTimestamp = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      isPrediction: isSet67(object.isPrediction) ? Boolean(object.isPrediction) : void 0,
      options: Array.isArray(object?.options) ? [...object.options] : [],
      predictionStatus: isSet67(object.predictionStatus) ? String(object.predictionStatus) : void 0,
      resolvedOptionId: isSet67(object.resolvedOptionId) ? String(object.resolvedOptionId) : void 0,
      totalStakeAmount: isSet67(object.totalStakeAmount) ? Number(object.totalStakeAmount) : void 0,
      totalVoteCount: isSet67(object.totalVoteCount) ? Number(object.totalVoteCount) : void 0,
      tournamentId: isSet67(object.tournamentId) ? String(object.tournamentId) : void 0,
      userSelection: isSet67(object.userSelection) ? String(object.userSelection) : void 0,
      userWonAmount: isSet67(object.userWonAmount) ? Number(object.userWonAmount) : void 0,
      voteUpdatesRemained: isSet67(object.voteUpdatesRemained) ? Number(object.voteUpdatesRemained) : void 0,
      votingEndTimestamp: isSet67(object.votingEndTimestamp) ? Number(object.votingEndTimestamp) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.isPrediction !== void 0 && (obj.isPrediction = message.isPrediction);
    if (message.options) {
      obj.options = message.options.map((e) => e);
    } else {
      obj.options = [];
    }
    message.predictionStatus !== void 0 && (obj.predictionStatus = message.predictionStatus);
    message.resolvedOptionId !== void 0 && (obj.resolvedOptionId = message.resolvedOptionId);
    message.totalStakeAmount !== void 0 && (obj.totalStakeAmount = message.totalStakeAmount);
    message.totalVoteCount !== void 0 && (obj.totalVoteCount = message.totalVoteCount);
    message.tournamentId !== void 0 && (obj.tournamentId = message.tournamentId);
    message.userSelection !== void 0 && (obj.userSelection = message.userSelection);
    message.userWonAmount !== void 0 && (obj.userWonAmount = message.userWonAmount);
    message.voteUpdatesRemained !== void 0 && (obj.voteUpdatesRemained = message.voteUpdatesRemained);
    message.votingEndTimestamp !== void 0 && (obj.votingEndTimestamp = message.votingEndTimestamp);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePoll();
    message.isPrediction = object.isPrediction ?? void 0;
    message.options = object.options?.map((e) => e) || [];
    message.predictionStatus = object.predictionStatus ?? void 0;
    message.resolvedOptionId = object.resolvedOptionId ?? void 0;
    message.totalStakeAmount = object.totalStakeAmount ?? void 0;
    message.totalVoteCount = object.totalVoteCount ?? void 0;
    message.tournamentId = object.tournamentId ?? void 0;
    message.userSelection = object.userSelection ?? void 0;
    message.userWonAmount = object.userWonAmount ?? void 0;
    message.voteUpdatesRemained = object.voteUpdatesRemained ?? void 0;
    message.votingEndTimestamp = object.votingEndTimestamp ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.gateway.Poll", Poll);
function createBaseAutomodResult() {
  return { result: "", errors: "" };
}
var AutomodResult = {
  $type: "devvit.gateway.AutomodResult",
  encode(message, writer = import_minimal73.default.Writer.create()) {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    if (message.errors !== "") {
      writer.uint32(18).string(message.errors);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal73.default.Reader ? input : new import_minimal73.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomodResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.result = reader.string();
          break;
        case 2:
          message.errors = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      result: isSet67(object.result) ? String(object.result) : "",
      errors: isSet67(object.errors) ? String(object.errors) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.result !== void 0 && (obj.result = message.result);
    message.errors !== void 0 && (obj.errors = message.errors);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomodResult();
    message.result = object.result ?? "";
    message.errors = object.errors ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.gateway.AutomodResult", AutomodResult);
function isSet67(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gateway/firehose-admin.js
var import_minimal74 = __toESM(require_minimal2(), 1);
function createBaseFirehoseAuthTokenRequest() {
  return { expiration: "", events: [], customer: "" };
}
var FirehoseAuthTokenRequest = {
  $type: "devvit.gateway.FirehoseAuthTokenRequest",
  encode(message, writer = import_minimal74.default.Writer.create()) {
    if (message.expiration !== "") {
      writer.uint32(10).string(message.expiration);
    }
    for (const v of message.events) {
      writer.uint32(18).string(v);
    }
    if (message.customer !== "") {
      writer.uint32(26).string(message.customer);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal74.default.Reader ? input : new import_minimal74.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFirehoseAuthTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.expiration = reader.string();
          break;
        case 2:
          message.events.push(reader.string());
          break;
        case 3:
          message.customer = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      expiration: isSet68(object.expiration) ? String(object.expiration) : "",
      events: Array.isArray(object?.events) ? object.events.map((e) => String(e)) : [],
      customer: isSet68(object.customer) ? String(object.customer) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.expiration !== void 0 && (obj.expiration = message.expiration);
    if (message.events) {
      obj.events = message.events.map((e) => e);
    } else {
      obj.events = [];
    }
    message.customer !== void 0 && (obj.customer = message.customer);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFirehoseAuthTokenRequest();
    message.expiration = object.expiration ?? "";
    message.events = object.events?.map((e) => e) || [];
    message.customer = object.customer ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.gateway.FirehoseAuthTokenRequest", FirehoseAuthTokenRequest);
function createBaseFirehoseAuthTokenResponse() {
  return { token: "" };
}
var FirehoseAuthTokenResponse = {
  $type: "devvit.gateway.FirehoseAuthTokenResponse",
  encode(message, writer = import_minimal74.default.Writer.create()) {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal74.default.Reader ? input : new import_minimal74.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFirehoseAuthTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.token = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { token: isSet68(object.token) ? String(object.token) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.token !== void 0 && (obj.token = message.token);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFirehoseAuthTokenResponse();
    message.token = object.token ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.gateway.FirehoseAuthTokenResponse", FirehoseAuthTokenResponse);
function isSet68(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gateway/resolvers.js
var import_minimal76 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/gql/subreddit_metadata.js
var import_minimal75 = __toESM(require_minimal2(), 1);
function createBaseSubredditContextActions() {
  return { actorHostname: "", actions: void 0 };
}
var SubredditContextActions = {
  $type: "devvit.gql.SubredditContextActions",
  encode(message, writer = import_minimal75.default.Writer.create()) {
    if (message.actorHostname !== "") {
      writer.uint32(10).string(message.actorHostname);
    }
    if (message.actions !== void 0) {
      ContextActionList.encode(message.actions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal75.default.Reader ? input : new import_minimal75.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditContextActions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actorHostname = reader.string();
          break;
        case 2:
          message.actions = ContextActionList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actorHostname: isSet69(object.actorHostname) ? String(object.actorHostname) : "",
      actions: isSet69(object.actions) ? ContextActionList.fromJSON(object.actions) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.actorHostname !== void 0 && (obj.actorHostname = message.actorHostname);
    message.actions !== void 0 && (obj.actions = message.actions ? ContextActionList.toJSON(message.actions) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditContextActions();
    message.actorHostname = object.actorHostname ?? "";
    message.actions = object.actions !== void 0 && object.actions !== null ? ContextActionList.fromPartial(object.actions) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.gql.SubredditContextActions", SubredditContextActions);
function createBaseDevvitSubredditMetadata() {
  return { installedRemoteApps: [], contextActions: [], errors: [] };
}
var DevvitSubredditMetadata = {
  $type: "devvit.gql.DevvitSubredditMetadata",
  encode(message, writer = import_minimal75.default.Writer.create()) {
    for (const v of message.installedRemoteApps) {
      LinkedBundle.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.contextActions) {
      SubredditContextActions.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.errors) {
      ErrorMessage.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal75.default.Reader ? input : new import_minimal75.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDevvitSubredditMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.installedRemoteApps.push(LinkedBundle.decode(reader, reader.uint32()));
          break;
        case 2:
          message.contextActions.push(SubredditContextActions.decode(reader, reader.uint32()));
          break;
        case 3:
          message.errors.push(ErrorMessage.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      installedRemoteApps: Array.isArray(object?.installedRemoteApps) ? object.installedRemoteApps.map((e) => LinkedBundle.fromJSON(e)) : [],
      contextActions: Array.isArray(object?.contextActions) ? object.contextActions.map((e) => SubredditContextActions.fromJSON(e)) : [],
      errors: Array.isArray(object?.errors) ? object.errors.map((e) => ErrorMessage.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.installedRemoteApps) {
      obj.installedRemoteApps = message.installedRemoteApps.map((e) => e ? LinkedBundle.toJSON(e) : void 0);
    } else {
      obj.installedRemoteApps = [];
    }
    if (message.contextActions) {
      obj.contextActions = message.contextActions.map((e) => e ? SubredditContextActions.toJSON(e) : void 0);
    } else {
      obj.contextActions = [];
    }
    if (message.errors) {
      obj.errors = message.errors.map((e) => e ? ErrorMessage.toJSON(e) : void 0);
    } else {
      obj.errors = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDevvitSubredditMetadata();
    message.installedRemoteApps = object.installedRemoteApps?.map((e) => LinkedBundle.fromPartial(e)) || [];
    message.contextActions = object.contextActions?.map((e) => SubredditContextActions.fromPartial(e)) || [];
    message.errors = object.errors?.map((e) => ErrorMessage.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.gql.DevvitSubredditMetadata", DevvitSubredditMetadata);
function createBaseErrorMessage() {
  return { message: "" };
}
var ErrorMessage = {
  $type: "devvit.gql.ErrorMessage",
  encode(message, writer = import_minimal75.default.Writer.create()) {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal75.default.Reader ? input : new import_minimal75.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseErrorMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { message: isSet69(object.message) ? String(object.message) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseErrorMessage();
    message.message = object.message ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.gql.ErrorMessage", ErrorMessage);
function isSet69(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gateway/resolvers.js
function createBaseSubredditMetadataRequest() {
  return { subreddit: "" };
}
var SubredditMetadataRequest = {
  $type: "devvit.gateway.SubredditMetadataRequest",
  encode(message, writer = import_minimal76.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal76.default.Reader ? input : new import_minimal76.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet70(object.subreddit) ? String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditMetadataRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.gateway.SubredditMetadataRequest", SubredditMetadataRequest);
function isSet70(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gateway/utils/v1alpha/utilities.js
var import_long5 = __toESM(require_long(), 1);
var import_minimal77 = __toESM(require_minimal2(), 1);
function createBaseAccessKeyPurgeRequest() {
  return { userId: "", includeRefresh: false };
}
var AccessKeyPurgeRequest = {
  $type: "devvit.gateway.utils.v1alpha.AccessKeyPurgeRequest",
  encode(message, writer = import_minimal77.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.includeRefresh === true) {
      writer.uint32(16).bool(message.includeRefresh);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal77.default.Reader ? input : new import_minimal77.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAccessKeyPurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.userId = reader.string();
          break;
        case 2:
          message.includeRefresh = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet71(object.userId) ? String(object.userId) : "",
      includeRefresh: isSet71(object.includeRefresh) ? Boolean(object.includeRefresh) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.userId !== void 0 && (obj.userId = message.userId);
    message.includeRefresh !== void 0 && (obj.includeRefresh = message.includeRefresh);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAccessKeyPurgeRequest();
    message.userId = object.userId ?? "";
    message.includeRefresh = object.includeRefresh ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.gateway.utils.v1alpha.AccessKeyPurgeRequest", AccessKeyPurgeRequest);
function createBaseInstallationsPurgeRequest() {
  return { subreddit: "" };
}
var InstallationsPurgeRequest = {
  $type: "devvit.gateway.utils.v1alpha.InstallationsPurgeRequest",
  encode(message, writer = import_minimal77.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal77.default.Reader ? input : new import_minimal77.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInstallationsPurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet71(object.subreddit) ? String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInstallationsPurgeRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.gateway.utils.v1alpha.InstallationsPurgeRequest", InstallationsPurgeRequest);
function createBasePurgeResult() {
  return { count: 0 };
}
var PurgeResult = {
  $type: "devvit.gateway.utils.v1alpha.PurgeResult",
  encode(message, writer = import_minimal77.default.Writer.create()) {
    if (message.count !== 0) {
      writer.uint32(8).int64(message.count);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal77.default.Reader ? input : new import_minimal77.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePurgeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.count = longToNumber5(reader.int64());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { count: isSet71(object.count) ? Number(object.count) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.count !== void 0 && (obj.count = Math.round(message.count));
    return obj;
  },
  fromPartial(object) {
    const message = createBasePurgeResult();
    message.count = object.count ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.gateway.utils.v1alpha.PurgeResult", PurgeResult);
var globalThis7 = (() => {
  if (typeof globalThis7 !== "undefined") {
    return globalThis7;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function longToNumber5(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis7.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal77.default.util.Long !== import_long5.default) {
  import_minimal77.default.util.Long = import_long5.default;
  import_minimal77.default.configure();
}
function isSet71(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/gateway/v1alpha/triggers.js
var import_minimal78 = __toESM(require_minimal2(), 1);
function createBaseTriggerResponse() {
  return { total: 0, success: [], errors: {} };
}
var TriggerResponse = {
  $type: "devvit.gateway.v1alpha.TriggerResponse",
  encode(message, writer = import_minimal78.default.Writer.create()) {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    for (const v of message.success) {
      writer.uint32(18).string(v);
    }
    Object.entries(message.errors).forEach(([key, value]) => {
      TriggerResponse_ErrorsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal78.default.Reader ? input : new import_minimal78.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTriggerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.total = reader.int32();
          break;
        case 2:
          message.success.push(reader.string());
          break;
        case 3:
          const entry3 = TriggerResponse_ErrorsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.errors[entry3.key] = entry3.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      total: isSet72(object.total) ? Number(object.total) : 0,
      success: Array.isArray(object?.success) ? object.success.map((e) => String(e)) : [],
      errors: isObject12(object.errors) ? Object.entries(object.errors).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.total !== void 0 && (obj.total = Math.round(message.total));
    if (message.success) {
      obj.success = message.success.map((e) => e);
    } else {
      obj.success = [];
    }
    obj.errors = {};
    if (message.errors) {
      Object.entries(message.errors).forEach(([k, v]) => {
        obj.errors[k] = v;
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTriggerResponse();
    message.total = object.total ?? 0;
    message.success = object.success?.map((e) => e) || [];
    message.errors = Object.entries(object.errors ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.gateway.v1alpha.TriggerResponse", TriggerResponse);
function createBaseTriggerResponse_ErrorsEntry() {
  return { key: "", value: "" };
}
var TriggerResponse_ErrorsEntry = {
  $type: "devvit.gateway.v1alpha.TriggerResponse.ErrorsEntry",
  encode(message, writer = import_minimal78.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal78.default.Reader ? input : new import_minimal78.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTriggerResponse_ErrorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet72(object.key) ? String(object.key) : "", value: isSet72(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTriggerResponse_ErrorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.gateway.v1alpha.TriggerResponse.ErrorsEntry", TriggerResponse_ErrorsEntry);
function isObject12(value) {
  return typeof value === "object" && value !== null;
}
function isSet72(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/automodregex/automodregex.js
var import_minimal79 = __toESM(require_minimal2(), 1);
function createBaseAutomodRegexInput() {
  return { pattern: "", input: "", caseInsensitive: false };
}
var AutomodRegexInput = {
  $type: "devvit.plugin.automodregex.AutomodRegexInput",
  encode(message, writer = import_minimal79.default.Writer.create()) {
    if (message.pattern !== "") {
      writer.uint32(10).string(message.pattern);
    }
    if (message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.caseInsensitive === true) {
      writer.uint32(24).bool(message.caseInsensitive);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal79.default.Reader ? input : new import_minimal79.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomodRegexInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pattern = reader.string();
          break;
        case 2:
          message.input = reader.string();
          break;
        case 3:
          message.caseInsensitive = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      pattern: isSet73(object.pattern) ? String(object.pattern) : "",
      input: isSet73(object.input) ? String(object.input) : "",
      caseInsensitive: isSet73(object.caseInsensitive) ? Boolean(object.caseInsensitive) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.pattern !== void 0 && (obj.pattern = message.pattern);
    message.input !== void 0 && (obj.input = message.input);
    message.caseInsensitive !== void 0 && (obj.caseInsensitive = message.caseInsensitive);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomodRegexInput();
    message.pattern = object.pattern ?? "";
    message.input = object.input ?? "";
    message.caseInsensitive = object.caseInsensitive ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.automodregex.AutomodRegexInput", AutomodRegexInput);
function createBaseAutomodRegexMatchOutput() {
  return { groups: [] };
}
var AutomodRegexMatchOutput = {
  $type: "devvit.plugin.automodregex.AutomodRegexMatchOutput",
  encode(message, writer = import_minimal79.default.Writer.create()) {
    for (const v of message.groups) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal79.default.Reader ? input : new import_minimal79.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomodRegexMatchOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groups.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { groups: Array.isArray(object?.groups) ? object.groups.map((e) => String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.groups) {
      obj.groups = message.groups.map((e) => e);
    } else {
      obj.groups = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomodRegexMatchOutput();
    message.groups = object.groups?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.automodregex.AutomodRegexMatchOutput", AutomodRegexMatchOutput);
function createBaseAutomodRegexTestOutput() {
  return { match: false };
}
var AutomodRegexTestOutput = {
  $type: "devvit.plugin.automodregex.AutomodRegexTestOutput",
  encode(message, writer = import_minimal79.default.Writer.create()) {
    if (message.match === true) {
      writer.uint32(8).bool(message.match);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal79.default.Reader ? input : new import_minimal79.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutomodRegexTestOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.match = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { match: isSet73(object.match) ? Boolean(object.match) : false };
  },
  toJSON(message) {
    const obj = {};
    message.match !== void 0 && (obj.match = message.match);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAutomodRegexTestOutput();
    message.match = object.match ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.automodregex.AutomodRegexTestOutput", AutomodRegexTestOutput);
function isSet73(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/builder/builder.js
var import_minimal80 = __toESM(require_minimal2(), 1);
function createBaseBuildResponse() {
  return { bundle: void 0, errors: [], warnings: [] };
}
var BuildResponse = {
  $type: "devvit.plugin.builder.BuildResponse",
  encode(message, writer = import_minimal80.default.Writer.create()) {
    if (message.bundle !== void 0) {
      LinkedBundle.encode(message.bundle, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.errors) {
      CompileLog.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.warnings) {
      CompileLog.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal80.default.Reader ? input : new import_minimal80.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBuildResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bundle = LinkedBundle.decode(reader, reader.uint32());
          break;
        case 2:
          message.errors.push(CompileLog.decode(reader, reader.uint32()));
          break;
        case 3:
          message.warnings.push(CompileLog.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      bundle: isSet74(object.bundle) ? LinkedBundle.fromJSON(object.bundle) : void 0,
      errors: Array.isArray(object?.errors) ? object.errors.map((e) => CompileLog.fromJSON(e)) : [],
      warnings: Array.isArray(object?.warnings) ? object.warnings.map((e) => CompileLog.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.bundle !== void 0 && (obj.bundle = message.bundle ? LinkedBundle.toJSON(message.bundle) : void 0);
    if (message.errors) {
      obj.errors = message.errors.map((e) => e ? CompileLog.toJSON(e) : void 0);
    } else {
      obj.errors = [];
    }
    if (message.warnings) {
      obj.warnings = message.warnings.map((e) => e ? CompileLog.toJSON(e) : void 0);
    } else {
      obj.warnings = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBuildResponse();
    message.bundle = object.bundle !== void 0 && object.bundle !== null ? LinkedBundle.fromPartial(object.bundle) : void 0;
    message.errors = object.errors?.map((e) => CompileLog.fromPartial(e)) || [];
    message.warnings = object.warnings?.map((e) => CompileLog.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.builder.BuildResponse", BuildResponse);
function isSet74(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/buildpack/buildpack.js
var import_minimal81 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/clock/clock.js
var import_minimal82 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/devserver/devserver.js
var import_minimal84 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/devserver/testcases.js
var import_minimal83 = __toESM(require_minimal2(), 1);
function createBaseTestCasesList() {
  return { actorName: "", testCases: [] };
}
var TestCasesList = {
  $type: "devvit.plugin.devserver.TestCasesList",
  encode(message, writer = import_minimal83.default.Writer.create()) {
    if (message.actorName !== "") {
      writer.uint32(10).string(message.actorName);
    }
    for (const v of message.testCases) {
      TestCase.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal83.default.Reader ? input : new import_minimal83.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTestCasesList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actorName = reader.string();
          break;
        case 2:
          message.testCases.push(TestCase.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actorName: isSet75(object.actorName) ? String(object.actorName) : "",
      testCases: Array.isArray(object?.testCases) ? object.testCases.map((e) => TestCase.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.actorName !== void 0 && (obj.actorName = message.actorName);
    if (message.testCases) {
      obj.testCases = message.testCases.map((e) => e ? TestCase.toJSON(e) : void 0);
    } else {
      obj.testCases = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTestCasesList();
    message.actorName = object.actorName ?? "";
    message.testCases = object.testCases?.map((e) => TestCase.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.TestCasesList", TestCasesList);
function createBaseTestCase() {
  return { methodName: "", testName: "", testInput: "" };
}
var TestCase = {
  $type: "devvit.plugin.devserver.TestCase",
  encode(message, writer = import_minimal83.default.Writer.create()) {
    if (message.methodName !== "") {
      writer.uint32(10).string(message.methodName);
    }
    if (message.testName !== "") {
      writer.uint32(18).string(message.testName);
    }
    if (message.testInput !== "") {
      writer.uint32(26).string(message.testInput);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal83.default.Reader ? input : new import_minimal83.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTestCase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.methodName = reader.string();
          break;
        case 2:
          message.testName = reader.string();
          break;
        case 3:
          message.testInput = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      methodName: isSet75(object.methodName) ? String(object.methodName) : "",
      testName: isSet75(object.testName) ? String(object.testName) : "",
      testInput: isSet75(object.testInput) ? String(object.testInput) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.methodName !== void 0 && (obj.methodName = message.methodName);
    message.testName !== void 0 && (obj.testName = message.testName);
    message.testInput !== void 0 && (obj.testInput = message.testInput);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTestCase();
    message.methodName = object.methodName ?? "";
    message.testName = object.testName ?? "";
    message.testInput = object.testInput ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.TestCase", TestCase);
function isSet75(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/devserver/devserver.js
function createBaseProjectListRequest() {
  return { projectRootDirectory: "" };
}
var ProjectListRequest = {
  $type: "devvit.plugin.devserver.ProjectListRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.projectRootDirectory !== "") {
      writer.uint32(10).string(message.projectRootDirectory);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : new import_minimal84.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.projectRootDirectory = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { projectRootDirectory: isSet76(object.projectRootDirectory) ? String(object.projectRootDirectory) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.projectRootDirectory !== void 0 && (obj.projectRootDirectory = message.projectRootDirectory);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseProjectListRequest();
    message.projectRootDirectory = object.projectRootDirectory ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.ProjectListRequest", ProjectListRequest);
function createBaseProjectBuildProblems() {
  return { warnings: [], errors: [] };
}
var ProjectBuildProblems = {
  $type: "devvit.plugin.devserver.ProjectBuildProblems",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    for (const v of message.warnings) {
      CompileLog.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.errors) {
      CompileLog.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : new import_minimal84.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectBuildProblems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.warnings.push(CompileLog.decode(reader, reader.uint32()));
          break;
        case 2:
          message.errors.push(CompileLog.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      warnings: Array.isArray(object?.warnings) ? object.warnings.map((e) => CompileLog.fromJSON(e)) : [],
      errors: Array.isArray(object?.errors) ? object.errors.map((e) => CompileLog.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.warnings) {
      obj.warnings = message.warnings.map((e) => e ? CompileLog.toJSON(e) : void 0);
    } else {
      obj.warnings = [];
    }
    if (message.errors) {
      obj.errors = message.errors.map((e) => e ? CompileLog.toJSON(e) : void 0);
    } else {
      obj.errors = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseProjectBuildProblems();
    message.warnings = object.warnings?.map((e) => CompileLog.fromPartial(e)) || [];
    message.errors = object.errors?.map((e) => CompileLog.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.ProjectBuildProblems", ProjectBuildProblems);
function createBaseProjectListingResponse() {
  return { projectRootDirectory: "", projectFileSystem: void 0, buildProblems: {} };
}
var ProjectListingResponse = {
  $type: "devvit.plugin.devserver.ProjectListingResponse",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.projectRootDirectory !== "") {
      writer.uint32(10).string(message.projectRootDirectory);
    }
    if (message.projectFileSystem !== void 0) {
      FileSystem.encode(message.projectFileSystem, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.buildProblems).forEach(([key, value]) => {
      ProjectListingResponse_BuildProblemsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : new import_minimal84.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectListingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.projectRootDirectory = reader.string();
          break;
        case 2:
          message.projectFileSystem = FileSystem.decode(reader, reader.uint32());
          break;
        case 3:
          const entry3 = ProjectListingResponse_BuildProblemsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.buildProblems[entry3.key] = entry3.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      projectRootDirectory: isSet76(object.projectRootDirectory) ? String(object.projectRootDirectory) : "",
      projectFileSystem: isSet76(object.projectFileSystem) ? FileSystem.fromJSON(object.projectFileSystem) : void 0,
      buildProblems: isObject13(object.buildProblems) ? Object.entries(object.buildProblems).reduce((acc, [key, value]) => {
        acc[key] = ProjectBuildProblems.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.projectRootDirectory !== void 0 && (obj.projectRootDirectory = message.projectRootDirectory);
    message.projectFileSystem !== void 0 && (obj.projectFileSystem = message.projectFileSystem ? FileSystem.toJSON(message.projectFileSystem) : void 0);
    obj.buildProblems = {};
    if (message.buildProblems) {
      Object.entries(message.buildProblems).forEach(([k, v]) => {
        obj.buildProblems[k] = ProjectBuildProblems.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseProjectListingResponse();
    message.projectRootDirectory = object.projectRootDirectory ?? "";
    message.projectFileSystem = object.projectFileSystem !== void 0 && object.projectFileSystem !== null ? FileSystem.fromPartial(object.projectFileSystem) : void 0;
    message.buildProblems = Object.entries(object.buildProblems ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ProjectBuildProblems.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.ProjectListingResponse", ProjectListingResponse);
function createBaseProjectListingResponse_BuildProblemsEntry() {
  return { key: "", value: void 0 };
}
var ProjectListingResponse_BuildProblemsEntry = {
  $type: "devvit.plugin.devserver.ProjectListingResponse.BuildProblemsEntry",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ProjectBuildProblems.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : new import_minimal84.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectListingResponse_BuildProblemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ProjectBuildProblems.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet76(object.key) ? String(object.key) : "",
      value: isSet76(object.value) ? ProjectBuildProblems.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ProjectBuildProblems.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseProjectListingResponse_BuildProblemsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ProjectBuildProblems.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.ProjectListingResponse.BuildProblemsEntry", ProjectListingResponse_BuildProblemsEntry);
function createBaseProjectUpdatesRequest() {
  return { projectRootDirectory: "" };
}
var ProjectUpdatesRequest = {
  $type: "devvit.plugin.devserver.ProjectUpdatesRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.projectRootDirectory !== "") {
      writer.uint32(10).string(message.projectRootDirectory);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : new import_minimal84.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectUpdatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.projectRootDirectory = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { projectRootDirectory: isSet76(object.projectRootDirectory) ? String(object.projectRootDirectory) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.projectRootDirectory !== void 0 && (obj.projectRootDirectory = message.projectRootDirectory);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseProjectUpdatesRequest();
    message.projectRootDirectory = object.projectRootDirectory ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.ProjectUpdatesRequest", ProjectUpdatesRequest);
function createBaseProjectUpdateResponse() {
  return { projectRootDirectory: "", file: void 0, linkedBundle: void 0, actorPath: "", buildProblems: {} };
}
var ProjectUpdateResponse = {
  $type: "devvit.plugin.devserver.ProjectUpdateResponse",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.projectRootDirectory !== "") {
      writer.uint32(10).string(message.projectRootDirectory);
    }
    if (message.file !== void 0) {
      File.encode(message.file, writer.uint32(18).fork()).ldelim();
    }
    if (message.linkedBundle !== void 0) {
      LinkedBundle.encode(message.linkedBundle, writer.uint32(26).fork()).ldelim();
    }
    if (message.actorPath !== "") {
      writer.uint32(34).string(message.actorPath);
    }
    Object.entries(message.buildProblems).forEach(([key, value]) => {
      ProjectUpdateResponse_BuildProblemsEntry.encode({ key, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : new import_minimal84.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.projectRootDirectory = reader.string();
          break;
        case 2:
          message.file = File.decode(reader, reader.uint32());
          break;
        case 3:
          message.linkedBundle = LinkedBundle.decode(reader, reader.uint32());
          break;
        case 4:
          message.actorPath = reader.string();
          break;
        case 5:
          const entry5 = ProjectUpdateResponse_BuildProblemsEntry.decode(reader, reader.uint32());
          if (entry5.value !== void 0) {
            message.buildProblems[entry5.key] = entry5.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      projectRootDirectory: isSet76(object.projectRootDirectory) ? String(object.projectRootDirectory) : "",
      file: isSet76(object.file) ? File.fromJSON(object.file) : void 0,
      linkedBundle: isSet76(object.linkedBundle) ? LinkedBundle.fromJSON(object.linkedBundle) : void 0,
      actorPath: isSet76(object.actorPath) ? String(object.actorPath) : "",
      buildProblems: isObject13(object.buildProblems) ? Object.entries(object.buildProblems).reduce((acc, [key, value]) => {
        acc[key] = ProjectBuildProblems.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.projectRootDirectory !== void 0 && (obj.projectRootDirectory = message.projectRootDirectory);
    message.file !== void 0 && (obj.file = message.file ? File.toJSON(message.file) : void 0);
    message.linkedBundle !== void 0 && (obj.linkedBundle = message.linkedBundle ? LinkedBundle.toJSON(message.linkedBundle) : void 0);
    message.actorPath !== void 0 && (obj.actorPath = message.actorPath);
    obj.buildProblems = {};
    if (message.buildProblems) {
      Object.entries(message.buildProblems).forEach(([k, v]) => {
        obj.buildProblems[k] = ProjectBuildProblems.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseProjectUpdateResponse();
    message.projectRootDirectory = object.projectRootDirectory ?? "";
    message.file = object.file !== void 0 && object.file !== null ? File.fromPartial(object.file) : void 0;
    message.linkedBundle = object.linkedBundle !== void 0 && object.linkedBundle !== null ? LinkedBundle.fromPartial(object.linkedBundle) : void 0;
    message.actorPath = object.actorPath ?? "";
    message.buildProblems = Object.entries(object.buildProblems ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ProjectBuildProblems.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.ProjectUpdateResponse", ProjectUpdateResponse);
function createBaseProjectUpdateResponse_BuildProblemsEntry() {
  return { key: "", value: void 0 };
}
var ProjectUpdateResponse_BuildProblemsEntry = {
  $type: "devvit.plugin.devserver.ProjectUpdateResponse.BuildProblemsEntry",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ProjectBuildProblems.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : new import_minimal84.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProjectUpdateResponse_BuildProblemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ProjectBuildProblems.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet76(object.key) ? String(object.key) : "",
      value: isSet76(object.value) ? ProjectBuildProblems.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ProjectBuildProblems.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseProjectUpdateResponse_BuildProblemsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ProjectBuildProblems.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.ProjectUpdateResponse.BuildProblemsEntry", ProjectUpdateResponse_BuildProblemsEntry);
function createBaseTestCasesRequest() {
  return { actorName: "" };
}
var TestCasesRequest = {
  $type: "devvit.plugin.devserver.TestCasesRequest",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.actorName !== "") {
      writer.uint32(10).string(message.actorName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : new import_minimal84.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTestCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actorName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { actorName: isSet76(object.actorName) ? String(object.actorName) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.actorName !== void 0 && (obj.actorName = message.actorName);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTestCasesRequest();
    message.actorName = object.actorName ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.TestCasesRequest", TestCasesRequest);
function createBaseAuthenticationRequest() {
  return {};
}
var AuthenticationRequest = {
  $type: "devvit.plugin.devserver.AuthenticationRequest",
  encode(_, writer = import_minimal84.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : new import_minimal84.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseAuthenticationRequest();
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.AuthenticationRequest", AuthenticationRequest);
function createBaseAuthenticationResponse() {
  return { storedToken: void 0 };
}
var AuthenticationResponse = {
  $type: "devvit.plugin.devserver.AuthenticationResponse",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.storedToken !== void 0) {
      StoredToken.encode(message.storedToken, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : new import_minimal84.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.storedToken = StoredToken.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { storedToken: isSet76(object.storedToken) ? StoredToken.fromJSON(object.storedToken) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.storedToken !== void 0 && (obj.storedToken = message.storedToken ? StoredToken.toJSON(message.storedToken) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAuthenticationResponse();
    message.storedToken = object.storedToken !== void 0 && object.storedToken !== null ? StoredToken.fromPartial(object.storedToken) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.AuthenticationResponse", AuthenticationResponse);
function createBaseValidationRequest() {
  return {};
}
var ValidationRequest = {
  $type: "devvit.plugin.devserver.ValidationRequest",
  encode(_, writer = import_minimal84.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : new import_minimal84.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseValidationRequest();
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.ValidationRequest", ValidationRequest);
function createBaseStoredToken() {
  return { refreshToken: "", accessToken: "", expiresAt: void 0, scope: "", tokenType: "" };
}
var StoredToken = {
  $type: "devvit.plugin.devserver.StoredToken",
  encode(message, writer = import_minimal84.default.Writer.create()) {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.expiresAt !== void 0) {
      Timestamp.encode(toTimestamp11(message.expiresAt), writer.uint32(26).fork()).ldelim();
    }
    if (message.scope !== "") {
      writer.uint32(34).string(message.scope);
    }
    if (message.tokenType !== "") {
      writer.uint32(42).string(message.tokenType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal84.default.Reader ? input : new import_minimal84.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStoredToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.refreshToken = reader.string();
          break;
        case 2:
          message.accessToken = reader.string();
          break;
        case 3:
          message.expiresAt = fromTimestamp11(Timestamp.decode(reader, reader.uint32()));
          break;
        case 4:
          message.scope = reader.string();
          break;
        case 5:
          message.tokenType = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      refreshToken: isSet76(object.refreshToken) ? String(object.refreshToken) : "",
      accessToken: isSet76(object.accessToken) ? String(object.accessToken) : "",
      expiresAt: isSet76(object.expiresAt) ? fromJsonTimestamp11(object.expiresAt) : void 0,
      scope: isSet76(object.scope) ? String(object.scope) : "",
      tokenType: isSet76(object.tokenType) ? String(object.tokenType) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.refreshToken !== void 0 && (obj.refreshToken = message.refreshToken);
    message.accessToken !== void 0 && (obj.accessToken = message.accessToken);
    message.expiresAt !== void 0 && (obj.expiresAt = message.expiresAt.toISOString());
    message.scope !== void 0 && (obj.scope = message.scope);
    message.tokenType !== void 0 && (obj.tokenType = message.tokenType);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStoredToken();
    message.refreshToken = object.refreshToken ?? "";
    message.accessToken = object.accessToken ?? "";
    message.expiresAt = object.expiresAt ?? void 0;
    message.scope = object.scope ?? "";
    message.tokenType = object.tokenType ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.devserver.StoredToken", StoredToken);
function toTimestamp11(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp11(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp11(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp11(Timestamp.fromJSON(o));
  }
}
function isObject13(value) {
  return typeof value === "object" && value !== null;
}
function isSet76(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/gl/glrenderer.js
var import_long6 = __toESM(require_long(), 1);
var import_minimal85 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/gl/methods.js
var GLMethod;
(function(GLMethod2) {
  GLMethod2[GLMethod2["activeTexture"] = 0] = "activeTexture";
  GLMethod2[GLMethod2["attachShader"] = 1] = "attachShader";
  GLMethod2[GLMethod2["bindAttribLocation"] = 2] = "bindAttribLocation";
  GLMethod2[GLMethod2["bindBuffer"] = 3] = "bindBuffer";
  GLMethod2[GLMethod2["bindFramebuffer"] = 4] = "bindFramebuffer";
  GLMethod2[GLMethod2["bindRenderbuffer"] = 5] = "bindRenderbuffer";
  GLMethod2[GLMethod2["bindTexture"] = 6] = "bindTexture";
  GLMethod2[GLMethod2["blendColor"] = 7] = "blendColor";
  GLMethod2[GLMethod2["blendEquation"] = 8] = "blendEquation";
  GLMethod2[GLMethod2["blendEquationSeparate"] = 9] = "blendEquationSeparate";
  GLMethod2[GLMethod2["blendFunc"] = 10] = "blendFunc";
  GLMethod2[GLMethod2["blendFuncSeparate"] = 11] = "blendFuncSeparate";
  GLMethod2[GLMethod2["bufferData"] = 12] = "bufferData";
  GLMethod2[GLMethod2["bufferSubData"] = 13] = "bufferSubData";
  GLMethod2[GLMethod2["checkFramebufferStatus"] = 14] = "checkFramebufferStatus";
  GLMethod2[GLMethod2["clear"] = 15] = "clear";
  GLMethod2[GLMethod2["clearColor"] = 16] = "clearColor";
  GLMethod2[GLMethod2["clearDepth"] = 17] = "clearDepth";
  GLMethod2[GLMethod2["clearStencil"] = 18] = "clearStencil";
  GLMethod2[GLMethod2["colorMask"] = 19] = "colorMask";
  GLMethod2[GLMethod2["compileShader"] = 20] = "compileShader";
  GLMethod2[GLMethod2["copyTexImage2D"] = 21] = "copyTexImage2D";
  GLMethod2[GLMethod2["copyTexSubImage2D"] = 22] = "copyTexSubImage2D";
  GLMethod2[GLMethod2["createBuffer"] = 23] = "createBuffer";
  GLMethod2[GLMethod2["createFramebuffer"] = 24] = "createFramebuffer";
  GLMethod2[GLMethod2["createProgram"] = 25] = "createProgram";
  GLMethod2[GLMethod2["createRenderbuffer"] = 26] = "createRenderbuffer";
  GLMethod2[GLMethod2["createShader"] = 27] = "createShader";
  GLMethod2[GLMethod2["createTexture"] = 28] = "createTexture";
  GLMethod2[GLMethod2["cullFace"] = 29] = "cullFace";
  GLMethod2[GLMethod2["deleteBuffer"] = 30] = "deleteBuffer";
  GLMethod2[GLMethod2["deleteFramebuffer"] = 31] = "deleteFramebuffer";
  GLMethod2[GLMethod2["deleteProgram"] = 32] = "deleteProgram";
  GLMethod2[GLMethod2["deleteRenderbuffer"] = 33] = "deleteRenderbuffer";
  GLMethod2[GLMethod2["deleteShader"] = 34] = "deleteShader";
  GLMethod2[GLMethod2["deleteTexture"] = 35] = "deleteTexture";
  GLMethod2[GLMethod2["depthFunc"] = 36] = "depthFunc";
  GLMethod2[GLMethod2["depthMask"] = 37] = "depthMask";
  GLMethod2[GLMethod2["depthRange"] = 38] = "depthRange";
  GLMethod2[GLMethod2["detachShader"] = 39] = "detachShader";
  GLMethod2[GLMethod2["disable"] = 40] = "disable";
  GLMethod2[GLMethod2["disableVertexAttribArray"] = 41] = "disableVertexAttribArray";
  GLMethod2[GLMethod2["drawArrays"] = 42] = "drawArrays";
  GLMethod2[GLMethod2["drawElements"] = 43] = "drawElements";
  GLMethod2[GLMethod2["enable"] = 44] = "enable";
  GLMethod2[GLMethod2["enableVertexAttribArray"] = 45] = "enableVertexAttribArray";
  GLMethod2[GLMethod2["finish"] = 46] = "finish";
  GLMethod2[GLMethod2["flush"] = 47] = "flush";
  GLMethod2[GLMethod2["framebufferRenderbuffer"] = 48] = "framebufferRenderbuffer";
  GLMethod2[GLMethod2["framebufferTexture2D"] = 49] = "framebufferTexture2D";
  GLMethod2[GLMethod2["frontFace"] = 50] = "frontFace";
  GLMethod2[GLMethod2["generateMipmap"] = 51] = "generateMipmap";
  GLMethod2[GLMethod2["getActiveAttrib"] = 52] = "getActiveAttrib";
  GLMethod2[GLMethod2["getActiveUniform"] = 53] = "getActiveUniform";
  GLMethod2[GLMethod2["getAttachedShaders"] = 54] = "getAttachedShaders";
  GLMethod2[GLMethod2["getAttribLocation"] = 55] = "getAttribLocation";
  GLMethod2[GLMethod2["getBufferParameter"] = 56] = "getBufferParameter";
  GLMethod2[GLMethod2["getContextAttributes"] = 57] = "getContextAttributes";
  GLMethod2[GLMethod2["getError"] = 58] = "getError";
  GLMethod2[GLMethod2["getExtension"] = 59] = "getExtension";
  GLMethod2[GLMethod2["getFramebufferAttachmentParameter"] = 60] = "getFramebufferAttachmentParameter";
  GLMethod2[GLMethod2["getParameter"] = 61] = "getParameter";
  GLMethod2[GLMethod2["getProgramInfoLog"] = 62] = "getProgramInfoLog";
  GLMethod2[GLMethod2["getProgramParameter"] = 63] = "getProgramParameter";
  GLMethod2[GLMethod2["getRenderbufferParameter"] = 64] = "getRenderbufferParameter";
  GLMethod2[GLMethod2["getShaderInfoLog"] = 65] = "getShaderInfoLog";
  GLMethod2[GLMethod2["getShaderParameter"] = 66] = "getShaderParameter";
  GLMethod2[GLMethod2["getShaderPrecisionFormat"] = 67] = "getShaderPrecisionFormat";
  GLMethod2[GLMethod2["getShaderSource"] = 68] = "getShaderSource";
  GLMethod2[GLMethod2["getSupportedExtensions"] = 69] = "getSupportedExtensions";
  GLMethod2[GLMethod2["getTexParameter"] = 70] = "getTexParameter";
  GLMethod2[GLMethod2["getUniform"] = 71] = "getUniform";
  GLMethod2[GLMethod2["getUniformLocation"] = 72] = "getUniformLocation";
  GLMethod2[GLMethod2["getVertexAttrib"] = 73] = "getVertexAttrib";
  GLMethod2[GLMethod2["getVertexAttribOffset"] = 74] = "getVertexAttribOffset";
  GLMethod2[GLMethod2["hint"] = 75] = "hint";
  GLMethod2[GLMethod2["isBuffer"] = 76] = "isBuffer";
  GLMethod2[GLMethod2["isContextLost"] = 77] = "isContextLost";
  GLMethod2[GLMethod2["isEnabled"] = 78] = "isEnabled";
  GLMethod2[GLMethod2["isFramebuffer"] = 79] = "isFramebuffer";
  GLMethod2[GLMethod2["isProgram"] = 80] = "isProgram";
  GLMethod2[GLMethod2["isRenderbuffer"] = 81] = "isRenderbuffer";
  GLMethod2[GLMethod2["isShader"] = 82] = "isShader";
  GLMethod2[GLMethod2["isTexture"] = 83] = "isTexture";
  GLMethod2[GLMethod2["lineWidth"] = 84] = "lineWidth";
  GLMethod2[GLMethod2["linkProgram"] = 85] = "linkProgram";
  GLMethod2[GLMethod2["polygonOffset"] = 86] = "polygonOffset";
  GLMethod2[GLMethod2["renderbufferStorage"] = 87] = "renderbufferStorage";
  GLMethod2[GLMethod2["sampleCoverage"] = 88] = "sampleCoverage";
  GLMethod2[GLMethod2["scissor"] = 89] = "scissor";
  GLMethod2[GLMethod2["shaderSource"] = 90] = "shaderSource";
  GLMethod2[GLMethod2["stencilFunc"] = 91] = "stencilFunc";
  GLMethod2[GLMethod2["stencilFuncSeparate"] = 92] = "stencilFuncSeparate";
  GLMethod2[GLMethod2["stencilMask"] = 93] = "stencilMask";
  GLMethod2[GLMethod2["stencilMaskSeparate"] = 94] = "stencilMaskSeparate";
  GLMethod2[GLMethod2["stencilOp"] = 95] = "stencilOp";
  GLMethod2[GLMethod2["stencilOpSeparate"] = 96] = "stencilOpSeparate";
  GLMethod2[GLMethod2["texParameterf"] = 97] = "texParameterf";
  GLMethod2[GLMethod2["texParameteri"] = 98] = "texParameteri";
  GLMethod2[GLMethod2["uniform1f"] = 99] = "uniform1f";
  GLMethod2[GLMethod2["uniform1i"] = 100] = "uniform1i";
  GLMethod2[GLMethod2["uniform2f"] = 101] = "uniform2f";
  GLMethod2[GLMethod2["uniform2i"] = 102] = "uniform2i";
  GLMethod2[GLMethod2["uniform3f"] = 103] = "uniform3f";
  GLMethod2[GLMethod2["uniform3i"] = 104] = "uniform3i";
  GLMethod2[GLMethod2["uniform4f"] = 105] = "uniform4f";
  GLMethod2[GLMethod2["uniform4i"] = 106] = "uniform4i";
  GLMethod2[GLMethod2["useProgram"] = 107] = "useProgram";
  GLMethod2[GLMethod2["validateProgram"] = 108] = "validateProgram";
  GLMethod2[GLMethod2["vertexAttrib1f"] = 109] = "vertexAttrib1f";
  GLMethod2[GLMethod2["vertexAttrib2f"] = 110] = "vertexAttrib2f";
  GLMethod2[GLMethod2["vertexAttrib3f"] = 111] = "vertexAttrib3f";
  GLMethod2[GLMethod2["vertexAttrib4f"] = 112] = "vertexAttrib4f";
  GLMethod2[GLMethod2["vertexAttribPointer"] = 113] = "vertexAttribPointer";
  GLMethod2[GLMethod2["viewport"] = 114] = "viewport";
  GLMethod2[GLMethod2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(GLMethod || (GLMethod = {}));
function gLMethodFromJSON(object) {
  switch (object) {
    case 0:
    case "activeTexture":
      return GLMethod.activeTexture;
    case 1:
    case "attachShader":
      return GLMethod.attachShader;
    case 2:
    case "bindAttribLocation":
      return GLMethod.bindAttribLocation;
    case 3:
    case "bindBuffer":
      return GLMethod.bindBuffer;
    case 4:
    case "bindFramebuffer":
      return GLMethod.bindFramebuffer;
    case 5:
    case "bindRenderbuffer":
      return GLMethod.bindRenderbuffer;
    case 6:
    case "bindTexture":
      return GLMethod.bindTexture;
    case 7:
    case "blendColor":
      return GLMethod.blendColor;
    case 8:
    case "blendEquation":
      return GLMethod.blendEquation;
    case 9:
    case "blendEquationSeparate":
      return GLMethod.blendEquationSeparate;
    case 10:
    case "blendFunc":
      return GLMethod.blendFunc;
    case 11:
    case "blendFuncSeparate":
      return GLMethod.blendFuncSeparate;
    case 12:
    case "bufferData":
      return GLMethod.bufferData;
    case 13:
    case "bufferSubData":
      return GLMethod.bufferSubData;
    case 14:
    case "checkFramebufferStatus":
      return GLMethod.checkFramebufferStatus;
    case 15:
    case "clear":
      return GLMethod.clear;
    case 16:
    case "clearColor":
      return GLMethod.clearColor;
    case 17:
    case "clearDepth":
      return GLMethod.clearDepth;
    case 18:
    case "clearStencil":
      return GLMethod.clearStencil;
    case 19:
    case "colorMask":
      return GLMethod.colorMask;
    case 20:
    case "compileShader":
      return GLMethod.compileShader;
    case 21:
    case "copyTexImage2D":
      return GLMethod.copyTexImage2D;
    case 22:
    case "copyTexSubImage2D":
      return GLMethod.copyTexSubImage2D;
    case 23:
    case "createBuffer":
      return GLMethod.createBuffer;
    case 24:
    case "createFramebuffer":
      return GLMethod.createFramebuffer;
    case 25:
    case "createProgram":
      return GLMethod.createProgram;
    case 26:
    case "createRenderbuffer":
      return GLMethod.createRenderbuffer;
    case 27:
    case "createShader":
      return GLMethod.createShader;
    case 28:
    case "createTexture":
      return GLMethod.createTexture;
    case 29:
    case "cullFace":
      return GLMethod.cullFace;
    case 30:
    case "deleteBuffer":
      return GLMethod.deleteBuffer;
    case 31:
    case "deleteFramebuffer":
      return GLMethod.deleteFramebuffer;
    case 32:
    case "deleteProgram":
      return GLMethod.deleteProgram;
    case 33:
    case "deleteRenderbuffer":
      return GLMethod.deleteRenderbuffer;
    case 34:
    case "deleteShader":
      return GLMethod.deleteShader;
    case 35:
    case "deleteTexture":
      return GLMethod.deleteTexture;
    case 36:
    case "depthFunc":
      return GLMethod.depthFunc;
    case 37:
    case "depthMask":
      return GLMethod.depthMask;
    case 38:
    case "depthRange":
      return GLMethod.depthRange;
    case 39:
    case "detachShader":
      return GLMethod.detachShader;
    case 40:
    case "disable":
      return GLMethod.disable;
    case 41:
    case "disableVertexAttribArray":
      return GLMethod.disableVertexAttribArray;
    case 42:
    case "drawArrays":
      return GLMethod.drawArrays;
    case 43:
    case "drawElements":
      return GLMethod.drawElements;
    case 44:
    case "enable":
      return GLMethod.enable;
    case 45:
    case "enableVertexAttribArray":
      return GLMethod.enableVertexAttribArray;
    case 46:
    case "finish":
      return GLMethod.finish;
    case 47:
    case "flush":
      return GLMethod.flush;
    case 48:
    case "framebufferRenderbuffer":
      return GLMethod.framebufferRenderbuffer;
    case 49:
    case "framebufferTexture2D":
      return GLMethod.framebufferTexture2D;
    case 50:
    case "frontFace":
      return GLMethod.frontFace;
    case 51:
    case "generateMipmap":
      return GLMethod.generateMipmap;
    case 52:
    case "getActiveAttrib":
      return GLMethod.getActiveAttrib;
    case 53:
    case "getActiveUniform":
      return GLMethod.getActiveUniform;
    case 54:
    case "getAttachedShaders":
      return GLMethod.getAttachedShaders;
    case 55:
    case "getAttribLocation":
      return GLMethod.getAttribLocation;
    case 56:
    case "getBufferParameter":
      return GLMethod.getBufferParameter;
    case 57:
    case "getContextAttributes":
      return GLMethod.getContextAttributes;
    case 58:
    case "getError":
      return GLMethod.getError;
    case 59:
    case "getExtension":
      return GLMethod.getExtension;
    case 60:
    case "getFramebufferAttachmentParameter":
      return GLMethod.getFramebufferAttachmentParameter;
    case 61:
    case "getParameter":
      return GLMethod.getParameter;
    case 62:
    case "getProgramInfoLog":
      return GLMethod.getProgramInfoLog;
    case 63:
    case "getProgramParameter":
      return GLMethod.getProgramParameter;
    case 64:
    case "getRenderbufferParameter":
      return GLMethod.getRenderbufferParameter;
    case 65:
    case "getShaderInfoLog":
      return GLMethod.getShaderInfoLog;
    case 66:
    case "getShaderParameter":
      return GLMethod.getShaderParameter;
    case 67:
    case "getShaderPrecisionFormat":
      return GLMethod.getShaderPrecisionFormat;
    case 68:
    case "getShaderSource":
      return GLMethod.getShaderSource;
    case 69:
    case "getSupportedExtensions":
      return GLMethod.getSupportedExtensions;
    case 70:
    case "getTexParameter":
      return GLMethod.getTexParameter;
    case 71:
    case "getUniform":
      return GLMethod.getUniform;
    case 72:
    case "getUniformLocation":
      return GLMethod.getUniformLocation;
    case 73:
    case "getVertexAttrib":
      return GLMethod.getVertexAttrib;
    case 74:
    case "getVertexAttribOffset":
      return GLMethod.getVertexAttribOffset;
    case 75:
    case "hint":
      return GLMethod.hint;
    case 76:
    case "isBuffer":
      return GLMethod.isBuffer;
    case 77:
    case "isContextLost":
      return GLMethod.isContextLost;
    case 78:
    case "isEnabled":
      return GLMethod.isEnabled;
    case 79:
    case "isFramebuffer":
      return GLMethod.isFramebuffer;
    case 80:
    case "isProgram":
      return GLMethod.isProgram;
    case 81:
    case "isRenderbuffer":
      return GLMethod.isRenderbuffer;
    case 82:
    case "isShader":
      return GLMethod.isShader;
    case 83:
    case "isTexture":
      return GLMethod.isTexture;
    case 84:
    case "lineWidth":
      return GLMethod.lineWidth;
    case 85:
    case "linkProgram":
      return GLMethod.linkProgram;
    case 86:
    case "polygonOffset":
      return GLMethod.polygonOffset;
    case 87:
    case "renderbufferStorage":
      return GLMethod.renderbufferStorage;
    case 88:
    case "sampleCoverage":
      return GLMethod.sampleCoverage;
    case 89:
    case "scissor":
      return GLMethod.scissor;
    case 90:
    case "shaderSource":
      return GLMethod.shaderSource;
    case 91:
    case "stencilFunc":
      return GLMethod.stencilFunc;
    case 92:
    case "stencilFuncSeparate":
      return GLMethod.stencilFuncSeparate;
    case 93:
    case "stencilMask":
      return GLMethod.stencilMask;
    case 94:
    case "stencilMaskSeparate":
      return GLMethod.stencilMaskSeparate;
    case 95:
    case "stencilOp":
      return GLMethod.stencilOp;
    case 96:
    case "stencilOpSeparate":
      return GLMethod.stencilOpSeparate;
    case 97:
    case "texParameterf":
      return GLMethod.texParameterf;
    case 98:
    case "texParameteri":
      return GLMethod.texParameteri;
    case 99:
    case "uniform1f":
      return GLMethod.uniform1f;
    case 100:
    case "uniform1i":
      return GLMethod.uniform1i;
    case 101:
    case "uniform2f":
      return GLMethod.uniform2f;
    case 102:
    case "uniform2i":
      return GLMethod.uniform2i;
    case 103:
    case "uniform3f":
      return GLMethod.uniform3f;
    case 104:
    case "uniform3i":
      return GLMethod.uniform3i;
    case 105:
    case "uniform4f":
      return GLMethod.uniform4f;
    case 106:
    case "uniform4i":
      return GLMethod.uniform4i;
    case 107:
    case "useProgram":
      return GLMethod.useProgram;
    case 108:
    case "validateProgram":
      return GLMethod.validateProgram;
    case 109:
    case "vertexAttrib1f":
      return GLMethod.vertexAttrib1f;
    case 110:
    case "vertexAttrib2f":
      return GLMethod.vertexAttrib2f;
    case 111:
    case "vertexAttrib3f":
      return GLMethod.vertexAttrib3f;
    case 112:
    case "vertexAttrib4f":
      return GLMethod.vertexAttrib4f;
    case 113:
    case "vertexAttribPointer":
      return GLMethod.vertexAttribPointer;
    case 114:
    case "viewport":
      return GLMethod.viewport;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GLMethod.UNRECOGNIZED;
  }
}
function gLMethodToJSON(object) {
  switch (object) {
    case GLMethod.activeTexture:
      return 0;
    case GLMethod.attachShader:
      return 1;
    case GLMethod.bindAttribLocation:
      return 2;
    case GLMethod.bindBuffer:
      return 3;
    case GLMethod.bindFramebuffer:
      return 4;
    case GLMethod.bindRenderbuffer:
      return 5;
    case GLMethod.bindTexture:
      return 6;
    case GLMethod.blendColor:
      return 7;
    case GLMethod.blendEquation:
      return 8;
    case GLMethod.blendEquationSeparate:
      return 9;
    case GLMethod.blendFunc:
      return 10;
    case GLMethod.blendFuncSeparate:
      return 11;
    case GLMethod.bufferData:
      return 12;
    case GLMethod.bufferSubData:
      return 13;
    case GLMethod.checkFramebufferStatus:
      return 14;
    case GLMethod.clear:
      return 15;
    case GLMethod.clearColor:
      return 16;
    case GLMethod.clearDepth:
      return 17;
    case GLMethod.clearStencil:
      return 18;
    case GLMethod.colorMask:
      return 19;
    case GLMethod.compileShader:
      return 20;
    case GLMethod.copyTexImage2D:
      return 21;
    case GLMethod.copyTexSubImage2D:
      return 22;
    case GLMethod.createBuffer:
      return 23;
    case GLMethod.createFramebuffer:
      return 24;
    case GLMethod.createProgram:
      return 25;
    case GLMethod.createRenderbuffer:
      return 26;
    case GLMethod.createShader:
      return 27;
    case GLMethod.createTexture:
      return 28;
    case GLMethod.cullFace:
      return 29;
    case GLMethod.deleteBuffer:
      return 30;
    case GLMethod.deleteFramebuffer:
      return 31;
    case GLMethod.deleteProgram:
      return 32;
    case GLMethod.deleteRenderbuffer:
      return 33;
    case GLMethod.deleteShader:
      return 34;
    case GLMethod.deleteTexture:
      return 35;
    case GLMethod.depthFunc:
      return 36;
    case GLMethod.depthMask:
      return 37;
    case GLMethod.depthRange:
      return 38;
    case GLMethod.detachShader:
      return 39;
    case GLMethod.disable:
      return 40;
    case GLMethod.disableVertexAttribArray:
      return 41;
    case GLMethod.drawArrays:
      return 42;
    case GLMethod.drawElements:
      return 43;
    case GLMethod.enable:
      return 44;
    case GLMethod.enableVertexAttribArray:
      return 45;
    case GLMethod.finish:
      return 46;
    case GLMethod.flush:
      return 47;
    case GLMethod.framebufferRenderbuffer:
      return 48;
    case GLMethod.framebufferTexture2D:
      return 49;
    case GLMethod.frontFace:
      return 50;
    case GLMethod.generateMipmap:
      return 51;
    case GLMethod.getActiveAttrib:
      return 52;
    case GLMethod.getActiveUniform:
      return 53;
    case GLMethod.getAttachedShaders:
      return 54;
    case GLMethod.getAttribLocation:
      return 55;
    case GLMethod.getBufferParameter:
      return 56;
    case GLMethod.getContextAttributes:
      return 57;
    case GLMethod.getError:
      return 58;
    case GLMethod.getExtension:
      return 59;
    case GLMethod.getFramebufferAttachmentParameter:
      return 60;
    case GLMethod.getParameter:
      return 61;
    case GLMethod.getProgramInfoLog:
      return 62;
    case GLMethod.getProgramParameter:
      return 63;
    case GLMethod.getRenderbufferParameter:
      return 64;
    case GLMethod.getShaderInfoLog:
      return 65;
    case GLMethod.getShaderParameter:
      return 66;
    case GLMethod.getShaderPrecisionFormat:
      return 67;
    case GLMethod.getShaderSource:
      return 68;
    case GLMethod.getSupportedExtensions:
      return 69;
    case GLMethod.getTexParameter:
      return 70;
    case GLMethod.getUniform:
      return 71;
    case GLMethod.getUniformLocation:
      return 72;
    case GLMethod.getVertexAttrib:
      return 73;
    case GLMethod.getVertexAttribOffset:
      return 74;
    case GLMethod.hint:
      return 75;
    case GLMethod.isBuffer:
      return 76;
    case GLMethod.isContextLost:
      return 77;
    case GLMethod.isEnabled:
      return 78;
    case GLMethod.isFramebuffer:
      return 79;
    case GLMethod.isProgram:
      return 80;
    case GLMethod.isRenderbuffer:
      return 81;
    case GLMethod.isShader:
      return 82;
    case GLMethod.isTexture:
      return 83;
    case GLMethod.lineWidth:
      return 84;
    case GLMethod.linkProgram:
      return 85;
    case GLMethod.polygonOffset:
      return 86;
    case GLMethod.renderbufferStorage:
      return 87;
    case GLMethod.sampleCoverage:
      return 88;
    case GLMethod.scissor:
      return 89;
    case GLMethod.shaderSource:
      return 90;
    case GLMethod.stencilFunc:
      return 91;
    case GLMethod.stencilFuncSeparate:
      return 92;
    case GLMethod.stencilMask:
      return 93;
    case GLMethod.stencilMaskSeparate:
      return 94;
    case GLMethod.stencilOp:
      return 95;
    case GLMethod.stencilOpSeparate:
      return 96;
    case GLMethod.texParameterf:
      return 97;
    case GLMethod.texParameteri:
      return 98;
    case GLMethod.uniform1f:
      return 99;
    case GLMethod.uniform1i:
      return 100;
    case GLMethod.uniform2f:
      return 101;
    case GLMethod.uniform2i:
      return 102;
    case GLMethod.uniform3f:
      return 103;
    case GLMethod.uniform3i:
      return 104;
    case GLMethod.uniform4f:
      return 105;
    case GLMethod.uniform4i:
      return 106;
    case GLMethod.useProgram:
      return 107;
    case GLMethod.validateProgram:
      return 108;
    case GLMethod.vertexAttrib1f:
      return 109;
    case GLMethod.vertexAttrib2f:
      return 110;
    case GLMethod.vertexAttrib3f:
      return 111;
    case GLMethod.vertexAttrib4f:
      return 112;
    case GLMethod.vertexAttribPointer:
      return 113;
    case GLMethod.viewport:
      return 114;
    case GLMethod.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/plugin/gl/methodtype.js
var GLMethodType;
(function(GLMethodType2) {
  GLMethodType2[GLMethodType2["ASYNC"] = 0] = "ASYNC";
  GLMethodType2[GLMethodType2["CONSTRUCTOR"] = 1] = "CONSTRUCTOR";
  GLMethodType2[GLMethodType2["DESTRUCTOR"] = 2] = "DESTRUCTOR";
  GLMethodType2[GLMethodType2["SYNC"] = 3] = "SYNC";
  GLMethodType2[GLMethodType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(GLMethodType || (GLMethodType = {}));
function gLMethodTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ASYNC":
      return GLMethodType.ASYNC;
    case 1:
    case "CONSTRUCTOR":
      return GLMethodType.CONSTRUCTOR;
    case 2:
    case "DESTRUCTOR":
      return GLMethodType.DESTRUCTOR;
    case 3:
    case "SYNC":
      return GLMethodType.SYNC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GLMethodType.UNRECOGNIZED;
  }
}
function gLMethodTypeToJSON(object) {
  switch (object) {
    case GLMethodType.ASYNC:
      return 0;
    case GLMethodType.CONSTRUCTOR:
      return 1;
    case GLMethodType.DESTRUCTOR:
      return 2;
    case GLMethodType.SYNC:
      return 3;
    case GLMethodType.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/plugin/gl/glrenderer.js
function createBaseCommandArgument() {
  return { null: void 0, scalar: void 0, blob: void 0, referenceId: void 0 };
}
var CommandArgument = {
  $type: "devvit.plugin.gl.CommandArgument",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.null !== void 0) {
      writer.uint32(8).bool(message.null);
    }
    if (message.scalar !== void 0) {
      Value.encode(Value.wrap(message.scalar), writer.uint32(18).fork()).ldelim();
    }
    if (message.blob !== void 0) {
      writer.uint32(26).bytes(message.blob);
    }
    if (message.referenceId !== void 0) {
      writer.uint32(32).uint64(message.referenceId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : new import_minimal85.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommandArgument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.null = reader.bool();
          break;
        case 2:
          message.scalar = Value.unwrap(Value.decode(reader, reader.uint32()));
          break;
        case 3:
          message.blob = reader.bytes();
          break;
        case 4:
          message.referenceId = longToNumber6(reader.uint64());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      null: isSet77(object.null) ? Boolean(object.null) : void 0,
      scalar: isSet77(object?.scalar) ? object.scalar : void 0,
      blob: isSet77(object.blob) ? bytesFromBase643(object.blob) : void 0,
      referenceId: isSet77(object.referenceId) ? Number(object.referenceId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.null !== void 0 && (obj.null = message.null);
    message.scalar !== void 0 && (obj.scalar = message.scalar);
    message.blob !== void 0 && (obj.blob = message.blob !== void 0 ? base64FromBytes3(message.blob) : void 0);
    message.referenceId !== void 0 && (obj.referenceId = Math.round(message.referenceId));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommandArgument();
    message.null = object.null ?? void 0;
    message.scalar = object.scalar ?? void 0;
    message.blob = object.blob ?? void 0;
    message.referenceId = object.referenceId ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.gl.CommandArgument", CommandArgument);
function createBaseGLCommand() {
  return { method: 0, type: 0, args: [], referenceId: 0 };
}
var GLCommand = {
  $type: "devvit.plugin.gl.GLCommand",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    if (message.method !== 0) {
      writer.uint32(8).int32(message.method);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    for (const v of message.args) {
      CommandArgument.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.referenceId !== 0) {
      writer.uint32(32).uint64(message.referenceId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : new import_minimal85.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGLCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.method = reader.int32();
          break;
        case 2:
          message.type = reader.int32();
          break;
        case 3:
          message.args.push(CommandArgument.decode(reader, reader.uint32()));
          break;
        case 4:
          message.referenceId = longToNumber6(reader.uint64());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      method: isSet77(object.method) ? gLMethodFromJSON(object.method) : 0,
      type: isSet77(object.type) ? gLMethodTypeFromJSON(object.type) : 0,
      args: Array.isArray(object?.args) ? object.args.map((e) => CommandArgument.fromJSON(e)) : [],
      referenceId: isSet77(object.referenceId) ? Number(object.referenceId) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.method !== void 0 && (obj.method = gLMethodToJSON(message.method));
    message.type !== void 0 && (obj.type = gLMethodTypeToJSON(message.type));
    if (message.args) {
      obj.args = message.args.map((e) => e ? CommandArgument.toJSON(e) : void 0);
    } else {
      obj.args = [];
    }
    message.referenceId !== void 0 && (obj.referenceId = Math.round(message.referenceId));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGLCommand();
    message.method = object.method ?? 0;
    message.type = object.type ?? 0;
    message.args = object.args?.map((e) => CommandArgument.fromPartial(e)) || [];
    message.referenceId = object.referenceId ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.gl.GLCommand", GLCommand);
function createBaseExecuteMessage() {
  return { commands: [] };
}
var ExecuteMessage = {
  $type: "devvit.plugin.gl.ExecuteMessage",
  encode(message, writer = import_minimal85.default.Writer.create()) {
    for (const v of message.commands) {
      GLCommand.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal85.default.Reader ? input : new import_minimal85.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExecuteMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.commands.push(GLCommand.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { commands: Array.isArray(object?.commands) ? object.commands.map((e) => GLCommand.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.commands) {
      obj.commands = message.commands.map((e) => e ? GLCommand.toJSON(e) : void 0);
    } else {
      obj.commands = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseExecuteMessage();
    message.commands = object.commands?.map((e) => GLCommand.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.gl.ExecuteMessage", ExecuteMessage);
var globalThis8 = (() => {
  if (typeof globalThis8 !== "undefined") {
    return globalThis8;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase643(b64) {
  if (globalThis8.Buffer) {
    return Uint8Array.from(globalThis8.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis8.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes3(arr) {
  if (globalThis8.Buffer) {
    return globalThis8.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return globalThis8.btoa(bin.join(""));
  }
}
function longToNumber6(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis8.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal85.default.util.Long !== import_long6.default) {
  import_minimal85.default.util.Long = import_long6.default;
  import_minimal85.default.configure();
}
function isSet77(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/http/http.js
var import_minimal86 = __toESM(require_minimal2(), 1);
function createBaseFetchRequest() {
  return { url: "", data: void 0 };
}
var FetchRequest = {
  $type: "devvit.plugin.http.FetchRequest",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.data !== void 0) {
      RequestData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : new import_minimal86.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFetchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.url = reader.string();
          break;
        case 2:
          message.data = RequestData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet78(object.url) ? String(object.url) : "",
      data: isSet78(object.data) ? RequestData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    message.data !== void 0 && (obj.data = message.data ? RequestData.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFetchRequest();
    message.url = object.url ?? "";
    message.data = object.data !== void 0 && object.data !== null ? RequestData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.http.FetchRequest", FetchRequest);
function createBaseRequestData() {
  return { method: "", headers: {}, body: new Uint8Array() };
}
var RequestData = {
  $type: "devvit.plugin.http.RequestData",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      RequestData_HeadersEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.body.length !== 0) {
      writer.uint32(26).bytes(message.body);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : new import_minimal86.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.method = reader.string();
          break;
        case 2:
          const entry2 = RequestData_HeadersEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.headers[entry2.key] = entry2.value;
          }
          break;
        case 3:
          message.body = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      method: isSet78(object.method) ? String(object.method) : "",
      headers: isObject14(object.headers) ? Object.entries(object.headers).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      body: isSet78(object.body) ? bytesFromBase644(object.body) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.method !== void 0 && (obj.method = message.method);
    obj.headers = {};
    if (message.headers) {
      Object.entries(message.headers).forEach(([k, v]) => {
        obj.headers[k] = v;
      });
    }
    message.body !== void 0 && (obj.body = base64FromBytes4(message.body !== void 0 ? message.body : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRequestData();
    message.method = object.method ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.body = object.body ?? new Uint8Array();
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.http.RequestData", RequestData);
function createBaseRequestData_HeadersEntry() {
  return { key: "", value: "" };
}
var RequestData_HeadersEntry = {
  $type: "devvit.plugin.http.RequestData.HeadersEntry",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : new import_minimal86.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequestData_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet78(object.key) ? String(object.key) : "", value: isSet78(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRequestData_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.http.RequestData.HeadersEntry", RequestData_HeadersEntry);
function createBaseFetchResponse() {
  return { url: "", body: new Uint8Array(), status: 0, headers: {} };
}
var FetchResponse = {
  $type: "devvit.plugin.http.FetchResponse",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.body.length !== 0) {
      writer.uint32(18).bytes(message.body);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      FetchResponse_HeadersEntry.encode({ key, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : new import_minimal86.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFetchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.url = reader.string();
          break;
        case 2:
          message.body = reader.bytes();
          break;
        case 3:
          message.status = reader.int32();
          break;
        case 4:
          const entry4 = FetchResponse_HeadersEntry.decode(reader, reader.uint32());
          if (entry4.value !== void 0) {
            message.headers[entry4.key] = entry4.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet78(object.url) ? String(object.url) : "",
      body: isSet78(object.body) ? bytesFromBase644(object.body) : new Uint8Array(),
      status: isSet78(object.status) ? Number(object.status) : 0,
      headers: isObject14(object.headers) ? Object.entries(object.headers).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    message.body !== void 0 && (obj.body = base64FromBytes4(message.body !== void 0 ? message.body : new Uint8Array()));
    message.status !== void 0 && (obj.status = Math.round(message.status));
    obj.headers = {};
    if (message.headers) {
      Object.entries(message.headers).forEach(([k, v]) => {
        obj.headers[k] = v;
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFetchResponse();
    message.url = object.url ?? "";
    message.body = object.body ?? new Uint8Array();
    message.status = object.status ?? 0;
    message.headers = Object.entries(object.headers ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.http.FetchResponse", FetchResponse);
function createBaseFetchResponse_HeadersEntry() {
  return { key: "", value: "" };
}
var FetchResponse_HeadersEntry = {
  $type: "devvit.plugin.http.FetchResponse.HeadersEntry",
  encode(message, writer = import_minimal86.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal86.default.Reader ? input : new import_minimal86.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFetchResponse_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet78(object.key) ? String(object.key) : "", value: isSet78(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFetchResponse_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.http.FetchResponse.HeadersEntry", FetchResponse_HeadersEntry);
var HTTPDefinition = {
  name: "HTTP",
  fullName: "devvit.plugin.http.HTTP",
  methods: {
    fetch: {
      name: "Fetch",
      requestType: FetchRequest,
      requestStream: false,
      responseType: FetchResponse,
      responseStream: false,
      options: {}
    }
  }
};
var globalThis9 = (() => {
  if (typeof globalThis9 !== "undefined") {
    return globalThis9;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase644(b64) {
  if (globalThis9.Buffer) {
    return Uint8Array.from(globalThis9.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis9.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes4(arr) {
  if (globalThis9.Buffer) {
    return globalThis9.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return globalThis9.btoa(bin.join(""));
  }
}
function isObject14(value) {
  return typeof value === "object" && value !== null;
}
function isSet78(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/inspector/inspector.js
var import_minimal87 = __toESM(require_minimal2(), 1);
var InspectorUpdateType;
(function(InspectorUpdateType2) {
  InspectorUpdateType2[InspectorUpdateType2["ADDED"] = 0] = "ADDED";
  InspectorUpdateType2[InspectorUpdateType2["REMOVED"] = 1] = "REMOVED";
  InspectorUpdateType2[InspectorUpdateType2["CHANGED"] = 2] = "CHANGED";
  InspectorUpdateType2[InspectorUpdateType2["SUBSCRIBED"] = 3] = "SUBSCRIBED";
  InspectorUpdateType2[InspectorUpdateType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(InspectorUpdateType || (InspectorUpdateType = {}));
function inspectorUpdateTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ADDED":
      return InspectorUpdateType.ADDED;
    case 1:
    case "REMOVED":
      return InspectorUpdateType.REMOVED;
    case 2:
    case "CHANGED":
      return InspectorUpdateType.CHANGED;
    case 3:
    case "SUBSCRIBED":
      return InspectorUpdateType.SUBSCRIBED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InspectorUpdateType.UNRECOGNIZED;
  }
}
function inspectorUpdateTypeToJSON(object) {
  switch (object) {
    case InspectorUpdateType.ADDED:
      return 0;
    case InspectorUpdateType.REMOVED:
      return 1;
    case InspectorUpdateType.CHANGED:
      return 2;
    case InspectorUpdateType.SUBSCRIBED:
      return 3;
    case InspectorUpdateType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseInspectorQuery() {
  return { type: "", hostname: "" };
}
var InspectorQuery = {
  $type: "devvit.plugin.inspector.InspectorQuery",
  encode(message, writer = import_minimal87.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal87.default.Reader ? input : new import_minimal87.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInspectorQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.string();
          break;
        case 2:
          message.hostname = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet79(object.type) ? String(object.type) : "",
      hostname: isSet79(object.hostname) ? String(object.hostname) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    message.hostname !== void 0 && (obj.hostname = message.hostname);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInspectorQuery();
    message.type = object.type ?? "";
    message.hostname = object.hostname ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.inspector.InspectorQuery", InspectorQuery);
function createBaseInspectorDescription() {
  return { provides: [], hostname: "" };
}
var InspectorDescription = {
  $type: "devvit.plugin.inspector.InspectorDescription",
  encode(message, writer = import_minimal87.default.Writer.create()) {
    for (const v of message.provides) {
      SerializableServiceDefinition.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal87.default.Reader ? input : new import_minimal87.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInspectorDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.provides.push(SerializableServiceDefinition.decode(reader, reader.uint32()));
          break;
        case 2:
          message.hostname = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      provides: Array.isArray(object?.provides) ? object.provides.map((e) => SerializableServiceDefinition.fromJSON(e)) : [],
      hostname: isSet79(object.hostname) ? String(object.hostname) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.provides) {
      obj.provides = message.provides.map((e) => e ? SerializableServiceDefinition.toJSON(e) : void 0);
    } else {
      obj.provides = [];
    }
    message.hostname !== void 0 && (obj.hostname = message.hostname);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInspectorDescription();
    message.provides = object.provides?.map((e) => SerializableServiceDefinition.fromPartial(e)) || [];
    message.hostname = object.hostname ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.inspector.InspectorDescription", InspectorDescription);
function createBaseInspectorDescriptions() {
  return { descriptions: [] };
}
var InspectorDescriptions = {
  $type: "devvit.plugin.inspector.InspectorDescriptions",
  encode(message, writer = import_minimal87.default.Writer.create()) {
    for (const v of message.descriptions) {
      InspectorDescription.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal87.default.Reader ? input : new import_minimal87.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInspectorDescriptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.descriptions.push(InspectorDescription.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      descriptions: Array.isArray(object?.descriptions) ? object.descriptions.map((e) => InspectorDescription.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.descriptions) {
      obj.descriptions = message.descriptions.map((e) => e ? InspectorDescription.toJSON(e) : void 0);
    } else {
      obj.descriptions = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInspectorDescriptions();
    message.descriptions = object.descriptions?.map((e) => InspectorDescription.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.inspector.InspectorDescriptions", InspectorDescriptions);
function createBaseInspectorUpdate() {
  return { description: void 0, type: 0 };
}
var InspectorUpdate = {
  $type: "devvit.plugin.inspector.InspectorUpdate",
  encode(message, writer = import_minimal87.default.Writer.create()) {
    if (message.description !== void 0) {
      InspectorDescription.encode(message.description, writer.uint32(10).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal87.default.Reader ? input : new import_minimal87.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInspectorUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.description = InspectorDescription.decode(reader, reader.uint32());
          break;
        case 2:
          message.type = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      description: isSet79(object.description) ? InspectorDescription.fromJSON(object.description) : void 0,
      type: isSet79(object.type) ? inspectorUpdateTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.description !== void 0 && (obj.description = message.description ? InspectorDescription.toJSON(message.description) : void 0);
    message.type !== void 0 && (obj.type = inspectorUpdateTypeToJSON(message.type));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInspectorUpdate();
    message.description = object.description !== void 0 && object.description !== null ? InspectorDescription.fromPartial(object.description) : void 0;
    message.type = object.type ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.inspector.InspectorUpdate", InspectorUpdate);
function isSet79(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/kvstore/kvstore.js
var import_minimal88 = __toESM(require_minimal2(), 1);
function createBaseMessageSet() {
  return { messages: {} };
}
var MessageSet = {
  $type: "devvit.plugin.kvstore.MessageSet",
  encode(message, writer = import_minimal88.default.Writer.create()) {
    Object.entries(message.messages).forEach(([key, value]) => {
      MessageSet_MessagesEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal88.default.Reader ? input : new import_minimal88.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = MessageSet_MessagesEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.messages[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      messages: isObject15(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    obj.messages = {};
    if (message.messages) {
      Object.entries(message.messages).forEach(([k, v]) => {
        obj.messages[k] = v;
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMessageSet();
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.kvstore.MessageSet", MessageSet);
function createBaseMessageSet_MessagesEntry() {
  return { key: "", value: "" };
}
var MessageSet_MessagesEntry = {
  $type: "devvit.plugin.kvstore.MessageSet.MessagesEntry",
  encode(message, writer = import_minimal88.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal88.default.Reader ? input : new import_minimal88.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageSet_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet80(object.key) ? String(object.key) : "", value: isSet80(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMessageSet_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.kvstore.MessageSet.MessagesEntry", MessageSet_MessagesEntry);
function createBaseKeySet() {
  return { keys: [] };
}
var KeySet = {
  $type: "devvit.plugin.kvstore.KeySet",
  encode(message, writer = import_minimal88.default.Writer.create()) {
    for (const v of message.keys) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal88.default.Reader ? input : new import_minimal88.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseKeySet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.keys.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { keys: Array.isArray(object?.keys) ? object.keys.map((e) => String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.keys) {
      obj.keys = message.keys.map((e) => e);
    } else {
      obj.keys = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseKeySet();
    message.keys = object.keys?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.kvstore.KeySet", KeySet);
function createBaseListFilter() {
  return { filter: "" };
}
var ListFilter = {
  $type: "devvit.plugin.kvstore.ListFilter",
  encode(message, writer = import_minimal88.default.Writer.create()) {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal88.default.Reader ? input : new import_minimal88.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.filter = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { filter: isSet80(object.filter) ? String(object.filter) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.filter !== void 0 && (obj.filter = message.filter);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseListFilter();
    message.filter = object.filter ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.kvstore.ListFilter", ListFilter);
function isObject15(value) {
  return typeof value === "object" && value !== null;
}
function isSet80(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/linker/linker.js
var import_minimal90 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/plugin/linker/resolver.js
var import_minimal89 = __toESM(require_minimal2(), 1);
function createBaseResolution() {
  return { bundle: void 0, error: void 0, plugin: void 0 };
}
var Resolution = {
  $type: "devvit.plugin.linker.Resolution",
  encode(message, writer = import_minimal89.default.Writer.create()) {
    if (message.bundle !== void 0) {
      Bundle.encode(message.bundle, writer.uint32(10).fork()).ldelim();
    }
    if (message.error !== void 0) {
      ResolutionError.encode(message.error, writer.uint32(18).fork()).ldelim();
    }
    if (message.plugin !== void 0) {
      InspectorDescription.encode(message.plugin, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal89.default.Reader ? input : new import_minimal89.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResolution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bundle = Bundle.decode(reader, reader.uint32());
          break;
        case 2:
          message.error = ResolutionError.decode(reader, reader.uint32());
          break;
        case 3:
          message.plugin = InspectorDescription.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      bundle: isSet81(object.bundle) ? Bundle.fromJSON(object.bundle) : void 0,
      error: isSet81(object.error) ? ResolutionError.fromJSON(object.error) : void 0,
      plugin: isSet81(object.plugin) ? InspectorDescription.fromJSON(object.plugin) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.bundle !== void 0 && (obj.bundle = message.bundle ? Bundle.toJSON(message.bundle) : void 0);
    message.error !== void 0 && (obj.error = message.error ? ResolutionError.toJSON(message.error) : void 0);
    message.plugin !== void 0 && (obj.plugin = message.plugin ? InspectorDescription.toJSON(message.plugin) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseResolution();
    message.bundle = object.bundle !== void 0 && object.bundle !== null ? Bundle.fromPartial(object.bundle) : void 0;
    message.error = object.error !== void 0 && object.error !== null ? ResolutionError.fromPartial(object.error) : void 0;
    message.plugin = object.plugin !== void 0 && object.plugin !== null ? InspectorDescription.fromPartial(object.plugin) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.linker.Resolution", Resolution);
function createBaseResolutionError() {
  return { query: void 0, text: "" };
}
var ResolutionError = {
  $type: "devvit.plugin.linker.ResolutionError",
  encode(message, writer = import_minimal89.default.Writer.create()) {
    if (message.query !== void 0) {
      PackageQuery.encode(message.query, writer.uint32(10).fork()).ldelim();
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal89.default.Reader ? input : new import_minimal89.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResolutionError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.query = PackageQuery.decode(reader, reader.uint32());
          break;
        case 2:
          message.text = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      query: isSet81(object.query) ? PackageQuery.fromJSON(object.query) : void 0,
      text: isSet81(object.text) ? String(object.text) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.query !== void 0 && (obj.query = message.query ? PackageQuery.toJSON(message.query) : void 0);
    message.text !== void 0 && (obj.text = message.text);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseResolutionError();
    message.query = object.query !== void 0 && object.query !== null ? PackageQuery.fromPartial(object.query) : void 0;
    message.text = object.text ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.linker.ResolutionError", ResolutionError);
function isSet81(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/linker/linker.js
function createBaseLinkerResponse() {
  return { bundle: void 0, errors: [] };
}
var LinkerResponse = {
  $type: "devvit.plugin.linker.LinkerResponse",
  encode(message, writer = import_minimal90.default.Writer.create()) {
    if (message.bundle !== void 0) {
      LinkedBundle.encode(message.bundle, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.errors) {
      ResolutionError.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal90.default.Reader ? input : new import_minimal90.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bundle = LinkedBundle.decode(reader, reader.uint32());
          break;
        case 2:
          message.errors.push(ResolutionError.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      bundle: isSet82(object.bundle) ? LinkedBundle.fromJSON(object.bundle) : void 0,
      errors: Array.isArray(object?.errors) ? object.errors.map((e) => ResolutionError.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.bundle !== void 0 && (obj.bundle = message.bundle ? LinkedBundle.toJSON(message.bundle) : void 0);
    if (message.errors) {
      obj.errors = message.errors.map((e) => e ? ResolutionError.toJSON(e) : void 0);
    } else {
      obj.errors = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseLinkerResponse();
    message.bundle = object.bundle !== void 0 && object.bundle !== null ? LinkedBundle.fromPartial(object.bundle) : void 0;
    message.errors = object.errors?.map((e) => ResolutionError.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.linker.LinkerResponse", LinkerResponse);
function isSet82(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/modlog/modlog.js
var import_minimal91 = __toESM(require_minimal2(), 1);
function createBaseModlogRequest() {
  return { action: "", details: void 0, description: void 0, note: void 0, target: void 0 };
}
var ModlogRequest = {
  $type: "devvit.plugin.modlog.ModlogRequest",
  encode(message, writer = import_minimal91.default.Writer.create()) {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.details !== void 0) {
      writer.uint32(18).string(message.details);
    }
    if (message.description !== void 0) {
      writer.uint32(26).string(message.description);
    }
    if (message.note !== void 0) {
      writer.uint32(34).string(message.note);
    }
    if (message.target !== void 0) {
      writer.uint32(42).string(message.target);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal91.default.Reader ? input : new import_minimal91.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModlogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.action = reader.string();
          break;
        case 2:
          message.details = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          message.note = reader.string();
          break;
        case 5:
          message.target = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      action: isSet83(object.action) ? String(object.action) : "",
      details: isSet83(object.details) ? String(object.details) : void 0,
      description: isSet83(object.description) ? String(object.description) : void 0,
      note: isSet83(object.note) ? String(object.note) : void 0,
      target: isSet83(object.target) ? String(object.target) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.action !== void 0 && (obj.action = message.action);
    message.details !== void 0 && (obj.details = message.details);
    message.description !== void 0 && (obj.description = message.description);
    message.note !== void 0 && (obj.note = message.note);
    message.target !== void 0 && (obj.target = message.target);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseModlogRequest();
    message.action = object.action ?? "";
    message.details = object.details ?? void 0;
    message.description = object.description ?? void 0;
    message.note = object.note ?? void 0;
    message.target = object.target ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.modlog.ModlogRequest", ModlogRequest);
function createBaseModlogResponse() {
  return { success: false };
}
var ModlogResponse = {
  $type: "devvit.plugin.modlog.ModlogResponse",
  encode(message, writer = import_minimal91.default.Writer.create()) {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal91.default.Reader ? input : new import_minimal91.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModlogResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.success = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { success: isSet83(object.success) ? Boolean(object.success) : false };
  },
  toJSON(message) {
    const obj = {};
    message.success !== void 0 && (obj.success = message.success);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseModlogResponse();
    message.success = object.success ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.modlog.ModlogResponse", ModlogResponse);
function isSet83(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/flair/flair_msg.js
var import_long7 = __toESM(require_long(), 1);
var import_minimal92 = __toESM(require_minimal2(), 1);
function createBaseClearFlairTemplatesRequest() {
  return { subreddit: "", flairType: "" };
}
var ClearFlairTemplatesRequest = {
  $type: "devvit.plugin.redditapi.flair.ClearFlairTemplatesRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.flairType !== "") {
      writer.uint32(18).string(message.flairType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClearFlairTemplatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.flairType = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "",
      flairType: isSet84(object.flairType) ? String(object.flairType) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.flairType !== void 0 && (obj.flairType = message.flairType);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseClearFlairTemplatesRequest();
    message.subreddit = object.subreddit ?? "";
    message.flairType = object.flairType ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.ClearFlairTemplatesRequest", ClearFlairTemplatesRequest);
function createBaseDeleteFlairRequest() {
  return { subreddit: "", name: "" };
}
var DeleteFlairRequest = {
  $type: "devvit.plugin.redditapi.flair.DeleteFlairRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteFlairRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "",
      name: isSet84(object.name) ? String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDeleteFlairRequest();
    message.subreddit = object.subreddit ?? "";
    message.name = object.name ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.DeleteFlairRequest", DeleteFlairRequest);
function createBaseDeleteFlairTemplateRequest() {
  return { subreddit: "", flairTemplateId: "" };
}
var DeleteFlairTemplateRequest = {
  $type: "devvit.plugin.redditapi.flair.DeleteFlairTemplateRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.flairTemplateId !== "") {
      writer.uint32(18).string(message.flairTemplateId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteFlairTemplateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.flairTemplateId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "",
      flairTemplateId: isSet84(object.flairTemplateId) ? String(object.flairTemplateId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.flairTemplateId !== void 0 && (obj.flairTemplateId = message.flairTemplateId);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDeleteFlairTemplateRequest();
    message.subreddit = object.subreddit ?? "";
    message.flairTemplateId = object.flairTemplateId ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.DeleteFlairTemplateRequest", DeleteFlairTemplateRequest);
function createBaseFlairRequest() {
  return { subreddit: "", cssClass: void 0, link: void 0, name: void 0, text: void 0 };
}
var FlairRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.cssClass !== void 0) {
      StringValue.encode({ value: message.cssClass }, writer.uint32(18).fork()).ldelim();
    }
    if (message.link !== void 0) {
      StringValue.encode({ value: message.link }, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
    }
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.cssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.link = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.text = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "",
      cssClass: isSet84(object.cssClass) ? String(object.cssClass) : void 0,
      link: isSet84(object.link) ? String(object.link) : void 0,
      name: isSet84(object.name) ? String(object.name) : void 0,
      text: isSet84(object.text) ? String(object.text) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.cssClass !== void 0 && (obj.cssClass = message.cssClass);
    message.link !== void 0 && (obj.link = message.link);
    message.name !== void 0 && (obj.name = message.name);
    message.text !== void 0 && (obj.text = message.text);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairRequest();
    message.subreddit = object.subreddit ?? "";
    message.cssClass = object.cssClass ?? void 0;
    message.link = object.link ?? void 0;
    message.name = object.name ?? void 0;
    message.text = object.text ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairRequest", FlairRequest);
function createBaseFlairTemplateOrderRequest() {
  return { subreddit: "", flairType: "", order: [] };
}
var FlairTemplateOrderRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairTemplateOrderRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.flairType !== "") {
      writer.uint32(18).string(message.flairType);
    }
    for (const v of message.order) {
      writer.uint32(26).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairTemplateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.flairType = reader.string();
          break;
        case 3:
          message.order.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "",
      flairType: isSet84(object.flairType) ? String(object.flairType) : "",
      order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.flairType !== void 0 && (obj.flairType = message.flairType);
    if (message.order) {
      obj.order = message.order.map((e) => e);
    } else {
      obj.order = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairTemplateOrderRequest();
    message.subreddit = object.subreddit ?? "";
    message.flairType = object.flairType ?? "";
    message.order = object.order?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairTemplateOrderRequest", FlairTemplateOrderRequest);
function createBaseFlairConfigRequest() {
  return {
    subreddit: "",
    flairEnabled: false,
    flairPosition: "",
    flairSelfAssignEnabled: false,
    linkFlairPosition: "",
    linkFlairSelfAssignEnabled: false
  };
}
var FlairConfigRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairConfigRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.flairEnabled === true) {
      writer.uint32(16).bool(message.flairEnabled);
    }
    if (message.flairPosition !== "") {
      writer.uint32(26).string(message.flairPosition);
    }
    if (message.flairSelfAssignEnabled === true) {
      writer.uint32(32).bool(message.flairSelfAssignEnabled);
    }
    if (message.linkFlairPosition !== "") {
      writer.uint32(42).string(message.linkFlairPosition);
    }
    if (message.linkFlairSelfAssignEnabled === true) {
      writer.uint32(48).bool(message.linkFlairSelfAssignEnabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.flairEnabled = reader.bool();
          break;
        case 3:
          message.flairPosition = reader.string();
          break;
        case 4:
          message.flairSelfAssignEnabled = reader.bool();
          break;
        case 5:
          message.linkFlairPosition = reader.string();
          break;
        case 6:
          message.linkFlairSelfAssignEnabled = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "",
      flairEnabled: isSet84(object.flairEnabled) ? Boolean(object.flairEnabled) : false,
      flairPosition: isSet84(object.flairPosition) ? String(object.flairPosition) : "",
      flairSelfAssignEnabled: isSet84(object.flairSelfAssignEnabled) ? Boolean(object.flairSelfAssignEnabled) : false,
      linkFlairPosition: isSet84(object.linkFlairPosition) ? String(object.linkFlairPosition) : "",
      linkFlairSelfAssignEnabled: isSet84(object.linkFlairSelfAssignEnabled) ? Boolean(object.linkFlairSelfAssignEnabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.flairEnabled !== void 0 && (obj.flairEnabled = message.flairEnabled);
    message.flairPosition !== void 0 && (obj.flairPosition = message.flairPosition);
    message.flairSelfAssignEnabled !== void 0 && (obj.flairSelfAssignEnabled = message.flairSelfAssignEnabled);
    message.linkFlairPosition !== void 0 && (obj.linkFlairPosition = message.linkFlairPosition);
    message.linkFlairSelfAssignEnabled !== void 0 && (obj.linkFlairSelfAssignEnabled = message.linkFlairSelfAssignEnabled);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairConfigRequest();
    message.subreddit = object.subreddit ?? "";
    message.flairEnabled = object.flairEnabled ?? false;
    message.flairPosition = object.flairPosition ?? "";
    message.flairSelfAssignEnabled = object.flairSelfAssignEnabled ?? false;
    message.linkFlairPosition = object.linkFlairPosition ?? "";
    message.linkFlairSelfAssignEnabled = object.linkFlairSelfAssignEnabled ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairConfigRequest", FlairConfigRequest);
function createBaseFlairCsvRequest() {
  return { subreddit: "", flairCsv: "" };
}
var FlairCsvRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairCsvRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.flairCsv !== "") {
      writer.uint32(18).string(message.flairCsv);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairCsvRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.flairCsv = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "",
      flairCsv: isSet84(object.flairCsv) ? String(object.flairCsv) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.flairCsv !== void 0 && (obj.flairCsv = message.flairCsv);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairCsvRequest();
    message.subreddit = object.subreddit ?? "";
    message.flairCsv = object.flairCsv ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairCsvRequest", FlairCsvRequest);
function createBaseFlairListRequest() {
  return {
    subreddit: "",
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    name: void 0,
    show: void 0
  };
}
var FlairListRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairListRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(18).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(26).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(34).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(50).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "",
      after: isSet84(object.after) ? String(object.after) : void 0,
      before: isSet84(object.before) ? String(object.before) : void 0,
      count: isSet84(object.count) ? Number(object.count) : void 0,
      limit: isSet84(object.limit) ? Number(object.limit) : void 0,
      name: isSet84(object.name) ? String(object.name) : void 0,
      show: isSet84(object.show) ? String(object.show) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.count !== void 0 && (obj.count = message.count);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.name !== void 0 && (obj.name = message.name);
    message.show !== void 0 && (obj.show = message.show);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairListRequest();
    message.subreddit = object.subreddit ?? "";
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.name = object.name ?? void 0;
    message.show = object.show ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairListRequest", FlairListRequest);
function createBaseFlairSelectorRequest() {
  return { subreddit: "", isNewlink: false, link: void 0, name: "" };
}
var FlairSelectorRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairSelectorRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.isNewlink === true) {
      writer.uint32(16).bool(message.isNewlink);
    }
    if (message.link !== void 0) {
      StringValue.encode({ value: message.link }, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairSelectorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.isNewlink = reader.bool();
          break;
        case 3:
          message.link = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "",
      isNewlink: isSet84(object.isNewlink) ? Boolean(object.isNewlink) : false,
      link: isSet84(object.link) ? String(object.link) : void 0,
      name: isSet84(object.name) ? String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.isNewlink !== void 0 && (obj.isNewlink = message.isNewlink);
    message.link !== void 0 && (obj.link = message.link);
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairSelectorRequest();
    message.subreddit = object.subreddit ?? "";
    message.isNewlink = object.isNewlink ?? false;
    message.link = object.link ?? void 0;
    message.name = object.name ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairSelectorRequest", FlairSelectorRequest);
function createBaseFlairTemplateRequest() {
  return {
    subreddit: "",
    allowableContent: "",
    backgroundColor: "",
    cssClass: "",
    flairTemplateId: "",
    flairType: "",
    maxEmojis: 0,
    modOnly: false,
    overrideCss: false,
    text: "",
    textColor: "",
    textEditable: false
  };
}
var FlairTemplateRequest = {
  $type: "devvit.plugin.redditapi.flair.FlairTemplateRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.allowableContent !== "") {
      writer.uint32(18).string(message.allowableContent);
    }
    if (message.backgroundColor !== "") {
      writer.uint32(26).string(message.backgroundColor);
    }
    if (message.cssClass !== "") {
      writer.uint32(34).string(message.cssClass);
    }
    if (message.flairTemplateId !== "") {
      writer.uint32(42).string(message.flairTemplateId);
    }
    if (message.flairType !== "") {
      writer.uint32(50).string(message.flairType);
    }
    if (message.maxEmojis !== 0) {
      writer.uint32(56).int64(message.maxEmojis);
    }
    if (message.modOnly === true) {
      writer.uint32(64).bool(message.modOnly);
    }
    if (message.overrideCss === true) {
      writer.uint32(72).bool(message.overrideCss);
    }
    if (message.text !== "") {
      writer.uint32(82).string(message.text);
    }
    if (message.textColor !== "") {
      writer.uint32(90).string(message.textColor);
    }
    if (message.textEditable === true) {
      writer.uint32(96).bool(message.textEditable);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairTemplateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.allowableContent = reader.string();
          break;
        case 3:
          message.backgroundColor = reader.string();
          break;
        case 4:
          message.cssClass = reader.string();
          break;
        case 5:
          message.flairTemplateId = reader.string();
          break;
        case 6:
          message.flairType = reader.string();
          break;
        case 7:
          message.maxEmojis = longToNumber7(reader.int64());
          break;
        case 8:
          message.modOnly = reader.bool();
          break;
        case 9:
          message.overrideCss = reader.bool();
          break;
        case 10:
          message.text = reader.string();
          break;
        case 11:
          message.textColor = reader.string();
          break;
        case 12:
          message.textEditable = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "",
      allowableContent: isSet84(object.allowableContent) ? String(object.allowableContent) : "",
      backgroundColor: isSet84(object.backgroundColor) ? String(object.backgroundColor) : "",
      cssClass: isSet84(object.cssClass) ? String(object.cssClass) : "",
      flairTemplateId: isSet84(object.flairTemplateId) ? String(object.flairTemplateId) : "",
      flairType: isSet84(object.flairType) ? String(object.flairType) : "",
      maxEmojis: isSet84(object.maxEmojis) ? Number(object.maxEmojis) : 0,
      modOnly: isSet84(object.modOnly) ? Boolean(object.modOnly) : false,
      overrideCss: isSet84(object.overrideCss) ? Boolean(object.overrideCss) : false,
      text: isSet84(object.text) ? String(object.text) : "",
      textColor: isSet84(object.textColor) ? String(object.textColor) : "",
      textEditable: isSet84(object.textEditable) ? Boolean(object.textEditable) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.allowableContent !== void 0 && (obj.allowableContent = message.allowableContent);
    message.backgroundColor !== void 0 && (obj.backgroundColor = message.backgroundColor);
    message.cssClass !== void 0 && (obj.cssClass = message.cssClass);
    message.flairTemplateId !== void 0 && (obj.flairTemplateId = message.flairTemplateId);
    message.flairType !== void 0 && (obj.flairType = message.flairType);
    message.maxEmojis !== void 0 && (obj.maxEmojis = Math.round(message.maxEmojis));
    message.modOnly !== void 0 && (obj.modOnly = message.modOnly);
    message.overrideCss !== void 0 && (obj.overrideCss = message.overrideCss);
    message.text !== void 0 && (obj.text = message.text);
    message.textColor !== void 0 && (obj.textColor = message.textColor);
    message.textEditable !== void 0 && (obj.textEditable = message.textEditable);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairTemplateRequest();
    message.subreddit = object.subreddit ?? "";
    message.allowableContent = object.allowableContent ?? "";
    message.backgroundColor = object.backgroundColor ?? "";
    message.cssClass = object.cssClass ?? "";
    message.flairTemplateId = object.flairTemplateId ?? "";
    message.flairType = object.flairType ?? "";
    message.maxEmojis = object.maxEmojis ?? 0;
    message.modOnly = object.modOnly ?? false;
    message.overrideCss = object.overrideCss ?? false;
    message.text = object.text ?? "";
    message.textColor = object.textColor ?? "";
    message.textEditable = object.textEditable ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairTemplateRequest", FlairTemplateRequest);
function createBaseLinkFlairRequest() {
  return { subreddit: "" };
}
var LinkFlairRequest = {
  $type: "devvit.plugin.redditapi.flair.LinkFlairRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkFlairRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseLinkFlairRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.LinkFlairRequest", LinkFlairRequest);
function createBaseSelectFlairRequest() {
  return {
    subreddit: "",
    backgroundColor: "",
    cssClass: "",
    flairTemplateId: "",
    link: "",
    name: "",
    returnRtjson: "",
    text: "",
    textColor: ""
  };
}
var SelectFlairRequest = {
  $type: "devvit.plugin.redditapi.flair.SelectFlairRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.backgroundColor !== "") {
      writer.uint32(18).string(message.backgroundColor);
    }
    if (message.cssClass !== "") {
      writer.uint32(26).string(message.cssClass);
    }
    if (message.flairTemplateId !== "") {
      writer.uint32(34).string(message.flairTemplateId);
    }
    if (message.link !== "") {
      writer.uint32(42).string(message.link);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.returnRtjson !== "") {
      writer.uint32(58).string(message.returnRtjson);
    }
    if (message.text !== "") {
      writer.uint32(66).string(message.text);
    }
    if (message.textColor !== "") {
      writer.uint32(74).string(message.textColor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSelectFlairRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.backgroundColor = reader.string();
          break;
        case 3:
          message.cssClass = reader.string();
          break;
        case 4:
          message.flairTemplateId = reader.string();
          break;
        case 5:
          message.link = reader.string();
          break;
        case 6:
          message.name = reader.string();
          break;
        case 7:
          message.returnRtjson = reader.string();
          break;
        case 8:
          message.text = reader.string();
          break;
        case 9:
          message.textColor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "",
      backgroundColor: isSet84(object.backgroundColor) ? String(object.backgroundColor) : "",
      cssClass: isSet84(object.cssClass) ? String(object.cssClass) : "",
      flairTemplateId: isSet84(object.flairTemplateId) ? String(object.flairTemplateId) : "",
      link: isSet84(object.link) ? String(object.link) : "",
      name: isSet84(object.name) ? String(object.name) : "",
      returnRtjson: isSet84(object.returnRtjson) ? String(object.returnRtjson) : "",
      text: isSet84(object.text) ? String(object.text) : "",
      textColor: isSet84(object.textColor) ? String(object.textColor) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.backgroundColor !== void 0 && (obj.backgroundColor = message.backgroundColor);
    message.cssClass !== void 0 && (obj.cssClass = message.cssClass);
    message.flairTemplateId !== void 0 && (obj.flairTemplateId = message.flairTemplateId);
    message.link !== void 0 && (obj.link = message.link);
    message.name !== void 0 && (obj.name = message.name);
    message.returnRtjson !== void 0 && (obj.returnRtjson = message.returnRtjson);
    message.text !== void 0 && (obj.text = message.text);
    message.textColor !== void 0 && (obj.textColor = message.textColor);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSelectFlairRequest();
    message.subreddit = object.subreddit ?? "";
    message.backgroundColor = object.backgroundColor ?? "";
    message.cssClass = object.cssClass ?? "";
    message.flairTemplateId = object.flairTemplateId ?? "";
    message.link = object.link ?? "";
    message.name = object.name ?? "";
    message.returnRtjson = object.returnRtjson ?? "";
    message.text = object.text ?? "";
    message.textColor = object.textColor ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.SelectFlairRequest", SelectFlairRequest);
function createBaseSetFlairEnabledRequest() {
  return { subreddit: "", flairEnabled: false };
}
var SetFlairEnabledRequest = {
  $type: "devvit.plugin.redditapi.flair.SetFlairEnabledRequest",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.flairEnabled === true) {
      writer.uint32(16).bool(message.flairEnabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetFlairEnabledRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.flairEnabled = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet84(object.subreddit) ? String(object.subreddit) : "",
      flairEnabled: isSet84(object.flairEnabled) ? Boolean(object.flairEnabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.flairEnabled !== void 0 && (obj.flairEnabled = message.flairEnabled);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSetFlairEnabledRequest();
    message.subreddit = object.subreddit ?? "";
    message.flairEnabled = object.flairEnabled ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.SetFlairEnabledRequest", SetFlairEnabledRequest);
function createBaseFlairObject() {
  return {
    allowableContent: void 0,
    text: void 0,
    textColor: void 0,
    modOnly: false,
    backgroundColor: void 0,
    id: void 0,
    cssClass: void 0,
    maxEmojis: 0,
    richtext: [],
    textEditable: false,
    overrideCss: false,
    type: void 0,
    flairType: void 0
  };
}
var FlairObject = {
  $type: "devvit.plugin.redditapi.flair.FlairObject",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.allowableContent !== void 0) {
      StringValue.encode({ value: message.allowableContent }, writer.uint32(10).fork()).ldelim();
    }
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(18).fork()).ldelim();
    }
    if (message.textColor !== void 0) {
      StringValue.encode({ value: message.textColor }, writer.uint32(26).fork()).ldelim();
    }
    if (message.modOnly === true) {
      writer.uint32(32).bool(message.modOnly);
    }
    if (message.backgroundColor !== void 0) {
      StringValue.encode({ value: message.backgroundColor }, writer.uint32(42).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(50).fork()).ldelim();
    }
    if (message.cssClass !== void 0) {
      StringValue.encode({ value: message.cssClass }, writer.uint32(58).fork()).ldelim();
    }
    if (message.maxEmojis !== 0) {
      writer.uint32(64).int64(message.maxEmojis);
    }
    for (const v of message.richtext) {
      StringValue.encode({ value: v }, writer.uint32(74).fork()).ldelim();
    }
    if (message.textEditable === true) {
      writer.uint32(80).bool(message.textEditable);
    }
    if (message.overrideCss === true) {
      writer.uint32(88).bool(message.overrideCss);
    }
    if (message.type !== void 0) {
      StringValue.encode({ value: message.type }, writer.uint32(98).fork()).ldelim();
    }
    if (message.flairType !== void 0) {
      StringValue.encode({ value: message.flairType }, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.allowableContent = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.text = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.textColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.modOnly = reader.bool();
          break;
        case 5:
          message.backgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.cssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.maxEmojis = longToNumber7(reader.int64());
          break;
        case 9:
          message.richtext.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 10:
          message.textEditable = reader.bool();
          break;
        case 11:
          message.overrideCss = reader.bool();
          break;
        case 12:
          message.type = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.flairType = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      allowableContent: isSet84(object.allowableContent) ? String(object.allowableContent) : void 0,
      text: isSet84(object.text) ? String(object.text) : void 0,
      textColor: isSet84(object.textColor) ? String(object.textColor) : void 0,
      modOnly: isSet84(object.modOnly) ? Boolean(object.modOnly) : false,
      backgroundColor: isSet84(object.backgroundColor) ? String(object.backgroundColor) : void 0,
      id: isSet84(object.id) ? String(object.id) : void 0,
      cssClass: isSet84(object.cssClass) ? String(object.cssClass) : void 0,
      maxEmojis: isSet84(object.maxEmojis) ? Number(object.maxEmojis) : 0,
      richtext: Array.isArray(object?.richtext) ? object.richtext.map((e) => String(e)) : [],
      textEditable: isSet84(object.textEditable) ? Boolean(object.textEditable) : false,
      overrideCss: isSet84(object.overrideCss) ? Boolean(object.overrideCss) : false,
      type: isSet84(object.type) ? String(object.type) : void 0,
      flairType: isSet84(object.flairType) ? String(object.flairType) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.allowableContent !== void 0 && (obj.allowableContent = message.allowableContent);
    message.text !== void 0 && (obj.text = message.text);
    message.textColor !== void 0 && (obj.textColor = message.textColor);
    message.modOnly !== void 0 && (obj.modOnly = message.modOnly);
    message.backgroundColor !== void 0 && (obj.backgroundColor = message.backgroundColor);
    message.id !== void 0 && (obj.id = message.id);
    message.cssClass !== void 0 && (obj.cssClass = message.cssClass);
    message.maxEmojis !== void 0 && (obj.maxEmojis = Math.round(message.maxEmojis));
    if (message.richtext) {
      obj.richtext = message.richtext.map((e) => e);
    } else {
      obj.richtext = [];
    }
    message.textEditable !== void 0 && (obj.textEditable = message.textEditable);
    message.overrideCss !== void 0 && (obj.overrideCss = message.overrideCss);
    message.type !== void 0 && (obj.type = message.type);
    message.flairType !== void 0 && (obj.flairType = message.flairType);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairObject();
    message.allowableContent = object.allowableContent ?? void 0;
    message.text = object.text ?? void 0;
    message.textColor = object.textColor ?? void 0;
    message.modOnly = object.modOnly ?? false;
    message.backgroundColor = object.backgroundColor ?? void 0;
    message.id = object.id ?? void 0;
    message.cssClass = object.cssClass ?? void 0;
    message.maxEmojis = object.maxEmojis ?? 0;
    message.richtext = object.richtext?.map((e) => e) || [];
    message.textEditable = object.textEditable ?? false;
    message.overrideCss = object.overrideCss ?? false;
    message.type = object.type ?? void 0;
    message.flairType = object.flairType ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairObject", FlairObject);
function createBaseFlairArray() {
  return { flair: [] };
}
var FlairArray = {
  $type: "devvit.plugin.redditapi.flair.FlairArray",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    for (const v of message.flair) {
      FlairObject.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.flair.push(FlairObject.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { flair: Array.isArray(object?.flair) ? object.flair.map((e) => FlairObject.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.flair) {
      obj.flair = message.flair.map((e) => e ? FlairObject.toJSON(e) : void 0);
    } else {
      obj.flair = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairArray();
    message.flair = object.flair?.map((e) => FlairObject.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairArray", FlairArray);
function createBaseFlairSelectorResponseOption() {
  return {
    flairCssClass: void 0,
    flairTemplateId: void 0,
    flairText: void 0,
    flairTextEditable: void 0,
    flairPosition: void 0
  };
}
var FlairSelectorResponseOption = {
  $type: "devvit.plugin.redditapi.flair.FlairSelectorResponseOption",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.flairCssClass !== void 0) {
      StringValue.encode({ value: message.flairCssClass }, writer.uint32(10).fork()).ldelim();
    }
    if (message.flairTemplateId !== void 0) {
      StringValue.encode({ value: message.flairTemplateId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.flairText !== void 0) {
      StringValue.encode({ value: message.flairText }, writer.uint32(26).fork()).ldelim();
    }
    if (message.flairTextEditable !== void 0) {
      BoolValue.encode({ value: message.flairTextEditable }, writer.uint32(34).fork()).ldelim();
    }
    if (message.flairPosition !== void 0) {
      StringValue.encode({ value: message.flairPosition }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairSelectorResponseOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.flairCssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.flairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.flairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.flairTextEditable = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.flairPosition = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      flairCssClass: isSet84(object.flairCssClass) ? String(object.flairCssClass) : void 0,
      flairTemplateId: isSet84(object.flairTemplateId) ? String(object.flairTemplateId) : void 0,
      flairText: isSet84(object.flairText) ? String(object.flairText) : void 0,
      flairTextEditable: isSet84(object.flairTextEditable) ? Boolean(object.flairTextEditable) : void 0,
      flairPosition: isSet84(object.flairPosition) ? String(object.flairPosition) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.flairCssClass !== void 0 && (obj.flairCssClass = message.flairCssClass);
    message.flairTemplateId !== void 0 && (obj.flairTemplateId = message.flairTemplateId);
    message.flairText !== void 0 && (obj.flairText = message.flairText);
    message.flairTextEditable !== void 0 && (obj.flairTextEditable = message.flairTextEditable);
    message.flairPosition !== void 0 && (obj.flairPosition = message.flairPosition);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairSelectorResponseOption();
    message.flairCssClass = object.flairCssClass ?? void 0;
    message.flairTemplateId = object.flairTemplateId ?? void 0;
    message.flairText = object.flairText ?? void 0;
    message.flairTextEditable = object.flairTextEditable ?? void 0;
    message.flairPosition = object.flairPosition ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairSelectorResponseOption", FlairSelectorResponseOption);
function createBaseFlairSelectorResponse() {
  return { current: void 0, choices: [] };
}
var FlairSelectorResponse = {
  $type: "devvit.plugin.redditapi.flair.FlairSelectorResponse",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.current !== void 0) {
      FlairSelectorResponseOption.encode(message.current, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.choices) {
      FlairSelectorResponseOption.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairSelectorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.current = FlairSelectorResponseOption.decode(reader, reader.uint32());
          break;
        case 2:
          message.choices.push(FlairSelectorResponseOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      current: isSet84(object.current) ? FlairSelectorResponseOption.fromJSON(object.current) : void 0,
      choices: Array.isArray(object?.choices) ? object.choices.map((e) => FlairSelectorResponseOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.current !== void 0 && (obj.current = message.current ? FlairSelectorResponseOption.toJSON(message.current) : void 0);
    if (message.choices) {
      obj.choices = message.choices.map((e) => e ? FlairSelectorResponseOption.toJSON(e) : void 0);
    } else {
      obj.choices = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairSelectorResponse();
    message.current = object.current !== void 0 && object.current !== null ? FlairSelectorResponseOption.fromPartial(object.current) : void 0;
    message.choices = object.choices?.map((e) => FlairSelectorResponseOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairSelectorResponse", FlairSelectorResponse);
function createBaseUserFlair() {
  return { flairCssClass: void 0, user: void 0, flairText: void 0 };
}
var UserFlair = {
  $type: "devvit.plugin.redditapi.flair.UserFlair",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.flairCssClass !== void 0) {
      StringValue.encode({ value: message.flairCssClass }, writer.uint32(10).fork()).ldelim();
    }
    if (message.user !== void 0) {
      StringValue.encode({ value: message.user }, writer.uint32(18).fork()).ldelim();
    }
    if (message.flairText !== void 0) {
      StringValue.encode({ value: message.flairText }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserFlair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.flairCssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.user = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.flairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      flairCssClass: isSet84(object.flairCssClass) ? String(object.flairCssClass) : void 0,
      user: isSet84(object.user) ? String(object.user) : void 0,
      flairText: isSet84(object.flairText) ? String(object.flairText) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.flairCssClass !== void 0 && (obj.flairCssClass = message.flairCssClass);
    message.user !== void 0 && (obj.user = message.user);
    message.flairText !== void 0 && (obj.flairText = message.flairText);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserFlair();
    message.flairCssClass = object.flairCssClass ?? void 0;
    message.user = object.user ?? void 0;
    message.flairText = object.flairText ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.UserFlair", UserFlair);
function createBaseFlairListResponse() {
  return { users: [] };
}
var FlairListResponse = {
  $type: "devvit.plugin.redditapi.flair.FlairListResponse",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    for (const v of message.users) {
      UserFlair.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.users.push(UserFlair.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { users: Array.isArray(object?.users) ? object.users.map((e) => UserFlair.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.users) {
      obj.users = message.users.map((e) => e ? UserFlair.toJSON(e) : void 0);
    } else {
      obj.users = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairListResponse();
    message.users = object.users?.map((e) => UserFlair.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairListResponse", FlairListResponse);
function createBaseFlairCsvResultError() {
  return { css: void 0, row: void 0, user: void 0 };
}
var FlairCsvResultError = {
  $type: "devvit.plugin.redditapi.flair.FlairCsvResultError",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.css !== void 0) {
      StringValue.encode({ value: message.css }, writer.uint32(10).fork()).ldelim();
    }
    if (message.row !== void 0) {
      StringValue.encode({ value: message.row }, writer.uint32(18).fork()).ldelim();
    }
    if (message.user !== void 0) {
      StringValue.encode({ value: message.user }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairCsvResultError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.css = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.row = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.user = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      css: isSet84(object.css) ? String(object.css) : void 0,
      row: isSet84(object.row) ? String(object.row) : void 0,
      user: isSet84(object.user) ? String(object.user) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.css !== void 0 && (obj.css = message.css);
    message.row !== void 0 && (obj.row = message.row);
    message.user !== void 0 && (obj.user = message.user);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairCsvResultError();
    message.css = object.css ?? void 0;
    message.row = object.row ?? void 0;
    message.user = object.user ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairCsvResultError", FlairCsvResultError);
function createBaseFlairCsvResultWarning() {
  return { text: void 0 };
}
var FlairCsvResultWarning = {
  $type: "devvit.plugin.redditapi.flair.FlairCsvResultWarning",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairCsvResultWarning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.text = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { text: isSet84(object.text) ? String(object.text) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.text !== void 0 && (obj.text = message.text);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairCsvResultWarning();
    message.text = object.text ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairCsvResultWarning", FlairCsvResultWarning);
function createBaseFlairCsvResult() {
  return { status: void 0, ok: void 0, errors: void 0, warnings: void 0 };
}
var FlairCsvResult = {
  $type: "devvit.plugin.redditapi.flair.FlairCsvResult",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    if (message.status !== void 0) {
      StringValue.encode({ value: message.status }, writer.uint32(10).fork()).ldelim();
    }
    if (message.ok !== void 0) {
      BoolValue.encode({ value: message.ok }, writer.uint32(18).fork()).ldelim();
    }
    if (message.errors !== void 0) {
      FlairCsvResultError.encode(message.errors, writer.uint32(26).fork()).ldelim();
    }
    if (message.warnings !== void 0) {
      FlairCsvResultWarning.encode(message.warnings, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairCsvResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.status = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.ok = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.errors = FlairCsvResultError.decode(reader, reader.uint32());
          break;
        case 4:
          message.warnings = FlairCsvResultWarning.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      status: isSet84(object.status) ? String(object.status) : void 0,
      ok: isSet84(object.ok) ? Boolean(object.ok) : void 0,
      errors: isSet84(object.errors) ? FlairCsvResultError.fromJSON(object.errors) : void 0,
      warnings: isSet84(object.warnings) ? FlairCsvResultWarning.fromJSON(object.warnings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.status !== void 0 && (obj.status = message.status);
    message.ok !== void 0 && (obj.ok = message.ok);
    message.errors !== void 0 && (obj.errors = message.errors ? FlairCsvResultError.toJSON(message.errors) : void 0);
    message.warnings !== void 0 && (obj.warnings = message.warnings ? FlairCsvResultWarning.toJSON(message.warnings) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairCsvResult();
    message.status = object.status ?? void 0;
    message.ok = object.ok ?? void 0;
    message.errors = object.errors !== void 0 && object.errors !== null ? FlairCsvResultError.fromPartial(object.errors) : void 0;
    message.warnings = object.warnings !== void 0 && object.warnings !== null ? FlairCsvResultWarning.fromPartial(object.warnings) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairCsvResult", FlairCsvResult);
function createBaseFlairCsvResponse() {
  return { result: [] };
}
var FlairCsvResponse = {
  $type: "devvit.plugin.redditapi.flair.FlairCsvResponse",
  encode(message, writer = import_minimal92.default.Writer.create()) {
    for (const v of message.result) {
      FlairCsvResult.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal92.default.Reader ? input : new import_minimal92.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlairCsvResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.result.push(FlairCsvResult.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { result: Array.isArray(object?.result) ? object.result.map((e) => FlairCsvResult.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.result) {
      obj.result = message.result.map((e) => e ? FlairCsvResult.toJSON(e) : void 0);
    } else {
      obj.result = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFlairCsvResponse();
    message.result = object.result?.map((e) => FlairCsvResult.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.flair.FlairCsvResponse", FlairCsvResponse);
var globalThis10 = (() => {
  if (typeof globalThis10 !== "undefined") {
    return globalThis10;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function longToNumber7(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis10.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal92.default.util.Long !== import_long7.default) {
  import_minimal92.default.util.Long = import_long7.default;
  import_minimal92.default.configure();
}
function isSet84(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/flair/flair_svc.js
var import_minimal93 = __toESM(require_minimal2(), 1);
var FlairDefinition = {
  name: "Flair",
  fullName: "devvit.plugin.redditapi.flair.Flair",
  methods: {
    /** https://www.reddit.com/dev/api#POST_api_clearflairtemplates */
    clearFlairTemplates: {
      name: "ClearFlairTemplates",
      requestType: ClearFlairTemplatesRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_deleteflair */
    deleteFlair: {
      name: "DeleteFlair",
      requestType: DeleteFlairRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_deleteflairtemplate */
    deleteFlairTemplate: {
      name: "DeleteFlairTemplate",
      requestType: DeleteFlairTemplateRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_flair */
    flair: {
      name: "Flair",
      requestType: FlairRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /**
     * https://www.reddit.com/dev/api#PATCH_api_flair_template_order
     * Note: Endpoint expects body as raw array of flair id's
     */
    flairTemplateOrder: {
      name: "FlairTemplateOrder",
      requestType: FlairTemplateOrderRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_flairconfig */
    flairConfig: {
      name: "FlairConfig",
      requestType: FlairConfigRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_flaircsv */
    flairCsv: {
      name: "FlairCsv",
      requestType: FlairCsvRequest,
      requestStream: false,
      responseType: FlairCsvResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_flairlist */
    flairList: {
      name: "FlairList",
      requestType: FlairListRequest,
      requestStream: false,
      responseType: FlairListResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_flairselector */
    flairSelector: {
      name: "FlairSelector",
      requestType: FlairSelectorRequest,
      requestStream: false,
      responseType: FlairSelectorResponse,
      responseStream: false,
      options: {}
    },
    /**
     * https://www.reddit.com/dev/api#POST_api_flairtemplate_v2
     * Note: We ignore the "v1" implementation of this method
     * Beware: The JSON response to this endpoint is a FlairObject in camelCase, not snake_case
     * like the other responses.
     */
    flairTemplate: {
      name: "FlairTemplate",
      requestType: FlairTemplateRequest,
      requestStream: false,
      responseType: FlairObject,
      responseStream: false,
      options: {}
    },
    /**
     * https://www.reddit.com/dev/api#GET_api_link_flair_v2
     * Note: We ignore the "v1" implementation of this method
     */
    linkFlair: {
      name: "LinkFlair",
      requestType: LinkFlairRequest,
      requestStream: false,
      responseType: FlairArray,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_selectflair */
    selectFlair: {
      name: "SelectFlair",
      requestType: SelectFlairRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_setflairenabled */
    setFlairEnabled: {
      name: "SetFlairEnabled",
      requestType: SetFlairEnabledRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /**
     * https://www.reddit.com/dev/api#GET_api_user_flair_v2
     * Note: We ignore the "v1" implementation of this method
     */
    userFlair: {
      name: "UserFlair",
      requestType: LinkFlairRequest,
      requestStream: false,
      responseType: FlairArray,
      responseStream: false,
      options: {}
    }
  }
};

// ../protos/dist/types/devvit/plugin/redditapi/linksandcomments/linksandcomments_msg.js
var import_minimal94 = __toESM(require_minimal2(), 1);
function createBaseCommentRequest() {
  return { richtextJson: void 0, text: "", thingId: "" };
}
var CommentRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.CommentRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.richtextJson !== void 0) {
      StringValue.encode({ value: message.richtextJson }, writer.uint32(10).fork()).ldelim();
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.thingId !== "") {
      writer.uint32(26).string(message.thingId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.richtextJson = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.text = reader.string();
          break;
        case 3:
          message.thingId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      richtextJson: isSet85(object.richtextJson) ? String(object.richtextJson) : void 0,
      text: isSet85(object.text) ? String(object.text) : "",
      thingId: isSet85(object.thingId) ? String(object.thingId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.richtextJson !== void 0 && (obj.richtextJson = message.richtextJson);
    message.text !== void 0 && (obj.text = message.text);
    message.thingId !== void 0 && (obj.thingId = message.thingId);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommentRequest();
    message.richtextJson = object.richtextJson ?? void 0;
    message.text = object.text ?? "";
    message.thingId = object.thingId ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.CommentRequest", CommentRequest);
function createBaseFollowPostRequest() {
  return { follow: false, fullname: "" };
}
var FollowPostRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.FollowPostRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.follow === true) {
      writer.uint32(8).bool(message.follow);
    }
    if (message.fullname !== "") {
      writer.uint32(18).string(message.fullname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFollowPostRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.follow = reader.bool();
          break;
        case 2:
          message.fullname = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      follow: isSet85(object.follow) ? Boolean(object.follow) : false,
      fullname: isSet85(object.fullname) ? String(object.fullname) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.follow !== void 0 && (obj.follow = message.follow);
    message.fullname !== void 0 && (obj.fullname = message.fullname);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFollowPostRequest();
    message.follow = object.follow ?? false;
    message.fullname = object.fullname ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.FollowPostRequest", FollowPostRequest);
function createBaseBasicIdRequest() {
  return { id: "" };
}
var BasicIdRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.BasicIdRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet85(object.id) ? String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBasicIdRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.BasicIdRequest", BasicIdRequest);
function createBaseInfoRequest() {
  return { subreddits: [], thingIds: [], url: void 0 };
}
var InfoRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.InfoRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    for (const v of message.subreddits) {
      writer.uint32(10).string(v);
    }
    for (const v of message.thingIds) {
      writer.uint32(18).string(v);
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddits.push(reader.string());
          break;
        case 2:
          message.thingIds.push(reader.string());
          break;
        case 3:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddits: Array.isArray(object?.subreddits) ? object.subreddits.map((e) => String(e)) : [],
      thingIds: Array.isArray(object?.thingIds) ? object.thingIds.map((e) => String(e)) : [],
      url: isSet85(object.url) ? String(object.url) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddits) {
      obj.subreddits = message.subreddits.map((e) => e);
    } else {
      obj.subreddits = [];
    }
    if (message.thingIds) {
      obj.thingIds = message.thingIds.map((e) => e);
    } else {
      obj.thingIds = [];
    }
    message.url !== void 0 && (obj.url = message.url);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseInfoRequest();
    message.subreddits = object.subreddits?.map((e) => e) || [];
    message.thingIds = object.thingIds?.map((e) => e) || [];
    message.url = object.url ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.InfoRequest", InfoRequest);
function createBaseMoreChildrenRequest() {
  return { children: [], depth: void 0, limitChildren: void 0, linkId: "", sort: void 0, id: void 0 };
}
var MoreChildrenRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.MoreChildrenRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    for (const v of message.children) {
      writer.uint32(10).string(v);
    }
    if (message.depth !== void 0) {
      Int32Value.encode({ value: message.depth }, writer.uint32(18).fork()).ldelim();
    }
    if (message.limitChildren !== void 0) {
      BoolValue.encode({ value: message.limitChildren }, writer.uint32(34).fork()).ldelim();
    }
    if (message.linkId !== "") {
      writer.uint32(42).string(message.linkId);
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(50).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMoreChildrenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.children.push(reader.string());
          break;
        case 2:
          message.depth = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limitChildren = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.linkId = reader.string();
          break;
        case 6:
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      children: Array.isArray(object?.children) ? object.children.map((e) => String(e)) : [],
      depth: isSet85(object.depth) ? Number(object.depth) : void 0,
      limitChildren: isSet85(object.limitChildren) ? Boolean(object.limitChildren) : void 0,
      linkId: isSet85(object.linkId) ? String(object.linkId) : "",
      sort: isSet85(object.sort) ? String(object.sort) : void 0,
      id: isSet85(object.id) ? String(object.id) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.children) {
      obj.children = message.children.map((e) => e);
    } else {
      obj.children = [];
    }
    message.depth !== void 0 && (obj.depth = message.depth);
    message.limitChildren !== void 0 && (obj.limitChildren = message.limitChildren);
    message.linkId !== void 0 && (obj.linkId = message.linkId);
    message.sort !== void 0 && (obj.sort = message.sort);
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMoreChildrenRequest();
    message.children = object.children?.map((e) => e) || [];
    message.depth = object.depth ?? void 0;
    message.limitChildren = object.limitChildren ?? void 0;
    message.linkId = object.linkId ?? "";
    message.sort = object.sort ?? void 0;
    message.id = object.id ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.MoreChildrenRequest", MoreChildrenRequest);
function createBaseReportRequest() {
  return {
    additionalInfo: void 0,
    customText: void 0,
    modmailConvId: void 0,
    otherReason: void 0,
    reason: "",
    ruleReason: void 0,
    siteReason: void 0,
    srName: void 0,
    thingId: "",
    usernames: void 0
  };
}
var ReportRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.ReportRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.additionalInfo !== void 0) {
      StringValue.encode({ value: message.additionalInfo }, writer.uint32(10).fork()).ldelim();
    }
    if (message.customText !== void 0) {
      StringValue.encode({ value: message.customText }, writer.uint32(18).fork()).ldelim();
    }
    if (message.modmailConvId !== void 0) {
      StringValue.encode({ value: message.modmailConvId }, writer.uint32(42).fork()).ldelim();
    }
    if (message.otherReason !== void 0) {
      StringValue.encode({ value: message.otherReason }, writer.uint32(50).fork()).ldelim();
    }
    if (message.reason !== "") {
      writer.uint32(58).string(message.reason);
    }
    if (message.ruleReason !== void 0) {
      StringValue.encode({ value: message.ruleReason }, writer.uint32(66).fork()).ldelim();
    }
    if (message.siteReason !== void 0) {
      StringValue.encode({ value: message.siteReason }, writer.uint32(74).fork()).ldelim();
    }
    if (message.srName !== void 0) {
      StringValue.encode({ value: message.srName }, writer.uint32(82).fork()).ldelim();
    }
    if (message.thingId !== "") {
      writer.uint32(90).string(message.thingId);
    }
    if (message.usernames !== void 0) {
      StringValue.encode({ value: message.usernames }, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.additionalInfo = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.customText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.modmailConvId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.otherReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.reason = reader.string();
          break;
        case 8:
          message.ruleReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.siteReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.srName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.thingId = reader.string();
          break;
        case 12:
          message.usernames = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      additionalInfo: isSet85(object.additionalInfo) ? String(object.additionalInfo) : void 0,
      customText: isSet85(object.customText) ? String(object.customText) : void 0,
      modmailConvId: isSet85(object.modmailConvId) ? String(object.modmailConvId) : void 0,
      otherReason: isSet85(object.otherReason) ? String(object.otherReason) : void 0,
      reason: isSet85(object.reason) ? String(object.reason) : "",
      ruleReason: isSet85(object.ruleReason) ? String(object.ruleReason) : void 0,
      siteReason: isSet85(object.siteReason) ? String(object.siteReason) : void 0,
      srName: isSet85(object.srName) ? String(object.srName) : void 0,
      thingId: isSet85(object.thingId) ? String(object.thingId) : "",
      usernames: isSet85(object.usernames) ? String(object.usernames) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.additionalInfo !== void 0 && (obj.additionalInfo = message.additionalInfo);
    message.customText !== void 0 && (obj.customText = message.customText);
    message.modmailConvId !== void 0 && (obj.modmailConvId = message.modmailConvId);
    message.otherReason !== void 0 && (obj.otherReason = message.otherReason);
    message.reason !== void 0 && (obj.reason = message.reason);
    message.ruleReason !== void 0 && (obj.ruleReason = message.ruleReason);
    message.siteReason !== void 0 && (obj.siteReason = message.siteReason);
    message.srName !== void 0 && (obj.srName = message.srName);
    message.thingId !== void 0 && (obj.thingId = message.thingId);
    message.usernames !== void 0 && (obj.usernames = message.usernames);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseReportRequest();
    message.additionalInfo = object.additionalInfo ?? void 0;
    message.customText = object.customText ?? void 0;
    message.modmailConvId = object.modmailConvId ?? void 0;
    message.otherReason = object.otherReason ?? void 0;
    message.reason = object.reason ?? "";
    message.ruleReason = object.ruleReason ?? void 0;
    message.siteReason = object.siteReason ?? void 0;
    message.srName = object.srName ?? void 0;
    message.thingId = object.thingId ?? "";
    message.usernames = object.usernames ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.ReportRequest", ReportRequest);
function createBaseReportAwardRequest() {
  return { awardId: "", reason: void 0 };
}
var ReportAwardRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.ReportAwardRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.awardId !== "") {
      writer.uint32(10).string(message.awardId);
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReportAwardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.awardId = reader.string();
          break;
        case 2:
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      awardId: isSet85(object.awardId) ? String(object.awardId) : "",
      reason: isSet85(object.reason) ? String(object.reason) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.awardId !== void 0 && (obj.awardId = message.awardId);
    message.reason !== void 0 && (obj.reason = message.reason);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseReportAwardRequest();
    message.awardId = object.awardId ?? "";
    message.reason = object.reason ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.ReportAwardRequest", ReportAwardRequest);
function createBaseSaveRequest() {
  return { id: "" };
}
var SaveRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.SaveRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSaveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet85(object.id) ? String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSaveRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SaveRequest", SaveRequest);
function createBaseSendRepliesRequest() {
  return { id: "", state: false };
}
var SendRepliesRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.SendRepliesRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.state === true) {
      writer.uint32(16).bool(message.state);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSendRepliesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.state = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet85(object.id) ? String(object.id) : "",
      state: isSet85(object.state) ? Boolean(object.state) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.state !== void 0 && (obj.state = message.state);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSendRepliesRequest();
    message.id = object.id ?? "";
    message.state = object.state ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SendRepliesRequest", SendRepliesRequest);
function createBaseSetContestModeRequest() {
  return { id: "", state: false };
}
var SetContestModeRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.SetContestModeRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.state === true) {
      writer.uint32(16).bool(message.state);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetContestModeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.state = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet85(object.id) ? String(object.id) : "",
      state: isSet85(object.state) ? Boolean(object.state) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.state !== void 0 && (obj.state = message.state);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSetContestModeRequest();
    message.id = object.id ?? "";
    message.state = object.state ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SetContestModeRequest", SetContestModeRequest);
function createBaseSetSubredditStickyRequest() {
  return { id: "", num: void 0, state: false, toProfile: void 0 };
}
var SetSubredditStickyRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.SetSubredditStickyRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.num !== void 0) {
      Int32Value.encode({ value: message.num }, writer.uint32(18).fork()).ldelim();
    }
    if (message.state === true) {
      writer.uint32(24).bool(message.state);
    }
    if (message.toProfile !== void 0) {
      BoolValue.encode({ value: message.toProfile }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetSubredditStickyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.num = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.state = reader.bool();
          break;
        case 4:
          message.toProfile = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet85(object.id) ? String(object.id) : "",
      num: isSet85(object.num) ? Number(object.num) : void 0,
      state: isSet85(object.state) ? Boolean(object.state) : false,
      toProfile: isSet85(object.toProfile) ? Boolean(object.toProfile) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.num !== void 0 && (obj.num = message.num);
    message.state !== void 0 && (obj.state = message.state);
    message.toProfile !== void 0 && (obj.toProfile = message.toProfile);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSetSubredditStickyRequest();
    message.id = object.id ?? "";
    message.num = object.num ?? void 0;
    message.state = object.state ?? false;
    message.toProfile = object.toProfile ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SetSubredditStickyRequest", SetSubredditStickyRequest);
function createBaseSetSuggestedSortRequest() {
  return { id: "", sort: "" };
}
var SetSuggestedSortRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.SetSuggestedSortRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sort !== "") {
      writer.uint32(18).string(message.sort);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetSuggestedSortRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.sort = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet85(object.id) ? String(object.id) : "", sort: isSet85(object.sort) ? String(object.sort) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.sort !== void 0 && (obj.sort = message.sort);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSetSuggestedSortRequest();
    message.id = object.id ?? "";
    message.sort = object.sort ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SetSuggestedSortRequest", SetSuggestedSortRequest);
function createBaseSubmitRequest() {
  return {
    collectionId: void 0,
    flairId: void 0,
    flairText: void 0,
    kind: "",
    nsfw: void 0,
    resubmit: void 0,
    richtextJson: void 0,
    sendreplies: void 0,
    spoiler: void 0,
    sr: "",
    text: void 0,
    title: "",
    url: void 0,
    videoPosterUrl: void 0,
    crosspostFullname: void 0
  };
}
var SubmitRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.SubmitRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.flairId !== void 0) {
      StringValue.encode({ value: message.flairId }, writer.uint32(58).fork()).ldelim();
    }
    if (message.flairText !== void 0) {
      StringValue.encode({ value: message.flairText }, writer.uint32(66).fork()).ldelim();
    }
    if (message.kind !== "") {
      writer.uint32(74).string(message.kind);
    }
    if (message.nsfw !== void 0) {
      BoolValue.encode({ value: message.nsfw }, writer.uint32(82).fork()).ldelim();
    }
    if (message.resubmit !== void 0) {
      BoolValue.encode({ value: message.resubmit }, writer.uint32(90).fork()).ldelim();
    }
    if (message.richtextJson !== void 0) {
      StringValue.encode({ value: message.richtextJson }, writer.uint32(98).fork()).ldelim();
    }
    if (message.sendreplies !== void 0) {
      BoolValue.encode({ value: message.sendreplies }, writer.uint32(106).fork()).ldelim();
    }
    if (message.spoiler !== void 0) {
      BoolValue.encode({ value: message.spoiler }, writer.uint32(114).fork()).ldelim();
    }
    if (message.sr !== "") {
      writer.uint32(122).string(message.sr);
    }
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(130).fork()).ldelim();
    }
    if (message.title !== "") {
      writer.uint32(138).string(message.title);
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(146).fork()).ldelim();
    }
    if (message.videoPosterUrl !== void 0) {
      StringValue.encode({ value: message.videoPosterUrl }, writer.uint32(154).fork()).ldelim();
    }
    if (message.crosspostFullname !== void 0) {
      StringValue.encode({ value: message.crosspostFullname }, writer.uint32(162).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.flairId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.flairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.kind = reader.string();
          break;
        case 10:
          message.nsfw = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.resubmit = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.richtextJson = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.sendreplies = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.spoiler = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.sr = reader.string();
          break;
        case 16:
          message.text = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.title = reader.string();
          break;
        case 18:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.videoPosterUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.crosspostFullname = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      collectionId: isSet85(object.collectionId) ? String(object.collectionId) : void 0,
      flairId: isSet85(object.flairId) ? String(object.flairId) : void 0,
      flairText: isSet85(object.flairText) ? String(object.flairText) : void 0,
      kind: isSet85(object.kind) ? String(object.kind) : "",
      nsfw: isSet85(object.nsfw) ? Boolean(object.nsfw) : void 0,
      resubmit: isSet85(object.resubmit) ? Boolean(object.resubmit) : void 0,
      richtextJson: isSet85(object.richtextJson) ? String(object.richtextJson) : void 0,
      sendreplies: isSet85(object.sendreplies) ? Boolean(object.sendreplies) : void 0,
      spoiler: isSet85(object.spoiler) ? Boolean(object.spoiler) : void 0,
      sr: isSet85(object.sr) ? String(object.sr) : "",
      text: isSet85(object.text) ? String(object.text) : void 0,
      title: isSet85(object.title) ? String(object.title) : "",
      url: isSet85(object.url) ? String(object.url) : void 0,
      videoPosterUrl: isSet85(object.videoPosterUrl) ? String(object.videoPosterUrl) : void 0,
      crosspostFullname: isSet85(object.crosspostFullname) ? String(object.crosspostFullname) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.flairId !== void 0 && (obj.flairId = message.flairId);
    message.flairText !== void 0 && (obj.flairText = message.flairText);
    message.kind !== void 0 && (obj.kind = message.kind);
    message.nsfw !== void 0 && (obj.nsfw = message.nsfw);
    message.resubmit !== void 0 && (obj.resubmit = message.resubmit);
    message.richtextJson !== void 0 && (obj.richtextJson = message.richtextJson);
    message.sendreplies !== void 0 && (obj.sendreplies = message.sendreplies);
    message.spoiler !== void 0 && (obj.spoiler = message.spoiler);
    message.sr !== void 0 && (obj.sr = message.sr);
    message.text !== void 0 && (obj.text = message.text);
    message.title !== void 0 && (obj.title = message.title);
    message.url !== void 0 && (obj.url = message.url);
    message.videoPosterUrl !== void 0 && (obj.videoPosterUrl = message.videoPosterUrl);
    message.crosspostFullname !== void 0 && (obj.crosspostFullname = message.crosspostFullname);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubmitRequest();
    message.collectionId = object.collectionId ?? void 0;
    message.flairId = object.flairId ?? void 0;
    message.flairText = object.flairText ?? void 0;
    message.kind = object.kind ?? "";
    message.nsfw = object.nsfw ?? void 0;
    message.resubmit = object.resubmit ?? void 0;
    message.richtextJson = object.richtextJson ?? void 0;
    message.sendreplies = object.sendreplies ?? void 0;
    message.spoiler = object.spoiler ?? void 0;
    message.sr = object.sr ?? "";
    message.text = object.text ?? void 0;
    message.title = object.title ?? "";
    message.url = object.url ?? void 0;
    message.videoPosterUrl = object.videoPosterUrl ?? void 0;
    message.crosspostFullname = object.crosspostFullname ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SubmitRequest", SubmitRequest);
function createBaseVoteRequest() {
  return { dir: 0, id: "" };
}
var VoteRequest = {
  $type: "devvit.plugin.redditapi.linksandcomments.VoteRequest",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.dir !== 0) {
      writer.uint32(8).int32(message.dir);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.dir = reader.int32();
          break;
        case 2:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { dir: isSet85(object.dir) ? Number(object.dir) : 0, id: isSet85(object.id) ? String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.dir !== void 0 && (obj.dir = Math.round(message.dir));
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseVoteRequest();
    message.dir = object.dir ?? 0;
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.VoteRequest", VoteRequest);
function createBaseJsonWrappedComment() {
  return { json: void 0 };
}
var JsonWrappedComment = {
  $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.json !== void 0) {
      JsonWrappedComment_Json.encode(message.json, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonWrappedComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.json = JsonWrappedComment_Json.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { json: isSet85(object.json) ? JsonWrappedComment_Json.fromJSON(object.json) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.json !== void 0 && (obj.json = message.json ? JsonWrappedComment_Json.toJSON(message.json) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseJsonWrappedComment();
    message.json = object.json !== void 0 && object.json !== null ? JsonWrappedComment_Json.fromPartial(object.json) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.JsonWrappedComment", JsonWrappedComment);
function createBaseJsonWrappedComment_WrappedComment() {
  return { kind: "", data: void 0 };
}
var JsonWrappedComment_WrappedComment = {
  $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.WrappedComment",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      Comment.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonWrappedComment_WrappedComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.data = Comment.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet85(object.kind) ? String(object.kind) : "",
      data: isSet85(object.data) ? Comment.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? Comment.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseJsonWrappedComment_WrappedComment();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? Comment.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.WrappedComment", JsonWrappedComment_WrappedComment);
function createBaseJsonWrappedComment_JsonData() {
  return { things: [] };
}
var JsonWrappedComment_JsonData = {
  $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.JsonData",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    for (const v of message.things) {
      JsonWrappedComment_WrappedComment.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonWrappedComment_JsonData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.things.push(JsonWrappedComment_WrappedComment.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      things: Array.isArray(object?.things) ? object.things.map((e) => JsonWrappedComment_WrappedComment.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.things) {
      obj.things = message.things.map((e) => e ? JsonWrappedComment_WrappedComment.toJSON(e) : void 0);
    } else {
      obj.things = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseJsonWrappedComment_JsonData();
    message.things = object.things?.map((e) => JsonWrappedComment_WrappedComment.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.JsonData", JsonWrappedComment_JsonData);
function createBaseJsonWrappedComment_Json() {
  return { errors: [], data: void 0 };
}
var JsonWrappedComment_Json = {
  $type: "devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.Json",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    for (const v of message.errors) {
      writer.uint32(10).string(v);
    }
    if (message.data !== void 0) {
      JsonWrappedComment_JsonData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonWrappedComment_Json();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.errors.push(reader.string());
          break;
        case 2:
          message.data = JsonWrappedComment_JsonData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      errors: Array.isArray(object?.errors) ? object.errors.map((e) => String(e)) : [],
      data: isSet85(object.data) ? JsonWrappedComment_JsonData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.errors) {
      obj.errors = message.errors.map((e) => e);
    } else {
      obj.errors = [];
    }
    message.data !== void 0 && (obj.data = message.data ? JsonWrappedComment_JsonData.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseJsonWrappedComment_Json();
    message.errors = object.errors?.map((e) => e) || [];
    message.data = object.data !== void 0 && object.data !== null ? JsonWrappedComment_JsonData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.JsonWrappedComment.Json", JsonWrappedComment_Json);
function createBaseSubmitResponse() {
  return { json: void 0 };
}
var SubmitResponse = {
  $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.json !== void 0) {
      SubmitResponse_JsonType.encode(message.json, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          message.json = SubmitResponse_JsonType.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { json: isSet85(object.json) ? SubmitResponse_JsonType.fromJSON(object.json) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.json !== void 0 && (obj.json = message.json ? SubmitResponse_JsonType.toJSON(message.json) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubmitResponse();
    message.json = object.json !== void 0 && object.json !== null ? SubmitResponse_JsonType.fromPartial(object.json) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SubmitResponse", SubmitResponse);
function createBaseSubmitResponse_JsonType() {
  return { errors: [], data: void 0 };
}
var SubmitResponse_JsonType = {
  $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse.JsonType",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    for (const v of message.errors) {
      Any.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      SubmitResponse_JsonType_JsonData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitResponse_JsonType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.errors.push(Any.decode(reader, reader.uint32()));
          break;
        case 2:
          message.data = SubmitResponse_JsonType_JsonData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      errors: Array.isArray(object?.errors) ? object.errors.map((e) => Any.fromJSON(e)) : [],
      data: isSet85(object.data) ? SubmitResponse_JsonType_JsonData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.errors) {
      obj.errors = message.errors.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.errors = [];
    }
    message.data !== void 0 && (obj.data = message.data ? SubmitResponse_JsonType_JsonData.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubmitResponse_JsonType();
    message.errors = object.errors?.map((e) => Any.fromPartial(e)) || [];
    message.data = object.data !== void 0 && object.data !== null ? SubmitResponse_JsonType_JsonData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SubmitResponse.JsonType", SubmitResponse_JsonType);
function createBaseSubmitResponse_JsonType_JsonData() {
  return { url: void 0, draftsCount: void 0, id: void 0, name: void 0 };
}
var SubmitResponse_JsonType_JsonData = {
  $type: "devvit.plugin.redditapi.linksandcomments.SubmitResponse.JsonType.JsonData",
  encode(message, writer = import_minimal94.default.Writer.create()) {
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(10).fork()).ldelim();
    }
    if (message.draftsCount !== void 0) {
      Int32Value.encode({ value: message.draftsCount }, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal94.default.Reader ? input : new import_minimal94.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitResponse_JsonType_JsonData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.draftsCount = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet85(object.url) ? String(object.url) : void 0,
      draftsCount: isSet85(object.draftsCount) ? Number(object.draftsCount) : void 0,
      id: isSet85(object.id) ? String(object.id) : void 0,
      name: isSet85(object.name) ? String(object.name) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    message.draftsCount !== void 0 && (obj.draftsCount = message.draftsCount);
    message.id !== void 0 && (obj.id = message.id);
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubmitResponse_JsonType_JsonData();
    message.url = object.url ?? void 0;
    message.draftsCount = object.draftsCount ?? void 0;
    message.id = object.id ?? void 0;
    message.name = object.name ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.linksandcomments.SubmitResponse.JsonType.JsonData", SubmitResponse_JsonType_JsonData);
function isSet85(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/linksandcomments/linksandcomments_svc.js
var import_minimal95 = __toESM(require_minimal2(), 1);
var LinksAndCommentsDefinition = {
  name: "LinksAndComments",
  fullName: "devvit.plugin.redditapi.linksandcomments.LinksAndComments",
  methods: {
    /**
     * Submit a new Comment
     * Note: `thing_id` refers to the Post or Comment this comment is replying to
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_comment}
     */
    comment: {
      name: "Comment",
      requestType: CommentRequest,
      requestStream: false,
      responseType: JsonWrappedComment,
      responseStream: false,
      options: {}
    },
    /**
     * Delete a Post or Comment
     * Note: `id` must be a single thing ID for a Post or Comment
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_del}
     */
    del: {
      name: "Del",
      requestType: BasicIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Edit the body text of a Comment or Post
     * Note: `thing_id` refers to the Post or Comment being edited
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_editusertext}
     */
    editUserText: {
      name: "EditUserText",
      requestType: CommentRequest,
      requestStream: false,
      responseType: JsonWrappedComment,
      responseStream: false,
      options: {}
    },
    /**
     * Follow or unfollow a Post
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_follow_post}
     */
    followPost: {
      name: "FollowPost",
      requestType: FollowPostRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Hide one or more Posts for the user
     * Note: `id` must be one or more comma-separated Post thing IDs
     *
     * @see {@link Unhide}
     * @see {@link https://www.reddit.com/dev/api#POST_api_hide}
     */
    hide: {
      name: "Hide",
      requestType: BasicIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Get one or more things by ID, Subreddit name, or Link Post URL
     *
     * @see {@link https://www.reddit.com/dev/api#GET_api_info}
     */
    info: {
      name: "Info",
      requestType: InfoRequest,
      requestStream: false,
      responseType: Listing,
      responseStream: false,
      options: {}
    },
    /**
     * Disable comments for a Post or Comment
     * Note: `id` must be a single thing ID for a Post or Comment
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_lock}
     */
    lock: {
      name: "Lock",
      requestType: BasicIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Marks a Post as Not-Safe-For-Work
     *
     * @see {@link UnmarkNSFW}
     * @see {@link https://www.reddit.com/dev/api#POST_api_marknsfw}
     */
    markNSFW: {
      name: "MarkNSFW",
      requestType: BasicIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Get more comments from a truncated Comment tree
     *
     * A comment tree has been truncated if it ends with an entry of kind "more"
     * instead of "t1".  Use this API to fetch the additional comments listed in
     * the "children" array of the "more" entry.
     *
     * @see {@link https://www.reddit.com/dev/api#GET_api_morechildren}
     */
    moreChildren: {
      name: "MoreChildren",
      requestType: MoreChildrenRequest,
      requestStream: false,
      responseType: JsonWrappedComment,
      responseStream: false,
      options: {}
    },
    /**
     * Report a Post, Comment, or Private Message
     *
     * If reporting a Post or Comment the report is sent to the moderators of the subreddit for review.
     * If reporting a Private Message the report is sent to Reddit for review.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_report}
     */
    report: {
      name: "Report",
      requestType: ReportRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /**
     * Report an award to Reddit for review
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_report_award}
     */
    reportAward: {
      name: "ReportAward",
      requestType: ReportAwardRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Save a Post or Comment to the user's Saved list
     *
     * @see {@link Unsave}
     * @see {@link https://www.reddit.com/dev/api#POST_api_save}
     */
    save: {
      name: "Save",
      requestType: SaveRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Enable or disable reply notifications for a Post or Comment
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_sendreplies}
     */
    sendReplies: {
      name: "SendReplies",
      requestType: SendRepliesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Toggle Contest Mode for a Post's comments
     *
     * Contest Mode randomizes the sort order and hides the vote score for comments
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_set_contest_mode}
     */
    setContestMode: {
      name: "SetContestMode",
      requestType: SetContestModeRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /**
     * Set the "sticky" or "pinned" status of a Post
     *
     * If the post was created by the current user they can pin the post
     * to the top of their user profile.  Otherwise they must be a moderator
     * of the subreddit to stick it to the top of the subreddit it was posted in.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_set_subreddit_sticky}
     */
    setSubredditSticky: {
      name: "SetSubredditSticky",
      requestType: SetSubredditStickyRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /**
     * Set the default sort order for comments in the given Post
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_set_suggested_sort}
     */
    setSuggestedSort: {
      name: "SetSuggestedSort",
      requestType: SetSuggestedSortRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /**
     * Sets the spoiler tag on a given Post to hide its contents by default
     * Note: `id` must be a single thing ID for a Post
     *
     * @see {@link Unspoiler}
     * @see {@link https://www.reddit.com/dev/api#POST_api_spoiler}
     */
    spoiler: {
      name: "Spoiler",
      requestType: BasicIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Create a new Post
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_submit}
     */
    submit: {
      name: "Submit",
      requestType: SubmitRequest,
      requestStream: false,
      responseType: SubmitResponse,
      responseStream: false,
      options: {}
    },
    /**
     * Unhide one or more Posts for the user
     * Note: `id` must be one or more comma-separated Post thing IDs
     *
     * @see {@link Hide}
     * @see {@link https://www.reddit.com/dev/api#POST_api_unhide}
     */
    unhide: {
      name: "Unhide",
      requestType: BasicIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Enable comments for a Post or Comment
     * Note: `id` must be a single thing ID for a Post or Comment
     *
     * @see {@link Lock}
     * @see {@link https://www.reddit.com/dev/api#POST_api_unlock}
     */
    unlock: {
      name: "Unlock",
      requestType: BasicIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Clears the Not-Safe-For-Work status from a Post
     *
     * @see {@link MarkNSFW}
     * @see {@link https://www.reddit.com/dev/api#POST_api_unmarknsfw}
     */
    unmarkNSFW: {
      name: "UnmarkNSFW",
      requestType: BasicIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Remove a Post or Comment from the user's Saved list
     *
     * @see {@link Save}
     * @see {@link https://www.reddit.com/dev/api#POST_api_unsave}
     */
    unsave: {
      name: "Unsave",
      requestType: BasicIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Clears the spoiler tag on a given Post
     *
     * @see {@link Spoiler}
     * @see {@link https://www.reddit.com/dev/api#POST_api_unspoiler}
     */
    unspoiler: {
      name: "Unspoiler",
      requestType: BasicIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Vote or clear a vote on a Post or Comment
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_vote}
     */
    vote: {
      name: "Vote",
      requestType: VoteRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    }
  }
};

// ../protos/dist/types/devvit/plugin/redditapi/listings/listings_msg.js
var import_minimal96 = __toESM(require_minimal2(), 1);
function createBaseGetBestRequest() {
  return { after: void 0, before: void 0, count: void 0, limit: void 0, show: void 0 };
}
var GetBestRequest = {
  $type: "devvit.plugin.redditapi.listings.GetBestRequest",
  encode(message, writer = import_minimal96.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal96.default.Reader ? input : new import_minimal96.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetBestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet86(object.after) ? String(object.after) : void 0,
      before: isSet86(object.before) ? String(object.before) : void 0,
      count: isSet86(object.count) ? Number(object.count) : void 0,
      limit: isSet86(object.limit) ? Number(object.limit) : void 0,
      show: isSet86(object.show) ? String(object.show) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.count !== void 0 && (obj.count = message.count);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.show !== void 0 && (obj.show = message.show);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetBestRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.show = object.show ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetBestRequest", GetBestRequest);
function createBaseGetSortRequest() {
  return {
    subreddit: void 0,
    sort: "",
    after: void 0,
    before: void 0,
    limit: void 0,
    count: void 0,
    show: void 0,
    t: void 0
  };
}
var GetSortRequest = {
  $type: "devvit.plugin.redditapi.listings.GetSortRequest",
  encode(message, writer = import_minimal96.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
    }
    if (message.sort !== "") {
      writer.uint32(18).string(message.sort);
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(34).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
    }
    if (message.t !== void 0) {
      StringValue.encode({ value: message.t }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal96.default.Reader ? input : new import_minimal96.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetSortRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.sort = reader.string();
          break;
        case 3:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.t = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet86(object.subreddit) ? String(object.subreddit) : void 0,
      sort: isSet86(object.sort) ? String(object.sort) : "",
      after: isSet86(object.after) ? String(object.after) : void 0,
      before: isSet86(object.before) ? String(object.before) : void 0,
      limit: isSet86(object.limit) ? Number(object.limit) : void 0,
      count: isSet86(object.count) ? Number(object.count) : void 0,
      show: isSet86(object.show) ? String(object.show) : void 0,
      t: isSet86(object.t) ? String(object.t) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.sort !== void 0 && (obj.sort = message.sort);
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.count !== void 0 && (obj.count = message.count);
    message.show !== void 0 && (obj.show = message.show);
    message.t !== void 0 && (obj.t = message.t);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetSortRequest();
    message.subreddit = object.subreddit ?? void 0;
    message.sort = object.sort ?? "";
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.limit = object.limit ?? void 0;
    message.count = object.count ?? void 0;
    message.show = object.show ?? void 0;
    message.t = object.t ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetSortRequest", GetSortRequest);
function createBaseGetCommentsRequest() {
  return {
    article: "",
    comment: void 0,
    context: void 0,
    depth: void 0,
    limit: void 0,
    sort: void 0,
    threaded: void 0,
    truncate: void 0
  };
}
var GetCommentsRequest = {
  $type: "devvit.plugin.redditapi.listings.GetCommentsRequest",
  encode(message, writer = import_minimal96.default.Writer.create()) {
    if (message.article !== "") {
      writer.uint32(10).string(message.article);
    }
    if (message.comment !== void 0) {
      StringValue.encode({ value: message.comment }, writer.uint32(18).fork()).ldelim();
    }
    if (message.context !== void 0) {
      Int64Value.encode({ value: message.context }, writer.uint32(26).fork()).ldelim();
    }
    if (message.depth !== void 0) {
      Int64Value.encode({ value: message.depth }, writer.uint32(34).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(50).fork()).ldelim();
    }
    if (message.threaded !== void 0) {
      BoolValue.encode({ value: message.threaded }, writer.uint32(58).fork()).ldelim();
    }
    if (message.truncate !== void 0) {
      Int64Value.encode({ value: message.truncate }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal96.default.Reader ? input : new import_minimal96.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetCommentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.article = reader.string();
          break;
        case 2:
          message.comment = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.context = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.depth = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.threaded = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.truncate = Int64Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      article: isSet86(object.article) ? String(object.article) : "",
      comment: isSet86(object.comment) ? String(object.comment) : void 0,
      context: isSet86(object.context) ? Number(object.context) : void 0,
      depth: isSet86(object.depth) ? Number(object.depth) : void 0,
      limit: isSet86(object.limit) ? Number(object.limit) : void 0,
      sort: isSet86(object.sort) ? String(object.sort) : void 0,
      threaded: isSet86(object.threaded) ? Boolean(object.threaded) : void 0,
      truncate: isSet86(object.truncate) ? Number(object.truncate) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.article !== void 0 && (obj.article = message.article);
    message.comment !== void 0 && (obj.comment = message.comment);
    message.context !== void 0 && (obj.context = message.context);
    message.depth !== void 0 && (obj.depth = message.depth);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.sort !== void 0 && (obj.sort = message.sort);
    message.threaded !== void 0 && (obj.threaded = message.threaded);
    message.truncate !== void 0 && (obj.truncate = message.truncate);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetCommentsRequest();
    message.article = object.article ?? "";
    message.comment = object.comment ?? void 0;
    message.context = object.context ?? void 0;
    message.depth = object.depth ?? void 0;
    message.limit = object.limit ?? void 0;
    message.sort = object.sort ?? void 0;
    message.threaded = object.threaded ?? void 0;
    message.truncate = object.truncate ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetCommentsRequest", GetCommentsRequest);
function createBaseGetByIdRequest() {
  return { postIds: "" };
}
var GetByIdRequest = {
  $type: "devvit.plugin.redditapi.listings.GetByIdRequest",
  encode(message, writer = import_minimal96.default.Writer.create()) {
    if (message.postIds !== "") {
      writer.uint32(10).string(message.postIds);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal96.default.Reader ? input : new import_minimal96.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.postIds = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { postIds: isSet86(object.postIds) ? String(object.postIds) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.postIds !== void 0 && (obj.postIds = message.postIds);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetByIdRequest();
    message.postIds = object.postIds ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetByIdRequest", GetByIdRequest);
function createBaseGetDuplicatesRequest() {
  return {
    article: "",
    before: void 0,
    after: void 0,
    limit: void 0,
    sort: void 0,
    sr: void 0,
    count: void 0,
    crosspostsOnly: void 0,
    show: void 0
  };
}
var GetDuplicatesRequest = {
  $type: "devvit.plugin.redditapi.listings.GetDuplicatesRequest",
  encode(message, writer = import_minimal96.default.Writer.create()) {
    if (message.article !== "") {
      writer.uint32(10).string(message.article);
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(42).fork()).ldelim();
    }
    if (message.sr !== void 0) {
      StringValue.encode({ value: message.sr }, writer.uint32(50).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(58).fork()).ldelim();
    }
    if (message.crosspostsOnly !== void 0) {
      BoolValue.encode({ value: message.crosspostsOnly }, writer.uint32(66).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal96.default.Reader ? input : new import_minimal96.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetDuplicatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.article = reader.string();
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.sr = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.crosspostsOnly = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      article: isSet86(object.article) ? String(object.article) : "",
      before: isSet86(object.before) ? String(object.before) : void 0,
      after: isSet86(object.after) ? String(object.after) : void 0,
      limit: isSet86(object.limit) ? Number(object.limit) : void 0,
      sort: isSet86(object.sort) ? String(object.sort) : void 0,
      sr: isSet86(object.sr) ? String(object.sr) : void 0,
      count: isSet86(object.count) ? Number(object.count) : void 0,
      crosspostsOnly: isSet86(object.crosspostsOnly) ? Boolean(object.crosspostsOnly) : void 0,
      show: isSet86(object.show) ? String(object.show) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.article !== void 0 && (obj.article = message.article);
    message.before !== void 0 && (obj.before = message.before);
    message.after !== void 0 && (obj.after = message.after);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.sort !== void 0 && (obj.sort = message.sort);
    message.sr !== void 0 && (obj.sr = message.sr);
    message.count !== void 0 && (obj.count = message.count);
    message.crosspostsOnly !== void 0 && (obj.crosspostsOnly = message.crosspostsOnly);
    message.show !== void 0 && (obj.show = message.show);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetDuplicatesRequest();
    message.article = object.article ?? "";
    message.before = object.before ?? void 0;
    message.after = object.after ?? void 0;
    message.limit = object.limit ?? void 0;
    message.sort = object.sort ?? void 0;
    message.sr = object.sr ?? void 0;
    message.count = object.count ?? void 0;
    message.crosspostsOnly = object.crosspostsOnly ?? void 0;
    message.show = object.show ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetDuplicatesRequest", GetDuplicatesRequest);
function createBaseGetHotRequest() {
  return {
    subreddit: void 0,
    before: void 0,
    after: void 0,
    limit: void 0,
    count: void 0,
    show: void 0,
    g: void 0
  };
}
var GetHotRequest = {
  $type: "devvit.plugin.redditapi.listings.GetHotRequest",
  encode(message, writer = import_minimal96.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(42).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
    }
    if (message.g !== void 0) {
      StringValue.encode({ value: message.g }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal96.default.Reader ? input : new import_minimal96.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetHotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.g = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet86(object.subreddit) ? String(object.subreddit) : void 0,
      before: isSet86(object.before) ? String(object.before) : void 0,
      after: isSet86(object.after) ? String(object.after) : void 0,
      limit: isSet86(object.limit) ? Number(object.limit) : void 0,
      count: isSet86(object.count) ? Number(object.count) : void 0,
      show: isSet86(object.show) ? String(object.show) : void 0,
      g: isSet86(object.g) ? String(object.g) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.before !== void 0 && (obj.before = message.before);
    message.after !== void 0 && (obj.after = message.after);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.count !== void 0 && (obj.count = message.count);
    message.show !== void 0 && (obj.show = message.show);
    message.g !== void 0 && (obj.g = message.g);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetHotRequest();
    message.subreddit = object.subreddit ?? void 0;
    message.before = object.before ?? void 0;
    message.after = object.after ?? void 0;
    message.limit = object.limit ?? void 0;
    message.count = object.count ?? void 0;
    message.show = object.show ?? void 0;
    message.g = object.g ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetHotRequest", GetHotRequest);
function createBaseGetNewRequest() {
  return {
    subreddit: void 0,
    before: void 0,
    after: void 0,
    limit: void 0,
    count: void 0,
    show: void 0
  };
}
var GetNewRequest = {
  $type: "devvit.plugin.redditapi.listings.GetNewRequest",
  encode(message, writer = import_minimal96.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(42).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal96.default.Reader ? input : new import_minimal96.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetNewRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet86(object.subreddit) ? String(object.subreddit) : void 0,
      before: isSet86(object.before) ? String(object.before) : void 0,
      after: isSet86(object.after) ? String(object.after) : void 0,
      limit: isSet86(object.limit) ? Number(object.limit) : void 0,
      count: isSet86(object.count) ? Number(object.count) : void 0,
      show: isSet86(object.show) ? String(object.show) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.before !== void 0 && (obj.before = message.before);
    message.after !== void 0 && (obj.after = message.after);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.count !== void 0 && (obj.count = message.count);
    message.show !== void 0 && (obj.show = message.show);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetNewRequest();
    message.subreddit = object.subreddit ?? void 0;
    message.before = object.before ?? void 0;
    message.after = object.after ?? void 0;
    message.limit = object.limit ?? void 0;
    message.count = object.count ?? void 0;
    message.show = object.show ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetNewRequest", GetNewRequest);
function createBaseGetRisingRequest() {
  return {
    subreddit: void 0,
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    show: void 0
  };
}
var GetRisingRequest = {
  $type: "devvit.plugin.redditapi.listings.GetRisingRequest",
  encode(message, writer = import_minimal96.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(18).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(26).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(34).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal96.default.Reader ? input : new import_minimal96.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetRisingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet86(object.subreddit) ? String(object.subreddit) : void 0,
      after: isSet86(object.after) ? String(object.after) : void 0,
      before: isSet86(object.before) ? String(object.before) : void 0,
      count: isSet86(object.count) ? Number(object.count) : void 0,
      limit: isSet86(object.limit) ? Number(object.limit) : void 0,
      show: isSet86(object.show) ? String(object.show) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.count !== void 0 && (obj.count = message.count);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.show !== void 0 && (obj.show = message.show);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetRisingRequest();
    message.subreddit = object.subreddit ?? void 0;
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.show = object.show ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.GetRisingRequest", GetRisingRequest);
function createBaseListingResponse() {
  return { listings: [] };
}
var ListingResponse = {
  $type: "devvit.plugin.redditapi.listings.ListingResponse",
  encode(message, writer = import_minimal96.default.Writer.create()) {
    for (const v of message.listings) {
      Listing.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal96.default.Reader ? input : new import_minimal96.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.listings.push(Listing.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { listings: Array.isArray(object?.listings) ? object.listings.map((e) => Listing.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.listings) {
      obj.listings = message.listings.map((e) => e ? Listing.toJSON(e) : void 0);
    } else {
      obj.listings = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseListingResponse();
    message.listings = object.listings?.map((e) => Listing.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.listings.ListingResponse", ListingResponse);
function isSet86(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/listings/listings_svc.js
var import_minimal97 = __toESM(require_minimal2(), 1);
var ListingsDefinition = {
  name: "Listings",
  fullName: "devvit.plugin.redditapi.listings.Listings",
  methods: {
    /**
     * Home listing
     *
     * @see {@link https://www.reddit.com/dev/api#GET_best}
     */
    best: {
      name: "Best",
      requestType: GetBestRequest,
      requestStream: false,
      responseType: Listing,
      responseStream: false,
      options: {}
    },
    /**
     * Create a custom listing with the Post IDs provided
     *
     * @see {@link https://www.reddit.com/dev/api#GET_by_id_\{names\}}
     */
    byId: {
      name: "ById",
      requestType: GetByIdRequest,
      requestStream: false,
      responseType: Listing,
      responseStream: false,
      options: {}
    },
    /**
     * Get a comment tree for a Post
     *
     * @see {@link https://www.reddit.com/dev/api#GET_comments_\{article\}}
     */
    comments: {
      name: "Comments",
      requestType: GetCommentsRequest,
      requestStream: false,
      responseType: ListingResponse,
      responseStream: false,
      options: {}
    },
    /**
     * Find duplicate posts that reference the same URL as this Post
     *
     * @see {@link https://www.reddit.com/dev/api#GET_duplicates_\{article\}}
     */
    duplicates: {
      name: "Duplicates",
      requestType: GetDuplicatesRequest,
      requestStream: false,
      responseType: ListingResponse,
      responseStream: false,
      options: {}
    },
    /**
     * Listing with Hot sort
     *
     * @see {@link https://www.reddit.com/dev/api#GET_hot}
     */
    hot: {
      name: "Hot",
      requestType: GetHotRequest,
      requestStream: false,
      responseType: Listing,
      responseStream: false,
      options: {}
    },
    /**
     * Listing with New sort
     *
     * @see {@link https://www.reddit.com/dev/api#GET_new}
     */
    new: {
      name: "New",
      requestType: GetNewRequest,
      requestStream: false,
      responseType: Listing,
      responseStream: false,
      options: {}
    },
    /**
     * Listing with Rising sort
     *
     * @see {@link https://www.reddit.com/dev/api#GET_rising}
     */
    rising: {
      name: "Rising",
      requestType: GetRisingRequest,
      requestStream: false,
      responseType: Listing,
      responseStream: false,
      options: {}
    },
    /**
     * Listing with Top or Controversial sort
     *
     * @see {@link https://www.reddit.com/dev/api#GET_\{sort\}}
     */
    sort: {
      name: "Sort",
      requestType: GetSortRequest,
      requestStream: false,
      responseType: Listing,
      responseStream: false,
      options: {}
    }
  }
};

// ../protos/dist/types/devvit/plugin/redditapi/moderation/moderation_msg.js
var import_minimal98 = __toESM(require_minimal2(), 1);
function createBaseAboutLogRequest() {
  return {
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    show: void 0,
    mod: void 0,
    type: void 0,
    subreddit: void 0
  };
}
var AboutLogRequest = {
  $type: "devvit.plugin.redditapi.moderation.AboutLogRequest",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
    }
    if (message.mod !== void 0) {
      StringValue.encode({ value: message.mod }, writer.uint32(50).fork()).ldelim();
    }
    if (message.type !== void 0) {
      StringValue.encode({ value: message.type }, writer.uint32(66).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutLogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.mod = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.type = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet87(object.after) ? String(object.after) : void 0,
      before: isSet87(object.before) ? String(object.before) : void 0,
      count: isSet87(object.count) ? Number(object.count) : void 0,
      limit: isSet87(object.limit) ? Number(object.limit) : void 0,
      show: isSet87(object.show) ? String(object.show) : void 0,
      mod: isSet87(object.mod) ? String(object.mod) : void 0,
      type: isSet87(object.type) ? String(object.type) : void 0,
      subreddit: isSet87(object.subreddit) ? String(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.count !== void 0 && (obj.count = message.count);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.show !== void 0 && (obj.show = message.show);
    message.mod !== void 0 && (obj.mod = message.mod);
    message.type !== void 0 && (obj.type = message.type);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAboutLogRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.show = object.show ?? void 0;
    message.mod = object.mod ?? void 0;
    message.type = object.type ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AboutLogRequest", AboutLogRequest);
function createBaseAboutLocationRequest() {
  return {
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    location: "",
    only: void 0,
    show: void 0,
    subreddit: ""
  };
}
var AboutLocationRequest = {
  $type: "devvit.plugin.redditapi.moderation.AboutLocationRequest",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.location !== "") {
      writer.uint32(42).string(message.location);
    }
    if (message.only !== void 0) {
      StringValue.encode({ value: message.only }, writer.uint32(50).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
    }
    if (message.subreddit !== "") {
      writer.uint32(66).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutLocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.location = reader.string();
          break;
        case 6:
          message.only = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet87(object.after) ? String(object.after) : void 0,
      before: isSet87(object.before) ? String(object.before) : void 0,
      count: isSet87(object.count) ? Number(object.count) : void 0,
      limit: isSet87(object.limit) ? Number(object.limit) : void 0,
      location: isSet87(object.location) ? String(object.location) : "",
      only: isSet87(object.only) ? String(object.only) : void 0,
      show: isSet87(object.show) ? String(object.show) : void 0,
      subreddit: isSet87(object.subreddit) ? String(object.subreddit) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.count !== void 0 && (obj.count = message.count);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.location !== void 0 && (obj.location = message.location);
    message.only !== void 0 && (obj.only = message.only);
    message.show !== void 0 && (obj.show = message.show);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAboutLocationRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.location = object.location ?? "";
    message.only = object.only ?? void 0;
    message.show = object.show ?? void 0;
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AboutLocationRequest", AboutLocationRequest);
function createBaseAcceptModeratorInviteRequest() {
  return { subreddit: "" };
}
var AcceptModeratorInviteRequest = {
  $type: "devvit.plugin.redditapi.moderation.AcceptModeratorInviteRequest",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAcceptModeratorInviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet87(object.subreddit) ? String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAcceptModeratorInviteRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AcceptModeratorInviteRequest", AcceptModeratorInviteRequest);
function createBaseBasicModerationIdRequest() {
  return { id: "" };
}
var BasicModerationIdRequest = {
  $type: "devvit.plugin.redditapi.moderation.BasicModerationIdRequest",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicModerationIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet87(object.id) ? String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBasicModerationIdRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.BasicModerationIdRequest", BasicModerationIdRequest);
function createBaseDistinguishRequest() {
  return { how: "", id: "", sticky: false };
}
var DistinguishRequest = {
  $type: "devvit.plugin.redditapi.moderation.DistinguishRequest",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.how !== "") {
      writer.uint32(10).string(message.how);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.sticky === true) {
      writer.uint32(24).bool(message.sticky);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDistinguishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.how = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.sticky = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      how: isSet87(object.how) ? String(object.how) : "",
      id: isSet87(object.id) ? String(object.id) : "",
      sticky: isSet87(object.sticky) ? Boolean(object.sticky) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.how !== void 0 && (obj.how = message.how);
    message.id !== void 0 && (obj.id = message.id);
    message.sticky !== void 0 && (obj.sticky = message.sticky);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDistinguishRequest();
    message.how = object.how ?? "";
    message.id = object.id ?? "";
    message.sticky = object.sticky ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.DistinguishRequest", DistinguishRequest);
function createBaseRemoveRequest() {
  return { id: "", spam: false };
}
var RemoveRequest = {
  $type: "devvit.plugin.redditapi.moderation.RemoveRequest",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.spam === true) {
      writer.uint32(16).bool(message.spam);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.spam = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet87(object.id) ? String(object.id) : "", spam: isSet87(object.spam) ? Boolean(object.spam) : false };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.spam !== void 0 && (obj.spam = message.spam);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRemoveRequest();
    message.id = object.id ?? "";
    message.spam = object.spam ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.RemoveRequest", RemoveRequest);
function createBaseSnoozeReportsRequest() {
  return { id: "", reason: "" };
}
var SnoozeReportsRequest = {
  $type: "devvit.plugin.redditapi.moderation.SnoozeReportsRequest",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnoozeReportsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.reason = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet87(object.id) ? String(object.id) : "", reason: isSet87(object.reason) ? String(object.reason) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.reason !== void 0 && (obj.reason = message.reason);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSnoozeReportsRequest();
    message.id = object.id ?? "";
    message.reason = object.reason ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.SnoozeReportsRequest", SnoozeReportsRequest);
function createBaseUpdateCrowdControlLevelRequest() {
  return { id: "", level: 0 };
}
var UpdateCrowdControlLevelRequest = {
  $type: "devvit.plugin.redditapi.moderation.UpdateCrowdControlLevelRequest",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCrowdControlLevelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.level = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet87(object.id) ? String(object.id) : "", level: isSet87(object.level) ? Number(object.level) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.level !== void 0 && (obj.level = Math.round(message.level));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateCrowdControlLevelRequest();
    message.id = object.id ?? "";
    message.level = object.level ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.UpdateCrowdControlLevelRequest", UpdateCrowdControlLevelRequest);
function createBaseStylesheetRequest() {
  return { subreddit: "" };
}
var StylesheetRequest = {
  $type: "devvit.plugin.redditapi.moderation.StylesheetRequest",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStylesheetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet87(object.subreddit) ? String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStylesheetRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.StylesheetRequest", StylesheetRequest);
function createBaseAboutLogResponse() {
  return { kind: "", data: void 0 };
}
var AboutLogResponse = {
  $type: "devvit.plugin.redditapi.moderation.AboutLogResponse",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      AboutLogResponse_AboutLogListing.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutLogResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.data = AboutLogResponse_AboutLogListing.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet87(object.kind) ? String(object.kind) : "",
      data: isSet87(object.data) ? AboutLogResponse_AboutLogListing.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? AboutLogResponse_AboutLogListing.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAboutLogResponse();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? AboutLogResponse_AboutLogListing.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AboutLogResponse", AboutLogResponse);
function createBaseAboutLogResponse_LogObject() {
  return {
    description: void 0,
    targetBody: void 0,
    modId36: void 0,
    createdUtc: void 0,
    subreddit: void 0,
    targetTitle: void 0,
    targetPermalink: void 0,
    subredditNamePrefixed: void 0,
    details: void 0,
    action: void 0,
    targetAuthor: void 0,
    targetFullname: void 0,
    srId36: void 0,
    id: void 0,
    mod: void 0
  };
}
var AboutLogResponse_LogObject = {
  $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.LogObject",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(10).fork()).ldelim();
    }
    if (message.targetBody !== void 0) {
      StringValue.encode({ value: message.targetBody }, writer.uint32(18).fork()).ldelim();
    }
    if (message.modId36 !== void 0) {
      StringValue.encode({ value: message.modId36 }, writer.uint32(26).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(34).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.targetTitle !== void 0) {
      StringValue.encode({ value: message.targetTitle }, writer.uint32(50).fork()).ldelim();
    }
    if (message.targetPermalink !== void 0) {
      StringValue.encode({ value: message.targetPermalink }, writer.uint32(58).fork()).ldelim();
    }
    if (message.subredditNamePrefixed !== void 0) {
      StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(66).fork()).ldelim();
    }
    if (message.details !== void 0) {
      StringValue.encode({ value: message.details }, writer.uint32(74).fork()).ldelim();
    }
    if (message.action !== void 0) {
      StringValue.encode({ value: message.action }, writer.uint32(82).fork()).ldelim();
    }
    if (message.targetAuthor !== void 0) {
      StringValue.encode({ value: message.targetAuthor }, writer.uint32(90).fork()).ldelim();
    }
    if (message.targetFullname !== void 0) {
      StringValue.encode({ value: message.targetFullname }, writer.uint32(98).fork()).ldelim();
    }
    if (message.srId36 !== void 0) {
      StringValue.encode({ value: message.srId36 }, writer.uint32(106).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(114).fork()).ldelim();
    }
    if (message.mod !== void 0) {
      StringValue.encode({ value: message.mod }, writer.uint32(122).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutLogResponse_LogObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.targetBody = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.modId36 = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.targetTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.targetPermalink = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.details = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.action = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.targetAuthor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.targetFullname = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.srId36 = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.mod = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      description: isSet87(object.description) ? String(object.description) : void 0,
      targetBody: isSet87(object.targetBody) ? String(object.targetBody) : void 0,
      modId36: isSet87(object.modId36) ? String(object.modId36) : void 0,
      createdUtc: isSet87(object.createdUtc) ? Number(object.createdUtc) : void 0,
      subreddit: isSet87(object.subreddit) ? String(object.subreddit) : void 0,
      targetTitle: isSet87(object.targetTitle) ? String(object.targetTitle) : void 0,
      targetPermalink: isSet87(object.targetPermalink) ? String(object.targetPermalink) : void 0,
      subredditNamePrefixed: isSet87(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : void 0,
      details: isSet87(object.details) ? String(object.details) : void 0,
      action: isSet87(object.action) ? String(object.action) : void 0,
      targetAuthor: isSet87(object.targetAuthor) ? String(object.targetAuthor) : void 0,
      targetFullname: isSet87(object.targetFullname) ? String(object.targetFullname) : void 0,
      srId36: isSet87(object.srId36) ? String(object.srId36) : void 0,
      id: isSet87(object.id) ? String(object.id) : void 0,
      mod: isSet87(object.mod) ? String(object.mod) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.description !== void 0 && (obj.description = message.description);
    message.targetBody !== void 0 && (obj.targetBody = message.targetBody);
    message.modId36 !== void 0 && (obj.modId36 = message.modId36);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.targetTitle !== void 0 && (obj.targetTitle = message.targetTitle);
    message.targetPermalink !== void 0 && (obj.targetPermalink = message.targetPermalink);
    message.subredditNamePrefixed !== void 0 && (obj.subredditNamePrefixed = message.subredditNamePrefixed);
    message.details !== void 0 && (obj.details = message.details);
    message.action !== void 0 && (obj.action = message.action);
    message.targetAuthor !== void 0 && (obj.targetAuthor = message.targetAuthor);
    message.targetFullname !== void 0 && (obj.targetFullname = message.targetFullname);
    message.srId36 !== void 0 && (obj.srId36 = message.srId36);
    message.id !== void 0 && (obj.id = message.id);
    message.mod !== void 0 && (obj.mod = message.mod);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAboutLogResponse_LogObject();
    message.description = object.description ?? void 0;
    message.targetBody = object.targetBody ?? void 0;
    message.modId36 = object.modId36 ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.targetTitle = object.targetTitle ?? void 0;
    message.targetPermalink = object.targetPermalink ?? void 0;
    message.subredditNamePrefixed = object.subredditNamePrefixed ?? void 0;
    message.details = object.details ?? void 0;
    message.action = object.action ?? void 0;
    message.targetAuthor = object.targetAuthor ?? void 0;
    message.targetFullname = object.targetFullname ?? void 0;
    message.srId36 = object.srId36 ?? void 0;
    message.id = object.id ?? void 0;
    message.mod = object.mod ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AboutLogResponse.LogObject", AboutLogResponse_LogObject);
function createBaseAboutLogResponse_AboutLogListing() {
  return { after: void 0, before: void 0, children: [], dist: void 0 };
}
var AboutLogResponse_AboutLogListing = {
  $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.children) {
      AboutLogResponse_AboutLogListing_WrappedLogObject.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int32Value.encode({ value: message.dist }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutLogResponse_AboutLogListing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.children.push(AboutLogResponse_AboutLogListing_WrappedLogObject.decode(reader, reader.uint32()));
          break;
        case 4:
          message.dist = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet87(object.after) ? String(object.after) : void 0,
      before: isSet87(object.before) ? String(object.before) : void 0,
      children: Array.isArray(object?.children) ? object.children.map((e) => AboutLogResponse_AboutLogListing_WrappedLogObject.fromJSON(e)) : [],
      dist: isSet87(object.dist) ? Number(object.dist) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    if (message.children) {
      obj.children = message.children.map((e) => e ? AboutLogResponse_AboutLogListing_WrappedLogObject.toJSON(e) : void 0);
    } else {
      obj.children = [];
    }
    message.dist !== void 0 && (obj.dist = message.dist);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAboutLogResponse_AboutLogListing();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.children = object.children?.map((e) => AboutLogResponse_AboutLogListing_WrappedLogObject.fromPartial(e)) || [];
    message.dist = object.dist ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing", AboutLogResponse_AboutLogListing);
function createBaseAboutLogResponse_AboutLogListing_WrappedLogObject() {
  return { kind: "", data: void 0 };
}
var AboutLogResponse_AboutLogListing_WrappedLogObject = {
  $type: "devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing.WrappedLogObject",
  encode(message, writer = import_minimal98.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      AboutLogResponse_LogObject.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal98.default.Reader ? input : new import_minimal98.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutLogResponse_AboutLogListing_WrappedLogObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.data = AboutLogResponse_LogObject.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet87(object.kind) ? String(object.kind) : "",
      data: isSet87(object.data) ? AboutLogResponse_LogObject.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? AboutLogResponse_LogObject.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAboutLogResponse_AboutLogListing_WrappedLogObject();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? AboutLogResponse_LogObject.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.moderation.AboutLogResponse.AboutLogListing.WrappedLogObject", AboutLogResponse_AboutLogListing_WrappedLogObject);
function isSet87(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/moderation/moderation_svc.js
var import_minimal99 = __toESM(require_minimal2(), 1);
var ModerationDefinition = {
  name: "Moderation",
  fullName: "devvit.plugin.redditapi.moderation.Moderation",
  methods: {
    /** https://www.reddit.com/dev/api#GET_about_log */
    aboutLog: {
      name: "AboutLog",
      requestType: AboutLogRequest,
      requestStream: false,
      responseType: AboutLogResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_about_\{location\} */
    aboutLocation: {
      name: "AboutLocation",
      requestType: AboutLocationRequest,
      requestStream: false,
      responseType: Listing,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_accept_moderator_invite */
    acceptModeratorInvite: {
      name: "AcceptModeratorInvite",
      requestType: AcceptModeratorInviteRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_approve */
    approve: {
      name: "Approve",
      requestType: BasicModerationIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_distinguish */
    distinguish: {
      name: "Distinguish",
      requestType: DistinguishRequest,
      requestStream: false,
      responseType: JsonRedditObjects,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_ignore_reports */
    ignoreReports: {
      name: "IgnoreReports",
      requestType: BasicModerationIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_leavecontributor */
    leaveContributor: {
      name: "LeaveContributor",
      requestType: BasicModerationIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_leavemoderator */
    leaveModerator: {
      name: "LeaveModerator",
      requestType: BasicModerationIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mute_message_author */
    muteMessageAuthor: {
      name: "MuteMessageAuthor",
      requestType: BasicModerationIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_remove */
    remove: {
      name: "Remove",
      requestType: RemoveRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_show_comment */
    showComment: {
      name: "ShowComment",
      requestType: BasicModerationIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_snooze_reports */
    snoozeReports: {
      name: "SnoozeReports",
      requestType: SnoozeReportsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_unignore_reports */
    unignoreReports: {
      name: "UnignoreReports",
      requestType: BasicModerationIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_unmute_message_author */
    unmuteMessageAuthor: {
      name: "UnmuteMessageAuthor",
      requestType: BasicModerationIdRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_unsnooze_reports */
    unsnoozeReports: {
      name: "UnsnoozeReports",
      requestType: SnoozeReportsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_update_crowd_control_level */
    updateCrowdControlLevel: {
      name: "UpdateCrowdControlLevel",
      requestType: UpdateCrowdControlLevelRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_stylesheet */
    stylesheet: {
      name: "Stylesheet",
      requestType: StylesheetRequest,
      requestStream: false,
      responseType: StringValue,
      responseStream: false,
      options: {}
    }
  }
};

// ../protos/dist/types/devvit/plugin/redditapi/modnote/modnote_msg.js
var import_minimal100 = __toESM(require_minimal2(), 1);
function createBaseDeleteNotesRequest() {
  return { subreddit: "", noteId: "", user: "" };
}
var DeleteNotesRequest = {
  $type: "devvit.plugin.redditapi.modnote.DeleteNotesRequest",
  encode(message, writer = import_minimal100.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.noteId !== "") {
      writer.uint32(18).string(message.noteId);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal100.default.Reader ? input : new import_minimal100.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteNotesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.noteId = reader.string();
          break;
        case 3:
          message.user = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet88(object.subreddit) ? String(object.subreddit) : "",
      noteId: isSet88(object.noteId) ? String(object.noteId) : "",
      user: isSet88(object.user) ? String(object.user) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.noteId !== void 0 && (obj.noteId = message.noteId);
    message.user !== void 0 && (obj.user = message.user);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDeleteNotesRequest();
    message.subreddit = object.subreddit ?? "";
    message.noteId = object.noteId ?? "";
    message.user = object.user ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.DeleteNotesRequest", DeleteNotesRequest);
function createBaseGetNotesRequest() {
  return { subreddit: "", before: void 0, filter: void 0, limit: void 0, user: "" };
}
var GetNotesRequest = {
  $type: "devvit.plugin.redditapi.modnote.GetNotesRequest",
  encode(message, writer = import_minimal100.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.filter !== void 0) {
      StringValue.encode({ value: message.filter }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.user !== "") {
      writer.uint32(42).string(message.user);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal100.default.Reader ? input : new import_minimal100.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetNotesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.filter = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.user = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet88(object.subreddit) ? String(object.subreddit) : "",
      before: isSet88(object.before) ? String(object.before) : void 0,
      filter: isSet88(object.filter) ? String(object.filter) : void 0,
      limit: isSet88(object.limit) ? Number(object.limit) : void 0,
      user: isSet88(object.user) ? String(object.user) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.before !== void 0 && (obj.before = message.before);
    message.filter !== void 0 && (obj.filter = message.filter);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.user !== void 0 && (obj.user = message.user);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetNotesRequest();
    message.subreddit = object.subreddit ?? "";
    message.before = object.before ?? void 0;
    message.filter = object.filter ?? void 0;
    message.limit = object.limit ?? void 0;
    message.user = object.user ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.GetNotesRequest", GetNotesRequest);
function createBasePostNotesRequest() {
  return { subreddit: "", label: "", note: "", redditId: void 0, user: "" };
}
var PostNotesRequest = {
  $type: "devvit.plugin.redditapi.modnote.PostNotesRequest",
  encode(message, writer = import_minimal100.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.note !== "") {
      writer.uint32(26).string(message.note);
    }
    if (message.redditId !== void 0) {
      StringValue.encode({ value: message.redditId }, writer.uint32(34).fork()).ldelim();
    }
    if (message.user !== "") {
      writer.uint32(42).string(message.user);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal100.default.Reader ? input : new import_minimal100.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostNotesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.label = reader.string();
          break;
        case 3:
          message.note = reader.string();
          break;
        case 4:
          message.redditId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.user = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet88(object.subreddit) ? String(object.subreddit) : "",
      label: isSet88(object.label) ? String(object.label) : "",
      note: isSet88(object.note) ? String(object.note) : "",
      redditId: isSet88(object.redditId) ? String(object.redditId) : void 0,
      user: isSet88(object.user) ? String(object.user) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.label !== void 0 && (obj.label = message.label);
    message.note !== void 0 && (obj.note = message.note);
    message.redditId !== void 0 && (obj.redditId = message.redditId);
    message.user !== void 0 && (obj.user = message.user);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePostNotesRequest();
    message.subreddit = object.subreddit ?? "";
    message.label = object.label ?? "";
    message.note = object.note ?? "";
    message.redditId = object.redditId ?? void 0;
    message.user = object.user ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.PostNotesRequest", PostNotesRequest);
function createBaseRecentNotesRequest() {
  return { subreddits: "", users: "" };
}
var RecentNotesRequest = {
  $type: "devvit.plugin.redditapi.modnote.RecentNotesRequest",
  encode(message, writer = import_minimal100.default.Writer.create()) {
    if (message.subreddits !== "") {
      writer.uint32(10).string(message.subreddits);
    }
    if (message.users !== "") {
      writer.uint32(18).string(message.users);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal100.default.Reader ? input : new import_minimal100.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRecentNotesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddits = reader.string();
          break;
        case 2:
          message.users = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddits: isSet88(object.subreddits) ? String(object.subreddits) : "",
      users: isSet88(object.users) ? String(object.users) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddits !== void 0 && (obj.subreddits = message.subreddits);
    message.users !== void 0 && (obj.users = message.users);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRecentNotesRequest();
    message.subreddits = object.subreddits ?? "";
    message.users = object.users ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.RecentNotesRequest", RecentNotesRequest);
function createBasePostRemovalNoteRequest() {
  return { itemIds: [], reasonId: "", modNote: void 0 };
}
var PostRemovalNoteRequest = {
  $type: "devvit.plugin.redditapi.modnote.PostRemovalNoteRequest",
  encode(message, writer = import_minimal100.default.Writer.create()) {
    for (const v of message.itemIds) {
      writer.uint32(10).string(v);
    }
    if (message.reasonId !== "") {
      writer.uint32(18).string(message.reasonId);
    }
    if (message.modNote !== void 0) {
      StringValue.encode({ value: message.modNote }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal100.default.Reader ? input : new import_minimal100.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostRemovalNoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemIds.push(reader.string());
          break;
        case 2:
          message.reasonId = reader.string();
          break;
        case 3:
          message.modNote = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      itemIds: Array.isArray(object?.itemIds) ? object.itemIds.map((e) => String(e)) : [],
      reasonId: isSet88(object.reasonId) ? String(object.reasonId) : "",
      modNote: isSet88(object.modNote) ? String(object.modNote) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.itemIds) {
      obj.itemIds = message.itemIds.map((e) => e);
    } else {
      obj.itemIds = [];
    }
    message.reasonId !== void 0 && (obj.reasonId = message.reasonId);
    message.modNote !== void 0 && (obj.modNote = message.modNote);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePostRemovalNoteRequest();
    message.itemIds = object.itemIds?.map((e) => e) || [];
    message.reasonId = object.reasonId ?? "";
    message.modNote = object.modNote ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.PostRemovalNoteRequest", PostRemovalNoteRequest);
function createBaseModNotesResponse() {
  return { modNotes: [], startCursor: void 0, endCursor: void 0, hasNextPage: void 0 };
}
var ModNotesResponse = {
  $type: "devvit.plugin.redditapi.modnote.ModNotesResponse",
  encode(message, writer = import_minimal100.default.Writer.create()) {
    for (const v of message.modNotes) {
      ModNoteObject.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.startCursor !== void 0) {
      StringValue.encode({ value: message.startCursor }, writer.uint32(18).fork()).ldelim();
    }
    if (message.endCursor !== void 0) {
      StringValue.encode({ value: message.endCursor }, writer.uint32(26).fork()).ldelim();
    }
    if (message.hasNextPage !== void 0) {
      BoolValue.encode({ value: message.hasNextPage }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal100.default.Reader ? input : new import_minimal100.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModNotesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.modNotes.push(ModNoteObject.decode(reader, reader.uint32()));
          break;
        case 2:
          message.startCursor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.endCursor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.hasNextPage = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      modNotes: Array.isArray(object?.modNotes) ? object.modNotes.map((e) => ModNoteObject.fromJSON(e)) : [],
      startCursor: isSet88(object.startCursor) ? String(object.startCursor) : void 0,
      endCursor: isSet88(object.endCursor) ? String(object.endCursor) : void 0,
      hasNextPage: isSet88(object.hasNextPage) ? Boolean(object.hasNextPage) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.modNotes) {
      obj.modNotes = message.modNotes.map((e) => e ? ModNoteObject.toJSON(e) : void 0);
    } else {
      obj.modNotes = [];
    }
    message.startCursor !== void 0 && (obj.startCursor = message.startCursor);
    message.endCursor !== void 0 && (obj.endCursor = message.endCursor);
    message.hasNextPage !== void 0 && (obj.hasNextPage = message.hasNextPage);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseModNotesResponse();
    message.modNotes = object.modNotes?.map((e) => ModNoteObject.fromPartial(e)) || [];
    message.startCursor = object.startCursor ?? void 0;
    message.endCursor = object.endCursor ?? void 0;
    message.hasNextPage = object.hasNextPage ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.ModNotesResponse", ModNotesResponse);
function createBaseDeleteNotesResponse() {
  return { deleted: void 0 };
}
var DeleteNotesResponse = {
  $type: "devvit.plugin.redditapi.modnote.DeleteNotesResponse",
  encode(message, writer = import_minimal100.default.Writer.create()) {
    if (message.deleted !== void 0) {
      BoolValue.encode({ value: message.deleted }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal100.default.Reader ? input : new import_minimal100.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteNotesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.deleted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { deleted: isSet88(object.deleted) ? Boolean(object.deleted) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.deleted !== void 0 && (obj.deleted = message.deleted);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDeleteNotesResponse();
    message.deleted = object.deleted ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.DeleteNotesResponse", DeleteNotesResponse);
function createBaseModNoteObject() {
  return {
    subredditId: void 0,
    operatorId: void 0,
    modActionData: void 0,
    userNoteData: void 0,
    subreddit: void 0,
    user: void 0,
    operator: void 0,
    id: void 0,
    userId: void 0,
    createdAt: void 0,
    cursor: void 0,
    type: void 0
  };
}
var ModNoteObject = {
  $type: "devvit.plugin.redditapi.modnote.ModNoteObject",
  encode(message, writer = import_minimal100.default.Writer.create()) {
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.operatorId !== void 0) {
      StringValue.encode({ value: message.operatorId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.modActionData !== void 0) {
      ModNoteObject_ModActionData.encode(message.modActionData, writer.uint32(26).fork()).ldelim();
    }
    if (message.userNoteData !== void 0) {
      ModNoteObject_UserNoteData.encode(message.userNoteData, writer.uint32(34).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.user !== void 0) {
      StringValue.encode({ value: message.user }, writer.uint32(50).fork()).ldelim();
    }
    if (message.operator !== void 0) {
      StringValue.encode({ value: message.operator }, writer.uint32(58).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(66).fork()).ldelim();
    }
    if (message.userId !== void 0) {
      StringValue.encode({ value: message.userId }, writer.uint32(74).fork()).ldelim();
    }
    if (message.createdAt !== void 0) {
      Int64Value.encode({ value: message.createdAt }, writer.uint32(82).fork()).ldelim();
    }
    if (message.cursor !== void 0) {
      StringValue.encode({ value: message.cursor }, writer.uint32(90).fork()).ldelim();
    }
    if (message.type !== void 0) {
      StringValue.encode({ value: message.type }, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal100.default.Reader ? input : new import_minimal100.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModNoteObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.operatorId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.modActionData = ModNoteObject_ModActionData.decode(reader, reader.uint32());
          break;
        case 4:
          message.userNoteData = ModNoteObject_UserNoteData.decode(reader, reader.uint32());
          break;
        case 5:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.user = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.operator = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.userId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.createdAt = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.cursor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.type = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subredditId: isSet88(object.subredditId) ? String(object.subredditId) : void 0,
      operatorId: isSet88(object.operatorId) ? String(object.operatorId) : void 0,
      modActionData: isSet88(object.modActionData) ? ModNoteObject_ModActionData.fromJSON(object.modActionData) : void 0,
      userNoteData: isSet88(object.userNoteData) ? ModNoteObject_UserNoteData.fromJSON(object.userNoteData) : void 0,
      subreddit: isSet88(object.subreddit) ? String(object.subreddit) : void 0,
      user: isSet88(object.user) ? String(object.user) : void 0,
      operator: isSet88(object.operator) ? String(object.operator) : void 0,
      id: isSet88(object.id) ? String(object.id) : void 0,
      userId: isSet88(object.userId) ? String(object.userId) : void 0,
      createdAt: isSet88(object.createdAt) ? Number(object.createdAt) : void 0,
      cursor: isSet88(object.cursor) ? String(object.cursor) : void 0,
      type: isSet88(object.type) ? String(object.type) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subredditId !== void 0 && (obj.subredditId = message.subredditId);
    message.operatorId !== void 0 && (obj.operatorId = message.operatorId);
    message.modActionData !== void 0 && (obj.modActionData = message.modActionData ? ModNoteObject_ModActionData.toJSON(message.modActionData) : void 0);
    message.userNoteData !== void 0 && (obj.userNoteData = message.userNoteData ? ModNoteObject_UserNoteData.toJSON(message.userNoteData) : void 0);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.user !== void 0 && (obj.user = message.user);
    message.operator !== void 0 && (obj.operator = message.operator);
    message.id !== void 0 && (obj.id = message.id);
    message.userId !== void 0 && (obj.userId = message.userId);
    message.createdAt !== void 0 && (obj.createdAt = message.createdAt);
    message.cursor !== void 0 && (obj.cursor = message.cursor);
    message.type !== void 0 && (obj.type = message.type);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseModNoteObject();
    message.subredditId = object.subredditId ?? void 0;
    message.operatorId = object.operatorId ?? void 0;
    message.modActionData = object.modActionData !== void 0 && object.modActionData !== null ? ModNoteObject_ModActionData.fromPartial(object.modActionData) : void 0;
    message.userNoteData = object.userNoteData !== void 0 && object.userNoteData !== null ? ModNoteObject_UserNoteData.fromPartial(object.userNoteData) : void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.user = object.user ?? void 0;
    message.operator = object.operator ?? void 0;
    message.id = object.id ?? void 0;
    message.userId = object.userId ?? void 0;
    message.createdAt = object.createdAt ?? void 0;
    message.cursor = object.cursor ?? void 0;
    message.type = object.type ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.ModNoteObject", ModNoteObject);
function createBaseModNoteObject_ModActionData() {
  return { action: void 0, redditId: void 0, details: void 0, description: void 0 };
}
var ModNoteObject_ModActionData = {
  $type: "devvit.plugin.redditapi.modnote.ModNoteObject.ModActionData",
  encode(message, writer = import_minimal100.default.Writer.create()) {
    if (message.action !== void 0) {
      StringValue.encode({ value: message.action }, writer.uint32(10).fork()).ldelim();
    }
    if (message.redditId !== void 0) {
      StringValue.encode({ value: message.redditId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.details !== void 0) {
      StringValue.encode({ value: message.details }, writer.uint32(26).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal100.default.Reader ? input : new import_minimal100.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModNoteObject_ModActionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.action = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.redditId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.details = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      action: isSet88(object.action) ? String(object.action) : void 0,
      redditId: isSet88(object.redditId) ? String(object.redditId) : void 0,
      details: isSet88(object.details) ? String(object.details) : void 0,
      description: isSet88(object.description) ? String(object.description) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.action !== void 0 && (obj.action = message.action);
    message.redditId !== void 0 && (obj.redditId = message.redditId);
    message.details !== void 0 && (obj.details = message.details);
    message.description !== void 0 && (obj.description = message.description);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseModNoteObject_ModActionData();
    message.action = object.action ?? void 0;
    message.redditId = object.redditId ?? void 0;
    message.details = object.details ?? void 0;
    message.description = object.description ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.ModNoteObject.ModActionData", ModNoteObject_ModActionData);
function createBaseModNoteObject_UserNoteData() {
  return { note: void 0, redditId: void 0, label: void 0 };
}
var ModNoteObject_UserNoteData = {
  $type: "devvit.plugin.redditapi.modnote.ModNoteObject.UserNoteData",
  encode(message, writer = import_minimal100.default.Writer.create()) {
    if (message.note !== void 0) {
      StringValue.encode({ value: message.note }, writer.uint32(10).fork()).ldelim();
    }
    if (message.redditId !== void 0) {
      StringValue.encode({ value: message.redditId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.label !== void 0) {
      StringValue.encode({ value: message.label }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal100.default.Reader ? input : new import_minimal100.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModNoteObject_UserNoteData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.note = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.redditId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.label = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      note: isSet88(object.note) ? String(object.note) : void 0,
      redditId: isSet88(object.redditId) ? String(object.redditId) : void 0,
      label: isSet88(object.label) ? String(object.label) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.note !== void 0 && (obj.note = message.note);
    message.redditId !== void 0 && (obj.redditId = message.redditId);
    message.label !== void 0 && (obj.label = message.label);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseModNoteObject_UserNoteData();
    message.note = object.note ?? void 0;
    message.redditId = object.redditId ?? void 0;
    message.label = object.label ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.ModNoteObject.UserNoteData", ModNoteObject_UserNoteData);
function createBasePostModNotesResponse() {
  return { created: void 0 };
}
var PostModNotesResponse = {
  $type: "devvit.plugin.redditapi.modnote.PostModNotesResponse",
  encode(message, writer = import_minimal100.default.Writer.create()) {
    if (message.created !== void 0) {
      ModNoteObject.encode(message.created, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal100.default.Reader ? input : new import_minimal100.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostModNotesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.created = ModNoteObject.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { created: isSet88(object.created) ? ModNoteObject.fromJSON(object.created) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.created !== void 0 && (obj.created = message.created ? ModNoteObject.toJSON(message.created) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePostModNotesResponse();
    message.created = object.created !== void 0 && object.created !== null ? ModNoteObject.fromPartial(object.created) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.modnote.PostModNotesResponse", PostModNotesResponse);
function isSet88(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/modnote/modnote_svc.js
var import_minimal101 = __toESM(require_minimal2(), 1);
var ModNoteDefinition = {
  name: "ModNote",
  fullName: "devvit.plugin.redditapi.modnote.ModNote",
  methods: {
    /** @see {@link https://www.reddit.com/dev/api#GET_api_mod_notes} */
    getNotes: {
      name: "GetNotes",
      requestType: GetNotesRequest,
      requestStream: false,
      responseType: ModNotesResponse,
      responseStream: false,
      options: {}
    },
    /** @see {@link https://www.reddit.com/dev/api/#DELETE_api_mod_notes} */
    deleteNotes: {
      name: "DeleteNotes",
      requestType: DeleteNotesRequest,
      requestStream: false,
      responseType: DeleteNotesResponse,
      responseStream: false,
      options: {}
    },
    /** @see {@link https://www.reddit.com/dev/api#POST_api_mod_notes} */
    postNotes: {
      name: "PostNotes",
      requestType: PostNotesRequest,
      requestStream: false,
      responseType: PostModNotesResponse,
      responseStream: false,
      options: {}
    },
    /** Add a mod note for why a post or comment was removed */
    postRemovalNote: {
      name: "PostRemovalNote",
      requestType: PostRemovalNoteRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** @see {@link https://www.reddit.com/dev/api#GET_api_mod_notes_recent} */
    recentNotes: {
      name: "RecentNotes",
      requestType: RecentNotesRequest,
      requestStream: false,
      responseType: ModNotesResponse,
      responseStream: false,
      options: {}
    }
  }
};

// ../protos/dist/types/devvit/plugin/redditapi/newmodmail/newmodmail_msg.js
var import_minimal102 = __toESM(require_minimal2(), 1);
function createBaseConversationData() {
  return {
    isAuto: void 0,
    participant: void 0,
    objIds: [],
    isRepliable: void 0,
    lastUserUpdate: void 0,
    isInternal: void 0,
    lastModUpdate: void 0,
    authors: [],
    lastUpdated: void 0,
    legacyFirstMessageId: void 0,
    state: void 0,
    conversationType: void 0,
    lastUnread: void 0,
    owner: void 0,
    subject: void 0,
    id: void 0,
    isHighlighted: void 0,
    numMessages: void 0,
    modActions: {}
  };
}
var ConversationData = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationData",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.isAuto !== void 0) {
      BoolValue.encode({ value: message.isAuto }, writer.uint32(10).fork()).ldelim();
    }
    if (message.participant !== void 0) {
      Participant.encode(message.participant, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.objIds) {
      ConversationData_ObjId.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.isRepliable !== void 0) {
      BoolValue.encode({ value: message.isRepliable }, writer.uint32(34).fork()).ldelim();
    }
    if (message.lastUserUpdate !== void 0) {
      StringValue.encode({ value: message.lastUserUpdate }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isInternal !== void 0) {
      BoolValue.encode({ value: message.isInternal }, writer.uint32(50).fork()).ldelim();
    }
    if (message.lastModUpdate !== void 0) {
      StringValue.encode({ value: message.lastModUpdate }, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.authors) {
      Participant.encode(v, writer.uint32(66).fork()).ldelim();
    }
    if (message.lastUpdated !== void 0) {
      StringValue.encode({ value: message.lastUpdated }, writer.uint32(74).fork()).ldelim();
    }
    if (message.legacyFirstMessageId !== void 0) {
      StringValue.encode({ value: message.legacyFirstMessageId }, writer.uint32(82).fork()).ldelim();
    }
    if (message.state !== void 0) {
      Int32Value.encode({ value: message.state }, writer.uint32(90).fork()).ldelim();
    }
    if (message.conversationType !== void 0) {
      StringValue.encode({ value: message.conversationType }, writer.uint32(98).fork()).ldelim();
    }
    if (message.lastUnread !== void 0) {
      StringValue.encode({ value: message.lastUnread }, writer.uint32(106).fork()).ldelim();
    }
    if (message.owner !== void 0) {
      ConversationData_Owner.encode(message.owner, writer.uint32(114).fork()).ldelim();
    }
    if (message.subject !== void 0) {
      StringValue.encode({ value: message.subject }, writer.uint32(122).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(130).fork()).ldelim();
    }
    if (message.isHighlighted !== void 0) {
      BoolValue.encode({ value: message.isHighlighted }, writer.uint32(138).fork()).ldelim();
    }
    if (message.numMessages !== void 0) {
      Int64Value.encode({ value: message.numMessages }, writer.uint32(146).fork()).ldelim();
    }
    Object.entries(message.modActions).forEach(([key, value]) => {
      ConversationData_ModActionsEntry.encode({ key, value }, writer.uint32(154).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isAuto = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.participant = Participant.decode(reader, reader.uint32());
          break;
        case 3:
          message.objIds.push(ConversationData_ObjId.decode(reader, reader.uint32()));
          break;
        case 4:
          message.isRepliable = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.lastUserUpdate = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.isInternal = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.lastModUpdate = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.authors.push(Participant.decode(reader, reader.uint32()));
          break;
        case 9:
          message.lastUpdated = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.legacyFirstMessageId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.state = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.conversationType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.lastUnread = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.owner = ConversationData_Owner.decode(reader, reader.uint32());
          break;
        case 15:
          message.subject = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.isHighlighted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.numMessages = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 19:
          const entry19 = ConversationData_ModActionsEntry.decode(reader, reader.uint32());
          if (entry19.value !== void 0) {
            message.modActions[entry19.key] = entry19.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      isAuto: isSet89(object.isAuto) ? Boolean(object.isAuto) : void 0,
      participant: isSet89(object.participant) ? Participant.fromJSON(object.participant) : void 0,
      objIds: Array.isArray(object?.objIds) ? object.objIds.map((e) => ConversationData_ObjId.fromJSON(e)) : [],
      isRepliable: isSet89(object.isRepliable) ? Boolean(object.isRepliable) : void 0,
      lastUserUpdate: isSet89(object.lastUserUpdate) ? String(object.lastUserUpdate) : void 0,
      isInternal: isSet89(object.isInternal) ? Boolean(object.isInternal) : void 0,
      lastModUpdate: isSet89(object.lastModUpdate) ? String(object.lastModUpdate) : void 0,
      authors: Array.isArray(object?.authors) ? object.authors.map((e) => Participant.fromJSON(e)) : [],
      lastUpdated: isSet89(object.lastUpdated) ? String(object.lastUpdated) : void 0,
      legacyFirstMessageId: isSet89(object.legacyFirstMessageId) ? String(object.legacyFirstMessageId) : void 0,
      state: isSet89(object.state) ? Number(object.state) : void 0,
      conversationType: isSet89(object.conversationType) ? String(object.conversationType) : void 0,
      lastUnread: isSet89(object.lastUnread) ? String(object.lastUnread) : void 0,
      owner: isSet89(object.owner) ? ConversationData_Owner.fromJSON(object.owner) : void 0,
      subject: isSet89(object.subject) ? String(object.subject) : void 0,
      id: isSet89(object.id) ? String(object.id) : void 0,
      isHighlighted: isSet89(object.isHighlighted) ? Boolean(object.isHighlighted) : void 0,
      numMessages: isSet89(object.numMessages) ? Number(object.numMessages) : void 0,
      modActions: isObject16(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.isAuto !== void 0 && (obj.isAuto = message.isAuto);
    message.participant !== void 0 && (obj.participant = message.participant ? Participant.toJSON(message.participant) : void 0);
    if (message.objIds) {
      obj.objIds = message.objIds.map((e) => e ? ConversationData_ObjId.toJSON(e) : void 0);
    } else {
      obj.objIds = [];
    }
    message.isRepliable !== void 0 && (obj.isRepliable = message.isRepliable);
    message.lastUserUpdate !== void 0 && (obj.lastUserUpdate = message.lastUserUpdate);
    message.isInternal !== void 0 && (obj.isInternal = message.isInternal);
    message.lastModUpdate !== void 0 && (obj.lastModUpdate = message.lastModUpdate);
    if (message.authors) {
      obj.authors = message.authors.map((e) => e ? Participant.toJSON(e) : void 0);
    } else {
      obj.authors = [];
    }
    message.lastUpdated !== void 0 && (obj.lastUpdated = message.lastUpdated);
    message.legacyFirstMessageId !== void 0 && (obj.legacyFirstMessageId = message.legacyFirstMessageId);
    message.state !== void 0 && (obj.state = message.state);
    message.conversationType !== void 0 && (obj.conversationType = message.conversationType);
    message.lastUnread !== void 0 && (obj.lastUnread = message.lastUnread);
    message.owner !== void 0 && (obj.owner = message.owner ? ConversationData_Owner.toJSON(message.owner) : void 0);
    message.subject !== void 0 && (obj.subject = message.subject);
    message.id !== void 0 && (obj.id = message.id);
    message.isHighlighted !== void 0 && (obj.isHighlighted = message.isHighlighted);
    message.numMessages !== void 0 && (obj.numMessages = message.numMessages);
    obj.modActions = {};
    if (message.modActions) {
      Object.entries(message.modActions).forEach(([k, v]) => {
        obj.modActions[k] = ModActionData.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationData();
    message.isAuto = object.isAuto ?? void 0;
    message.participant = object.participant !== void 0 && object.participant !== null ? Participant.fromPartial(object.participant) : void 0;
    message.objIds = object.objIds?.map((e) => ConversationData_ObjId.fromPartial(e)) || [];
    message.isRepliable = object.isRepliable ?? void 0;
    message.lastUserUpdate = object.lastUserUpdate ?? void 0;
    message.isInternal = object.isInternal ?? void 0;
    message.lastModUpdate = object.lastModUpdate ?? void 0;
    message.authors = object.authors?.map((e) => Participant.fromPartial(e)) || [];
    message.lastUpdated = object.lastUpdated ?? void 0;
    message.legacyFirstMessageId = object.legacyFirstMessageId ?? void 0;
    message.state = object.state ?? void 0;
    message.conversationType = object.conversationType ?? void 0;
    message.lastUnread = object.lastUnread ?? void 0;
    message.owner = object.owner !== void 0 && object.owner !== null ? ConversationData_Owner.fromPartial(object.owner) : void 0;
    message.subject = object.subject ?? void 0;
    message.id = object.id ?? void 0;
    message.isHighlighted = object.isHighlighted ?? void 0;
    message.numMessages = object.numMessages ?? void 0;
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationData", ConversationData);
function createBaseConversationData_ObjId() {
  return { id: void 0, key: void 0 };
}
var ConversationData_ObjId = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationData.ObjId",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
    }
    if (message.key !== void 0) {
      StringValue.encode({ value: message.key }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationData_ObjId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.key = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet89(object.id) ? String(object.id) : void 0,
      key: isSet89(object.key) ? String(object.key) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.key !== void 0 && (obj.key = message.key);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationData_ObjId();
    message.id = object.id ?? void 0;
    message.key = object.key ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationData.ObjId", ConversationData_ObjId);
function createBaseConversationData_Owner() {
  return { displayName: void 0, type: void 0, id: void 0 };
}
var ConversationData_Owner = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationData.Owner",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(10).fork()).ldelim();
    }
    if (message.type !== void 0) {
      StringValue.encode({ value: message.type }, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationData_Owner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.type = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      displayName: isSet89(object.displayName) ? String(object.displayName) : void 0,
      type: isSet89(object.type) ? String(object.type) : void 0,
      id: isSet89(object.id) ? String(object.id) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    message.type !== void 0 && (obj.type = message.type);
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationData_Owner();
    message.displayName = object.displayName ?? void 0;
    message.type = object.type ?? void 0;
    message.id = object.id ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationData.Owner", ConversationData_Owner);
function createBaseConversationData_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var ConversationData_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationData.ModActionsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationData_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ModActionData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ModActionData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationData_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationData.ModActionsEntry", ConversationData_ModActionsEntry);
function createBaseMessageData() {
  return {
    body: void 0,
    author: void 0,
    isInternal: void 0,
    date: void 0,
    bodyMarkdown: void 0,
    id: void 0,
    participatingAs: void 0
  };
}
var MessageData = {
  $type: "devvit.plugin.redditapi.newmodmail.MessageData",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.body !== void 0) {
      StringValue.encode({ value: message.body }, writer.uint32(10).fork()).ldelim();
    }
    if (message.author !== void 0) {
      Participant.encode(message.author, writer.uint32(18).fork()).ldelim();
    }
    if (message.isInternal !== void 0) {
      BoolValue.encode({ value: message.isInternal }, writer.uint32(26).fork()).ldelim();
    }
    if (message.date !== void 0) {
      StringValue.encode({ value: message.date }, writer.uint32(34).fork()).ldelim();
    }
    if (message.bodyMarkdown !== void 0) {
      StringValue.encode({ value: message.bodyMarkdown }, writer.uint32(42).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(50).fork()).ldelim();
    }
    if (message.participatingAs !== void 0) {
      StringValue.encode({ value: message.participatingAs }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.body = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.author = Participant.decode(reader, reader.uint32());
          break;
        case 3:
          message.isInternal = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.date = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.bodyMarkdown = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.participatingAs = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      body: isSet89(object.body) ? String(object.body) : void 0,
      author: isSet89(object.author) ? Participant.fromJSON(object.author) : void 0,
      isInternal: isSet89(object.isInternal) ? Boolean(object.isInternal) : void 0,
      date: isSet89(object.date) ? String(object.date) : void 0,
      bodyMarkdown: isSet89(object.bodyMarkdown) ? String(object.bodyMarkdown) : void 0,
      id: isSet89(object.id) ? String(object.id) : void 0,
      participatingAs: isSet89(object.participatingAs) ? String(object.participatingAs) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.body !== void 0 && (obj.body = message.body);
    message.author !== void 0 && (obj.author = message.author ? Participant.toJSON(message.author) : void 0);
    message.isInternal !== void 0 && (obj.isInternal = message.isInternal);
    message.date !== void 0 && (obj.date = message.date);
    message.bodyMarkdown !== void 0 && (obj.bodyMarkdown = message.bodyMarkdown);
    message.id !== void 0 && (obj.id = message.id);
    message.participatingAs !== void 0 && (obj.participatingAs = message.participatingAs);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMessageData();
    message.body = object.body ?? void 0;
    message.author = object.author !== void 0 && object.author !== null ? Participant.fromPartial(object.author) : void 0;
    message.isInternal = object.isInternal ?? void 0;
    message.date = object.date ?? void 0;
    message.bodyMarkdown = object.bodyMarkdown ?? void 0;
    message.id = object.id ?? void 0;
    message.participatingAs = object.participatingAs ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.MessageData", MessageData);
function createBaseConversationUserData() {
  return {
    recentComments: {},
    muteStatus: void 0,
    name: void 0,
    created: void 0,
    banStatus: void 0,
    isSuspended: void 0,
    approveStatus: void 0,
    isShadowBanned: void 0,
    recentPosts: {},
    recentConvos: {},
    id: void 0
  };
}
var ConversationUserData = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    Object.entries(message.recentComments).forEach(([key, value]) => {
      ConversationUserData_RecentCommentsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    if (message.muteStatus !== void 0) {
      ConversationUserData_MuteStatus.encode(message.muteStatus, writer.uint32(18).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
    }
    if (message.created !== void 0) {
      StringValue.encode({ value: message.created }, writer.uint32(34).fork()).ldelim();
    }
    if (message.banStatus !== void 0) {
      ConversationUserData_BanStatus.encode(message.banStatus, writer.uint32(42).fork()).ldelim();
    }
    if (message.isSuspended !== void 0) {
      BoolValue.encode({ value: message.isSuspended }, writer.uint32(50).fork()).ldelim();
    }
    if (message.approveStatus !== void 0) {
      ConversationUserData_ApproveStatus.encode(message.approveStatus, writer.uint32(58).fork()).ldelim();
    }
    if (message.isShadowBanned !== void 0) {
      BoolValue.encode({ value: message.isShadowBanned }, writer.uint32(66).fork()).ldelim();
    }
    Object.entries(message.recentPosts).forEach(([key, value]) => {
      ConversationUserData_RecentPostsEntry.encode({ key, value }, writer.uint32(74).fork()).ldelim();
    });
    Object.entries(message.recentConvos).forEach(([key, value]) => {
      ConversationUserData_RecentConvosEntry.encode({ key, value }, writer.uint32(82).fork()).ldelim();
    });
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = ConversationUserData_RecentCommentsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.recentComments[entry1.key] = entry1.value;
          }
          break;
        case 2:
          message.muteStatus = ConversationUserData_MuteStatus.decode(reader, reader.uint32());
          break;
        case 3:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.created = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.banStatus = ConversationUserData_BanStatus.decode(reader, reader.uint32());
          break;
        case 6:
          message.isSuspended = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.approveStatus = ConversationUserData_ApproveStatus.decode(reader, reader.uint32());
          break;
        case 8:
          message.isShadowBanned = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          const entry9 = ConversationUserData_RecentPostsEntry.decode(reader, reader.uint32());
          if (entry9.value !== void 0) {
            message.recentPosts[entry9.key] = entry9.value;
          }
          break;
        case 10:
          const entry10 = ConversationUserData_RecentConvosEntry.decode(reader, reader.uint32());
          if (entry10.value !== void 0) {
            message.recentConvos[entry10.key] = entry10.value;
          }
          break;
        case 11:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      recentComments: isObject16(object.recentComments) ? Object.entries(object.recentComments).reduce((acc, [key, value]) => {
        acc[key] = ConversationUserData_CommentData.fromJSON(value);
        return acc;
      }, {}) : {},
      muteStatus: isSet89(object.muteStatus) ? ConversationUserData_MuteStatus.fromJSON(object.muteStatus) : void 0,
      name: isSet89(object.name) ? String(object.name) : void 0,
      created: isSet89(object.created) ? String(object.created) : void 0,
      banStatus: isSet89(object.banStatus) ? ConversationUserData_BanStatus.fromJSON(object.banStatus) : void 0,
      isSuspended: isSet89(object.isSuspended) ? Boolean(object.isSuspended) : void 0,
      approveStatus: isSet89(object.approveStatus) ? ConversationUserData_ApproveStatus.fromJSON(object.approveStatus) : void 0,
      isShadowBanned: isSet89(object.isShadowBanned) ? Boolean(object.isShadowBanned) : void 0,
      recentPosts: isObject16(object.recentPosts) ? Object.entries(object.recentPosts).reduce((acc, [key, value]) => {
        acc[key] = ConversationUserData_PostData.fromJSON(value);
        return acc;
      }, {}) : {},
      recentConvos: isObject16(object.recentConvos) ? Object.entries(object.recentConvos).reduce((acc, [key, value]) => {
        acc[key] = ConversationUserData_ConvoData.fromJSON(value);
        return acc;
      }, {}) : {},
      id: isSet89(object.id) ? String(object.id) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    obj.recentComments = {};
    if (message.recentComments) {
      Object.entries(message.recentComments).forEach(([k, v]) => {
        obj.recentComments[k] = ConversationUserData_CommentData.toJSON(v);
      });
    }
    message.muteStatus !== void 0 && (obj.muteStatus = message.muteStatus ? ConversationUserData_MuteStatus.toJSON(message.muteStatus) : void 0);
    message.name !== void 0 && (obj.name = message.name);
    message.created !== void 0 && (obj.created = message.created);
    message.banStatus !== void 0 && (obj.banStatus = message.banStatus ? ConversationUserData_BanStatus.toJSON(message.banStatus) : void 0);
    message.isSuspended !== void 0 && (obj.isSuspended = message.isSuspended);
    message.approveStatus !== void 0 && (obj.approveStatus = message.approveStatus ? ConversationUserData_ApproveStatus.toJSON(message.approveStatus) : void 0);
    message.isShadowBanned !== void 0 && (obj.isShadowBanned = message.isShadowBanned);
    obj.recentPosts = {};
    if (message.recentPosts) {
      Object.entries(message.recentPosts).forEach(([k, v]) => {
        obj.recentPosts[k] = ConversationUserData_PostData.toJSON(v);
      });
    }
    obj.recentConvos = {};
    if (message.recentConvos) {
      Object.entries(message.recentConvos).forEach(([k, v]) => {
        obj.recentConvos[k] = ConversationUserData_ConvoData.toJSON(v);
      });
    }
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationUserData();
    message.recentComments = Object.entries(object.recentComments ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ConversationUserData_CommentData.fromPartial(value);
      }
      return acc;
    }, {});
    message.muteStatus = object.muteStatus !== void 0 && object.muteStatus !== null ? ConversationUserData_MuteStatus.fromPartial(object.muteStatus) : void 0;
    message.name = object.name ?? void 0;
    message.created = object.created ?? void 0;
    message.banStatus = object.banStatus !== void 0 && object.banStatus !== null ? ConversationUserData_BanStatus.fromPartial(object.banStatus) : void 0;
    message.isSuspended = object.isSuspended ?? void 0;
    message.approveStatus = object.approveStatus !== void 0 && object.approveStatus !== null ? ConversationUserData_ApproveStatus.fromPartial(object.approveStatus) : void 0;
    message.isShadowBanned = object.isShadowBanned ?? void 0;
    message.recentPosts = Object.entries(object.recentPosts ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ConversationUserData_PostData.fromPartial(value);
      }
      return acc;
    }, {});
    message.recentConvos = Object.entries(object.recentConvos ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ConversationUserData_ConvoData.fromPartial(value);
      }
      return acc;
    }, {});
    message.id = object.id ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData", ConversationUserData);
function createBaseConversationUserData_CommentData() {
  return { comment: void 0, date: void 0, permalink: void 0, title: void 0 };
}
var ConversationUserData_CommentData = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.CommentData",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.comment !== void 0) {
      StringValue.encode({ value: message.comment }, writer.uint32(10).fork()).ldelim();
    }
    if (message.date !== void 0) {
      StringValue.encode({ value: message.date }, writer.uint32(18).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(26).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_CommentData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.comment = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.date = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      comment: isSet89(object.comment) ? String(object.comment) : void 0,
      date: isSet89(object.date) ? String(object.date) : void 0,
      permalink: isSet89(object.permalink) ? String(object.permalink) : void 0,
      title: isSet89(object.title) ? String(object.title) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.comment !== void 0 && (obj.comment = message.comment);
    message.date !== void 0 && (obj.date = message.date);
    message.permalink !== void 0 && (obj.permalink = message.permalink);
    message.title !== void 0 && (obj.title = message.title);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_CommentData();
    message.comment = object.comment ?? void 0;
    message.date = object.date ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.title = object.title ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.CommentData", ConversationUserData_CommentData);
function createBaseConversationUserData_MuteStatus() {
  return { muteCount: void 0, isMuted: void 0, endDate: void 0, reason: void 0 };
}
var ConversationUserData_MuteStatus = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.MuteStatus",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.muteCount !== void 0) {
      Int64Value.encode({ value: message.muteCount }, writer.uint32(10).fork()).ldelim();
    }
    if (message.isMuted !== void 0) {
      BoolValue.encode({ value: message.isMuted }, writer.uint32(18).fork()).ldelim();
    }
    if (message.endDate !== void 0) {
      StringValue.encode({ value: message.endDate }, writer.uint32(26).fork()).ldelim();
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_MuteStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.muteCount = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.isMuted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.endDate = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      muteCount: isSet89(object.muteCount) ? Number(object.muteCount) : void 0,
      isMuted: isSet89(object.isMuted) ? Boolean(object.isMuted) : void 0,
      endDate: isSet89(object.endDate) ? String(object.endDate) : void 0,
      reason: isSet89(object.reason) ? String(object.reason) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.muteCount !== void 0 && (obj.muteCount = message.muteCount);
    message.isMuted !== void 0 && (obj.isMuted = message.isMuted);
    message.endDate !== void 0 && (obj.endDate = message.endDate);
    message.reason !== void 0 && (obj.reason = message.reason);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_MuteStatus();
    message.muteCount = object.muteCount ?? void 0;
    message.isMuted = object.isMuted ?? void 0;
    message.endDate = object.endDate ?? void 0;
    message.reason = object.reason ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.MuteStatus", ConversationUserData_MuteStatus);
function createBaseConversationUserData_BanStatus() {
  return { isBanned: void 0, isPermanent: void 0, endDate: void 0, reason: void 0 };
}
var ConversationUserData_BanStatus = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.BanStatus",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.isBanned !== void 0) {
      BoolValue.encode({ value: message.isBanned }, writer.uint32(10).fork()).ldelim();
    }
    if (message.isPermanent !== void 0) {
      BoolValue.encode({ value: message.isPermanent }, writer.uint32(18).fork()).ldelim();
    }
    if (message.endDate !== void 0) {
      StringValue.encode({ value: message.endDate }, writer.uint32(26).fork()).ldelim();
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_BanStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isBanned = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.isPermanent = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.endDate = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      isBanned: isSet89(object.isBanned) ? Boolean(object.isBanned) : void 0,
      isPermanent: isSet89(object.isPermanent) ? Boolean(object.isPermanent) : void 0,
      endDate: isSet89(object.endDate) ? String(object.endDate) : void 0,
      reason: isSet89(object.reason) ? String(object.reason) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.isBanned !== void 0 && (obj.isBanned = message.isBanned);
    message.isPermanent !== void 0 && (obj.isPermanent = message.isPermanent);
    message.endDate !== void 0 && (obj.endDate = message.endDate);
    message.reason !== void 0 && (obj.reason = message.reason);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_BanStatus();
    message.isBanned = object.isBanned ?? void 0;
    message.isPermanent = object.isPermanent ?? void 0;
    message.endDate = object.endDate ?? void 0;
    message.reason = object.reason ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.BanStatus", ConversationUserData_BanStatus);
function createBaseConversationUserData_ApproveStatus() {
  return { isApproved: void 0 };
}
var ConversationUserData_ApproveStatus = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.ApproveStatus",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.isApproved !== void 0) {
      BoolValue.encode({ value: message.isApproved }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_ApproveStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isApproved = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { isApproved: isSet89(object.isApproved) ? Boolean(object.isApproved) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.isApproved !== void 0 && (obj.isApproved = message.isApproved);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_ApproveStatus();
    message.isApproved = object.isApproved ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.ApproveStatus", ConversationUserData_ApproveStatus);
function createBaseConversationUserData_PostData() {
  return { date: void 0, permalink: void 0, title: void 0 };
}
var ConversationUserData_PostData = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.PostData",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.date !== void 0) {
      StringValue.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(18).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_PostData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.date = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      date: isSet89(object.date) ? String(object.date) : void 0,
      permalink: isSet89(object.permalink) ? String(object.permalink) : void 0,
      title: isSet89(object.title) ? String(object.title) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.date !== void 0 && (obj.date = message.date);
    message.permalink !== void 0 && (obj.permalink = message.permalink);
    message.title !== void 0 && (obj.title = message.title);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_PostData();
    message.date = object.date ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.title = object.title ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.PostData", ConversationUserData_PostData);
function createBaseConversationUserData_ConvoData() {
  return { date: void 0, permalink: void 0, id: void 0, subject: void 0 };
}
var ConversationUserData_ConvoData = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.ConvoData",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.date !== void 0) {
      StringValue.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
    }
    if (message.subject !== void 0) {
      StringValue.encode({ value: message.subject }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_ConvoData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.date = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.subject = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      date: isSet89(object.date) ? String(object.date) : void 0,
      permalink: isSet89(object.permalink) ? String(object.permalink) : void 0,
      id: isSet89(object.id) ? String(object.id) : void 0,
      subject: isSet89(object.subject) ? String(object.subject) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.date !== void 0 && (obj.date = message.date);
    message.permalink !== void 0 && (obj.permalink = message.permalink);
    message.id !== void 0 && (obj.id = message.id);
    message.subject !== void 0 && (obj.subject = message.subject);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_ConvoData();
    message.date = object.date ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.id = object.id ?? void 0;
    message.subject = object.subject ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.ConvoData", ConversationUserData_ConvoData);
function createBaseConversationUserData_RecentCommentsEntry() {
  return { key: "", value: void 0 };
}
var ConversationUserData_RecentCommentsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentCommentsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ConversationUserData_CommentData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_RecentCommentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ConversationUserData_CommentData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? ConversationUserData_CommentData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ConversationUserData_CommentData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_RecentCommentsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ConversationUserData_CommentData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentCommentsEntry", ConversationUserData_RecentCommentsEntry);
function createBaseConversationUserData_RecentPostsEntry() {
  return { key: "", value: void 0 };
}
var ConversationUserData_RecentPostsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentPostsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ConversationUserData_PostData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_RecentPostsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ConversationUserData_PostData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? ConversationUserData_PostData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ConversationUserData_PostData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_RecentPostsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ConversationUserData_PostData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentPostsEntry", ConversationUserData_RecentPostsEntry);
function createBaseConversationUserData_RecentConvosEntry() {
  return { key: "", value: void 0 };
}
var ConversationUserData_RecentConvosEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentConvosEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ConversationUserData_ConvoData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConversationUserData_RecentConvosEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ConversationUserData_ConvoData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? ConversationUserData_ConvoData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ConversationUserData_ConvoData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseConversationUserData_RecentConvosEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ConversationUserData_ConvoData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentConvosEntry", ConversationUserData_RecentConvosEntry);
function createBaseParticipant() {
  return {
    isMod: void 0,
    isAdmin: void 0,
    name: void 0,
    isOp: void 0,
    isParticipant: void 0,
    isApproved: void 0,
    isHidden: void 0,
    id: void 0,
    isDeleted: void 0
  };
}
var Participant = {
  $type: "devvit.plugin.redditapi.newmodmail.Participant",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.isMod !== void 0) {
      BoolValue.encode({ value: message.isMod }, writer.uint32(10).fork()).ldelim();
    }
    if (message.isAdmin !== void 0) {
      BoolValue.encode({ value: message.isAdmin }, writer.uint32(18).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
    }
    if (message.isOp !== void 0) {
      BoolValue.encode({ value: message.isOp }, writer.uint32(34).fork()).ldelim();
    }
    if (message.isParticipant !== void 0) {
      BoolValue.encode({ value: message.isParticipant }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isApproved !== void 0) {
      BoolValue.encode({ value: message.isApproved }, writer.uint32(50).fork()).ldelim();
    }
    if (message.isHidden !== void 0) {
      BoolValue.encode({ value: message.isHidden }, writer.uint32(58).fork()).ldelim();
    }
    if (message.id !== void 0) {
      Int64Value.encode({ value: message.id }, writer.uint32(66).fork()).ldelim();
    }
    if (message.isDeleted !== void 0) {
      BoolValue.encode({ value: message.isDeleted }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isMod = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.isAdmin = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.isOp = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.isParticipant = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.isApproved = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.isHidden = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.id = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.isDeleted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      isMod: isSet89(object.isMod) ? Boolean(object.isMod) : void 0,
      isAdmin: isSet89(object.isAdmin) ? Boolean(object.isAdmin) : void 0,
      name: isSet89(object.name) ? String(object.name) : void 0,
      isOp: isSet89(object.isOp) ? Boolean(object.isOp) : void 0,
      isParticipant: isSet89(object.isParticipant) ? Boolean(object.isParticipant) : void 0,
      isApproved: isSet89(object.isApproved) ? Boolean(object.isApproved) : void 0,
      isHidden: isSet89(object.isHidden) ? Boolean(object.isHidden) : void 0,
      id: isSet89(object.id) ? Number(object.id) : void 0,
      isDeleted: isSet89(object.isDeleted) ? Boolean(object.isDeleted) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.isMod !== void 0 && (obj.isMod = message.isMod);
    message.isAdmin !== void 0 && (obj.isAdmin = message.isAdmin);
    message.name !== void 0 && (obj.name = message.name);
    message.isOp !== void 0 && (obj.isOp = message.isOp);
    message.isParticipant !== void 0 && (obj.isParticipant = message.isParticipant);
    message.isApproved !== void 0 && (obj.isApproved = message.isApproved);
    message.isHidden !== void 0 && (obj.isHidden = message.isHidden);
    message.id !== void 0 && (obj.id = message.id);
    message.isDeleted !== void 0 && (obj.isDeleted = message.isDeleted);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseParticipant();
    message.isMod = object.isMod ?? void 0;
    message.isAdmin = object.isAdmin ?? void 0;
    message.name = object.name ?? void 0;
    message.isOp = object.isOp ?? void 0;
    message.isParticipant = object.isParticipant ?? void 0;
    message.isApproved = object.isApproved ?? void 0;
    message.isHidden = object.isHidden ?? void 0;
    message.id = object.id ?? void 0;
    message.isDeleted = object.isDeleted ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.Participant", Participant);
function createBaseModActionData() {
  return { date: void 0, actionTypeId: void 0, id: void 0, author: void 0 };
}
var ModActionData = {
  $type: "devvit.plugin.redditapi.newmodmail.ModActionData",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.date !== void 0) {
      StringValue.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
    }
    if (message.actionTypeId !== void 0) {
      Int32Value.encode({ value: message.actionTypeId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
    }
    if (message.author !== void 0) {
      ModActionData_ModActionAuthor.encode(message.author, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModActionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.date = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.actionTypeId = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.author = ModActionData_ModActionAuthor.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      date: isSet89(object.date) ? String(object.date) : void 0,
      actionTypeId: isSet89(object.actionTypeId) ? Number(object.actionTypeId) : void 0,
      id: isSet89(object.id) ? String(object.id) : void 0,
      author: isSet89(object.author) ? ModActionData_ModActionAuthor.fromJSON(object.author) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.date !== void 0 && (obj.date = message.date);
    message.actionTypeId !== void 0 && (obj.actionTypeId = message.actionTypeId);
    message.id !== void 0 && (obj.id = message.id);
    message.author !== void 0 && (obj.author = message.author ? ModActionData_ModActionAuthor.toJSON(message.author) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseModActionData();
    message.date = object.date ?? void 0;
    message.actionTypeId = object.actionTypeId ?? void 0;
    message.id = object.id ?? void 0;
    message.author = object.author !== void 0 && object.author !== null ? ModActionData_ModActionAuthor.fromPartial(object.author) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ModActionData", ModActionData);
function createBaseModActionData_ModActionAuthor() {
  return {
    isMod: void 0,
    isAdmin: void 0,
    name: void 0,
    isHidden: void 0,
    id: void 0,
    isDeleted: void 0
  };
}
var ModActionData_ModActionAuthor = {
  $type: "devvit.plugin.redditapi.newmodmail.ModActionData.ModActionAuthor",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.isMod !== void 0) {
      BoolValue.encode({ value: message.isMod }, writer.uint32(10).fork()).ldelim();
    }
    if (message.isAdmin !== void 0) {
      BoolValue.encode({ value: message.isAdmin }, writer.uint32(18).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
    }
    if (message.isHidden !== void 0) {
      BoolValue.encode({ value: message.isHidden }, writer.uint32(34).fork()).ldelim();
    }
    if (message.id !== void 0) {
      Int64Value.encode({ value: message.id }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isDeleted !== void 0) {
      BoolValue.encode({ value: message.isDeleted }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseModActionData_ModActionAuthor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isMod = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.isAdmin = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.isHidden = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.id = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.isDeleted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      isMod: isSet89(object.isMod) ? Boolean(object.isMod) : void 0,
      isAdmin: isSet89(object.isAdmin) ? Boolean(object.isAdmin) : void 0,
      name: isSet89(object.name) ? String(object.name) : void 0,
      isHidden: isSet89(object.isHidden) ? Boolean(object.isHidden) : void 0,
      id: isSet89(object.id) ? Number(object.id) : void 0,
      isDeleted: isSet89(object.isDeleted) ? Boolean(object.isDeleted) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.isMod !== void 0 && (obj.isMod = message.isMod);
    message.isAdmin !== void 0 && (obj.isAdmin = message.isAdmin);
    message.name !== void 0 && (obj.name = message.name);
    message.isHidden !== void 0 && (obj.isHidden = message.isHidden);
    message.id !== void 0 && (obj.id = message.id);
    message.isDeleted !== void 0 && (obj.isDeleted = message.isDeleted);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseModActionData_ModActionAuthor();
    message.isMod = object.isMod ?? void 0;
    message.isAdmin = object.isAdmin ?? void 0;
    message.name = object.name ?? void 0;
    message.isHidden = object.isHidden ?? void 0;
    message.id = object.id ?? void 0;
    message.isDeleted = object.isDeleted ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ModActionData.ModActionAuthor", ModActionData_ModActionAuthor);
function createBaseBulkReadConversationsRequest() {
  return { entity: "", state: "" };
}
var BulkReadConversationsRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.BulkReadConversationsRequest",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.entity !== "") {
      writer.uint32(10).string(message.entity);
    }
    if (message.state !== "") {
      writer.uint32(18).string(message.state);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBulkReadConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entity = reader.string();
          break;
        case 2:
          message.state = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      entity: isSet89(object.entity) ? String(object.entity) : "",
      state: isSet89(object.state) ? String(object.state) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.entity !== void 0 && (obj.entity = message.entity);
    message.state !== void 0 && (obj.state = message.state);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBulkReadConversationsRequest();
    message.entity = object.entity ?? "";
    message.state = object.state ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.BulkReadConversationsRequest", BulkReadConversationsRequest);
function createBaseGetConversationsRequest() {
  return { after: void 0, entity: void 0, limit: void 0, sort: void 0, state: void 0 };
}
var GetConversationsRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationsRequest",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.entity !== void 0) {
      StringValue.encode({ value: message.entity }, writer.uint32(18).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int32Value.encode({ value: message.limit }, writer.uint32(26).fork()).ldelim();
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(34).fork()).ldelim();
    }
    if (message.state !== void 0) {
      StringValue.encode({ value: message.state }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.entity = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.state = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet89(object.after) ? String(object.after) : void 0,
      entity: isSet89(object.entity) ? String(object.entity) : void 0,
      limit: isSet89(object.limit) ? Number(object.limit) : void 0,
      sort: isSet89(object.sort) ? String(object.sort) : void 0,
      state: isSet89(object.state) ? String(object.state) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.entity !== void 0 && (obj.entity = message.entity);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.sort !== void 0 && (obj.sort = message.sort);
    message.state !== void 0 && (obj.state = message.state);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetConversationsRequest();
    message.after = object.after ?? void 0;
    message.entity = object.entity ?? void 0;
    message.limit = object.limit ?? void 0;
    message.sort = object.sort ?? void 0;
    message.state = object.state ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationsRequest", GetConversationsRequest);
function createBaseCreateConversationRequest() {
  return { body: "", isAuthorHidden: false, srName: "", subject: "", to: "" };
}
var CreateConversationRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationRequest",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.body !== "") {
      writer.uint32(10).string(message.body);
    }
    if (message.isAuthorHidden === true) {
      writer.uint32(16).bool(message.isAuthorHidden);
    }
    if (message.srName !== "") {
      writer.uint32(26).string(message.srName);
    }
    if (message.subject !== "") {
      writer.uint32(34).string(message.subject);
    }
    if (message.to !== "") {
      writer.uint32(42).string(message.to);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.body = reader.string();
          break;
        case 2:
          message.isAuthorHidden = reader.bool();
          break;
        case 3:
          message.srName = reader.string();
          break;
        case 4:
          message.subject = reader.string();
          break;
        case 5:
          message.to = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      body: isSet89(object.body) ? String(object.body) : "",
      isAuthorHidden: isSet89(object.isAuthorHidden) ? Boolean(object.isAuthorHidden) : false,
      srName: isSet89(object.srName) ? String(object.srName) : "",
      subject: isSet89(object.subject) ? String(object.subject) : "",
      to: isSet89(object.to) ? String(object.to) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.body !== void 0 && (obj.body = message.body);
    message.isAuthorHidden !== void 0 && (obj.isAuthorHidden = message.isAuthorHidden);
    message.srName !== void 0 && (obj.srName = message.srName);
    message.subject !== void 0 && (obj.subject = message.subject);
    message.to !== void 0 && (obj.to = message.to);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCreateConversationRequest();
    message.body = object.body ?? "";
    message.isAuthorHidden = object.isAuthorHidden ?? false;
    message.srName = object.srName ?? "";
    message.subject = object.subject ?? "";
    message.to = object.to ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationRequest", CreateConversationRequest);
function createBaseGetConversationRequest() {
  return { conversationId: "", markRead: false };
}
var GetConversationRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationRequest",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.markRead === true) {
      writer.uint32(16).bool(message.markRead);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversationId = reader.string();
          break;
        case 2:
          message.markRead = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversationId: isSet89(object.conversationId) ? String(object.conversationId) : "",
      markRead: isSet89(object.markRead) ? Boolean(object.markRead) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.conversationId !== void 0 && (obj.conversationId = message.conversationId);
    message.markRead !== void 0 && (obj.markRead = message.markRead);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetConversationRequest();
    message.conversationId = object.conversationId ?? "";
    message.markRead = object.markRead ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationRequest", GetConversationRequest);
function createBaseCreateConversationMessageRequest() {
  return { body: "", isAuthorHidden: false, isInternal: false, conversationId: "" };
}
var CreateConversationMessageRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageRequest",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.body !== "") {
      writer.uint32(10).string(message.body);
    }
    if (message.isAuthorHidden === true) {
      writer.uint32(16).bool(message.isAuthorHidden);
    }
    if (message.isInternal === true) {
      writer.uint32(24).bool(message.isInternal);
    }
    if (message.conversationId !== "") {
      writer.uint32(34).string(message.conversationId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.body = reader.string();
          break;
        case 2:
          message.isAuthorHidden = reader.bool();
          break;
        case 3:
          message.isInternal = reader.bool();
          break;
        case 4:
          message.conversationId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      body: isSet89(object.body) ? String(object.body) : "",
      isAuthorHidden: isSet89(object.isAuthorHidden) ? Boolean(object.isAuthorHidden) : false,
      isInternal: isSet89(object.isInternal) ? Boolean(object.isInternal) : false,
      conversationId: isSet89(object.conversationId) ? String(object.conversationId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.body !== void 0 && (obj.body = message.body);
    message.isAuthorHidden !== void 0 && (obj.isAuthorHidden = message.isAuthorHidden);
    message.isInternal !== void 0 && (obj.isInternal = message.isInternal);
    message.conversationId !== void 0 && (obj.conversationId = message.conversationId);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCreateConversationMessageRequest();
    message.body = object.body ?? "";
    message.isAuthorHidden = object.isAuthorHidden ?? false;
    message.isInternal = object.isInternal ?? false;
    message.conversationId = object.conversationId ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationMessageRequest", CreateConversationMessageRequest);
function createBaseBasicConversationRequest() {
  return { conversationId: "" };
}
var BasicConversationRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversationId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { conversationId: isSet89(object.conversationId) ? String(object.conversationId) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.conversationId !== void 0 && (obj.conversationId = message.conversationId);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBasicConversationRequest();
    message.conversationId = object.conversationId ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.BasicConversationRequest", BasicConversationRequest);
function createBaseBasicConversationsRequest() {
  return { conversationIds: "" };
}
var BasicConversationsRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.BasicConversationsRequest",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversationIds !== "") {
      writer.uint32(10).string(message.conversationIds);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversationIds = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { conversationIds: isSet89(object.conversationIds) ? String(object.conversationIds) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.conversationIds !== void 0 && (obj.conversationIds = message.conversationIds);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBasicConversationsRequest();
    message.conversationIds = object.conversationIds ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.BasicConversationsRequest", BasicConversationsRequest);
function createBaseMuteConversationRequest() {
  return { conversationId: "", numHours: 0 };
}
var MuteConversationRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.MuteConversationRequest",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.numHours !== 0) {
      writer.uint32(16).int32(message.numHours);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMuteConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversationId = reader.string();
          break;
        case 2:
          message.numHours = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversationId: isSet89(object.conversationId) ? String(object.conversationId) : "",
      numHours: isSet89(object.numHours) ? Number(object.numHours) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.conversationId !== void 0 && (obj.conversationId = message.conversationId);
    message.numHours !== void 0 && (obj.numHours = Math.round(message.numHours));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMuteConversationRequest();
    message.conversationId = object.conversationId ?? "";
    message.numHours = object.numHours ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.MuteConversationRequest", MuteConversationRequest);
function createBaseTempBanRequest() {
  return { conversationId: "", duration: 0 };
}
var TempBanRequest = {
  $type: "devvit.plugin.redditapi.newmodmail.TempBanRequest",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.duration !== 0) {
      writer.uint32(16).int32(message.duration);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTempBanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversationId = reader.string();
          break;
        case 2:
          message.duration = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversationId: isSet89(object.conversationId) ? String(object.conversationId) : "",
      duration: isSet89(object.duration) ? Number(object.duration) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.conversationId !== void 0 && (obj.conversationId = message.conversationId);
    message.duration !== void 0 && (obj.duration = Math.round(message.duration));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTempBanRequest();
    message.conversationId = object.conversationId ?? "";
    message.duration = object.duration ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.TempBanRequest", TempBanRequest);
function createBaseBulkReadConversationsResponse() {
  return { conversationIds: [] };
}
var BulkReadConversationsResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.BulkReadConversationsResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    for (const v of message.conversationIds) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBulkReadConversationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversationIds.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversationIds: Array.isArray(object?.conversationIds) ? object.conversationIds.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.conversationIds) {
      obj.conversationIds = message.conversationIds.map((e) => e);
    } else {
      obj.conversationIds = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBulkReadConversationsResponse();
    message.conversationIds = object.conversationIds?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.BulkReadConversationsResponse", BulkReadConversationsResponse);
function createBaseGetConversationsResponse() {
  return { conversations: {}, messages: {}, viewerId: void 0, conversationIds: [] };
}
var GetConversationsResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    Object.entries(message.conversations).forEach(([key, value]) => {
      GetConversationsResponse_ConversationsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    Object.entries(message.messages).forEach(([key, value]) => {
      GetConversationsResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.viewerId !== void 0) {
      StringValue.encode({ value: message.viewerId }, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.conversationIds) {
      StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = GetConversationsResponse_ConversationsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.conversations[entry1.key] = entry1.value;
          }
          break;
        case 2:
          const entry2 = GetConversationsResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          break;
        case 3:
          message.viewerId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.conversationIds.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversations: isObject16(object.conversations) ? Object.entries(object.conversations).reduce((acc, [key, value]) => {
        acc[key] = ConversationData.fromJSON(value);
        return acc;
      }, {}) : {},
      messages: isObject16(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      viewerId: isSet89(object.viewerId) ? String(object.viewerId) : void 0,
      conversationIds: Array.isArray(object?.conversationIds) ? object.conversationIds.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    obj.conversations = {};
    if (message.conversations) {
      Object.entries(message.conversations).forEach(([k, v]) => {
        obj.conversations[k] = ConversationData.toJSON(v);
      });
    }
    obj.messages = {};
    if (message.messages) {
      Object.entries(message.messages).forEach(([k, v]) => {
        obj.messages[k] = MessageData.toJSON(v);
      });
    }
    message.viewerId !== void 0 && (obj.viewerId = message.viewerId);
    if (message.conversationIds) {
      obj.conversationIds = message.conversationIds.map((e) => e);
    } else {
      obj.conversationIds = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetConversationsResponse();
    message.conversations = Object.entries(object.conversations ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ConversationData.fromPartial(value);
      }
      return acc;
    }, {});
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.viewerId = object.viewerId ?? void 0;
    message.conversationIds = object.conversationIds?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationsResponse", GetConversationsResponse);
function createBaseGetConversationsResponse_ConversationsEntry() {
  return { key: "", value: void 0 };
}
var GetConversationsResponse_ConversationsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse.ConversationsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ConversationData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationsResponse_ConversationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ConversationData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? ConversationData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ConversationData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetConversationsResponse_ConversationsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ConversationData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationsResponse.ConversationsEntry", GetConversationsResponse_ConversationsEntry);
function createBaseGetConversationsResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var GetConversationsResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse.MessagesEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationsResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = MessageData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? MessageData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetConversationsResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationsResponse.MessagesEntry", GetConversationsResponse_MessagesEntry);
function createBaseCreateConversationResponse() {
  return {
    conversation: void 0,
    messages: {},
    modActions: {},
    fields: [],
    reason: void 0,
    message: void 0,
    explanation: void 0
  };
}
var CreateConversationResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversation !== void 0) {
      ConversationData.encode(message.conversation, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      CreateConversationResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    Object.entries(message.modActions).forEach(([key, value]) => {
      CreateConversationResponse_ModActionsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    for (const v of message.fields) {
      StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(42).fork()).ldelim();
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(50).fork()).ldelim();
    }
    if (message.explanation !== void 0) {
      StringValue.encode({ value: message.explanation }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversation = ConversationData.decode(reader, reader.uint32());
          break;
        case 2:
          const entry2 = CreateConversationResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          break;
        case 3:
          const entry3 = CreateConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.modActions[entry3.key] = entry3.value;
          }
          break;
        case 4:
          message.fields.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 5:
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.message = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.explanation = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversation: isSet89(object.conversation) ? ConversationData.fromJSON(object.conversation) : void 0,
      messages: isObject16(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      modActions: isObject16(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {},
      fields: Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
      reason: isSet89(object.reason) ? String(object.reason) : void 0,
      message: isSet89(object.message) ? String(object.message) : void 0,
      explanation: isSet89(object.explanation) ? String(object.explanation) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.conversation !== void 0 && (obj.conversation = message.conversation ? ConversationData.toJSON(message.conversation) : void 0);
    obj.messages = {};
    if (message.messages) {
      Object.entries(message.messages).forEach(([k, v]) => {
        obj.messages[k] = MessageData.toJSON(v);
      });
    }
    obj.modActions = {};
    if (message.modActions) {
      Object.entries(message.modActions).forEach(([k, v]) => {
        obj.modActions[k] = ModActionData.toJSON(v);
      });
    }
    if (message.fields) {
      obj.fields = message.fields.map((e) => e);
    } else {
      obj.fields = [];
    }
    message.reason !== void 0 && (obj.reason = message.reason);
    message.message !== void 0 && (obj.message = message.message);
    message.explanation !== void 0 && (obj.explanation = message.explanation);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCreateConversationResponse();
    message.conversation = object.conversation !== void 0 && object.conversation !== null ? ConversationData.fromPartial(object.conversation) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    message.fields = object.fields?.map((e) => e) || [];
    message.reason = object.reason ?? void 0;
    message.message = object.message ?? void 0;
    message.explanation = object.explanation ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationResponse", CreateConversationResponse);
function createBaseCreateConversationResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var CreateConversationResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse.MessagesEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = MessageData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? MessageData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCreateConversationResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationResponse.MessagesEntry", CreateConversationResponse_MessagesEntry);
function createBaseCreateConversationResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var CreateConversationResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse.ModActionsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ModActionData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ModActionData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCreateConversationResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationResponse.ModActionsEntry", CreateConversationResponse_ModActionsEntry);
function createBaseGetConversationResponse() {
  return { conversation: void 0, messages: {}, modActions: {}, participantSubreddit: void 0, user: void 0 };
}
var GetConversationResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversation !== void 0) {
      ConversationData.encode(message.conversation, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      GetConversationResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    Object.entries(message.modActions).forEach(([key, value]) => {
      GetConversationResponse_ModActionsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.participantSubreddit !== void 0) {
      Any.encode(message.participantSubreddit, writer.uint32(34).fork()).ldelim();
    }
    if (message.user !== void 0) {
      ConversationUserData.encode(message.user, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversation = ConversationData.decode(reader, reader.uint32());
          break;
        case 2:
          const entry2 = GetConversationResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          break;
        case 3:
          const entry3 = GetConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.modActions[entry3.key] = entry3.value;
          }
          break;
        case 4:
          message.participantSubreddit = Any.decode(reader, reader.uint32());
          break;
        case 5:
          message.user = ConversationUserData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversation: isSet89(object.conversation) ? ConversationData.fromJSON(object.conversation) : void 0,
      messages: isObject16(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      modActions: isObject16(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {},
      participantSubreddit: isSet89(object.participantSubreddit) ? Any.fromJSON(object.participantSubreddit) : void 0,
      user: isSet89(object.user) ? ConversationUserData.fromJSON(object.user) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.conversation !== void 0 && (obj.conversation = message.conversation ? ConversationData.toJSON(message.conversation) : void 0);
    obj.messages = {};
    if (message.messages) {
      Object.entries(message.messages).forEach(([k, v]) => {
        obj.messages[k] = MessageData.toJSON(v);
      });
    }
    obj.modActions = {};
    if (message.modActions) {
      Object.entries(message.modActions).forEach(([k, v]) => {
        obj.modActions[k] = ModActionData.toJSON(v);
      });
    }
    message.participantSubreddit !== void 0 && (obj.participantSubreddit = message.participantSubreddit ? Any.toJSON(message.participantSubreddit) : void 0);
    message.user !== void 0 && (obj.user = message.user ? ConversationUserData.toJSON(message.user) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetConversationResponse();
    message.conversation = object.conversation !== void 0 && object.conversation !== null ? ConversationData.fromPartial(object.conversation) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    message.participantSubreddit = object.participantSubreddit !== void 0 && object.participantSubreddit !== null ? Any.fromPartial(object.participantSubreddit) : void 0;
    message.user = object.user !== void 0 && object.user !== null ? ConversationUserData.fromPartial(object.user) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationResponse", GetConversationResponse);
function createBaseGetConversationResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var GetConversationResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse.MessagesEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = MessageData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? MessageData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetConversationResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationResponse.MessagesEntry", GetConversationResponse_MessagesEntry);
function createBaseGetConversationResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var GetConversationResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse.ModActionsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConversationResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ModActionData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ModActionData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetConversationResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.GetConversationResponse.ModActionsEntry", GetConversationResponse_ModActionsEntry);
function createBaseCreateConversationMessageResponse() {
  return { conversation: void 0, messages: {} };
}
var CreateConversationMessageResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversation !== void 0) {
      ConversationData.encode(message.conversation, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      CreateConversationMessageResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversation = ConversationData.decode(reader, reader.uint32());
          break;
        case 2:
          const entry2 = CreateConversationMessageResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversation: isSet89(object.conversation) ? ConversationData.fromJSON(object.conversation) : void 0,
      messages: isObject16(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.conversation !== void 0 && (obj.conversation = message.conversation ? ConversationData.toJSON(message.conversation) : void 0);
    obj.messages = {};
    if (message.messages) {
      Object.entries(message.messages).forEach(([k, v]) => {
        obj.messages[k] = MessageData.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCreateConversationMessageResponse();
    message.conversation = object.conversation !== void 0 && object.conversation !== null ? ConversationData.fromPartial(object.conversation) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse", CreateConversationMessageResponse);
function createBaseCreateConversationMessageResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var CreateConversationMessageResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse.MessagesEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationMessageResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = MessageData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? MessageData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCreateConversationMessageResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse.MessagesEntry", CreateConversationMessageResponse_MessagesEntry);
function createBaseApproveConversationResponse() {
  return {
    conversations: void 0,
    messages: {},
    user: void 0,
    modActions: {},
    fields: [],
    reason: void 0,
    message: void 0,
    explanation: void 0
  };
}
var ApproveConversationResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversations !== void 0) {
      ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      ApproveConversationResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.user !== void 0) {
      ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.modActions).forEach(([key, value]) => {
      ApproveConversationResponse_ModActionsEntry.encode({ key, value }, writer.uint32(34).fork()).ldelim();
    });
    for (const v of message.fields) {
      StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(50).fork()).ldelim();
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(58).fork()).ldelim();
    }
    if (message.explanation !== void 0) {
      StringValue.encode({ value: message.explanation }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseApproveConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversations = ConversationData.decode(reader, reader.uint32());
          break;
        case 2:
          const entry2 = ApproveConversationResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          break;
        case 3:
          message.user = ConversationUserData.decode(reader, reader.uint32());
          break;
        case 4:
          const entry4 = ApproveConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== void 0) {
            message.modActions[entry4.key] = entry4.value;
          }
          break;
        case 5:
          message.fields.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 6:
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.message = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.explanation = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversations: isSet89(object.conversations) ? ConversationData.fromJSON(object.conversations) : void 0,
      messages: isObject16(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      user: isSet89(object.user) ? ConversationUserData.fromJSON(object.user) : void 0,
      modActions: isObject16(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {},
      fields: Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
      reason: isSet89(object.reason) ? String(object.reason) : void 0,
      message: isSet89(object.message) ? String(object.message) : void 0,
      explanation: isSet89(object.explanation) ? String(object.explanation) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.conversations !== void 0 && (obj.conversations = message.conversations ? ConversationData.toJSON(message.conversations) : void 0);
    obj.messages = {};
    if (message.messages) {
      Object.entries(message.messages).forEach(([k, v]) => {
        obj.messages[k] = MessageData.toJSON(v);
      });
    }
    message.user !== void 0 && (obj.user = message.user ? ConversationUserData.toJSON(message.user) : void 0);
    obj.modActions = {};
    if (message.modActions) {
      Object.entries(message.modActions).forEach(([k, v]) => {
        obj.modActions[k] = ModActionData.toJSON(v);
      });
    }
    if (message.fields) {
      obj.fields = message.fields.map((e) => e);
    } else {
      obj.fields = [];
    }
    message.reason !== void 0 && (obj.reason = message.reason);
    message.message !== void 0 && (obj.message = message.message);
    message.explanation !== void 0 && (obj.explanation = message.explanation);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseApproveConversationResponse();
    message.conversations = object.conversations !== void 0 && object.conversations !== null ? ConversationData.fromPartial(object.conversations) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.user = object.user !== void 0 && object.user !== null ? ConversationUserData.fromPartial(object.user) : void 0;
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    message.fields = object.fields?.map((e) => e) || [];
    message.reason = object.reason ?? void 0;
    message.message = object.message ?? void 0;
    message.explanation = object.explanation ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ApproveConversationResponse", ApproveConversationResponse);
function createBaseApproveConversationResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var ApproveConversationResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.MessagesEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseApproveConversationResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = MessageData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? MessageData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseApproveConversationResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.MessagesEntry", ApproveConversationResponse_MessagesEntry);
function createBaseApproveConversationResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var ApproveConversationResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.ModActionsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseApproveConversationResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ModActionData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ModActionData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseApproveConversationResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.ModActionsEntry", ApproveConversationResponse_ModActionsEntry);
function createBaseArchiveConversationResponse() {
  return { conversations: void 0, messages: {}, modActions: {} };
}
var ArchiveConversationResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversations !== void 0) {
      ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      ArchiveConversationResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    Object.entries(message.modActions).forEach(([key, value]) => {
      ArchiveConversationResponse_ModActionsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseArchiveConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversations = ConversationData.decode(reader, reader.uint32());
          break;
        case 2:
          const entry2 = ArchiveConversationResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          break;
        case 3:
          const entry3 = ArchiveConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.modActions[entry3.key] = entry3.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversations: isSet89(object.conversations) ? ConversationData.fromJSON(object.conversations) : void 0,
      messages: isObject16(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      modActions: isObject16(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.conversations !== void 0 && (obj.conversations = message.conversations ? ConversationData.toJSON(message.conversations) : void 0);
    obj.messages = {};
    if (message.messages) {
      Object.entries(message.messages).forEach(([k, v]) => {
        obj.messages[k] = MessageData.toJSON(v);
      });
    }
    obj.modActions = {};
    if (message.modActions) {
      Object.entries(message.modActions).forEach(([k, v]) => {
        obj.modActions[k] = ModActionData.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseArchiveConversationResponse();
    message.conversations = object.conversations !== void 0 && object.conversations !== null ? ConversationData.fromPartial(object.conversations) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse", ArchiveConversationResponse);
function createBaseArchiveConversationResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var ArchiveConversationResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.MessagesEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseArchiveConversationResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = MessageData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? MessageData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseArchiveConversationResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.MessagesEntry", ArchiveConversationResponse_MessagesEntry);
function createBaseArchiveConversationResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var ArchiveConversationResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.ModActionsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseArchiveConversationResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ModActionData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ModActionData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseArchiveConversationResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.ModActionsEntry", ArchiveConversationResponse_ModActionsEntry);
function createBaseHighlightConversationResponse() {
  return { conversations: void 0, messages: {}, modActions: {} };
}
var HighlightConversationResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversations !== void 0) {
      ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      HighlightConversationResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    Object.entries(message.modActions).forEach(([key, value]) => {
      HighlightConversationResponse_ModActionsEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHighlightConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversations = ConversationData.decode(reader, reader.uint32());
          break;
        case 2:
          const entry2 = HighlightConversationResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          break;
        case 3:
          const entry3 = HighlightConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.modActions[entry3.key] = entry3.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversations: isSet89(object.conversations) ? ConversationData.fromJSON(object.conversations) : void 0,
      messages: isObject16(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      modActions: isObject16(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.conversations !== void 0 && (obj.conversations = message.conversations ? ConversationData.toJSON(message.conversations) : void 0);
    obj.messages = {};
    if (message.messages) {
      Object.entries(message.messages).forEach(([k, v]) => {
        obj.messages[k] = MessageData.toJSON(v);
      });
    }
    obj.modActions = {};
    if (message.modActions) {
      Object.entries(message.modActions).forEach(([k, v]) => {
        obj.modActions[k] = ModActionData.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseHighlightConversationResponse();
    message.conversations = object.conversations !== void 0 && object.conversations !== null ? ConversationData.fromPartial(object.conversations) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.HighlightConversationResponse", HighlightConversationResponse);
function createBaseHighlightConversationResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var HighlightConversationResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.MessagesEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHighlightConversationResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = MessageData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? MessageData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseHighlightConversationResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.MessagesEntry", HighlightConversationResponse_MessagesEntry);
function createBaseHighlightConversationResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var HighlightConversationResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.ModActionsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHighlightConversationResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ModActionData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ModActionData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseHighlightConversationResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.ModActionsEntry", HighlightConversationResponse_ModActionsEntry);
function createBaseMuteConversationResponse() {
  return { conversations: void 0, messages: {}, user: void 0, modActions: {} };
}
var MuteConversationResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversations !== void 0) {
      ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      MuteConversationResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.user !== void 0) {
      ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.modActions).forEach(([key, value]) => {
      MuteConversationResponse_ModActionsEntry.encode({ key, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMuteConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversations = ConversationData.decode(reader, reader.uint32());
          break;
        case 2:
          const entry2 = MuteConversationResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          break;
        case 3:
          message.user = ConversationUserData.decode(reader, reader.uint32());
          break;
        case 4:
          const entry4 = MuteConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== void 0) {
            message.modActions[entry4.key] = entry4.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversations: isSet89(object.conversations) ? ConversationData.fromJSON(object.conversations) : void 0,
      messages: isObject16(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      user: isSet89(object.user) ? ConversationUserData.fromJSON(object.user) : void 0,
      modActions: isObject16(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.conversations !== void 0 && (obj.conversations = message.conversations ? ConversationData.toJSON(message.conversations) : void 0);
    obj.messages = {};
    if (message.messages) {
      Object.entries(message.messages).forEach(([k, v]) => {
        obj.messages[k] = MessageData.toJSON(v);
      });
    }
    message.user !== void 0 && (obj.user = message.user ? ConversationUserData.toJSON(message.user) : void 0);
    obj.modActions = {};
    if (message.modActions) {
      Object.entries(message.modActions).forEach(([k, v]) => {
        obj.modActions[k] = ModActionData.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMuteConversationResponse();
    message.conversations = object.conversations !== void 0 && object.conversations !== null ? ConversationData.fromPartial(object.conversations) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.user = object.user !== void 0 && object.user !== null ? ConversationUserData.fromPartial(object.user) : void 0;
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.MuteConversationResponse", MuteConversationResponse);
function createBaseMuteConversationResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var MuteConversationResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse.MessagesEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMuteConversationResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = MessageData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? MessageData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMuteConversationResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.MuteConversationResponse.MessagesEntry", MuteConversationResponse_MessagesEntry);
function createBaseMuteConversationResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var MuteConversationResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse.ModActionsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMuteConversationResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ModActionData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ModActionData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMuteConversationResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.MuteConversationResponse.ModActionsEntry", MuteConversationResponse_ModActionsEntry);
function createBaseTempBanResponse() {
  return {
    conversations: void 0,
    messages: {},
    user: void 0,
    modActions: {},
    fields: [],
    reason: void 0,
    message: void 0
  };
}
var TempBanResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.conversations !== void 0) {
      ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.messages).forEach(([key, value]) => {
      TempBanResponse_MessagesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.user !== void 0) {
      ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.modActions).forEach(([key, value]) => {
      TempBanResponse_ModActionsEntry.encode({ key, value }, writer.uint32(34).fork()).ldelim();
    });
    for (const v of message.fields) {
      StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(50).fork()).ldelim();
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTempBanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversations = ConversationData.decode(reader, reader.uint32());
          break;
        case 2:
          const entry2 = TempBanResponse_MessagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.messages[entry2.key] = entry2.value;
          }
          break;
        case 3:
          message.user = ConversationUserData.decode(reader, reader.uint32());
          break;
        case 4:
          const entry4 = TempBanResponse_ModActionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== void 0) {
            message.modActions[entry4.key] = entry4.value;
          }
          break;
        case 5:
          message.fields.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 6:
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.message = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      conversations: isSet89(object.conversations) ? ConversationData.fromJSON(object.conversations) : void 0,
      messages: isObject16(object.messages) ? Object.entries(object.messages).reduce((acc, [key, value]) => {
        acc[key] = MessageData.fromJSON(value);
        return acc;
      }, {}) : {},
      user: isSet89(object.user) ? ConversationUserData.fromJSON(object.user) : void 0,
      modActions: isObject16(object.modActions) ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
        acc[key] = ModActionData.fromJSON(value);
        return acc;
      }, {}) : {},
      fields: Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
      reason: isSet89(object.reason) ? String(object.reason) : void 0,
      message: isSet89(object.message) ? String(object.message) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.conversations !== void 0 && (obj.conversations = message.conversations ? ConversationData.toJSON(message.conversations) : void 0);
    obj.messages = {};
    if (message.messages) {
      Object.entries(message.messages).forEach(([k, v]) => {
        obj.messages[k] = MessageData.toJSON(v);
      });
    }
    message.user !== void 0 && (obj.user = message.user ? ConversationUserData.toJSON(message.user) : void 0);
    obj.modActions = {};
    if (message.modActions) {
      Object.entries(message.modActions).forEach(([k, v]) => {
        obj.modActions[k] = ModActionData.toJSON(v);
      });
    }
    if (message.fields) {
      obj.fields = message.fields.map((e) => e);
    } else {
      obj.fields = [];
    }
    message.reason !== void 0 && (obj.reason = message.reason);
    message.message !== void 0 && (obj.message = message.message);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTempBanResponse();
    message.conversations = object.conversations !== void 0 && object.conversations !== null ? ConversationData.fromPartial(object.conversations) : void 0;
    message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MessageData.fromPartial(value);
      }
      return acc;
    }, {});
    message.user = object.user !== void 0 && object.user !== null ? ConversationUserData.fromPartial(object.user) : void 0;
    message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = ModActionData.fromPartial(value);
      }
      return acc;
    }, {});
    message.fields = object.fields?.map((e) => e) || [];
    message.reason = object.reason ?? void 0;
    message.message = object.message ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.TempBanResponse", TempBanResponse);
function createBaseTempBanResponse_MessagesEntry() {
  return { key: "", value: void 0 };
}
var TempBanResponse_MessagesEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse.MessagesEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTempBanResponse_MessagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = MessageData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? MessageData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? MessageData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTempBanResponse_MessagesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MessageData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.TempBanResponse.MessagesEntry", TempBanResponse_MessagesEntry);
function createBaseTempBanResponse_ModActionsEntry() {
  return { key: "", value: void 0 };
}
var TempBanResponse_ModActionsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse.ModActionsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTempBanResponse_ModActionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ModActionData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? ModActionData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? ModActionData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTempBanResponse_ModActionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ModActionData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.TempBanResponse.ModActionsEntry", TempBanResponse_ModActionsEntry);
function createBaseSubredditsResponse() {
  return { subreddits: {} };
}
var SubredditsResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    Object.entries(message.subreddits).forEach(([key, value]) => {
      SubredditsResponse_SubredditsEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = SubredditsResponse_SubredditsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.subreddits[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddits: isObject16(object.subreddits) ? Object.entries(object.subreddits).reduce((acc, [key, value]) => {
        acc[key] = SubredditsResponse_SubredditData.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    obj.subreddits = {};
    if (message.subreddits) {
      Object.entries(message.subreddits).forEach(([k, v]) => {
        obj.subreddits[k] = SubredditsResponse_SubredditData.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditsResponse();
    message.subreddits = Object.entries(object.subreddits ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = SubredditsResponse_SubredditData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.SubredditsResponse", SubredditsResponse);
function createBaseSubredditsResponse_SubredditData() {
  return {
    communityIcon: void 0,
    keyColor: void 0,
    displayName: void 0,
    name: void 0,
    subscribers: void 0,
    primaryColor: void 0,
    id: void 0,
    lastUpdated: void 0,
    icon: void 0
  };
}
var SubredditsResponse_SubredditData = {
  $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditData",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(10).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(18).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int32Value.encode({ value: message.subscribers }, writer.uint32(42).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(50).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(58).fork()).ldelim();
    }
    if (message.lastUpdated !== void 0) {
      StringValue.encode({ value: message.lastUpdated }, writer.uint32(66).fork()).ldelim();
    }
    if (message.icon !== void 0) {
      StringValue.encode({ value: message.icon }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsResponse_SubredditData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.subscribers = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.lastUpdated = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.icon = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      communityIcon: isSet89(object.communityIcon) ? String(object.communityIcon) : void 0,
      keyColor: isSet89(object.keyColor) ? String(object.keyColor) : void 0,
      displayName: isSet89(object.displayName) ? String(object.displayName) : void 0,
      name: isSet89(object.name) ? String(object.name) : void 0,
      subscribers: isSet89(object.subscribers) ? Number(object.subscribers) : void 0,
      primaryColor: isSet89(object.primaryColor) ? String(object.primaryColor) : void 0,
      id: isSet89(object.id) ? String(object.id) : void 0,
      lastUpdated: isSet89(object.lastUpdated) ? String(object.lastUpdated) : void 0,
      icon: isSet89(object.icon) ? String(object.icon) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.communityIcon !== void 0 && (obj.communityIcon = message.communityIcon);
    message.keyColor !== void 0 && (obj.keyColor = message.keyColor);
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    message.name !== void 0 && (obj.name = message.name);
    message.subscribers !== void 0 && (obj.subscribers = message.subscribers);
    message.primaryColor !== void 0 && (obj.primaryColor = message.primaryColor);
    message.id !== void 0 && (obj.id = message.id);
    message.lastUpdated !== void 0 && (obj.lastUpdated = message.lastUpdated);
    message.icon !== void 0 && (obj.icon = message.icon);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditsResponse_SubredditData();
    message.communityIcon = object.communityIcon ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.name = object.name ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.primaryColor = object.primaryColor ?? void 0;
    message.id = object.id ?? void 0;
    message.lastUpdated = object.lastUpdated ?? void 0;
    message.icon = object.icon ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditData", SubredditsResponse_SubredditData);
function createBaseSubredditsResponse_SubredditsEntry() {
  return { key: "", value: void 0 };
}
var SubredditsResponse_SubredditsEntry = {
  $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditsEntry",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      SubredditsResponse_SubredditData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsResponse_SubredditsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = SubredditsResponse_SubredditData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet89(object.key) ? String(object.key) : "",
      value: isSet89(object.value) ? SubredditsResponse_SubredditData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? SubredditsResponse_SubredditData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditsResponse_SubredditsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? SubredditsResponse_SubredditData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditsEntry", SubredditsResponse_SubredditsEntry);
function createBaseUnreadCountResponse() {
  return {
    archived: void 0,
    appeals: void 0,
    highlighted: void 0,
    notifications: void 0,
    joinRequests: void 0,
    filtered: void 0,
    new: void 0,
    inprogress: void 0,
    mod: void 0
  };
}
var UnreadCountResponse = {
  $type: "devvit.plugin.redditapi.newmodmail.UnreadCountResponse",
  encode(message, writer = import_minimal102.default.Writer.create()) {
    if (message.archived !== void 0) {
      Int32Value.encode({ value: message.archived }, writer.uint32(10).fork()).ldelim();
    }
    if (message.appeals !== void 0) {
      Int32Value.encode({ value: message.appeals }, writer.uint32(18).fork()).ldelim();
    }
    if (message.highlighted !== void 0) {
      Int32Value.encode({ value: message.highlighted }, writer.uint32(26).fork()).ldelim();
    }
    if (message.notifications !== void 0) {
      Int32Value.encode({ value: message.notifications }, writer.uint32(34).fork()).ldelim();
    }
    if (message.joinRequests !== void 0) {
      Int32Value.encode({ value: message.joinRequests }, writer.uint32(42).fork()).ldelim();
    }
    if (message.filtered !== void 0) {
      Int32Value.encode({ value: message.filtered }, writer.uint32(50).fork()).ldelim();
    }
    if (message.new !== void 0) {
      Int32Value.encode({ value: message.new }, writer.uint32(58).fork()).ldelim();
    }
    if (message.inprogress !== void 0) {
      Int32Value.encode({ value: message.inprogress }, writer.uint32(66).fork()).ldelim();
    }
    if (message.mod !== void 0) {
      Int32Value.encode({ value: message.mod }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal102.default.Reader ? input : new import_minimal102.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnreadCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.archived = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.appeals = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.highlighted = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.notifications = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.joinRequests = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.filtered = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.new = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.inprogress = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.mod = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      archived: isSet89(object.archived) ? Number(object.archived) : void 0,
      appeals: isSet89(object.appeals) ? Number(object.appeals) : void 0,
      highlighted: isSet89(object.highlighted) ? Number(object.highlighted) : void 0,
      notifications: isSet89(object.notifications) ? Number(object.notifications) : void 0,
      joinRequests: isSet89(object.joinRequests) ? Number(object.joinRequests) : void 0,
      filtered: isSet89(object.filtered) ? Number(object.filtered) : void 0,
      new: isSet89(object.new) ? Number(object.new) : void 0,
      inprogress: isSet89(object.inprogress) ? Number(object.inprogress) : void 0,
      mod: isSet89(object.mod) ? Number(object.mod) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.archived !== void 0 && (obj.archived = message.archived);
    message.appeals !== void 0 && (obj.appeals = message.appeals);
    message.highlighted !== void 0 && (obj.highlighted = message.highlighted);
    message.notifications !== void 0 && (obj.notifications = message.notifications);
    message.joinRequests !== void 0 && (obj.joinRequests = message.joinRequests);
    message.filtered !== void 0 && (obj.filtered = message.filtered);
    message.new !== void 0 && (obj.new = message.new);
    message.inprogress !== void 0 && (obj.inprogress = message.inprogress);
    message.mod !== void 0 && (obj.mod = message.mod);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUnreadCountResponse();
    message.archived = object.archived ?? void 0;
    message.appeals = object.appeals ?? void 0;
    message.highlighted = object.highlighted ?? void 0;
    message.notifications = object.notifications ?? void 0;
    message.joinRequests = object.joinRequests ?? void 0;
    message.filtered = object.filtered ?? void 0;
    message.new = object.new ?? void 0;
    message.inprogress = object.inprogress ?? void 0;
    message.mod = object.mod ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.newmodmail.UnreadCountResponse", UnreadCountResponse);
function isObject16(value) {
  return typeof value === "object" && value !== null;
}
function isSet89(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/newmodmail/newmodmail_svc.js
var import_minimal103 = __toESM(require_minimal2(), 1);
var NewModmailDefinition = {
  name: "NewModmail",
  fullName: "devvit.plugin.redditapi.newmodmail.NewModmail",
  methods: {
    /** https://www.reddit.com/dev/api#POST_api_mod_bulk_read */
    bulkReadConversations: {
      name: "BulkReadConversations",
      requestType: BulkReadConversationsRequest,
      requestStream: false,
      responseType: BulkReadConversationsResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_mod_conversations */
    getConversations: {
      name: "GetConversations",
      requestType: GetConversationsRequest,
      requestStream: false,
      responseType: GetConversationsResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations */
    createConversation: {
      name: "CreateConversation",
      requestType: CreateConversationRequest,
      requestStream: false,
      responseType: CreateConversationResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_mod_conversations_:conversation_id */
    getConversation: {
      name: "GetConversation",
      requestType: GetConversationRequest,
      requestStream: false,
      responseType: GetConversationResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id */
    createConversationMessage: {
      name: "CreateConversationMessage",
      requestType: CreateConversationMessageRequest,
      requestStream: false,
      responseType: CreateConversationMessageResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_approve */
    approveConversation: {
      name: "ApproveConversation",
      requestType: BasicConversationRequest,
      requestStream: false,
      responseType: ApproveConversationResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_archive */
    archiveConversation: {
      name: "ArchiveConversation",
      requestType: BasicConversationRequest,
      requestStream: false,
      responseType: ArchiveConversationResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_disapprove */
    disapproveConversation: {
      name: "DisapproveConversation",
      requestType: BasicConversationRequest,
      requestStream: false,
      responseType: ApproveConversationResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#DELETE_api_mod_conversations_:conversation_id_highlight */
    unhighlightConversation: {
      name: "UnhighlightConversation",
      requestType: BasicConversationRequest,
      requestStream: false,
      responseType: HighlightConversationResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_highlight */
    highlightConversation: {
      name: "HighlightConversation",
      requestType: BasicConversationRequest,
      requestStream: false,
      responseType: HighlightConversationResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_mute */
    muteConversation: {
      name: "MuteConversation",
      requestType: MuteConversationRequest,
      requestStream: false,
      responseType: MuteConversationResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_temp_ban */
    tempBan: {
      name: "TempBan",
      requestType: TempBanRequest,
      requestStream: false,
      responseType: TempBanResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_unarchive */
    unarchiveConversation: {
      name: "UnarchiveConversation",
      requestType: BasicConversationRequest,
      requestStream: false,
      responseType: ArchiveConversationResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_unban */
    unban: {
      name: "Unban",
      requestType: BasicConversationRequest,
      requestStream: false,
      responseType: TempBanResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_:conversation_id_unmute */
    unmuteConversation: {
      name: "UnmuteConversation",
      requestType: BasicConversationRequest,
      requestStream: false,
      responseType: MuteConversationResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_mod_conversations_:conversation_id_user */
    userConversations: {
      name: "UserConversations",
      requestType: BasicConversationRequest,
      requestStream: false,
      responseType: ConversationUserData,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_read */
    read: {
      name: "Read",
      requestType: BasicConversationsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_mod_conversations_subreddits */
    subreddits: {
      name: "Subreddits",
      requestType: Empty,
      requestStream: false,
      responseType: SubredditsResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_mod_conversations_unread */
    unread: {
      name: "Unread",
      requestType: BasicConversationsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_mod_conversations_unread_count */
    unreadCount: {
      name: "UnreadCount",
      requestType: Empty,
      requestStream: false,
      responseType: UnreadCountResponse,
      responseStream: false,
      options: {}
    }
  }
};

// ../protos/dist/types/devvit/plugin/redditapi/privatemessages/privatemessages_msg.js
var import_minimal104 = __toESM(require_minimal2(), 1);
function createBaseGenericPrivateMessagesRequest() {
  return { id: "" };
}
var GenericPrivateMessagesRequest = {
  $type: "devvit.plugin.redditapi.privatemessages.GenericPrivateMessagesRequest",
  encode(message, writer = import_minimal104.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal104.default.Reader ? input : new import_minimal104.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenericPrivateMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet90(object.id) ? String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGenericPrivateMessagesRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.privatemessages.GenericPrivateMessagesRequest", GenericPrivateMessagesRequest);
function createBaseComposeRequest() {
  return { to: "", subject: "", text: "", fromSr: "" };
}
var ComposeRequest = {
  $type: "devvit.plugin.redditapi.privatemessages.ComposeRequest",
  encode(message, writer = import_minimal104.default.Writer.create()) {
    if (message.to !== "") {
      writer.uint32(10).string(message.to);
    }
    if (message.subject !== "") {
      writer.uint32(18).string(message.subject);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.fromSr !== "") {
      writer.uint32(34).string(message.fromSr);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal104.default.Reader ? input : new import_minimal104.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseComposeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.to = reader.string();
          break;
        case 2:
          message.subject = reader.string();
          break;
        case 3:
          message.text = reader.string();
          break;
        case 4:
          message.fromSr = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      to: isSet90(object.to) ? String(object.to) : "",
      subject: isSet90(object.subject) ? String(object.subject) : "",
      text: isSet90(object.text) ? String(object.text) : "",
      fromSr: isSet90(object.fromSr) ? String(object.fromSr) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.to !== void 0 && (obj.to = message.to);
    message.subject !== void 0 && (obj.subject = message.subject);
    message.text !== void 0 && (obj.text = message.text);
    message.fromSr !== void 0 && (obj.fromSr = message.fromSr);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseComposeRequest();
    message.to = object.to ?? "";
    message.subject = object.subject ?? "";
    message.text = object.text ?? "";
    message.fromSr = object.fromSr ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.privatemessages.ComposeRequest", ComposeRequest);
function createBaseReadAllMessagesRequest() {
  return { filterTypes: "" };
}
var ReadAllMessagesRequest = {
  $type: "devvit.plugin.redditapi.privatemessages.ReadAllMessagesRequest",
  encode(message, writer = import_minimal104.default.Writer.create()) {
    if (message.filterTypes !== "") {
      writer.uint32(10).string(message.filterTypes);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal104.default.Reader ? input : new import_minimal104.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReadAllMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.filterTypes = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { filterTypes: isSet90(object.filterTypes) ? String(object.filterTypes) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.filterTypes !== void 0 && (obj.filterTypes = message.filterTypes);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseReadAllMessagesRequest();
    message.filterTypes = object.filterTypes ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.privatemessages.ReadAllMessagesRequest", ReadAllMessagesRequest);
function createBaseMessageWhereRequest() {
  return {
    where: "",
    mark: void 0,
    mid: void 0,
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    show: void 0
  };
}
var MessageWhereRequest = {
  $type: "devvit.plugin.redditapi.privatemessages.MessageWhereRequest",
  encode(message, writer = import_minimal104.default.Writer.create()) {
    if (message.where !== "") {
      writer.uint32(10).string(message.where);
    }
    if (message.mark !== void 0) {
      BoolValue.encode({ value: message.mark }, writer.uint32(18).fork()).ldelim();
    }
    if (message.mid !== void 0) {
      StringValue.encode({ value: message.mid }, writer.uint32(26).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(34).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(42).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(58).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal104.default.Reader ? input : new import_minimal104.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageWhereRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.where = reader.string();
          break;
        case 2:
          message.mark = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.mid = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      where: isSet90(object.where) ? String(object.where) : "",
      mark: isSet90(object.mark) ? Boolean(object.mark) : void 0,
      mid: isSet90(object.mid) ? String(object.mid) : void 0,
      after: isSet90(object.after) ? String(object.after) : void 0,
      before: isSet90(object.before) ? String(object.before) : void 0,
      count: isSet90(object.count) ? Number(object.count) : void 0,
      limit: isSet90(object.limit) ? Number(object.limit) : void 0,
      show: isSet90(object.show) ? String(object.show) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.where !== void 0 && (obj.where = message.where);
    message.mark !== void 0 && (obj.mark = message.mark);
    message.mid !== void 0 && (obj.mid = message.mid);
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.count !== void 0 && (obj.count = message.count);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.show !== void 0 && (obj.show = message.show);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMessageWhereRequest();
    message.where = object.where ?? "";
    message.mark = object.mark ?? void 0;
    message.mid = object.mid ?? void 0;
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.show = object.show ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.privatemessages.MessageWhereRequest", MessageWhereRequest);
function isSet90(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/privatemessages/privatemessages_svc.js
var import_minimal105 = __toESM(require_minimal2(), 1);
var PrivateMessagesDefinition = {
  name: "PrivateMessages",
  fullName: "devvit.plugin.redditapi.privatemessages.PrivateMessages",
  methods: {
    /** https://www.reddit.com/dev/api#POST_api_block */
    block: {
      name: "Block",
      requestType: GenericPrivateMessagesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_collapse_message */
    collapseMessage: {
      name: "CollapseMessage",
      requestType: GenericPrivateMessagesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_compose */
    compose: {
      name: "Compose",
      requestType: ComposeRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_del_msg */
    delMsg: {
      name: "DelMsg",
      requestType: GenericPrivateMessagesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_read_all_messages */
    readAllMessages: {
      name: "ReadAllMessages",
      requestType: ReadAllMessagesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_read_message */
    readMessage: {
      name: "ReadMessage",
      requestType: GenericPrivateMessagesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_unblock_subreddit */
    unblockSubreddit: {
      name: "UnblockSubreddit",
      requestType: GenericPrivateMessagesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_uncollapse_message */
    uncollapseMessage: {
      name: "UncollapseMessage",
      requestType: GenericPrivateMessagesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_unread_message */
    unreadMessage: {
      name: "UnreadMessage",
      requestType: GenericPrivateMessagesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_message_where */
    messageWhere: {
      name: "MessageWhere",
      requestType: MessageWhereRequest,
      requestStream: false,
      responseType: Listing,
      responseStream: false,
      options: {}
    }
  }
};

// ../protos/dist/types/devvit/plugin/redditapi/subreddits/subreddits_msg.js
var import_long8 = __toESM(require_long(), 1);
var import_minimal106 = __toESM(require_minimal2(), 1);
function createBaseAboutWhereRequest() {
  return {
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    show: void 0,
    user: void 0,
    subreddit: void 0,
    where: ""
  };
}
var AboutWhereRequest = {
  $type: "devvit.plugin.redditapi.subreddits.AboutWhereRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
    }
    if (message.user !== void 0) {
      StringValue.encode({ value: message.user }, writer.uint32(58).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(66).fork()).ldelim();
    }
    if (message.where !== "") {
      writer.uint32(74).string(message.where);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAboutWhereRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.user = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.where = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet91(object.after) ? String(object.after) : void 0,
      before: isSet91(object.before) ? String(object.before) : void 0,
      count: isSet91(object.count) ? Number(object.count) : void 0,
      limit: isSet91(object.limit) ? Number(object.limit) : void 0,
      show: isSet91(object.show) ? String(object.show) : void 0,
      user: isSet91(object.user) ? String(object.user) : void 0,
      subreddit: isSet91(object.subreddit) ? String(object.subreddit) : void 0,
      where: isSet91(object.where) ? String(object.where) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.count !== void 0 && (obj.count = message.count);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.show !== void 0 && (obj.show = message.show);
    message.user !== void 0 && (obj.user = message.user);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.where !== void 0 && (obj.where = message.where);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAboutWhereRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.show = object.show ?? void 0;
    message.user = object.user ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.where = object.where ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.AboutWhereRequest", AboutWhereRequest);
function createBaseBasicSubredditRequest() {
  return { subreddit: "" };
}
var BasicSubredditRequest = {
  $type: "devvit.plugin.redditapi.subreddits.BasicSubredditRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicSubredditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet91(object.subreddit) ? String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBasicSubredditRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.BasicSubredditRequest", BasicSubredditRequest);
function createBaseDeleteSrImgRequest() {
  return { subreddit: "", imgName: "" };
}
var DeleteSrImgRequest = {
  $type: "devvit.plugin.redditapi.subreddits.DeleteSrImgRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.imgName !== "") {
      writer.uint32(18).string(message.imgName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteSrImgRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.imgName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet91(object.subreddit) ? String(object.subreddit) : "",
      imgName: isSet91(object.imgName) ? String(object.imgName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.imgName !== void 0 && (obj.imgName = message.imgName);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDeleteSrImgRequest();
    message.subreddit = object.subreddit ?? "";
    message.imgName = object.imgName ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.DeleteSrImgRequest", DeleteSrImgRequest);
function createBaseBasicSearchRequest() {
  return {
    exact: void 0,
    includeOver18: void 0,
    includeUnadvertisable: void 0,
    query: "",
    searchQueryId: void 0,
    typeaheadActive: void 0
  };
}
var BasicSearchRequest = {
  $type: "devvit.plugin.redditapi.subreddits.BasicSearchRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.exact !== void 0) {
      BoolValue.encode({ value: message.exact }, writer.uint32(10).fork()).ldelim();
    }
    if (message.includeOver18 !== void 0) {
      BoolValue.encode({ value: message.includeOver18 }, writer.uint32(18).fork()).ldelim();
    }
    if (message.includeUnadvertisable !== void 0) {
      BoolValue.encode({ value: message.includeUnadvertisable }, writer.uint32(26).fork()).ldelim();
    }
    if (message.query !== "") {
      writer.uint32(34).string(message.query);
    }
    if (message.searchQueryId !== void 0) {
      StringValue.encode({ value: message.searchQueryId }, writer.uint32(42).fork()).ldelim();
    }
    if (message.typeaheadActive !== void 0) {
      BoolValue.encode({ value: message.typeaheadActive }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.exact = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.includeOver18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.includeUnadvertisable = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.query = reader.string();
          break;
        case 5:
          message.searchQueryId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.typeaheadActive = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      exact: isSet91(object.exact) ? Boolean(object.exact) : void 0,
      includeOver18: isSet91(object.includeOver18) ? Boolean(object.includeOver18) : void 0,
      includeUnadvertisable: isSet91(object.includeUnadvertisable) ? Boolean(object.includeUnadvertisable) : void 0,
      query: isSet91(object.query) ? String(object.query) : "",
      searchQueryId: isSet91(object.searchQueryId) ? String(object.searchQueryId) : void 0,
      typeaheadActive: isSet91(object.typeaheadActive) ? Boolean(object.typeaheadActive) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.exact !== void 0 && (obj.exact = message.exact);
    message.includeOver18 !== void 0 && (obj.includeOver18 = message.includeOver18);
    message.includeUnadvertisable !== void 0 && (obj.includeUnadvertisable = message.includeUnadvertisable);
    message.query !== void 0 && (obj.query = message.query);
    message.searchQueryId !== void 0 && (obj.searchQueryId = message.searchQueryId);
    message.typeaheadActive !== void 0 && (obj.typeaheadActive = message.typeaheadActive);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBasicSearchRequest();
    message.exact = object.exact ?? void 0;
    message.includeOver18 = object.includeOver18 ?? void 0;
    message.includeUnadvertisable = object.includeUnadvertisable ?? void 0;
    message.query = object.query ?? "";
    message.searchQueryId = object.searchQueryId ?? void 0;
    message.typeaheadActive = object.typeaheadActive ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.BasicSearchRequest", BasicSearchRequest);
function createBaseSiteAdminRequest() {
  return {
    acceptFollowers: false,
    adminOverrideSpamComments: false,
    adminOverrideSpamLinks: false,
    adminOverrideSpamSelfposts: false,
    allOriginalContent: false,
    allowChatPostCreation: false,
    allowDiscovery: false,
    allowGalleries: false,
    allowImages: false,
    allowPolls: false,
    allowPostCrossposts: false,
    allowPredictionContributors: false,
    allowPredictions: false,
    allowPredictionsTournament: false,
    allowTalks: false,
    allowTop: false,
    allowVideos: false,
    banEvasionThreshold: 0,
    collapseDeletedComments: false,
    commentContributionSettings: void 0,
    commentScoreHideMins: 0,
    crowdControlFilter: false,
    crowdControlLevel: 0,
    crowdControlMode: false,
    crowdControlPostLevel: 0,
    description: "",
    disableContributorRequests: false,
    excludeBannedModqueue: false,
    freeFormReports: false,
    gRecaptchaResponse: "",
    hatefulContentThresholdAbuse: 0,
    hatefulContentThresholdIdentity: 0,
    headerTitle: "",
    keyColor: "",
    linkType: "",
    name: "",
    newPinnedPostPnsEnabled: false,
    originalContentTagEnabled: false,
    over18: false,
    predictionLeaderboardEntryType: 0,
    publicDescription: "",
    restrictCommenting: false,
    restrictPosting: false,
    shouldArchivePosts: false,
    showMedia: false,
    showMediaPreview: false,
    spamComments: "",
    spamLinks: "",
    spamSelfposts: "",
    spoilersEnabled: false,
    sr: "",
    submitLinkLabel: "",
    submitText: "",
    submitTextLabel: "",
    suggestedCommentSort: "",
    title: "",
    toxicityThresholdChatLevel: 0,
    type: "",
    userFlairPnsEnabled: false,
    welcomeMessageEnabled: false,
    welcomeMessageText: "",
    wikiEditAge: 0,
    wikiEditKarma: 0,
    wikimode: "",
    crowdControlChatLevel: 0,
    hideAds: false,
    modmailHarassmentFilterEnabled: false
  };
}
var SiteAdminRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SiteAdminRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.acceptFollowers === true) {
      writer.uint32(8).bool(message.acceptFollowers);
    }
    if (message.adminOverrideSpamComments === true) {
      writer.uint32(16).bool(message.adminOverrideSpamComments);
    }
    if (message.adminOverrideSpamLinks === true) {
      writer.uint32(24).bool(message.adminOverrideSpamLinks);
    }
    if (message.adminOverrideSpamSelfposts === true) {
      writer.uint32(32).bool(message.adminOverrideSpamSelfposts);
    }
    if (message.allOriginalContent === true) {
      writer.uint32(40).bool(message.allOriginalContent);
    }
    if (message.allowChatPostCreation === true) {
      writer.uint32(48).bool(message.allowChatPostCreation);
    }
    if (message.allowDiscovery === true) {
      writer.uint32(56).bool(message.allowDiscovery);
    }
    if (message.allowGalleries === true) {
      writer.uint32(64).bool(message.allowGalleries);
    }
    if (message.allowImages === true) {
      writer.uint32(72).bool(message.allowImages);
    }
    if (message.allowPolls === true) {
      writer.uint32(80).bool(message.allowPolls);
    }
    if (message.allowPostCrossposts === true) {
      writer.uint32(88).bool(message.allowPostCrossposts);
    }
    if (message.allowPredictionContributors === true) {
      writer.uint32(96).bool(message.allowPredictionContributors);
    }
    if (message.allowPredictions === true) {
      writer.uint32(104).bool(message.allowPredictions);
    }
    if (message.allowPredictionsTournament === true) {
      writer.uint32(112).bool(message.allowPredictionsTournament);
    }
    if (message.allowTalks === true) {
      writer.uint32(120).bool(message.allowTalks);
    }
    if (message.allowTop === true) {
      writer.uint32(128).bool(message.allowTop);
    }
    if (message.allowVideos === true) {
      writer.uint32(136).bool(message.allowVideos);
    }
    if (message.banEvasionThreshold !== 0) {
      writer.uint32(144).int64(message.banEvasionThreshold);
    }
    if (message.collapseDeletedComments === true) {
      writer.uint32(152).bool(message.collapseDeletedComments);
    }
    if (message.commentContributionSettings !== void 0) {
      CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(162).fork()).ldelim();
    }
    if (message.commentScoreHideMins !== 0) {
      writer.uint32(168).int32(message.commentScoreHideMins);
    }
    if (message.crowdControlFilter === true) {
      writer.uint32(176).bool(message.crowdControlFilter);
    }
    if (message.crowdControlLevel !== 0) {
      writer.uint32(184).int64(message.crowdControlLevel);
    }
    if (message.crowdControlMode === true) {
      writer.uint32(192).bool(message.crowdControlMode);
    }
    if (message.crowdControlPostLevel !== 0) {
      writer.uint32(200).int64(message.crowdControlPostLevel);
    }
    if (message.description !== "") {
      writer.uint32(210).string(message.description);
    }
    if (message.disableContributorRequests === true) {
      writer.uint32(216).bool(message.disableContributorRequests);
    }
    if (message.excludeBannedModqueue === true) {
      writer.uint32(224).bool(message.excludeBannedModqueue);
    }
    if (message.freeFormReports === true) {
      writer.uint32(232).bool(message.freeFormReports);
    }
    if (message.gRecaptchaResponse !== "") {
      writer.uint32(242).string(message.gRecaptchaResponse);
    }
    if (message.hatefulContentThresholdAbuse !== 0) {
      writer.uint32(248).int64(message.hatefulContentThresholdAbuse);
    }
    if (message.hatefulContentThresholdIdentity !== 0) {
      writer.uint32(256).int64(message.hatefulContentThresholdIdentity);
    }
    if (message.headerTitle !== "") {
      writer.uint32(266).string(message.headerTitle);
    }
    if (message.keyColor !== "") {
      writer.uint32(274).string(message.keyColor);
    }
    if (message.linkType !== "") {
      writer.uint32(290).string(message.linkType);
    }
    if (message.name !== "") {
      writer.uint32(298).string(message.name);
    }
    if (message.newPinnedPostPnsEnabled === true) {
      writer.uint32(304).bool(message.newPinnedPostPnsEnabled);
    }
    if (message.originalContentTagEnabled === true) {
      writer.uint32(312).bool(message.originalContentTagEnabled);
    }
    if (message.over18 === true) {
      writer.uint32(320).bool(message.over18);
    }
    if (message.predictionLeaderboardEntryType !== 0) {
      writer.uint32(328).int64(message.predictionLeaderboardEntryType);
    }
    if (message.publicDescription !== "") {
      writer.uint32(338).string(message.publicDescription);
    }
    if (message.restrictCommenting === true) {
      writer.uint32(344).bool(message.restrictCommenting);
    }
    if (message.restrictPosting === true) {
      writer.uint32(352).bool(message.restrictPosting);
    }
    if (message.shouldArchivePosts === true) {
      writer.uint32(360).bool(message.shouldArchivePosts);
    }
    if (message.showMedia === true) {
      writer.uint32(368).bool(message.showMedia);
    }
    if (message.showMediaPreview === true) {
      writer.uint32(376).bool(message.showMediaPreview);
    }
    if (message.spamComments !== "") {
      writer.uint32(386).string(message.spamComments);
    }
    if (message.spamLinks !== "") {
      writer.uint32(394).string(message.spamLinks);
    }
    if (message.spamSelfposts !== "") {
      writer.uint32(402).string(message.spamSelfposts);
    }
    if (message.spoilersEnabled === true) {
      writer.uint32(408).bool(message.spoilersEnabled);
    }
    if (message.sr !== "") {
      writer.uint32(418).string(message.sr);
    }
    if (message.submitLinkLabel !== "") {
      writer.uint32(426).string(message.submitLinkLabel);
    }
    if (message.submitText !== "") {
      writer.uint32(434).string(message.submitText);
    }
    if (message.submitTextLabel !== "") {
      writer.uint32(442).string(message.submitTextLabel);
    }
    if (message.suggestedCommentSort !== "") {
      writer.uint32(450).string(message.suggestedCommentSort);
    }
    if (message.title !== "") {
      writer.uint32(458).string(message.title);
    }
    if (message.toxicityThresholdChatLevel !== 0) {
      writer.uint32(464).int64(message.toxicityThresholdChatLevel);
    }
    if (message.type !== "") {
      writer.uint32(474).string(message.type);
    }
    if (message.userFlairPnsEnabled === true) {
      writer.uint32(480).bool(message.userFlairPnsEnabled);
    }
    if (message.welcomeMessageEnabled === true) {
      writer.uint32(488).bool(message.welcomeMessageEnabled);
    }
    if (message.welcomeMessageText !== "") {
      writer.uint32(498).string(message.welcomeMessageText);
    }
    if (message.wikiEditAge !== 0) {
      writer.uint32(504).int64(message.wikiEditAge);
    }
    if (message.wikiEditKarma !== 0) {
      writer.uint32(512).int64(message.wikiEditKarma);
    }
    if (message.wikimode !== "") {
      writer.uint32(522).string(message.wikimode);
    }
    if (message.crowdControlChatLevel !== 0) {
      writer.uint32(528).int64(message.crowdControlChatLevel);
    }
    if (message.hideAds === true) {
      writer.uint32(536).bool(message.hideAds);
    }
    if (message.modmailHarassmentFilterEnabled === true) {
      writer.uint32(544).bool(message.modmailHarassmentFilterEnabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSiteAdminRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.acceptFollowers = reader.bool();
          break;
        case 2:
          message.adminOverrideSpamComments = reader.bool();
          break;
        case 3:
          message.adminOverrideSpamLinks = reader.bool();
          break;
        case 4:
          message.adminOverrideSpamSelfposts = reader.bool();
          break;
        case 5:
          message.allOriginalContent = reader.bool();
          break;
        case 6:
          message.allowChatPostCreation = reader.bool();
          break;
        case 7:
          message.allowDiscovery = reader.bool();
          break;
        case 8:
          message.allowGalleries = reader.bool();
          break;
        case 9:
          message.allowImages = reader.bool();
          break;
        case 10:
          message.allowPolls = reader.bool();
          break;
        case 11:
          message.allowPostCrossposts = reader.bool();
          break;
        case 12:
          message.allowPredictionContributors = reader.bool();
          break;
        case 13:
          message.allowPredictions = reader.bool();
          break;
        case 14:
          message.allowPredictionsTournament = reader.bool();
          break;
        case 15:
          message.allowTalks = reader.bool();
          break;
        case 16:
          message.allowTop = reader.bool();
          break;
        case 17:
          message.allowVideos = reader.bool();
          break;
        case 18:
          message.banEvasionThreshold = longToNumber8(reader.int64());
          break;
        case 19:
          message.collapseDeletedComments = reader.bool();
          break;
        case 20:
          message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
          break;
        case 21:
          message.commentScoreHideMins = reader.int32();
          break;
        case 22:
          message.crowdControlFilter = reader.bool();
          break;
        case 23:
          message.crowdControlLevel = longToNumber8(reader.int64());
          break;
        case 24:
          message.crowdControlMode = reader.bool();
          break;
        case 25:
          message.crowdControlPostLevel = longToNumber8(reader.int64());
          break;
        case 26:
          message.description = reader.string();
          break;
        case 27:
          message.disableContributorRequests = reader.bool();
          break;
        case 28:
          message.excludeBannedModqueue = reader.bool();
          break;
        case 29:
          message.freeFormReports = reader.bool();
          break;
        case 30:
          message.gRecaptchaResponse = reader.string();
          break;
        case 31:
          message.hatefulContentThresholdAbuse = longToNumber8(reader.int64());
          break;
        case 32:
          message.hatefulContentThresholdIdentity = longToNumber8(reader.int64());
          break;
        case 33:
          message.headerTitle = reader.string();
          break;
        case 34:
          message.keyColor = reader.string();
          break;
        case 36:
          message.linkType = reader.string();
          break;
        case 37:
          message.name = reader.string();
          break;
        case 38:
          message.newPinnedPostPnsEnabled = reader.bool();
          break;
        case 39:
          message.originalContentTagEnabled = reader.bool();
          break;
        case 40:
          message.over18 = reader.bool();
          break;
        case 41:
          message.predictionLeaderboardEntryType = longToNumber8(reader.int64());
          break;
        case 42:
          message.publicDescription = reader.string();
          break;
        case 43:
          message.restrictCommenting = reader.bool();
          break;
        case 44:
          message.restrictPosting = reader.bool();
          break;
        case 45:
          message.shouldArchivePosts = reader.bool();
          break;
        case 46:
          message.showMedia = reader.bool();
          break;
        case 47:
          message.showMediaPreview = reader.bool();
          break;
        case 48:
          message.spamComments = reader.string();
          break;
        case 49:
          message.spamLinks = reader.string();
          break;
        case 50:
          message.spamSelfposts = reader.string();
          break;
        case 51:
          message.spoilersEnabled = reader.bool();
          break;
        case 52:
          message.sr = reader.string();
          break;
        case 53:
          message.submitLinkLabel = reader.string();
          break;
        case 54:
          message.submitText = reader.string();
          break;
        case 55:
          message.submitTextLabel = reader.string();
          break;
        case 56:
          message.suggestedCommentSort = reader.string();
          break;
        case 57:
          message.title = reader.string();
          break;
        case 58:
          message.toxicityThresholdChatLevel = longToNumber8(reader.int64());
          break;
        case 59:
          message.type = reader.string();
          break;
        case 60:
          message.userFlairPnsEnabled = reader.bool();
          break;
        case 61:
          message.welcomeMessageEnabled = reader.bool();
          break;
        case 62:
          message.welcomeMessageText = reader.string();
          break;
        case 63:
          message.wikiEditAge = longToNumber8(reader.int64());
          break;
        case 64:
          message.wikiEditKarma = longToNumber8(reader.int64());
          break;
        case 65:
          message.wikimode = reader.string();
          break;
        case 66:
          message.crowdControlChatLevel = longToNumber8(reader.int64());
          break;
        case 67:
          message.hideAds = reader.bool();
          break;
        case 68:
          message.modmailHarassmentFilterEnabled = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      acceptFollowers: isSet91(object.acceptFollowers) ? Boolean(object.acceptFollowers) : false,
      adminOverrideSpamComments: isSet91(object.adminOverrideSpamComments) ? Boolean(object.adminOverrideSpamComments) : false,
      adminOverrideSpamLinks: isSet91(object.adminOverrideSpamLinks) ? Boolean(object.adminOverrideSpamLinks) : false,
      adminOverrideSpamSelfposts: isSet91(object.adminOverrideSpamSelfposts) ? Boolean(object.adminOverrideSpamSelfposts) : false,
      allOriginalContent: isSet91(object.allOriginalContent) ? Boolean(object.allOriginalContent) : false,
      allowChatPostCreation: isSet91(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : false,
      allowDiscovery: isSet91(object.allowDiscovery) ? Boolean(object.allowDiscovery) : false,
      allowGalleries: isSet91(object.allowGalleries) ? Boolean(object.allowGalleries) : false,
      allowImages: isSet91(object.allowImages) ? Boolean(object.allowImages) : false,
      allowPolls: isSet91(object.allowPolls) ? Boolean(object.allowPolls) : false,
      allowPostCrossposts: isSet91(object.allowPostCrossposts) ? Boolean(object.allowPostCrossposts) : false,
      allowPredictionContributors: isSet91(object.allowPredictionContributors) ? Boolean(object.allowPredictionContributors) : false,
      allowPredictions: isSet91(object.allowPredictions) ? Boolean(object.allowPredictions) : false,
      allowPredictionsTournament: isSet91(object.allowPredictionsTournament) ? Boolean(object.allowPredictionsTournament) : false,
      allowTalks: isSet91(object.allowTalks) ? Boolean(object.allowTalks) : false,
      allowTop: isSet91(object.allowTop) ? Boolean(object.allowTop) : false,
      allowVideos: isSet91(object.allowVideos) ? Boolean(object.allowVideos) : false,
      banEvasionThreshold: isSet91(object.banEvasionThreshold) ? Number(object.banEvasionThreshold) : 0,
      collapseDeletedComments: isSet91(object.collapseDeletedComments) ? Boolean(object.collapseDeletedComments) : false,
      commentContributionSettings: isSet91(object.commentContributionSettings) ? CommentContributionSettings.fromJSON(object.commentContributionSettings) : void 0,
      commentScoreHideMins: isSet91(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : 0,
      crowdControlFilter: isSet91(object.crowdControlFilter) ? Boolean(object.crowdControlFilter) : false,
      crowdControlLevel: isSet91(object.crowdControlLevel) ? Number(object.crowdControlLevel) : 0,
      crowdControlMode: isSet91(object.crowdControlMode) ? Boolean(object.crowdControlMode) : false,
      crowdControlPostLevel: isSet91(object.crowdControlPostLevel) ? Number(object.crowdControlPostLevel) : 0,
      description: isSet91(object.description) ? String(object.description) : "",
      disableContributorRequests: isSet91(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : false,
      excludeBannedModqueue: isSet91(object.excludeBannedModqueue) ? Boolean(object.excludeBannedModqueue) : false,
      freeFormReports: isSet91(object.freeFormReports) ? Boolean(object.freeFormReports) : false,
      gRecaptchaResponse: isSet91(object.gRecaptchaResponse) ? String(object.gRecaptchaResponse) : "",
      hatefulContentThresholdAbuse: isSet91(object.hatefulContentThresholdAbuse) ? Number(object.hatefulContentThresholdAbuse) : 0,
      hatefulContentThresholdIdentity: isSet91(object.hatefulContentThresholdIdentity) ? Number(object.hatefulContentThresholdIdentity) : 0,
      headerTitle: isSet91(object.headerTitle) ? String(object.headerTitle) : "",
      keyColor: isSet91(object.keyColor) ? String(object.keyColor) : "",
      linkType: isSet91(object.linkType) ? String(object.linkType) : "",
      name: isSet91(object.name) ? String(object.name) : "",
      newPinnedPostPnsEnabled: isSet91(object.newPinnedPostPnsEnabled) ? Boolean(object.newPinnedPostPnsEnabled) : false,
      originalContentTagEnabled: isSet91(object.originalContentTagEnabled) ? Boolean(object.originalContentTagEnabled) : false,
      over18: isSet91(object.over18) ? Boolean(object.over18) : false,
      predictionLeaderboardEntryType: isSet91(object.predictionLeaderboardEntryType) ? Number(object.predictionLeaderboardEntryType) : 0,
      publicDescription: isSet91(object.publicDescription) ? String(object.publicDescription) : "",
      restrictCommenting: isSet91(object.restrictCommenting) ? Boolean(object.restrictCommenting) : false,
      restrictPosting: isSet91(object.restrictPosting) ? Boolean(object.restrictPosting) : false,
      shouldArchivePosts: isSet91(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : false,
      showMedia: isSet91(object.showMedia) ? Boolean(object.showMedia) : false,
      showMediaPreview: isSet91(object.showMediaPreview) ? Boolean(object.showMediaPreview) : false,
      spamComments: isSet91(object.spamComments) ? String(object.spamComments) : "",
      spamLinks: isSet91(object.spamLinks) ? String(object.spamLinks) : "",
      spamSelfposts: isSet91(object.spamSelfposts) ? String(object.spamSelfposts) : "",
      spoilersEnabled: isSet91(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : false,
      sr: isSet91(object.sr) ? String(object.sr) : "",
      submitLinkLabel: isSet91(object.submitLinkLabel) ? String(object.submitLinkLabel) : "",
      submitText: isSet91(object.submitText) ? String(object.submitText) : "",
      submitTextLabel: isSet91(object.submitTextLabel) ? String(object.submitTextLabel) : "",
      suggestedCommentSort: isSet91(object.suggestedCommentSort) ? String(object.suggestedCommentSort) : "",
      title: isSet91(object.title) ? String(object.title) : "",
      toxicityThresholdChatLevel: isSet91(object.toxicityThresholdChatLevel) ? Number(object.toxicityThresholdChatLevel) : 0,
      type: isSet91(object.type) ? String(object.type) : "",
      userFlairPnsEnabled: isSet91(object.userFlairPnsEnabled) ? Boolean(object.userFlairPnsEnabled) : false,
      welcomeMessageEnabled: isSet91(object.welcomeMessageEnabled) ? Boolean(object.welcomeMessageEnabled) : false,
      welcomeMessageText: isSet91(object.welcomeMessageText) ? String(object.welcomeMessageText) : "",
      wikiEditAge: isSet91(object.wikiEditAge) ? Number(object.wikiEditAge) : 0,
      wikiEditKarma: isSet91(object.wikiEditKarma) ? Number(object.wikiEditKarma) : 0,
      wikimode: isSet91(object.wikimode) ? String(object.wikimode) : "",
      crowdControlChatLevel: isSet91(object.crowdControlChatLevel) ? Number(object.crowdControlChatLevel) : 0,
      hideAds: isSet91(object.hideAds) ? Boolean(object.hideAds) : false,
      modmailHarassmentFilterEnabled: isSet91(object.modmailHarassmentFilterEnabled) ? Boolean(object.modmailHarassmentFilterEnabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.acceptFollowers !== void 0 && (obj.acceptFollowers = message.acceptFollowers);
    message.adminOverrideSpamComments !== void 0 && (obj.adminOverrideSpamComments = message.adminOverrideSpamComments);
    message.adminOverrideSpamLinks !== void 0 && (obj.adminOverrideSpamLinks = message.adminOverrideSpamLinks);
    message.adminOverrideSpamSelfposts !== void 0 && (obj.adminOverrideSpamSelfposts = message.adminOverrideSpamSelfposts);
    message.allOriginalContent !== void 0 && (obj.allOriginalContent = message.allOriginalContent);
    message.allowChatPostCreation !== void 0 && (obj.allowChatPostCreation = message.allowChatPostCreation);
    message.allowDiscovery !== void 0 && (obj.allowDiscovery = message.allowDiscovery);
    message.allowGalleries !== void 0 && (obj.allowGalleries = message.allowGalleries);
    message.allowImages !== void 0 && (obj.allowImages = message.allowImages);
    message.allowPolls !== void 0 && (obj.allowPolls = message.allowPolls);
    message.allowPostCrossposts !== void 0 && (obj.allowPostCrossposts = message.allowPostCrossposts);
    message.allowPredictionContributors !== void 0 && (obj.allowPredictionContributors = message.allowPredictionContributors);
    message.allowPredictions !== void 0 && (obj.allowPredictions = message.allowPredictions);
    message.allowPredictionsTournament !== void 0 && (obj.allowPredictionsTournament = message.allowPredictionsTournament);
    message.allowTalks !== void 0 && (obj.allowTalks = message.allowTalks);
    message.allowTop !== void 0 && (obj.allowTop = message.allowTop);
    message.allowVideos !== void 0 && (obj.allowVideos = message.allowVideos);
    message.banEvasionThreshold !== void 0 && (obj.banEvasionThreshold = Math.round(message.banEvasionThreshold));
    message.collapseDeletedComments !== void 0 && (obj.collapseDeletedComments = message.collapseDeletedComments);
    message.commentContributionSettings !== void 0 && (obj.commentContributionSettings = message.commentContributionSettings ? CommentContributionSettings.toJSON(message.commentContributionSettings) : void 0);
    message.commentScoreHideMins !== void 0 && (obj.commentScoreHideMins = Math.round(message.commentScoreHideMins));
    message.crowdControlFilter !== void 0 && (obj.crowdControlFilter = message.crowdControlFilter);
    message.crowdControlLevel !== void 0 && (obj.crowdControlLevel = Math.round(message.crowdControlLevel));
    message.crowdControlMode !== void 0 && (obj.crowdControlMode = message.crowdControlMode);
    message.crowdControlPostLevel !== void 0 && (obj.crowdControlPostLevel = Math.round(message.crowdControlPostLevel));
    message.description !== void 0 && (obj.description = message.description);
    message.disableContributorRequests !== void 0 && (obj.disableContributorRequests = message.disableContributorRequests);
    message.excludeBannedModqueue !== void 0 && (obj.excludeBannedModqueue = message.excludeBannedModqueue);
    message.freeFormReports !== void 0 && (obj.freeFormReports = message.freeFormReports);
    message.gRecaptchaResponse !== void 0 && (obj.gRecaptchaResponse = message.gRecaptchaResponse);
    message.hatefulContentThresholdAbuse !== void 0 && (obj.hatefulContentThresholdAbuse = Math.round(message.hatefulContentThresholdAbuse));
    message.hatefulContentThresholdIdentity !== void 0 && (obj.hatefulContentThresholdIdentity = Math.round(message.hatefulContentThresholdIdentity));
    message.headerTitle !== void 0 && (obj.headerTitle = message.headerTitle);
    message.keyColor !== void 0 && (obj.keyColor = message.keyColor);
    message.linkType !== void 0 && (obj.linkType = message.linkType);
    message.name !== void 0 && (obj.name = message.name);
    message.newPinnedPostPnsEnabled !== void 0 && (obj.newPinnedPostPnsEnabled = message.newPinnedPostPnsEnabled);
    message.originalContentTagEnabled !== void 0 && (obj.originalContentTagEnabled = message.originalContentTagEnabled);
    message.over18 !== void 0 && (obj.over18 = message.over18);
    message.predictionLeaderboardEntryType !== void 0 && (obj.predictionLeaderboardEntryType = Math.round(message.predictionLeaderboardEntryType));
    message.publicDescription !== void 0 && (obj.publicDescription = message.publicDescription);
    message.restrictCommenting !== void 0 && (obj.restrictCommenting = message.restrictCommenting);
    message.restrictPosting !== void 0 && (obj.restrictPosting = message.restrictPosting);
    message.shouldArchivePosts !== void 0 && (obj.shouldArchivePosts = message.shouldArchivePosts);
    message.showMedia !== void 0 && (obj.showMedia = message.showMedia);
    message.showMediaPreview !== void 0 && (obj.showMediaPreview = message.showMediaPreview);
    message.spamComments !== void 0 && (obj.spamComments = message.spamComments);
    message.spamLinks !== void 0 && (obj.spamLinks = message.spamLinks);
    message.spamSelfposts !== void 0 && (obj.spamSelfposts = message.spamSelfposts);
    message.spoilersEnabled !== void 0 && (obj.spoilersEnabled = message.spoilersEnabled);
    message.sr !== void 0 && (obj.sr = message.sr);
    message.submitLinkLabel !== void 0 && (obj.submitLinkLabel = message.submitLinkLabel);
    message.submitText !== void 0 && (obj.submitText = message.submitText);
    message.submitTextLabel !== void 0 && (obj.submitTextLabel = message.submitTextLabel);
    message.suggestedCommentSort !== void 0 && (obj.suggestedCommentSort = message.suggestedCommentSort);
    message.title !== void 0 && (obj.title = message.title);
    message.toxicityThresholdChatLevel !== void 0 && (obj.toxicityThresholdChatLevel = Math.round(message.toxicityThresholdChatLevel));
    message.type !== void 0 && (obj.type = message.type);
    message.userFlairPnsEnabled !== void 0 && (obj.userFlairPnsEnabled = message.userFlairPnsEnabled);
    message.welcomeMessageEnabled !== void 0 && (obj.welcomeMessageEnabled = message.welcomeMessageEnabled);
    message.welcomeMessageText !== void 0 && (obj.welcomeMessageText = message.welcomeMessageText);
    message.wikiEditAge !== void 0 && (obj.wikiEditAge = Math.round(message.wikiEditAge));
    message.wikiEditKarma !== void 0 && (obj.wikiEditKarma = Math.round(message.wikiEditKarma));
    message.wikimode !== void 0 && (obj.wikimode = message.wikimode);
    message.crowdControlChatLevel !== void 0 && (obj.crowdControlChatLevel = Math.round(message.crowdControlChatLevel));
    message.hideAds !== void 0 && (obj.hideAds = message.hideAds);
    message.modmailHarassmentFilterEnabled !== void 0 && (obj.modmailHarassmentFilterEnabled = message.modmailHarassmentFilterEnabled);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSiteAdminRequest();
    message.acceptFollowers = object.acceptFollowers ?? false;
    message.adminOverrideSpamComments = object.adminOverrideSpamComments ?? false;
    message.adminOverrideSpamLinks = object.adminOverrideSpamLinks ?? false;
    message.adminOverrideSpamSelfposts = object.adminOverrideSpamSelfposts ?? false;
    message.allOriginalContent = object.allOriginalContent ?? false;
    message.allowChatPostCreation = object.allowChatPostCreation ?? false;
    message.allowDiscovery = object.allowDiscovery ?? false;
    message.allowGalleries = object.allowGalleries ?? false;
    message.allowImages = object.allowImages ?? false;
    message.allowPolls = object.allowPolls ?? false;
    message.allowPostCrossposts = object.allowPostCrossposts ?? false;
    message.allowPredictionContributors = object.allowPredictionContributors ?? false;
    message.allowPredictions = object.allowPredictions ?? false;
    message.allowPredictionsTournament = object.allowPredictionsTournament ?? false;
    message.allowTalks = object.allowTalks ?? false;
    message.allowTop = object.allowTop ?? false;
    message.allowVideos = object.allowVideos ?? false;
    message.banEvasionThreshold = object.banEvasionThreshold ?? 0;
    message.collapseDeletedComments = object.collapseDeletedComments ?? false;
    message.commentContributionSettings = object.commentContributionSettings !== void 0 && object.commentContributionSettings !== null ? CommentContributionSettings.fromPartial(object.commentContributionSettings) : void 0;
    message.commentScoreHideMins = object.commentScoreHideMins ?? 0;
    message.crowdControlFilter = object.crowdControlFilter ?? false;
    message.crowdControlLevel = object.crowdControlLevel ?? 0;
    message.crowdControlMode = object.crowdControlMode ?? false;
    message.crowdControlPostLevel = object.crowdControlPostLevel ?? 0;
    message.description = object.description ?? "";
    message.disableContributorRequests = object.disableContributorRequests ?? false;
    message.excludeBannedModqueue = object.excludeBannedModqueue ?? false;
    message.freeFormReports = object.freeFormReports ?? false;
    message.gRecaptchaResponse = object.gRecaptchaResponse ?? "";
    message.hatefulContentThresholdAbuse = object.hatefulContentThresholdAbuse ?? 0;
    message.hatefulContentThresholdIdentity = object.hatefulContentThresholdIdentity ?? 0;
    message.headerTitle = object.headerTitle ?? "";
    message.keyColor = object.keyColor ?? "";
    message.linkType = object.linkType ?? "";
    message.name = object.name ?? "";
    message.newPinnedPostPnsEnabled = object.newPinnedPostPnsEnabled ?? false;
    message.originalContentTagEnabled = object.originalContentTagEnabled ?? false;
    message.over18 = object.over18 ?? false;
    message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? 0;
    message.publicDescription = object.publicDescription ?? "";
    message.restrictCommenting = object.restrictCommenting ?? false;
    message.restrictPosting = object.restrictPosting ?? false;
    message.shouldArchivePosts = object.shouldArchivePosts ?? false;
    message.showMedia = object.showMedia ?? false;
    message.showMediaPreview = object.showMediaPreview ?? false;
    message.spamComments = object.spamComments ?? "";
    message.spamLinks = object.spamLinks ?? "";
    message.spamSelfposts = object.spamSelfposts ?? "";
    message.spoilersEnabled = object.spoilersEnabled ?? false;
    message.sr = object.sr ?? "";
    message.submitLinkLabel = object.submitLinkLabel ?? "";
    message.submitText = object.submitText ?? "";
    message.submitTextLabel = object.submitTextLabel ?? "";
    message.suggestedCommentSort = object.suggestedCommentSort ?? "";
    message.title = object.title ?? "";
    message.toxicityThresholdChatLevel = object.toxicityThresholdChatLevel ?? 0;
    message.type = object.type ?? "";
    message.userFlairPnsEnabled = object.userFlairPnsEnabled ?? false;
    message.welcomeMessageEnabled = object.welcomeMessageEnabled ?? false;
    message.welcomeMessageText = object.welcomeMessageText ?? "";
    message.wikiEditAge = object.wikiEditAge ?? 0;
    message.wikiEditKarma = object.wikiEditKarma ?? 0;
    message.wikimode = object.wikimode ?? "";
    message.crowdControlChatLevel = object.crowdControlChatLevel ?? 0;
    message.hideAds = object.hideAds ?? false;
    message.modmailHarassmentFilterEnabled = object.modmailHarassmentFilterEnabled ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SiteAdminRequest", SiteAdminRequest);
function createBaseSubredditAutocompleteRequest() {
  return {
    includeOver18: void 0,
    includeProfiles: void 0,
    limit: void 0,
    query: "",
    searchQueryId: void 0,
    typeaheadActive: void 0
  };
}
var SubredditAutocompleteRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.includeOver18 !== void 0) {
      BoolValue.encode({ value: message.includeOver18 }, writer.uint32(10).fork()).ldelim();
    }
    if (message.includeProfiles !== void 0) {
      BoolValue.encode({ value: message.includeProfiles }, writer.uint32(18).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(26).fork()).ldelim();
    }
    if (message.query !== "") {
      writer.uint32(34).string(message.query);
    }
    if (message.searchQueryId !== void 0) {
      StringValue.encode({ value: message.searchQueryId }, writer.uint32(42).fork()).ldelim();
    }
    if (message.typeaheadActive !== void 0) {
      BoolValue.encode({ value: message.typeaheadActive }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.includeOver18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.includeProfiles = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.query = reader.string();
          break;
        case 5:
          message.searchQueryId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.typeaheadActive = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      includeOver18: isSet91(object.includeOver18) ? Boolean(object.includeOver18) : void 0,
      includeProfiles: isSet91(object.includeProfiles) ? Boolean(object.includeProfiles) : void 0,
      limit: isSet91(object.limit) ? Number(object.limit) : void 0,
      query: isSet91(object.query) ? String(object.query) : "",
      searchQueryId: isSet91(object.searchQueryId) ? String(object.searchQueryId) : void 0,
      typeaheadActive: isSet91(object.typeaheadActive) ? Boolean(object.typeaheadActive) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.includeOver18 !== void 0 && (obj.includeOver18 = message.includeOver18);
    message.includeProfiles !== void 0 && (obj.includeProfiles = message.includeProfiles);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.query !== void 0 && (obj.query = message.query);
    message.searchQueryId !== void 0 && (obj.searchQueryId = message.searchQueryId);
    message.typeaheadActive !== void 0 && (obj.typeaheadActive = message.typeaheadActive);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteRequest();
    message.includeOver18 = object.includeOver18 ?? void 0;
    message.includeProfiles = object.includeProfiles ?? void 0;
    message.limit = object.limit ?? void 0;
    message.query = object.query ?? "";
    message.searchQueryId = object.searchQueryId ?? void 0;
    message.typeaheadActive = object.typeaheadActive ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteRequest", SubredditAutocompleteRequest);
function createBaseSubredditStylesheetRequest() {
  return { op: "", reason: "", stylesheetContents: "", subreddit: "" };
}
var SubredditStylesheetRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditStylesheetRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.op !== "") {
      writer.uint32(10).string(message.op);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.stylesheetContents !== "") {
      writer.uint32(26).string(message.stylesheetContents);
    }
    if (message.subreddit !== "") {
      writer.uint32(34).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditStylesheetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.string();
          break;
        case 2:
          message.reason = reader.string();
          break;
        case 3:
          message.stylesheetContents = reader.string();
          break;
        case 4:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      op: isSet91(object.op) ? String(object.op) : "",
      reason: isSet91(object.reason) ? String(object.reason) : "",
      stylesheetContents: isSet91(object.stylesheetContents) ? String(object.stylesheetContents) : "",
      subreddit: isSet91(object.subreddit) ? String(object.subreddit) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.op !== void 0 && (obj.op = message.op);
    message.reason !== void 0 && (obj.reason = message.reason);
    message.stylesheetContents !== void 0 && (obj.stylesheetContents = message.stylesheetContents);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditStylesheetRequest();
    message.op = object.op ?? "";
    message.reason = object.reason ?? "";
    message.stylesheetContents = object.stylesheetContents ?? "";
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditStylesheetRequest", SubredditStylesheetRequest);
function createBaseSubscribeRequest() {
  return { action: "", actionSource: "", skipInitialDefaults: false, sr: "", srName: "" };
}
var SubscribeRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SubscribeRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.actionSource !== "") {
      writer.uint32(18).string(message.actionSource);
    }
    if (message.skipInitialDefaults === true) {
      writer.uint32(24).bool(message.skipInitialDefaults);
    }
    if (message.sr !== "") {
      writer.uint32(34).string(message.sr);
    }
    if (message.srName !== "") {
      writer.uint32(42).string(message.srName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.action = reader.string();
          break;
        case 2:
          message.actionSource = reader.string();
          break;
        case 3:
          message.skipInitialDefaults = reader.bool();
          break;
        case 4:
          message.sr = reader.string();
          break;
        case 5:
          message.srName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      action: isSet91(object.action) ? String(object.action) : "",
      actionSource: isSet91(object.actionSource) ? String(object.actionSource) : "",
      skipInitialDefaults: isSet91(object.skipInitialDefaults) ? Boolean(object.skipInitialDefaults) : false,
      sr: isSet91(object.sr) ? String(object.sr) : "",
      srName: isSet91(object.srName) ? String(object.srName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.action !== void 0 && (obj.action = message.action);
    message.actionSource !== void 0 && (obj.actionSource = message.actionSource);
    message.skipInitialDefaults !== void 0 && (obj.skipInitialDefaults = message.skipInitialDefaults);
    message.sr !== void 0 && (obj.sr = message.sr);
    message.srName !== void 0 && (obj.srName = message.srName);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubscribeRequest();
    message.action = object.action ?? "";
    message.actionSource = object.actionSource ?? "";
    message.skipInitialDefaults = object.skipInitialDefaults ?? false;
    message.sr = object.sr ?? "";
    message.srName = object.srName ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubscribeRequest", SubscribeRequest);
function createBaseUploadSrImgRequest() {
  return { file: "", header: 0, imgType: "", name: "", uploadType: "", subreddit: "" };
}
var UploadSrImgRequest = {
  $type: "devvit.plugin.redditapi.subreddits.UploadSrImgRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.file !== "") {
      writer.uint32(10).string(message.file);
    }
    if (message.header !== 0) {
      writer.uint32(16).int64(message.header);
    }
    if (message.imgType !== "") {
      writer.uint32(26).string(message.imgType);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.uploadType !== "") {
      writer.uint32(42).string(message.uploadType);
    }
    if (message.subreddit !== "") {
      writer.uint32(50).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUploadSrImgRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.file = reader.string();
          break;
        case 2:
          message.header = longToNumber8(reader.int64());
          break;
        case 3:
          message.imgType = reader.string();
          break;
        case 4:
          message.name = reader.string();
          break;
        case 5:
          message.uploadType = reader.string();
          break;
        case 6:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      file: isSet91(object.file) ? String(object.file) : "",
      header: isSet91(object.header) ? Number(object.header) : 0,
      imgType: isSet91(object.imgType) ? String(object.imgType) : "",
      name: isSet91(object.name) ? String(object.name) : "",
      uploadType: isSet91(object.uploadType) ? String(object.uploadType) : "",
      subreddit: isSet91(object.subreddit) ? String(object.subreddit) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.file !== void 0 && (obj.file = message.file);
    message.header !== void 0 && (obj.header = Math.round(message.header));
    message.imgType !== void 0 && (obj.imgType = message.imgType);
    message.name !== void 0 && (obj.name = message.name);
    message.uploadType !== void 0 && (obj.uploadType = message.uploadType);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUploadSrImgRequest();
    message.file = object.file ?? "";
    message.header = object.header ?? 0;
    message.imgType = object.imgType ?? "";
    message.name = object.name ?? "";
    message.uploadType = object.uploadType ?? "";
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UploadSrImgRequest", UploadSrImgRequest);
function createBaseSubredditAboutEditRequest() {
  return { created: "", location: "", subreddit: "" };
}
var SubredditAboutEditRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.created !== "") {
      writer.uint32(10).string(message.created);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.subreddit !== "") {
      writer.uint32(26).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutEditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.created = reader.string();
          break;
        case 2:
          message.location = reader.string();
          break;
        case 3:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      created: isSet91(object.created) ? String(object.created) : "",
      location: isSet91(object.location) ? String(object.location) : "",
      subreddit: isSet91(object.subreddit) ? String(object.subreddit) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.created !== void 0 && (obj.created = message.created);
    message.location !== void 0 && (obj.location = message.location);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutEditRequest();
    message.created = object.created ?? "";
    message.location = object.location ?? "";
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutEditRequest", SubredditAboutEditRequest);
function createBaseStickyRequest() {
  return { num: 0, subreddit: "" };
}
var StickyRequest = {
  $type: "devvit.plugin.redditapi.subreddits.StickyRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.num !== 0) {
      writer.uint32(8).int64(message.num);
    }
    if (message.subreddit !== "") {
      writer.uint32(18).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStickyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.num = longToNumber8(reader.int64());
          break;
        case 2:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      num: isSet91(object.num) ? Number(object.num) : 0,
      subreddit: isSet91(object.subreddit) ? String(object.subreddit) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.num !== void 0 && (obj.num = Math.round(message.num));
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStickyRequest();
    message.num = object.num ?? 0;
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.StickyRequest", StickyRequest);
function createBaseBasicWhereRequest() {
  return { after: void 0, before: void 0, count: void 0, limit: void 0, show: void 0, where: "" };
}
var BasicWhereRequest = {
  $type: "devvit.plugin.redditapi.subreddits.BasicWhereRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
    }
    if (message.where !== "") {
      writer.uint32(58).string(message.where);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBasicWhereRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.where = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet91(object.after) ? String(object.after) : void 0,
      before: isSet91(object.before) ? String(object.before) : void 0,
      count: isSet91(object.count) ? Number(object.count) : void 0,
      limit: isSet91(object.limit) ? Number(object.limit) : void 0,
      show: isSet91(object.show) ? String(object.show) : void 0,
      where: isSet91(object.where) ? String(object.where) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.count !== void 0 && (obj.count = message.count);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.show !== void 0 && (obj.show = message.show);
    message.where !== void 0 && (obj.where = message.where);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBasicWhereRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.show = object.show ?? void 0;
    message.where = object.where ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.BasicWhereRequest", BasicWhereRequest);
function createBaseSubredditsSearchRequest() {
  return {
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    q: "",
    searchQueryId: void 0,
    show: void 0,
    showUsers: void 0,
    sort: void 0,
    typeaheadActive: void 0
  };
}
var SubredditsSearchRequest = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.q !== "") {
      writer.uint32(42).string(message.q);
    }
    if (message.searchQueryId !== void 0) {
      StringValue.encode({ value: message.searchQueryId }, writer.uint32(50).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
    }
    if (message.showUsers !== void 0) {
      BoolValue.encode({ value: message.showUsers }, writer.uint32(66).fork()).ldelim();
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(74).fork()).ldelim();
    }
    if (message.typeaheadActive !== void 0) {
      BoolValue.encode({ value: message.typeaheadActive }, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.q = reader.string();
          break;
        case 6:
          message.searchQueryId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.showUsers = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.typeaheadActive = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet91(object.after) ? String(object.after) : void 0,
      before: isSet91(object.before) ? String(object.before) : void 0,
      count: isSet91(object.count) ? Number(object.count) : void 0,
      limit: isSet91(object.limit) ? Number(object.limit) : void 0,
      q: isSet91(object.q) ? String(object.q) : "",
      searchQueryId: isSet91(object.searchQueryId) ? String(object.searchQueryId) : void 0,
      show: isSet91(object.show) ? String(object.show) : void 0,
      showUsers: isSet91(object.showUsers) ? Boolean(object.showUsers) : void 0,
      sort: isSet91(object.sort) ? String(object.sort) : void 0,
      typeaheadActive: isSet91(object.typeaheadActive) ? Boolean(object.typeaheadActive) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.count !== void 0 && (obj.count = message.count);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.q !== void 0 && (obj.q = message.q);
    message.searchQueryId !== void 0 && (obj.searchQueryId = message.searchQueryId);
    message.show !== void 0 && (obj.show = message.show);
    message.showUsers !== void 0 && (obj.showUsers = message.showUsers);
    message.sort !== void 0 && (obj.sort = message.sort);
    message.typeaheadActive !== void 0 && (obj.typeaheadActive = message.typeaheadActive);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditsSearchRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.q = object.q ?? "";
    message.searchQueryId = object.searchQueryId ?? void 0;
    message.show = object.show ?? void 0;
    message.showUsers = object.showUsers ?? void 0;
    message.sort = object.sort ?? void 0;
    message.typeaheadActive = object.typeaheadActive ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditsSearchRequest", SubredditsSearchRequest);
function createBaseUsersSearchRequest() {
  return {
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    q: "",
    searchQueryId: void 0,
    show: void 0,
    sort: void 0,
    typeaheadActive: void 0
  };
}
var UsersSearchRequest = {
  $type: "devvit.plugin.redditapi.subreddits.UsersSearchRequest",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.q !== "") {
      writer.uint32(42).string(message.q);
    }
    if (message.searchQueryId !== void 0) {
      StringValue.encode({ value: message.searchQueryId }, writer.uint32(50).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(66).fork()).ldelim();
    }
    if (message.typeaheadActive !== void 0) {
      BoolValue.encode({ value: message.typeaheadActive }, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUsersSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.q = reader.string();
          break;
        case 6:
          message.searchQueryId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.typeaheadActive = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet91(object.after) ? String(object.after) : void 0,
      before: isSet91(object.before) ? String(object.before) : void 0,
      count: isSet91(object.count) ? Number(object.count) : void 0,
      limit: isSet91(object.limit) ? Number(object.limit) : void 0,
      q: isSet91(object.q) ? String(object.q) : "",
      searchQueryId: isSet91(object.searchQueryId) ? String(object.searchQueryId) : void 0,
      show: isSet91(object.show) ? String(object.show) : void 0,
      sort: isSet91(object.sort) ? String(object.sort) : void 0,
      typeaheadActive: isSet91(object.typeaheadActive) ? Boolean(object.typeaheadActive) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.count !== void 0 && (obj.count = message.count);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.q !== void 0 && (obj.q = message.q);
    message.searchQueryId !== void 0 && (obj.searchQueryId = message.searchQueryId);
    message.show !== void 0 && (obj.show = message.show);
    message.sort !== void 0 && (obj.sort = message.sort);
    message.typeaheadActive !== void 0 && (obj.typeaheadActive = message.typeaheadActive);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUsersSearchRequest();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.q = object.q ?? "";
    message.searchQueryId = object.searchQueryId ?? void 0;
    message.show = object.show ?? void 0;
    message.sort = object.sort ?? void 0;
    message.typeaheadActive = object.typeaheadActive ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UsersSearchRequest", UsersSearchRequest);
function createBaseSearchRedditNamesResponse() {
  return { names: [] };
}
var SearchRedditNamesResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SearchRedditNamesResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    for (const v of message.names) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSearchRedditNamesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.names.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { names: Array.isArray(object?.names) ? object.names.map((e) => String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.names) {
      obj.names = message.names.map((e) => e);
    } else {
      obj.names = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSearchRedditNamesResponse();
    message.names = object.names?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SearchRedditNamesResponse", SearchRedditNamesResponse);
function createBaseSearchSubredditsResponse() {
  return { subreddits: [] };
}
var SearchSubredditsResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SearchSubredditsResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    for (const v of message.subreddits) {
      SearchSubredditsResponse_SubredditData.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSearchSubredditsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddits.push(SearchSubredditsResponse_SubredditData.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddits: Array.isArray(object?.subreddits) ? object.subreddits.map((e) => SearchSubredditsResponse_SubredditData.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.subreddits) {
      obj.subreddits = message.subreddits.map((e) => e ? SearchSubredditsResponse_SubredditData.toJSON(e) : void 0);
    } else {
      obj.subreddits = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSearchSubredditsResponse();
    message.subreddits = object.subreddits?.map((e) => SearchSubredditsResponse_SubredditData.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SearchSubredditsResponse", SearchSubredditsResponse);
function createBaseSearchSubredditsResponse_SubredditData() {
  return {
    activeUserCount: void 0,
    iconImg: void 0,
    keyColor: void 0,
    name: void 0,
    subscriberCount: void 0,
    isChatPostFeatureEnabled: void 0,
    allowChatPostCreation: void 0,
    allowImages: void 0
  };
}
var SearchSubredditsResponse_SubredditData = {
  $type: "devvit.plugin.redditapi.subreddits.SearchSubredditsResponse.SubredditData",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.activeUserCount !== void 0) {
      Int32Value.encode({ value: message.activeUserCount }, writer.uint32(10).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(18).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
    }
    if (message.subscriberCount !== void 0) {
      Int32Value.encode({ value: message.subscriberCount }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isChatPostFeatureEnabled !== void 0) {
      BoolValue.encode({ value: message.isChatPostFeatureEnabled }, writer.uint32(50).fork()).ldelim();
    }
    if (message.allowChatPostCreation !== void 0) {
      BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(58).fork()).ldelim();
    }
    if (message.allowImages !== void 0) {
      BoolValue.encode({ value: message.allowImages }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSearchSubredditsResponse_SubredditData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.activeUserCount = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.subscriberCount = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.isChatPostFeatureEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      activeUserCount: isSet91(object.activeUserCount) ? Number(object.activeUserCount) : void 0,
      iconImg: isSet91(object.iconImg) ? String(object.iconImg) : void 0,
      keyColor: isSet91(object.keyColor) ? String(object.keyColor) : void 0,
      name: isSet91(object.name) ? String(object.name) : void 0,
      subscriberCount: isSet91(object.subscriberCount) ? Number(object.subscriberCount) : void 0,
      isChatPostFeatureEnabled: isSet91(object.isChatPostFeatureEnabled) ? Boolean(object.isChatPostFeatureEnabled) : void 0,
      allowChatPostCreation: isSet91(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : void 0,
      allowImages: isSet91(object.allowImages) ? Boolean(object.allowImages) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.activeUserCount !== void 0 && (obj.activeUserCount = message.activeUserCount);
    message.iconImg !== void 0 && (obj.iconImg = message.iconImg);
    message.keyColor !== void 0 && (obj.keyColor = message.keyColor);
    message.name !== void 0 && (obj.name = message.name);
    message.subscriberCount !== void 0 && (obj.subscriberCount = message.subscriberCount);
    message.isChatPostFeatureEnabled !== void 0 && (obj.isChatPostFeatureEnabled = message.isChatPostFeatureEnabled);
    message.allowChatPostCreation !== void 0 && (obj.allowChatPostCreation = message.allowChatPostCreation);
    message.allowImages !== void 0 && (obj.allowImages = message.allowImages);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSearchSubredditsResponse_SubredditData();
    message.activeUserCount = object.activeUserCount ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.name = object.name ?? void 0;
    message.subscriberCount = object.subscriberCount ?? void 0;
    message.isChatPostFeatureEnabled = object.isChatPostFeatureEnabled ?? void 0;
    message.allowChatPostCreation = object.allowChatPostCreation ?? void 0;
    message.allowImages = object.allowImages ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SearchSubredditsResponse.SubredditData", SearchSubredditsResponse_SubredditData);
function createBaseSubmitTextResponse() {
  return { submitText: void 0, submitTextHtml: void 0 };
}
var SubmitTextResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubmitTextResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.submitText !== void 0) {
      StringValue.encode({ value: message.submitText }, writer.uint32(10).fork()).ldelim();
    }
    if (message.submitTextHtml !== void 0) {
      StringValue.encode({ value: message.submitTextHtml }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.submitText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.submitTextHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      submitText: isSet91(object.submitText) ? String(object.submitText) : void 0,
      submitTextHtml: isSet91(object.submitTextHtml) ? String(object.submitTextHtml) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.submitText !== void 0 && (obj.submitText = message.submitText);
    message.submitTextHtml !== void 0 && (obj.submitTextHtml = message.submitTextHtml);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubmitTextResponse();
    message.submitText = object.submitText ?? void 0;
    message.submitTextHtml = object.submitTextHtml ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubmitTextResponse", SubmitTextResponse);
function createBaseSubredditAutocompleteResponse() {
  return { kind: void 0, data: void 0 };
}
var SubredditAutocompleteResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      SubredditAutocompleteResponse_AutocompleteResponse.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = SubredditAutocompleteResponse_AutocompleteResponse.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet91(object.kind) ? String(object.kind) : void 0,
      data: isSet91(object.data) ? SubredditAutocompleteResponse_AutocompleteResponse.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? SubredditAutocompleteResponse_AutocompleteResponse.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? SubredditAutocompleteResponse_AutocompleteResponse.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse", SubredditAutocompleteResponse);
function createBaseSubredditAutocompleteResponse_AutocompleteAccount() {
  return {
    isEmployee: void 0,
    isFriend: void 0,
    snoovatarSize: void 0,
    id: void 0,
    verified: void 0,
    isGold: void 0,
    isMod: void 0,
    hasVerifiedEmail: void 0,
    iconImg: void 0,
    hideFromRobots: void 0,
    linkKarma: void 0,
    acceptChats: void 0,
    isBlocked: void 0,
    prefShowSnoovatar: void 0,
    name: void 0,
    created: void 0,
    createdUtc: void 0,
    snoovatarImg: void 0,
    commentKarma: void 0,
    acceptFollowers: void 0,
    hasSubscribed: void 0,
    acceptPms: void 0
  };
}
var SubredditAutocompleteResponse_AutocompleteAccount = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteAccount",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.isEmployee !== void 0) {
      BoolValue.encode({ value: message.isEmployee }, writer.uint32(10).fork()).ldelim();
    }
    if (message.isFriend !== void 0) {
      BoolValue.encode({ value: message.isFriend }, writer.uint32(18).fork()).ldelim();
    }
    if (message.snoovatarSize !== void 0) {
      Int32Value.encode({ value: message.snoovatarSize }, writer.uint32(26).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(34).fork()).ldelim();
    }
    if (message.verified !== void 0) {
      BoolValue.encode({ value: message.verified }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isGold !== void 0) {
      BoolValue.encode({ value: message.isGold }, writer.uint32(50).fork()).ldelim();
    }
    if (message.isMod !== void 0) {
      BoolValue.encode({ value: message.isMod }, writer.uint32(58).fork()).ldelim();
    }
    if (message.hasVerifiedEmail !== void 0) {
      BoolValue.encode({ value: message.hasVerifiedEmail }, writer.uint32(66).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(74).fork()).ldelim();
    }
    if (message.hideFromRobots !== void 0) {
      BoolValue.encode({ value: message.hideFromRobots }, writer.uint32(82).fork()).ldelim();
    }
    if (message.linkKarma !== void 0) {
      Int32Value.encode({ value: message.linkKarma }, writer.uint32(90).fork()).ldelim();
    }
    if (message.acceptChats !== void 0) {
      BoolValue.encode({ value: message.acceptChats }, writer.uint32(98).fork()).ldelim();
    }
    if (message.isBlocked !== void 0) {
      BoolValue.encode({ value: message.isBlocked }, writer.uint32(106).fork()).ldelim();
    }
    if (message.prefShowSnoovatar !== void 0) {
      BoolValue.encode({ value: message.prefShowSnoovatar }, writer.uint32(114).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(122).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int64Value.encode({ value: message.created }, writer.uint32(130).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(138).fork()).ldelim();
    }
    if (message.snoovatarImg !== void 0) {
      StringValue.encode({ value: message.snoovatarImg }, writer.uint32(146).fork()).ldelim();
    }
    if (message.commentKarma !== void 0) {
      Int64Value.encode({ value: message.commentKarma }, writer.uint32(154).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(162).fork()).ldelim();
    }
    if (message.hasSubscribed !== void 0) {
      BoolValue.encode({ value: message.hasSubscribed }, writer.uint32(170).fork()).ldelim();
    }
    if (message.acceptPms !== void 0) {
      BoolValue.encode({ value: message.acceptPms }, writer.uint32(178).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteResponse_AutocompleteAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isEmployee = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.isFriend = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.snoovatarSize = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.verified = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.isGold = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.isMod = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.hasVerifiedEmail = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.hideFromRobots = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.linkKarma = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.acceptChats = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.isBlocked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.prefShowSnoovatar = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.created = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.snoovatarImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.commentKarma = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.hasSubscribed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.acceptPms = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      isEmployee: isSet91(object.isEmployee) ? Boolean(object.isEmployee) : void 0,
      isFriend: isSet91(object.isFriend) ? Boolean(object.isFriend) : void 0,
      snoovatarSize: isSet91(object.snoovatarSize) ? Number(object.snoovatarSize) : void 0,
      id: isSet91(object.id) ? String(object.id) : void 0,
      verified: isSet91(object.verified) ? Boolean(object.verified) : void 0,
      isGold: isSet91(object.isGold) ? Boolean(object.isGold) : void 0,
      isMod: isSet91(object.isMod) ? Boolean(object.isMod) : void 0,
      hasVerifiedEmail: isSet91(object.hasVerifiedEmail) ? Boolean(object.hasVerifiedEmail) : void 0,
      iconImg: isSet91(object.iconImg) ? String(object.iconImg) : void 0,
      hideFromRobots: isSet91(object.hideFromRobots) ? Boolean(object.hideFromRobots) : void 0,
      linkKarma: isSet91(object.linkKarma) ? Number(object.linkKarma) : void 0,
      acceptChats: isSet91(object.acceptChats) ? Boolean(object.acceptChats) : void 0,
      isBlocked: isSet91(object.isBlocked) ? Boolean(object.isBlocked) : void 0,
      prefShowSnoovatar: isSet91(object.prefShowSnoovatar) ? Boolean(object.prefShowSnoovatar) : void 0,
      name: isSet91(object.name) ? String(object.name) : void 0,
      created: isSet91(object.created) ? Number(object.created) : void 0,
      createdUtc: isSet91(object.createdUtc) ? Number(object.createdUtc) : void 0,
      snoovatarImg: isSet91(object.snoovatarImg) ? String(object.snoovatarImg) : void 0,
      commentKarma: isSet91(object.commentKarma) ? Number(object.commentKarma) : void 0,
      acceptFollowers: isSet91(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      hasSubscribed: isSet91(object.hasSubscribed) ? Boolean(object.hasSubscribed) : void 0,
      acceptPms: isSet91(object.acceptPms) ? Boolean(object.acceptPms) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.isEmployee !== void 0 && (obj.isEmployee = message.isEmployee);
    message.isFriend !== void 0 && (obj.isFriend = message.isFriend);
    message.snoovatarSize !== void 0 && (obj.snoovatarSize = message.snoovatarSize);
    message.id !== void 0 && (obj.id = message.id);
    message.verified !== void 0 && (obj.verified = message.verified);
    message.isGold !== void 0 && (obj.isGold = message.isGold);
    message.isMod !== void 0 && (obj.isMod = message.isMod);
    message.hasVerifiedEmail !== void 0 && (obj.hasVerifiedEmail = message.hasVerifiedEmail);
    message.iconImg !== void 0 && (obj.iconImg = message.iconImg);
    message.hideFromRobots !== void 0 && (obj.hideFromRobots = message.hideFromRobots);
    message.linkKarma !== void 0 && (obj.linkKarma = message.linkKarma);
    message.acceptChats !== void 0 && (obj.acceptChats = message.acceptChats);
    message.isBlocked !== void 0 && (obj.isBlocked = message.isBlocked);
    message.prefShowSnoovatar !== void 0 && (obj.prefShowSnoovatar = message.prefShowSnoovatar);
    message.name !== void 0 && (obj.name = message.name);
    message.created !== void 0 && (obj.created = message.created);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    message.snoovatarImg !== void 0 && (obj.snoovatarImg = message.snoovatarImg);
    message.commentKarma !== void 0 && (obj.commentKarma = message.commentKarma);
    message.acceptFollowers !== void 0 && (obj.acceptFollowers = message.acceptFollowers);
    message.hasSubscribed !== void 0 && (obj.hasSubscribed = message.hasSubscribed);
    message.acceptPms !== void 0 && (obj.acceptPms = message.acceptPms);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteResponse_AutocompleteAccount();
    message.isEmployee = object.isEmployee ?? void 0;
    message.isFriend = object.isFriend ?? void 0;
    message.snoovatarSize = object.snoovatarSize ?? void 0;
    message.id = object.id ?? void 0;
    message.verified = object.verified ?? void 0;
    message.isGold = object.isGold ?? void 0;
    message.isMod = object.isMod ?? void 0;
    message.hasVerifiedEmail = object.hasVerifiedEmail ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.hideFromRobots = object.hideFromRobots ?? void 0;
    message.linkKarma = object.linkKarma ?? void 0;
    message.acceptChats = object.acceptChats ?? void 0;
    message.isBlocked = object.isBlocked ?? void 0;
    message.prefShowSnoovatar = object.prefShowSnoovatar ?? void 0;
    message.name = object.name ?? void 0;
    message.created = object.created ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.snoovatarImg = object.snoovatarImg ?? void 0;
    message.commentKarma = object.commentKarma ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.hasSubscribed = object.hasSubscribed ?? void 0;
    message.acceptPms = object.acceptPms ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteAccount", SubredditAutocompleteResponse_AutocompleteAccount);
function createBaseSubredditAutocompleteResponse_AutocompleteAccount_Subreddit() {
  return {
    defaultSet: void 0,
    userIsContributor: void 0,
    bannerImg: void 0,
    allowedMediaInComments: [],
    userIsBanned: void 0,
    freeFormReports: void 0,
    communityIcon: void 0,
    showMedia: void 0,
    iconColor: void 0,
    userIsMuted: void 0,
    displayName: void 0,
    headerImg: void 0,
    title: void 0,
    previousNames: [],
    over18: void 0,
    iconSize: [],
    primaryColor: void 0,
    iconImg: void 0,
    description: void 0,
    submitLinkLabel: void 0,
    headerSize: void 0,
    restrictPosting: void 0,
    restrictCommenting: void 0,
    subscribers: void 0,
    submitTextLabel: void 0,
    isDefaultIcon: void 0,
    inkFlairPosition: void 0,
    displayNamePrefixed: void 0,
    keyColor: void 0,
    name: void 0,
    isDefaultBanner: void 0,
    url: void 0,
    quarantine: void 0,
    bannerSize: void 0,
    userIsModerator: void 0,
    acceptFollowers: void 0,
    publicDescription: void 0,
    linkFlairEnabled: void 0,
    disableContributorRequests: void 0,
    subredditType: void 0,
    userIsSubscriber: void 0
  };
}
var SubredditAutocompleteResponse_AutocompleteAccount_Subreddit = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteAccount.Subreddit",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.defaultSet !== void 0) {
      BoolValue.encode({ value: message.defaultSet }, writer.uint32(10).fork()).ldelim();
    }
    if (message.userIsContributor !== void 0) {
      BoolValue.encode({ value: message.userIsContributor }, writer.uint32(18).fork()).ldelim();
    }
    if (message.bannerImg !== void 0) {
      StringValue.encode({ value: message.bannerImg }, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.allowedMediaInComments) {
      StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
    }
    if (message.userIsBanned !== void 0) {
      BoolValue.encode({ value: message.userIsBanned }, writer.uint32(42).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(50).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(58).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(66).fork()).ldelim();
    }
    if (message.iconColor !== void 0) {
      StringValue.encode({ value: message.iconColor }, writer.uint32(74).fork()).ldelim();
    }
    if (message.userIsMuted !== void 0) {
      BoolValue.encode({ value: message.userIsMuted }, writer.uint32(82).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(90).fork()).ldelim();
    }
    if (message.headerImg !== void 0) {
      StringValue.encode({ value: message.headerImg }, writer.uint32(98).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(106).fork()).ldelim();
    }
    for (const v of message.previousNames) {
      StringValue.encode({ value: v }, writer.uint32(114).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(122).fork()).ldelim();
    }
    for (const v of message.iconSize) {
      Int32Value.encode({ value: v }, writer.uint32(130).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(138).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(146).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(154).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(162).fork()).ldelim();
    }
    if (message.headerSize !== void 0) {
      Int32Value.encode({ value: message.headerSize }, writer.uint32(170).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(178).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(186).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int64Value.encode({ value: message.subscribers }, writer.uint32(194).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(202).fork()).ldelim();
    }
    if (message.isDefaultIcon !== void 0) {
      BoolValue.encode({ value: message.isDefaultIcon }, writer.uint32(210).fork()).ldelim();
    }
    if (message.inkFlairPosition !== void 0) {
      StringValue.encode({ value: message.inkFlairPosition }, writer.uint32(218).fork()).ldelim();
    }
    if (message.displayNamePrefixed !== void 0) {
      StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(226).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(234).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(242).fork()).ldelim();
    }
    if (message.isDefaultBanner !== void 0) {
      BoolValue.encode({ value: message.isDefaultBanner }, writer.uint32(250).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(258).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(266).fork()).ldelim();
    }
    if (message.bannerSize !== void 0) {
      Int32Value.encode({ value: message.bannerSize }, writer.uint32(274).fork()).ldelim();
    }
    if (message.userIsModerator !== void 0) {
      BoolValue.encode({ value: message.userIsModerator }, writer.uint32(282).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(290).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(298).fork()).ldelim();
    }
    if (message.linkFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(306).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(314).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(322).fork()).ldelim();
    }
    if (message.userIsSubscriber !== void 0) {
      BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(330).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteResponse_AutocompleteAccount_Subreddit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 5:
          message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.iconColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.userIsMuted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.headerImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.previousNames.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 15:
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.iconSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 17:
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.headerSize = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.isDefaultIcon = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 27:
          message.inkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.isDefaultBanner = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.bannerSize = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 35:
          message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 37:
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 38:
          message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 39:
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 40:
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 41:
          message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      defaultSet: isSet91(object.defaultSet) ? Boolean(object.defaultSet) : void 0,
      userIsContributor: isSet91(object.userIsContributor) ? Boolean(object.userIsContributor) : void 0,
      bannerImg: isSet91(object.bannerImg) ? String(object.bannerImg) : void 0,
      allowedMediaInComments: Array.isArray(object?.allowedMediaInComments) ? object.allowedMediaInComments.map((e) => String(e)) : [],
      userIsBanned: isSet91(object.userIsBanned) ? Boolean(object.userIsBanned) : void 0,
      freeFormReports: isSet91(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      communityIcon: isSet91(object.communityIcon) ? String(object.communityIcon) : void 0,
      showMedia: isSet91(object.showMedia) ? Boolean(object.showMedia) : void 0,
      iconColor: isSet91(object.iconColor) ? String(object.iconColor) : void 0,
      userIsMuted: isSet91(object.userIsMuted) ? Boolean(object.userIsMuted) : void 0,
      displayName: isSet91(object.displayName) ? String(object.displayName) : void 0,
      headerImg: isSet91(object.headerImg) ? String(object.headerImg) : void 0,
      title: isSet91(object.title) ? String(object.title) : void 0,
      previousNames: Array.isArray(object?.previousNames) ? object.previousNames.map((e) => String(e)) : [],
      over18: isSet91(object.over18) ? Boolean(object.over18) : void 0,
      iconSize: Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
      primaryColor: isSet91(object.primaryColor) ? String(object.primaryColor) : void 0,
      iconImg: isSet91(object.iconImg) ? String(object.iconImg) : void 0,
      description: isSet91(object.description) ? String(object.description) : void 0,
      submitLinkLabel: isSet91(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      headerSize: isSet91(object.headerSize) ? Number(object.headerSize) : void 0,
      restrictPosting: isSet91(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      restrictCommenting: isSet91(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      subscribers: isSet91(object.subscribers) ? Number(object.subscribers) : void 0,
      submitTextLabel: isSet91(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      isDefaultIcon: isSet91(object.isDefaultIcon) ? Boolean(object.isDefaultIcon) : void 0,
      inkFlairPosition: isSet91(object.inkFlairPosition) ? String(object.inkFlairPosition) : void 0,
      displayNamePrefixed: isSet91(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : void 0,
      keyColor: isSet91(object.keyColor) ? String(object.keyColor) : void 0,
      name: isSet91(object.name) ? String(object.name) : void 0,
      isDefaultBanner: isSet91(object.isDefaultBanner) ? Boolean(object.isDefaultBanner) : void 0,
      url: isSet91(object.url) ? String(object.url) : void 0,
      quarantine: isSet91(object.quarantine) ? Boolean(object.quarantine) : void 0,
      bannerSize: isSet91(object.bannerSize) ? Number(object.bannerSize) : void 0,
      userIsModerator: isSet91(object.userIsModerator) ? Boolean(object.userIsModerator) : void 0,
      acceptFollowers: isSet91(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      publicDescription: isSet91(object.publicDescription) ? String(object.publicDescription) : void 0,
      linkFlairEnabled: isSet91(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : void 0,
      disableContributorRequests: isSet91(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      subredditType: isSet91(object.subredditType) ? String(object.subredditType) : void 0,
      userIsSubscriber: isSet91(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.defaultSet !== void 0 && (obj.defaultSet = message.defaultSet);
    message.userIsContributor !== void 0 && (obj.userIsContributor = message.userIsContributor);
    message.bannerImg !== void 0 && (obj.bannerImg = message.bannerImg);
    if (message.allowedMediaInComments) {
      obj.allowedMediaInComments = message.allowedMediaInComments.map((e) => e);
    } else {
      obj.allowedMediaInComments = [];
    }
    message.userIsBanned !== void 0 && (obj.userIsBanned = message.userIsBanned);
    message.freeFormReports !== void 0 && (obj.freeFormReports = message.freeFormReports);
    message.communityIcon !== void 0 && (obj.communityIcon = message.communityIcon);
    message.showMedia !== void 0 && (obj.showMedia = message.showMedia);
    message.iconColor !== void 0 && (obj.iconColor = message.iconColor);
    message.userIsMuted !== void 0 && (obj.userIsMuted = message.userIsMuted);
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    message.headerImg !== void 0 && (obj.headerImg = message.headerImg);
    message.title !== void 0 && (obj.title = message.title);
    if (message.previousNames) {
      obj.previousNames = message.previousNames.map((e) => e);
    } else {
      obj.previousNames = [];
    }
    message.over18 !== void 0 && (obj.over18 = message.over18);
    if (message.iconSize) {
      obj.iconSize = message.iconSize.map((e) => e);
    } else {
      obj.iconSize = [];
    }
    message.primaryColor !== void 0 && (obj.primaryColor = message.primaryColor);
    message.iconImg !== void 0 && (obj.iconImg = message.iconImg);
    message.description !== void 0 && (obj.description = message.description);
    message.submitLinkLabel !== void 0 && (obj.submitLinkLabel = message.submitLinkLabel);
    message.headerSize !== void 0 && (obj.headerSize = message.headerSize);
    message.restrictPosting !== void 0 && (obj.restrictPosting = message.restrictPosting);
    message.restrictCommenting !== void 0 && (obj.restrictCommenting = message.restrictCommenting);
    message.subscribers !== void 0 && (obj.subscribers = message.subscribers);
    message.submitTextLabel !== void 0 && (obj.submitTextLabel = message.submitTextLabel);
    message.isDefaultIcon !== void 0 && (obj.isDefaultIcon = message.isDefaultIcon);
    message.inkFlairPosition !== void 0 && (obj.inkFlairPosition = message.inkFlairPosition);
    message.displayNamePrefixed !== void 0 && (obj.displayNamePrefixed = message.displayNamePrefixed);
    message.keyColor !== void 0 && (obj.keyColor = message.keyColor);
    message.name !== void 0 && (obj.name = message.name);
    message.isDefaultBanner !== void 0 && (obj.isDefaultBanner = message.isDefaultBanner);
    message.url !== void 0 && (obj.url = message.url);
    message.quarantine !== void 0 && (obj.quarantine = message.quarantine);
    message.bannerSize !== void 0 && (obj.bannerSize = message.bannerSize);
    message.userIsModerator !== void 0 && (obj.userIsModerator = message.userIsModerator);
    message.acceptFollowers !== void 0 && (obj.acceptFollowers = message.acceptFollowers);
    message.publicDescription !== void 0 && (obj.publicDescription = message.publicDescription);
    message.linkFlairEnabled !== void 0 && (obj.linkFlairEnabled = message.linkFlairEnabled);
    message.disableContributorRequests !== void 0 && (obj.disableContributorRequests = message.disableContributorRequests);
    message.subredditType !== void 0 && (obj.subredditType = message.subredditType);
    message.userIsSubscriber !== void 0 && (obj.userIsSubscriber = message.userIsSubscriber);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteResponse_AutocompleteAccount_Subreddit();
    message.defaultSet = object.defaultSet ?? void 0;
    message.userIsContributor = object.userIsContributor ?? void 0;
    message.bannerImg = object.bannerImg ?? void 0;
    message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
    message.userIsBanned = object.userIsBanned ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.iconColor = object.iconColor ?? void 0;
    message.userIsMuted = object.userIsMuted ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.headerImg = object.headerImg ?? void 0;
    message.title = object.title ?? void 0;
    message.previousNames = object.previousNames?.map((e) => e) || [];
    message.over18 = object.over18 ?? void 0;
    message.iconSize = object.iconSize?.map((e) => e) || [];
    message.primaryColor = object.primaryColor ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.description = object.description ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.headerSize = object.headerSize ?? void 0;
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.isDefaultIcon = object.isDefaultIcon ?? void 0;
    message.inkFlairPosition = object.inkFlairPosition ?? void 0;
    message.displayNamePrefixed = object.displayNamePrefixed ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.name = object.name ?? void 0;
    message.isDefaultBanner = object.isDefaultBanner ?? void 0;
    message.url = object.url ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.bannerSize = object.bannerSize ?? void 0;
    message.userIsModerator = object.userIsModerator ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.linkFlairEnabled = object.linkFlairEnabled ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.userIsSubscriber = object.userIsSubscriber ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteAccount.Subreddit", SubredditAutocompleteResponse_AutocompleteAccount_Subreddit);
function createBaseSubredditAutocompleteResponse_WrappedAutoCompleteSubreddit() {
  return { kind: "", data: void 0 };
}
var SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.WrappedAutoCompleteSubreddit",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      FullSubredditObject.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteResponse_WrappedAutoCompleteSubreddit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.data = FullSubredditObject.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet91(object.kind) ? String(object.kind) : "",
      data: isSet91(object.data) ? FullSubredditObject.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? FullSubredditObject.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteResponse_WrappedAutoCompleteSubreddit();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? FullSubredditObject.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.WrappedAutoCompleteSubreddit", SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit);
function createBaseSubredditAutocompleteResponse_WrappedAutoCompleteAccount() {
  return { kind: "", data: void 0 };
}
var SubredditAutocompleteResponse_WrappedAutoCompleteAccount = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.WrappedAutoCompleteAccount",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      SubredditAutocompleteResponse_AutocompleteAccount.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteResponse_WrappedAutoCompleteAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.data = SubredditAutocompleteResponse_AutocompleteAccount.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet91(object.kind) ? String(object.kind) : "",
      data: isSet91(object.data) ? SubredditAutocompleteResponse_AutocompleteAccount.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? SubredditAutocompleteResponse_AutocompleteAccount.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteResponse_WrappedAutoCompleteAccount();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? SubredditAutocompleteResponse_AutocompleteAccount.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.WrappedAutoCompleteAccount", SubredditAutocompleteResponse_WrappedAutoCompleteAccount);
function createBaseSubredditAutocompleteResponse_AutocompleteResponse() {
  return { after: void 0, before: void 0, dist: void 0, childrenSubreddits: [], childrenAccounts: [] };
}
var SubredditAutocompleteResponse_AutocompleteResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int32Value.encode({ value: message.dist }, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.childrenSubreddits) {
      SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.childrenAccounts) {
      SubredditAutocompleteResponse_WrappedAutoCompleteAccount.encode(v, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAutocompleteResponse_AutocompleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.dist = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.childrenSubreddits.push(SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.decode(reader, reader.uint32()));
          break;
        case 5:
          message.childrenAccounts.push(SubredditAutocompleteResponse_WrappedAutoCompleteAccount.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet91(object.after) ? String(object.after) : void 0,
      before: isSet91(object.before) ? String(object.before) : void 0,
      dist: isSet91(object.dist) ? Number(object.dist) : void 0,
      childrenSubreddits: Array.isArray(object?.childrenSubreddits) ? object.childrenSubreddits.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.fromJSON(e)) : [],
      childrenAccounts: Array.isArray(object?.childrenAccounts) ? object.childrenAccounts.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteAccount.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.dist !== void 0 && (obj.dist = message.dist);
    if (message.childrenSubreddits) {
      obj.childrenSubreddits = message.childrenSubreddits.map((e) => e ? SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.toJSON(e) : void 0);
    } else {
      obj.childrenSubreddits = [];
    }
    if (message.childrenAccounts) {
      obj.childrenAccounts = message.childrenAccounts.map((e) => e ? SubredditAutocompleteResponse_WrappedAutoCompleteAccount.toJSON(e) : void 0);
    } else {
      obj.childrenAccounts = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAutocompleteResponse_AutocompleteResponse();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.dist = object.dist ?? void 0;
    message.childrenSubreddits = object.childrenSubreddits?.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteSubreddit.fromPartial(e)) || [];
    message.childrenAccounts = object.childrenAccounts?.map((e) => SubredditAutocompleteResponse_WrappedAutoCompleteAccount.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAutocompleteResponse.AutocompleteResponse", SubredditAutocompleteResponse_AutocompleteResponse);
function createBaseUploadSrImgResponse() {
  return { errors: [], imgSrc: void 0, errorsValues: [] };
}
var UploadSrImgResponse = {
  $type: "devvit.plugin.redditapi.subreddits.UploadSrImgResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    for (const v of message.errors) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    if (message.imgSrc !== void 0) {
      StringValue.encode({ value: message.imgSrc }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.errorsValues) {
      StringValue.encode({ value: v }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUploadSrImgResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.errors.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 2:
          message.imgSrc = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.errorsValues.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      errors: Array.isArray(object?.errors) ? object.errors.map((e) => String(e)) : [],
      imgSrc: isSet91(object.imgSrc) ? String(object.imgSrc) : void 0,
      errorsValues: Array.isArray(object?.errorsValues) ? object.errorsValues.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.errors) {
      obj.errors = message.errors.map((e) => e);
    } else {
      obj.errors = [];
    }
    message.imgSrc !== void 0 && (obj.imgSrc = message.imgSrc);
    if (message.errorsValues) {
      obj.errorsValues = message.errorsValues.map((e) => e);
    } else {
      obj.errorsValues = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUploadSrImgResponse();
    message.errors = object.errors?.map((e) => e) || [];
    message.imgSrc = object.imgSrc ?? void 0;
    message.errorsValues = object.errorsValues?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UploadSrImgResponse", UploadSrImgResponse);
function createBaseSubredditPostRequirementsResponse() {
  return {
    titleRegexes: [],
    bodyBlacklistedStrings: [],
    titleBlacklistedStrings: [],
    bodyTextMaxLength: void 0,
    titleRequiredStrings: [],
    guidelinesText: void 0,
    galleryMinItems: void 0,
    domainBlacklist: [],
    domainWhitelist: [],
    titleTextMaxLength: void 0,
    bodyRestrictionPolicy: void 0,
    linkRestrictionPolicy: void 0,
    guidelinesDisplayPolicy: void 0,
    bodyRequiredStrings: [],
    titleTextMinLength: void 0,
    galleryCaptionsRequirement: void 0,
    isFlairRequired: void 0,
    galleryMaxItems: void 0,
    galleryUrlsRequirement: void 0,
    bodyRegexes: [],
    linkRepostAge: void 0,
    bodyTextMinLength: void 0
  };
}
var SubredditPostRequirementsResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditPostRequirementsResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    for (const v of message.titleRegexes) {
      StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.bodyBlacklistedStrings) {
      StringValue.encode({ value: v }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.titleBlacklistedStrings) {
      StringValue.encode({ value: v }, writer.uint32(26).fork()).ldelim();
    }
    if (message.bodyTextMaxLength !== void 0) {
      Int32Value.encode({ value: message.bodyTextMaxLength }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.titleRequiredStrings) {
      StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
    }
    if (message.guidelinesText !== void 0) {
      StringValue.encode({ value: message.guidelinesText }, writer.uint32(50).fork()).ldelim();
    }
    if (message.galleryMinItems !== void 0) {
      Int32Value.encode({ value: message.galleryMinItems }, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.domainBlacklist) {
      StringValue.encode({ value: v }, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.domainWhitelist) {
      StringValue.encode({ value: v }, writer.uint32(74).fork()).ldelim();
    }
    if (message.titleTextMaxLength !== void 0) {
      Int32Value.encode({ value: message.titleTextMaxLength }, writer.uint32(82).fork()).ldelim();
    }
    if (message.bodyRestrictionPolicy !== void 0) {
      StringValue.encode({ value: message.bodyRestrictionPolicy }, writer.uint32(90).fork()).ldelim();
    }
    if (message.linkRestrictionPolicy !== void 0) {
      StringValue.encode({ value: message.linkRestrictionPolicy }, writer.uint32(98).fork()).ldelim();
    }
    if (message.guidelinesDisplayPolicy !== void 0) {
      StringValue.encode({ value: message.guidelinesDisplayPolicy }, writer.uint32(106).fork()).ldelim();
    }
    for (const v of message.bodyRequiredStrings) {
      StringValue.encode({ value: v }, writer.uint32(114).fork()).ldelim();
    }
    if (message.titleTextMinLength !== void 0) {
      Int32Value.encode({ value: message.titleTextMinLength }, writer.uint32(122).fork()).ldelim();
    }
    if (message.galleryCaptionsRequirement !== void 0) {
      StringValue.encode({ value: message.galleryCaptionsRequirement }, writer.uint32(130).fork()).ldelim();
    }
    if (message.isFlairRequired !== void 0) {
      BoolValue.encode({ value: message.isFlairRequired }, writer.uint32(138).fork()).ldelim();
    }
    if (message.galleryMaxItems !== void 0) {
      Int32Value.encode({ value: message.galleryMaxItems }, writer.uint32(146).fork()).ldelim();
    }
    if (message.galleryUrlsRequirement !== void 0) {
      StringValue.encode({ value: message.galleryUrlsRequirement }, writer.uint32(154).fork()).ldelim();
    }
    for (const v of message.bodyRegexes) {
      StringValue.encode({ value: v }, writer.uint32(162).fork()).ldelim();
    }
    if (message.linkRepostAge !== void 0) {
      Int32Value.encode({ value: message.linkRepostAge }, writer.uint32(170).fork()).ldelim();
    }
    if (message.bodyTextMinLength !== void 0) {
      Int32Value.encode({ value: message.bodyTextMinLength }, writer.uint32(178).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditPostRequirementsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.titleRegexes.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 2:
          message.bodyBlacklistedStrings.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 3:
          message.titleBlacklistedStrings.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 4:
          message.bodyTextMaxLength = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.titleRequiredStrings.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 6:
          message.guidelinesText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.galleryMinItems = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.domainBlacklist.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 9:
          message.domainWhitelist.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 10:
          message.titleTextMaxLength = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.bodyRestrictionPolicy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.linkRestrictionPolicy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.guidelinesDisplayPolicy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.bodyRequiredStrings.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 15:
          message.titleTextMinLength = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.galleryCaptionsRequirement = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.isFlairRequired = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.galleryMaxItems = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.galleryUrlsRequirement = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.bodyRegexes.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 21:
          message.linkRepostAge = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.bodyTextMinLength = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      titleRegexes: Array.isArray(object?.titleRegexes) ? object.titleRegexes.map((e) => String(e)) : [],
      bodyBlacklistedStrings: Array.isArray(object?.bodyBlacklistedStrings) ? object.bodyBlacklistedStrings.map((e) => String(e)) : [],
      titleBlacklistedStrings: Array.isArray(object?.titleBlacklistedStrings) ? object.titleBlacklistedStrings.map((e) => String(e)) : [],
      bodyTextMaxLength: isSet91(object.bodyTextMaxLength) ? Number(object.bodyTextMaxLength) : void 0,
      titleRequiredStrings: Array.isArray(object?.titleRequiredStrings) ? object.titleRequiredStrings.map((e) => String(e)) : [],
      guidelinesText: isSet91(object.guidelinesText) ? String(object.guidelinesText) : void 0,
      galleryMinItems: isSet91(object.galleryMinItems) ? Number(object.galleryMinItems) : void 0,
      domainBlacklist: Array.isArray(object?.domainBlacklist) ? object.domainBlacklist.map((e) => String(e)) : [],
      domainWhitelist: Array.isArray(object?.domainWhitelist) ? object.domainWhitelist.map((e) => String(e)) : [],
      titleTextMaxLength: isSet91(object.titleTextMaxLength) ? Number(object.titleTextMaxLength) : void 0,
      bodyRestrictionPolicy: isSet91(object.bodyRestrictionPolicy) ? String(object.bodyRestrictionPolicy) : void 0,
      linkRestrictionPolicy: isSet91(object.linkRestrictionPolicy) ? String(object.linkRestrictionPolicy) : void 0,
      guidelinesDisplayPolicy: isSet91(object.guidelinesDisplayPolicy) ? String(object.guidelinesDisplayPolicy) : void 0,
      bodyRequiredStrings: Array.isArray(object?.bodyRequiredStrings) ? object.bodyRequiredStrings.map((e) => String(e)) : [],
      titleTextMinLength: isSet91(object.titleTextMinLength) ? Number(object.titleTextMinLength) : void 0,
      galleryCaptionsRequirement: isSet91(object.galleryCaptionsRequirement) ? String(object.galleryCaptionsRequirement) : void 0,
      isFlairRequired: isSet91(object.isFlairRequired) ? Boolean(object.isFlairRequired) : void 0,
      galleryMaxItems: isSet91(object.galleryMaxItems) ? Number(object.galleryMaxItems) : void 0,
      galleryUrlsRequirement: isSet91(object.galleryUrlsRequirement) ? String(object.galleryUrlsRequirement) : void 0,
      bodyRegexes: Array.isArray(object?.bodyRegexes) ? object.bodyRegexes.map((e) => String(e)) : [],
      linkRepostAge: isSet91(object.linkRepostAge) ? Number(object.linkRepostAge) : void 0,
      bodyTextMinLength: isSet91(object.bodyTextMinLength) ? Number(object.bodyTextMinLength) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.titleRegexes) {
      obj.titleRegexes = message.titleRegexes.map((e) => e);
    } else {
      obj.titleRegexes = [];
    }
    if (message.bodyBlacklistedStrings) {
      obj.bodyBlacklistedStrings = message.bodyBlacklistedStrings.map((e) => e);
    } else {
      obj.bodyBlacklistedStrings = [];
    }
    if (message.titleBlacklistedStrings) {
      obj.titleBlacklistedStrings = message.titleBlacklistedStrings.map((e) => e);
    } else {
      obj.titleBlacklistedStrings = [];
    }
    message.bodyTextMaxLength !== void 0 && (obj.bodyTextMaxLength = message.bodyTextMaxLength);
    if (message.titleRequiredStrings) {
      obj.titleRequiredStrings = message.titleRequiredStrings.map((e) => e);
    } else {
      obj.titleRequiredStrings = [];
    }
    message.guidelinesText !== void 0 && (obj.guidelinesText = message.guidelinesText);
    message.galleryMinItems !== void 0 && (obj.galleryMinItems = message.galleryMinItems);
    if (message.domainBlacklist) {
      obj.domainBlacklist = message.domainBlacklist.map((e) => e);
    } else {
      obj.domainBlacklist = [];
    }
    if (message.domainWhitelist) {
      obj.domainWhitelist = message.domainWhitelist.map((e) => e);
    } else {
      obj.domainWhitelist = [];
    }
    message.titleTextMaxLength !== void 0 && (obj.titleTextMaxLength = message.titleTextMaxLength);
    message.bodyRestrictionPolicy !== void 0 && (obj.bodyRestrictionPolicy = message.bodyRestrictionPolicy);
    message.linkRestrictionPolicy !== void 0 && (obj.linkRestrictionPolicy = message.linkRestrictionPolicy);
    message.guidelinesDisplayPolicy !== void 0 && (obj.guidelinesDisplayPolicy = message.guidelinesDisplayPolicy);
    if (message.bodyRequiredStrings) {
      obj.bodyRequiredStrings = message.bodyRequiredStrings.map((e) => e);
    } else {
      obj.bodyRequiredStrings = [];
    }
    message.titleTextMinLength !== void 0 && (obj.titleTextMinLength = message.titleTextMinLength);
    message.galleryCaptionsRequirement !== void 0 && (obj.galleryCaptionsRequirement = message.galleryCaptionsRequirement);
    message.isFlairRequired !== void 0 && (obj.isFlairRequired = message.isFlairRequired);
    message.galleryMaxItems !== void 0 && (obj.galleryMaxItems = message.galleryMaxItems);
    message.galleryUrlsRequirement !== void 0 && (obj.galleryUrlsRequirement = message.galleryUrlsRequirement);
    if (message.bodyRegexes) {
      obj.bodyRegexes = message.bodyRegexes.map((e) => e);
    } else {
      obj.bodyRegexes = [];
    }
    message.linkRepostAge !== void 0 && (obj.linkRepostAge = message.linkRepostAge);
    message.bodyTextMinLength !== void 0 && (obj.bodyTextMinLength = message.bodyTextMinLength);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditPostRequirementsResponse();
    message.titleRegexes = object.titleRegexes?.map((e) => e) || [];
    message.bodyBlacklistedStrings = object.bodyBlacklistedStrings?.map((e) => e) || [];
    message.titleBlacklistedStrings = object.titleBlacklistedStrings?.map((e) => e) || [];
    message.bodyTextMaxLength = object.bodyTextMaxLength ?? void 0;
    message.titleRequiredStrings = object.titleRequiredStrings?.map((e) => e) || [];
    message.guidelinesText = object.guidelinesText ?? void 0;
    message.galleryMinItems = object.galleryMinItems ?? void 0;
    message.domainBlacklist = object.domainBlacklist?.map((e) => e) || [];
    message.domainWhitelist = object.domainWhitelist?.map((e) => e) || [];
    message.titleTextMaxLength = object.titleTextMaxLength ?? void 0;
    message.bodyRestrictionPolicy = object.bodyRestrictionPolicy ?? void 0;
    message.linkRestrictionPolicy = object.linkRestrictionPolicy ?? void 0;
    message.guidelinesDisplayPolicy = object.guidelinesDisplayPolicy ?? void 0;
    message.bodyRequiredStrings = object.bodyRequiredStrings?.map((e) => e) || [];
    message.titleTextMinLength = object.titleTextMinLength ?? void 0;
    message.galleryCaptionsRequirement = object.galleryCaptionsRequirement ?? void 0;
    message.isFlairRequired = object.isFlairRequired ?? void 0;
    message.galleryMaxItems = object.galleryMaxItems ?? void 0;
    message.galleryUrlsRequirement = object.galleryUrlsRequirement ?? void 0;
    message.bodyRegexes = object.bodyRegexes?.map((e) => e) || [];
    message.linkRepostAge = object.linkRepostAge ?? void 0;
    message.bodyTextMinLength = object.bodyTextMinLength ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditPostRequirementsResponse", SubredditPostRequirementsResponse);
function createBaseSubredditAboutResponse() {
  return { kind: void 0, data: void 0 };
}
var SubredditAboutResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      SubredditAboutResponse_AboutData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = SubredditAboutResponse_AboutData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet91(object.kind) ? String(object.kind) : void 0,
      data: isSet91(object.data) ? SubredditAboutResponse_AboutData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? SubredditAboutResponse_AboutData.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? SubredditAboutResponse_AboutData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutResponse", SubredditAboutResponse);
function createBaseSubredditAboutResponse_AboutData() {
  return {
    userFlairBackgroundColor: void 0,
    submitTextHtml: void 0,
    restrictPosting: void 0,
    userIsBanned: void 0,
    freeFormReports: void 0,
    wikiEnabled: void 0,
    userIsMuted: void 0,
    userCanFlairInSr: void 0,
    displayName: void 0,
    headerImg: void 0,
    title: void 0,
    allowGalleries: void 0,
    iconSize: void 0,
    primaryColor: void 0,
    activeUserCount: void 0,
    iconImg: void 0,
    displayNamePrefixed: void 0,
    accountsActive: void 0,
    publicTraffic: void 0,
    subscribers: void 0,
    userFlairRichtext: [],
    name: void 0,
    quarantine: void 0,
    hideAds: void 0,
    predictionLeaderboardEntryType: void 0,
    emojisEnabled: void 0,
    advertiserCategory: void 0,
    publicDescription: void 0,
    commentScoreHideMins: void 0,
    allowPredictions: void 0,
    userHasFavorited: void 0,
    userFlairTemplateId: void 0,
    communityIcon: void 0,
    bannerBackgroundImage: void 0,
    originalContentTagEnabled: void 0,
    communityReviewed: void 0,
    submitText: void 0,
    descriptionHtml: void 0,
    spoilersEnabled: void 0,
    commentContributionSettings: void 0,
    allowTalks: void 0,
    headerSize: void 0,
    userFlairPosition: void 0,
    allOriginalContent: void 0,
    collectionsEnabled: void 0,
    isEnrolledInNewModmail: void 0,
    keyColor: void 0,
    eventPostsEnabled: void 0,
    canAssignUserFlair: void 0,
    created: void 0,
    wls: void 0,
    showMediaPreview: void 0,
    submissionType: void 0,
    userIsSubscriber: void 0,
    allowedMediaInComments: [],
    allowVideogifs: void 0,
    shouldArchivePosts: void 0,
    userFlairType: void 0,
    allowPolls: void 0,
    collapseDeletedComments: void 0,
    coins: void 0,
    emojisCustomSize: void 0,
    publicDescriptionHtml: void 0,
    allowVideos: void 0,
    isCrosspostableSubreddit: void 0,
    notificationLevel: void 0,
    shouldShowMediaInCommentsSetting: void 0,
    canAssignLinkFlair: void 0,
    hasMenuWidget: void 0,
    accountsActiveIsFuzzed: void 0,
    allowPredictionContributors: void 0,
    submitTextLabel: void 0,
    linkFlairPosition: void 0,
    userSrFlairEnabled: void 0,
    userFlairEnabledInSr: void 0,
    allowChatPostCreation: void 0,
    allowDiscovery: void 0,
    acceptFollowers: void 0,
    userSrThemeEnabled: void 0,
    linkFlairEnabled: void 0,
    disableContributorRequests: void 0,
    subredditType: void 0,
    suggestedCommentSort: void 0,
    bannerImg: void 0,
    userFlairText: void 0,
    bannerBackgroundColor: void 0,
    showMedia: void 0,
    id: void 0,
    userIsModerator: void 0,
    over18: void 0,
    headerTitle: void 0,
    description: void 0,
    isChatPostFeatureEnabled: void 0,
    submitLinkLabel: void 0,
    userFlairTextColor: void 0,
    restrictCommenting: void 0,
    userFlairCssClass: void 0,
    allowImages: void 0,
    lang: void 0,
    whitelistStatus: void 0,
    url: void 0,
    createdUtc: void 0,
    bannerSize: void 0,
    mobileBannerImage: void 0,
    userIsContributor: void 0,
    allowPredictionsTournament: void 0
  };
}
var SubredditAboutResponse_AboutData = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutResponse.AboutData",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.userFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.userFlairBackgroundColor }, writer.uint32(10).fork()).ldelim();
    }
    if (message.submitTextHtml !== void 0) {
      StringValue.encode({ value: message.submitTextHtml }, writer.uint32(18).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(26).fork()).ldelim();
    }
    if (message.userIsBanned !== void 0) {
      BoolValue.encode({ value: message.userIsBanned }, writer.uint32(34).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(42).fork()).ldelim();
    }
    if (message.wikiEnabled !== void 0) {
      BoolValue.encode({ value: message.wikiEnabled }, writer.uint32(50).fork()).ldelim();
    }
    if (message.userIsMuted !== void 0) {
      BoolValue.encode({ value: message.userIsMuted }, writer.uint32(58).fork()).ldelim();
    }
    if (message.userCanFlairInSr !== void 0) {
      BoolValue.encode({ value: message.userCanFlairInSr }, writer.uint32(66).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(74).fork()).ldelim();
    }
    if (message.headerImg !== void 0) {
      StringValue.encode({ value: message.headerImg }, writer.uint32(82).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(90).fork()).ldelim();
    }
    if (message.allowGalleries !== void 0) {
      BoolValue.encode({ value: message.allowGalleries }, writer.uint32(98).fork()).ldelim();
    }
    if (message.iconSize !== void 0) {
      Int64Value.encode({ value: message.iconSize }, writer.uint32(106).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(114).fork()).ldelim();
    }
    if (message.activeUserCount !== void 0) {
      Int64Value.encode({ value: message.activeUserCount }, writer.uint32(122).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(130).fork()).ldelim();
    }
    if (message.displayNamePrefixed !== void 0) {
      StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(138).fork()).ldelim();
    }
    if (message.accountsActive !== void 0) {
      Int64Value.encode({ value: message.accountsActive }, writer.uint32(146).fork()).ldelim();
    }
    if (message.publicTraffic !== void 0) {
      BoolValue.encode({ value: message.publicTraffic }, writer.uint32(154).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int64Value.encode({ value: message.subscribers }, writer.uint32(162).fork()).ldelim();
    }
    for (const v of message.userFlairRichtext) {
      UserFlairRichtext.encode(v, writer.uint32(170).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(178).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(186).fork()).ldelim();
    }
    if (message.hideAds !== void 0) {
      BoolValue.encode({ value: message.hideAds }, writer.uint32(194).fork()).ldelim();
    }
    if (message.predictionLeaderboardEntryType !== void 0) {
      StringValue.encode({ value: message.predictionLeaderboardEntryType }, writer.uint32(202).fork()).ldelim();
    }
    if (message.emojisEnabled !== void 0) {
      BoolValue.encode({ value: message.emojisEnabled }, writer.uint32(210).fork()).ldelim();
    }
    if (message.advertiserCategory !== void 0) {
      StringValue.encode({ value: message.advertiserCategory }, writer.uint32(218).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(226).fork()).ldelim();
    }
    if (message.commentScoreHideMins !== void 0) {
      Int32Value.encode({ value: message.commentScoreHideMins }, writer.uint32(234).fork()).ldelim();
    }
    if (message.allowPredictions !== void 0) {
      BoolValue.encode({ value: message.allowPredictions }, writer.uint32(242).fork()).ldelim();
    }
    if (message.userHasFavorited !== void 0) {
      BoolValue.encode({ value: message.userHasFavorited }, writer.uint32(250).fork()).ldelim();
    }
    if (message.userFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.userFlairTemplateId }, writer.uint32(258).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(266).fork()).ldelim();
    }
    if (message.bannerBackgroundImage !== void 0) {
      StringValue.encode({ value: message.bannerBackgroundImage }, writer.uint32(274).fork()).ldelim();
    }
    if (message.originalContentTagEnabled !== void 0) {
      BoolValue.encode({ value: message.originalContentTagEnabled }, writer.uint32(282).fork()).ldelim();
    }
    if (message.communityReviewed !== void 0) {
      BoolValue.encode({ value: message.communityReviewed }, writer.uint32(290).fork()).ldelim();
    }
    if (message.submitText !== void 0) {
      StringValue.encode({ value: message.submitText }, writer.uint32(298).fork()).ldelim();
    }
    if (message.descriptionHtml !== void 0) {
      StringValue.encode({ value: message.descriptionHtml }, writer.uint32(306).fork()).ldelim();
    }
    if (message.spoilersEnabled !== void 0) {
      BoolValue.encode({ value: message.spoilersEnabled }, writer.uint32(314).fork()).ldelim();
    }
    if (message.commentContributionSettings !== void 0) {
      CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(322).fork()).ldelim();
    }
    if (message.allowTalks !== void 0) {
      BoolValue.encode({ value: message.allowTalks }, writer.uint32(330).fork()).ldelim();
    }
    if (message.headerSize !== void 0) {
      Int64Value.encode({ value: message.headerSize }, writer.uint32(338).fork()).ldelim();
    }
    if (message.userFlairPosition !== void 0) {
      StringValue.encode({ value: message.userFlairPosition }, writer.uint32(346).fork()).ldelim();
    }
    if (message.allOriginalContent !== void 0) {
      BoolValue.encode({ value: message.allOriginalContent }, writer.uint32(354).fork()).ldelim();
    }
    if (message.collectionsEnabled !== void 0) {
      BoolValue.encode({ value: message.collectionsEnabled }, writer.uint32(362).fork()).ldelim();
    }
    if (message.isEnrolledInNewModmail !== void 0) {
      BoolValue.encode({ value: message.isEnrolledInNewModmail }, writer.uint32(370).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(378).fork()).ldelim();
    }
    if (message.eventPostsEnabled !== void 0) {
      BoolValue.encode({ value: message.eventPostsEnabled }, writer.uint32(386).fork()).ldelim();
    }
    if (message.canAssignUserFlair !== void 0) {
      BoolValue.encode({ value: message.canAssignUserFlair }, writer.uint32(394).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int64Value.encode({ value: message.created }, writer.uint32(402).fork()).ldelim();
    }
    if (message.wls !== void 0) {
      StringValue.encode({ value: message.wls }, writer.uint32(410).fork()).ldelim();
    }
    if (message.showMediaPreview !== void 0) {
      BoolValue.encode({ value: message.showMediaPreview }, writer.uint32(418).fork()).ldelim();
    }
    if (message.submissionType !== void 0) {
      StringValue.encode({ value: message.submissionType }, writer.uint32(426).fork()).ldelim();
    }
    if (message.userIsSubscriber !== void 0) {
      BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(434).fork()).ldelim();
    }
    for (const v of message.allowedMediaInComments) {
      StringValue.encode({ value: v }, writer.uint32(442).fork()).ldelim();
    }
    if (message.allowVideogifs !== void 0) {
      BoolValue.encode({ value: message.allowVideogifs }, writer.uint32(450).fork()).ldelim();
    }
    if (message.shouldArchivePosts !== void 0) {
      BoolValue.encode({ value: message.shouldArchivePosts }, writer.uint32(458).fork()).ldelim();
    }
    if (message.userFlairType !== void 0) {
      StringValue.encode({ value: message.userFlairType }, writer.uint32(466).fork()).ldelim();
    }
    if (message.allowPolls !== void 0) {
      BoolValue.encode({ value: message.allowPolls }, writer.uint32(474).fork()).ldelim();
    }
    if (message.collapseDeletedComments !== void 0) {
      BoolValue.encode({ value: message.collapseDeletedComments }, writer.uint32(482).fork()).ldelim();
    }
    if (message.coins !== void 0) {
      Int64Value.encode({ value: message.coins }, writer.uint32(490).fork()).ldelim();
    }
    if (message.emojisCustomSize !== void 0) {
      Int64Value.encode({ value: message.emojisCustomSize }, writer.uint32(498).fork()).ldelim();
    }
    if (message.publicDescriptionHtml !== void 0) {
      StringValue.encode({ value: message.publicDescriptionHtml }, writer.uint32(506).fork()).ldelim();
    }
    if (message.allowVideos !== void 0) {
      BoolValue.encode({ value: message.allowVideos }, writer.uint32(514).fork()).ldelim();
    }
    if (message.isCrosspostableSubreddit !== void 0) {
      BoolValue.encode({ value: message.isCrosspostableSubreddit }, writer.uint32(522).fork()).ldelim();
    }
    if (message.notificationLevel !== void 0) {
      StringValue.encode({ value: message.notificationLevel }, writer.uint32(530).fork()).ldelim();
    }
    if (message.shouldShowMediaInCommentsSetting !== void 0) {
      BoolValue.encode({ value: message.shouldShowMediaInCommentsSetting }, writer.uint32(538).fork()).ldelim();
    }
    if (message.canAssignLinkFlair !== void 0) {
      BoolValue.encode({ value: message.canAssignLinkFlair }, writer.uint32(546).fork()).ldelim();
    }
    if (message.hasMenuWidget !== void 0) {
      BoolValue.encode({ value: message.hasMenuWidget }, writer.uint32(554).fork()).ldelim();
    }
    if (message.accountsActiveIsFuzzed !== void 0) {
      BoolValue.encode({ value: message.accountsActiveIsFuzzed }, writer.uint32(562).fork()).ldelim();
    }
    if (message.allowPredictionContributors !== void 0) {
      BoolValue.encode({ value: message.allowPredictionContributors }, writer.uint32(570).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(578).fork()).ldelim();
    }
    if (message.linkFlairPosition !== void 0) {
      StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(586).fork()).ldelim();
    }
    if (message.userSrFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.userSrFlairEnabled }, writer.uint32(594).fork()).ldelim();
    }
    if (message.userFlairEnabledInSr !== void 0) {
      BoolValue.encode({ value: message.userFlairEnabledInSr }, writer.uint32(602).fork()).ldelim();
    }
    if (message.allowChatPostCreation !== void 0) {
      BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(610).fork()).ldelim();
    }
    if (message.allowDiscovery !== void 0) {
      BoolValue.encode({ value: message.allowDiscovery }, writer.uint32(618).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(626).fork()).ldelim();
    }
    if (message.userSrThemeEnabled !== void 0) {
      BoolValue.encode({ value: message.userSrThemeEnabled }, writer.uint32(634).fork()).ldelim();
    }
    if (message.linkFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(642).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(650).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(658).fork()).ldelim();
    }
    if (message.suggestedCommentSort !== void 0) {
      StringValue.encode({ value: message.suggestedCommentSort }, writer.uint32(666).fork()).ldelim();
    }
    if (message.bannerImg !== void 0) {
      StringValue.encode({ value: message.bannerImg }, writer.uint32(674).fork()).ldelim();
    }
    if (message.userFlairText !== void 0) {
      StringValue.encode({ value: message.userFlairText }, writer.uint32(682).fork()).ldelim();
    }
    if (message.bannerBackgroundColor !== void 0) {
      StringValue.encode({ value: message.bannerBackgroundColor }, writer.uint32(690).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(698).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(706).fork()).ldelim();
    }
    if (message.userIsModerator !== void 0) {
      BoolValue.encode({ value: message.userIsModerator }, writer.uint32(714).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(722).fork()).ldelim();
    }
    if (message.headerTitle !== void 0) {
      StringValue.encode({ value: message.headerTitle }, writer.uint32(730).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(738).fork()).ldelim();
    }
    if (message.isChatPostFeatureEnabled !== void 0) {
      BoolValue.encode({ value: message.isChatPostFeatureEnabled }, writer.uint32(746).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(754).fork()).ldelim();
    }
    if (message.userFlairTextColor !== void 0) {
      StringValue.encode({ value: message.userFlairTextColor }, writer.uint32(762).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(770).fork()).ldelim();
    }
    if (message.userFlairCssClass !== void 0) {
      StringValue.encode({ value: message.userFlairCssClass }, writer.uint32(778).fork()).ldelim();
    }
    if (message.allowImages !== void 0) {
      BoolValue.encode({ value: message.allowImages }, writer.uint32(786).fork()).ldelim();
    }
    if (message.lang !== void 0) {
      StringValue.encode({ value: message.lang }, writer.uint32(794).fork()).ldelim();
    }
    if (message.whitelistStatus !== void 0) {
      BoolValue.encode({ value: message.whitelistStatus }, writer.uint32(802).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(810).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(818).fork()).ldelim();
    }
    if (message.bannerSize !== void 0) {
      Int64Value.encode({ value: message.bannerSize }, writer.uint32(826).fork()).ldelim();
    }
    if (message.mobileBannerImage !== void 0) {
      StringValue.encode({ value: message.mobileBannerImage }, writer.uint32(834).fork()).ldelim();
    }
    if (message.userIsContributor !== void 0) {
      BoolValue.encode({ value: message.userIsContributor }, writer.uint32(842).fork()).ldelim();
    }
    if (message.allowPredictionsTournament !== void 0) {
      BoolValue.encode({ value: message.allowPredictionsTournament }, writer.uint32(850).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutResponse_AboutData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.userFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.submitTextHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.wikiEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.userIsMuted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.userCanFlairInSr = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.headerImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.allowGalleries = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.iconSize = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.activeUserCount = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.accountsActive = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.publicTraffic = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.userFlairRichtext.push(UserFlairRichtext.decode(reader, reader.uint32()));
          break;
        case 22:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.hideAds = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.predictionLeaderboardEntryType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.emojisEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 27:
          message.advertiserCategory = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.commentScoreHideMins = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.allowPredictions = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.userHasFavorited = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.userFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.bannerBackgroundImage = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 35:
          message.originalContentTagEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.communityReviewed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 37:
          message.submitText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 38:
          message.descriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 39:
          message.spoilersEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 40:
          message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
          break;
        case 41:
          message.allowTalks = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 42:
          message.headerSize = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 43:
          message.userFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 44:
          message.allOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 45:
          message.collectionsEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 46:
          message.isEnrolledInNewModmail = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 47:
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 48:
          message.eventPostsEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 49:
          message.canAssignUserFlair = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 50:
          message.created = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 51:
          message.wls = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 52:
          message.showMediaPreview = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 53:
          message.submissionType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 54:
          message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 55:
          message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 56:
          message.allowVideogifs = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 57:
          message.shouldArchivePosts = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 58:
          message.userFlairType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 59:
          message.allowPolls = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 60:
          message.collapseDeletedComments = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 61:
          message.coins = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 62:
          message.emojisCustomSize = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 63:
          message.publicDescriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 64:
          message.allowVideos = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 65:
          message.isCrosspostableSubreddit = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 66:
          message.notificationLevel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 67:
          message.shouldShowMediaInCommentsSetting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 68:
          message.canAssignLinkFlair = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 69:
          message.hasMenuWidget = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 70:
          message.accountsActiveIsFuzzed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 71:
          message.allowPredictionContributors = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 72:
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 73:
          message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 74:
          message.userSrFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 75:
          message.userFlairEnabledInSr = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 76:
          message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 77:
          message.allowDiscovery = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 78:
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 79:
          message.userSrThemeEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 80:
          message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 81:
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 82:
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 83:
          message.suggestedCommentSort = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 84:
          message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 85:
          message.userFlairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 86:
          message.bannerBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 87:
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 88:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 89:
          message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 90:
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 91:
          message.headerTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 92:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 93:
          message.isChatPostFeatureEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 94:
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 95:
          message.userFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 96:
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 97:
          message.userFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 98:
          message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 99:
          message.lang = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 100:
          message.whitelistStatus = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 101:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 102:
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 103:
          message.bannerSize = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 104:
          message.mobileBannerImage = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 105:
          message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 106:
          message.allowPredictionsTournament = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      userFlairBackgroundColor: isSet91(object.userFlairBackgroundColor) ? String(object.userFlairBackgroundColor) : void 0,
      submitTextHtml: isSet91(object.submitTextHtml) ? String(object.submitTextHtml) : void 0,
      restrictPosting: isSet91(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      userIsBanned: isSet91(object.userIsBanned) ? Boolean(object.userIsBanned) : void 0,
      freeFormReports: isSet91(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      wikiEnabled: isSet91(object.wikiEnabled) ? Boolean(object.wikiEnabled) : void 0,
      userIsMuted: isSet91(object.userIsMuted) ? Boolean(object.userIsMuted) : void 0,
      userCanFlairInSr: isSet91(object.userCanFlairInSr) ? Boolean(object.userCanFlairInSr) : void 0,
      displayName: isSet91(object.displayName) ? String(object.displayName) : void 0,
      headerImg: isSet91(object.headerImg) ? String(object.headerImg) : void 0,
      title: isSet91(object.title) ? String(object.title) : void 0,
      allowGalleries: isSet91(object.allowGalleries) ? Boolean(object.allowGalleries) : void 0,
      iconSize: isSet91(object.iconSize) ? Number(object.iconSize) : void 0,
      primaryColor: isSet91(object.primaryColor) ? String(object.primaryColor) : void 0,
      activeUserCount: isSet91(object.activeUserCount) ? Number(object.activeUserCount) : void 0,
      iconImg: isSet91(object.iconImg) ? String(object.iconImg) : void 0,
      displayNamePrefixed: isSet91(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : void 0,
      accountsActive: isSet91(object.accountsActive) ? Number(object.accountsActive) : void 0,
      publicTraffic: isSet91(object.publicTraffic) ? Boolean(object.publicTraffic) : void 0,
      subscribers: isSet91(object.subscribers) ? Number(object.subscribers) : void 0,
      userFlairRichtext: Array.isArray(object?.userFlairRichtext) ? object.userFlairRichtext.map((e) => UserFlairRichtext.fromJSON(e)) : [],
      name: isSet91(object.name) ? String(object.name) : void 0,
      quarantine: isSet91(object.quarantine) ? Boolean(object.quarantine) : void 0,
      hideAds: isSet91(object.hideAds) ? Boolean(object.hideAds) : void 0,
      predictionLeaderboardEntryType: isSet91(object.predictionLeaderboardEntryType) ? String(object.predictionLeaderboardEntryType) : void 0,
      emojisEnabled: isSet91(object.emojisEnabled) ? Boolean(object.emojisEnabled) : void 0,
      advertiserCategory: isSet91(object.advertiserCategory) ? String(object.advertiserCategory) : void 0,
      publicDescription: isSet91(object.publicDescription) ? String(object.publicDescription) : void 0,
      commentScoreHideMins: isSet91(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : void 0,
      allowPredictions: isSet91(object.allowPredictions) ? Boolean(object.allowPredictions) : void 0,
      userHasFavorited: isSet91(object.userHasFavorited) ? Boolean(object.userHasFavorited) : void 0,
      userFlairTemplateId: isSet91(object.userFlairTemplateId) ? String(object.userFlairTemplateId) : void 0,
      communityIcon: isSet91(object.communityIcon) ? String(object.communityIcon) : void 0,
      bannerBackgroundImage: isSet91(object.bannerBackgroundImage) ? String(object.bannerBackgroundImage) : void 0,
      originalContentTagEnabled: isSet91(object.originalContentTagEnabled) ? Boolean(object.originalContentTagEnabled) : void 0,
      communityReviewed: isSet91(object.communityReviewed) ? Boolean(object.communityReviewed) : void 0,
      submitText: isSet91(object.submitText) ? String(object.submitText) : void 0,
      descriptionHtml: isSet91(object.descriptionHtml) ? String(object.descriptionHtml) : void 0,
      spoilersEnabled: isSet91(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : void 0,
      commentContributionSettings: isSet91(object.commentContributionSettings) ? CommentContributionSettings.fromJSON(object.commentContributionSettings) : void 0,
      allowTalks: isSet91(object.allowTalks) ? Boolean(object.allowTalks) : void 0,
      headerSize: isSet91(object.headerSize) ? Number(object.headerSize) : void 0,
      userFlairPosition: isSet91(object.userFlairPosition) ? String(object.userFlairPosition) : void 0,
      allOriginalContent: isSet91(object.allOriginalContent) ? Boolean(object.allOriginalContent) : void 0,
      collectionsEnabled: isSet91(object.collectionsEnabled) ? Boolean(object.collectionsEnabled) : void 0,
      isEnrolledInNewModmail: isSet91(object.isEnrolledInNewModmail) ? Boolean(object.isEnrolledInNewModmail) : void 0,
      keyColor: isSet91(object.keyColor) ? String(object.keyColor) : void 0,
      eventPostsEnabled: isSet91(object.eventPostsEnabled) ? Boolean(object.eventPostsEnabled) : void 0,
      canAssignUserFlair: isSet91(object.canAssignUserFlair) ? Boolean(object.canAssignUserFlair) : void 0,
      created: isSet91(object.created) ? Number(object.created) : void 0,
      wls: isSet91(object.wls) ? String(object.wls) : void 0,
      showMediaPreview: isSet91(object.showMediaPreview) ? Boolean(object.showMediaPreview) : void 0,
      submissionType: isSet91(object.submissionType) ? String(object.submissionType) : void 0,
      userIsSubscriber: isSet91(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : void 0,
      allowedMediaInComments: Array.isArray(object?.allowedMediaInComments) ? object.allowedMediaInComments.map((e) => String(e)) : [],
      allowVideogifs: isSet91(object.allowVideogifs) ? Boolean(object.allowVideogifs) : void 0,
      shouldArchivePosts: isSet91(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : void 0,
      userFlairType: isSet91(object.userFlairType) ? String(object.userFlairType) : void 0,
      allowPolls: isSet91(object.allowPolls) ? Boolean(object.allowPolls) : void 0,
      collapseDeletedComments: isSet91(object.collapseDeletedComments) ? Boolean(object.collapseDeletedComments) : void 0,
      coins: isSet91(object.coins) ? Number(object.coins) : void 0,
      emojisCustomSize: isSet91(object.emojisCustomSize) ? Number(object.emojisCustomSize) : void 0,
      publicDescriptionHtml: isSet91(object.publicDescriptionHtml) ? String(object.publicDescriptionHtml) : void 0,
      allowVideos: isSet91(object.allowVideos) ? Boolean(object.allowVideos) : void 0,
      isCrosspostableSubreddit: isSet91(object.isCrosspostableSubreddit) ? Boolean(object.isCrosspostableSubreddit) : void 0,
      notificationLevel: isSet91(object.notificationLevel) ? String(object.notificationLevel) : void 0,
      shouldShowMediaInCommentsSetting: isSet91(object.shouldShowMediaInCommentsSetting) ? Boolean(object.shouldShowMediaInCommentsSetting) : void 0,
      canAssignLinkFlair: isSet91(object.canAssignLinkFlair) ? Boolean(object.canAssignLinkFlair) : void 0,
      hasMenuWidget: isSet91(object.hasMenuWidget) ? Boolean(object.hasMenuWidget) : void 0,
      accountsActiveIsFuzzed: isSet91(object.accountsActiveIsFuzzed) ? Boolean(object.accountsActiveIsFuzzed) : void 0,
      allowPredictionContributors: isSet91(object.allowPredictionContributors) ? Boolean(object.allowPredictionContributors) : void 0,
      submitTextLabel: isSet91(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      linkFlairPosition: isSet91(object.linkFlairPosition) ? String(object.linkFlairPosition) : void 0,
      userSrFlairEnabled: isSet91(object.userSrFlairEnabled) ? Boolean(object.userSrFlairEnabled) : void 0,
      userFlairEnabledInSr: isSet91(object.userFlairEnabledInSr) ? Boolean(object.userFlairEnabledInSr) : void 0,
      allowChatPostCreation: isSet91(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : void 0,
      allowDiscovery: isSet91(object.allowDiscovery) ? Boolean(object.allowDiscovery) : void 0,
      acceptFollowers: isSet91(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      userSrThemeEnabled: isSet91(object.userSrThemeEnabled) ? Boolean(object.userSrThemeEnabled) : void 0,
      linkFlairEnabled: isSet91(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : void 0,
      disableContributorRequests: isSet91(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      subredditType: isSet91(object.subredditType) ? String(object.subredditType) : void 0,
      suggestedCommentSort: isSet91(object.suggestedCommentSort) ? String(object.suggestedCommentSort) : void 0,
      bannerImg: isSet91(object.bannerImg) ? String(object.bannerImg) : void 0,
      userFlairText: isSet91(object.userFlairText) ? String(object.userFlairText) : void 0,
      bannerBackgroundColor: isSet91(object.bannerBackgroundColor) ? String(object.bannerBackgroundColor) : void 0,
      showMedia: isSet91(object.showMedia) ? Boolean(object.showMedia) : void 0,
      id: isSet91(object.id) ? String(object.id) : void 0,
      userIsModerator: isSet91(object.userIsModerator) ? Boolean(object.userIsModerator) : void 0,
      over18: isSet91(object.over18) ? Boolean(object.over18) : void 0,
      headerTitle: isSet91(object.headerTitle) ? String(object.headerTitle) : void 0,
      description: isSet91(object.description) ? String(object.description) : void 0,
      isChatPostFeatureEnabled: isSet91(object.isChatPostFeatureEnabled) ? Boolean(object.isChatPostFeatureEnabled) : void 0,
      submitLinkLabel: isSet91(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      userFlairTextColor: isSet91(object.userFlairTextColor) ? String(object.userFlairTextColor) : void 0,
      restrictCommenting: isSet91(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      userFlairCssClass: isSet91(object.userFlairCssClass) ? String(object.userFlairCssClass) : void 0,
      allowImages: isSet91(object.allowImages) ? Boolean(object.allowImages) : void 0,
      lang: isSet91(object.lang) ? String(object.lang) : void 0,
      whitelistStatus: isSet91(object.whitelistStatus) ? Boolean(object.whitelistStatus) : void 0,
      url: isSet91(object.url) ? String(object.url) : void 0,
      createdUtc: isSet91(object.createdUtc) ? Number(object.createdUtc) : void 0,
      bannerSize: isSet91(object.bannerSize) ? Number(object.bannerSize) : void 0,
      mobileBannerImage: isSet91(object.mobileBannerImage) ? String(object.mobileBannerImage) : void 0,
      userIsContributor: isSet91(object.userIsContributor) ? Boolean(object.userIsContributor) : void 0,
      allowPredictionsTournament: isSet91(object.allowPredictionsTournament) ? Boolean(object.allowPredictionsTournament) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.userFlairBackgroundColor !== void 0 && (obj.userFlairBackgroundColor = message.userFlairBackgroundColor);
    message.submitTextHtml !== void 0 && (obj.submitTextHtml = message.submitTextHtml);
    message.restrictPosting !== void 0 && (obj.restrictPosting = message.restrictPosting);
    message.userIsBanned !== void 0 && (obj.userIsBanned = message.userIsBanned);
    message.freeFormReports !== void 0 && (obj.freeFormReports = message.freeFormReports);
    message.wikiEnabled !== void 0 && (obj.wikiEnabled = message.wikiEnabled);
    message.userIsMuted !== void 0 && (obj.userIsMuted = message.userIsMuted);
    message.userCanFlairInSr !== void 0 && (obj.userCanFlairInSr = message.userCanFlairInSr);
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    message.headerImg !== void 0 && (obj.headerImg = message.headerImg);
    message.title !== void 0 && (obj.title = message.title);
    message.allowGalleries !== void 0 && (obj.allowGalleries = message.allowGalleries);
    message.iconSize !== void 0 && (obj.iconSize = message.iconSize);
    message.primaryColor !== void 0 && (obj.primaryColor = message.primaryColor);
    message.activeUserCount !== void 0 && (obj.activeUserCount = message.activeUserCount);
    message.iconImg !== void 0 && (obj.iconImg = message.iconImg);
    message.displayNamePrefixed !== void 0 && (obj.displayNamePrefixed = message.displayNamePrefixed);
    message.accountsActive !== void 0 && (obj.accountsActive = message.accountsActive);
    message.publicTraffic !== void 0 && (obj.publicTraffic = message.publicTraffic);
    message.subscribers !== void 0 && (obj.subscribers = message.subscribers);
    if (message.userFlairRichtext) {
      obj.userFlairRichtext = message.userFlairRichtext.map((e) => e ? UserFlairRichtext.toJSON(e) : void 0);
    } else {
      obj.userFlairRichtext = [];
    }
    message.name !== void 0 && (obj.name = message.name);
    message.quarantine !== void 0 && (obj.quarantine = message.quarantine);
    message.hideAds !== void 0 && (obj.hideAds = message.hideAds);
    message.predictionLeaderboardEntryType !== void 0 && (obj.predictionLeaderboardEntryType = message.predictionLeaderboardEntryType);
    message.emojisEnabled !== void 0 && (obj.emojisEnabled = message.emojisEnabled);
    message.advertiserCategory !== void 0 && (obj.advertiserCategory = message.advertiserCategory);
    message.publicDescription !== void 0 && (obj.publicDescription = message.publicDescription);
    message.commentScoreHideMins !== void 0 && (obj.commentScoreHideMins = message.commentScoreHideMins);
    message.allowPredictions !== void 0 && (obj.allowPredictions = message.allowPredictions);
    message.userHasFavorited !== void 0 && (obj.userHasFavorited = message.userHasFavorited);
    message.userFlairTemplateId !== void 0 && (obj.userFlairTemplateId = message.userFlairTemplateId);
    message.communityIcon !== void 0 && (obj.communityIcon = message.communityIcon);
    message.bannerBackgroundImage !== void 0 && (obj.bannerBackgroundImage = message.bannerBackgroundImage);
    message.originalContentTagEnabled !== void 0 && (obj.originalContentTagEnabled = message.originalContentTagEnabled);
    message.communityReviewed !== void 0 && (obj.communityReviewed = message.communityReviewed);
    message.submitText !== void 0 && (obj.submitText = message.submitText);
    message.descriptionHtml !== void 0 && (obj.descriptionHtml = message.descriptionHtml);
    message.spoilersEnabled !== void 0 && (obj.spoilersEnabled = message.spoilersEnabled);
    message.commentContributionSettings !== void 0 && (obj.commentContributionSettings = message.commentContributionSettings ? CommentContributionSettings.toJSON(message.commentContributionSettings) : void 0);
    message.allowTalks !== void 0 && (obj.allowTalks = message.allowTalks);
    message.headerSize !== void 0 && (obj.headerSize = message.headerSize);
    message.userFlairPosition !== void 0 && (obj.userFlairPosition = message.userFlairPosition);
    message.allOriginalContent !== void 0 && (obj.allOriginalContent = message.allOriginalContent);
    message.collectionsEnabled !== void 0 && (obj.collectionsEnabled = message.collectionsEnabled);
    message.isEnrolledInNewModmail !== void 0 && (obj.isEnrolledInNewModmail = message.isEnrolledInNewModmail);
    message.keyColor !== void 0 && (obj.keyColor = message.keyColor);
    message.eventPostsEnabled !== void 0 && (obj.eventPostsEnabled = message.eventPostsEnabled);
    message.canAssignUserFlair !== void 0 && (obj.canAssignUserFlair = message.canAssignUserFlair);
    message.created !== void 0 && (obj.created = message.created);
    message.wls !== void 0 && (obj.wls = message.wls);
    message.showMediaPreview !== void 0 && (obj.showMediaPreview = message.showMediaPreview);
    message.submissionType !== void 0 && (obj.submissionType = message.submissionType);
    message.userIsSubscriber !== void 0 && (obj.userIsSubscriber = message.userIsSubscriber);
    if (message.allowedMediaInComments) {
      obj.allowedMediaInComments = message.allowedMediaInComments.map((e) => e);
    } else {
      obj.allowedMediaInComments = [];
    }
    message.allowVideogifs !== void 0 && (obj.allowVideogifs = message.allowVideogifs);
    message.shouldArchivePosts !== void 0 && (obj.shouldArchivePosts = message.shouldArchivePosts);
    message.userFlairType !== void 0 && (obj.userFlairType = message.userFlairType);
    message.allowPolls !== void 0 && (obj.allowPolls = message.allowPolls);
    message.collapseDeletedComments !== void 0 && (obj.collapseDeletedComments = message.collapseDeletedComments);
    message.coins !== void 0 && (obj.coins = message.coins);
    message.emojisCustomSize !== void 0 && (obj.emojisCustomSize = message.emojisCustomSize);
    message.publicDescriptionHtml !== void 0 && (obj.publicDescriptionHtml = message.publicDescriptionHtml);
    message.allowVideos !== void 0 && (obj.allowVideos = message.allowVideos);
    message.isCrosspostableSubreddit !== void 0 && (obj.isCrosspostableSubreddit = message.isCrosspostableSubreddit);
    message.notificationLevel !== void 0 && (obj.notificationLevel = message.notificationLevel);
    message.shouldShowMediaInCommentsSetting !== void 0 && (obj.shouldShowMediaInCommentsSetting = message.shouldShowMediaInCommentsSetting);
    message.canAssignLinkFlair !== void 0 && (obj.canAssignLinkFlair = message.canAssignLinkFlair);
    message.hasMenuWidget !== void 0 && (obj.hasMenuWidget = message.hasMenuWidget);
    message.accountsActiveIsFuzzed !== void 0 && (obj.accountsActiveIsFuzzed = message.accountsActiveIsFuzzed);
    message.allowPredictionContributors !== void 0 && (obj.allowPredictionContributors = message.allowPredictionContributors);
    message.submitTextLabel !== void 0 && (obj.submitTextLabel = message.submitTextLabel);
    message.linkFlairPosition !== void 0 && (obj.linkFlairPosition = message.linkFlairPosition);
    message.userSrFlairEnabled !== void 0 && (obj.userSrFlairEnabled = message.userSrFlairEnabled);
    message.userFlairEnabledInSr !== void 0 && (obj.userFlairEnabledInSr = message.userFlairEnabledInSr);
    message.allowChatPostCreation !== void 0 && (obj.allowChatPostCreation = message.allowChatPostCreation);
    message.allowDiscovery !== void 0 && (obj.allowDiscovery = message.allowDiscovery);
    message.acceptFollowers !== void 0 && (obj.acceptFollowers = message.acceptFollowers);
    message.userSrThemeEnabled !== void 0 && (obj.userSrThemeEnabled = message.userSrThemeEnabled);
    message.linkFlairEnabled !== void 0 && (obj.linkFlairEnabled = message.linkFlairEnabled);
    message.disableContributorRequests !== void 0 && (obj.disableContributorRequests = message.disableContributorRequests);
    message.subredditType !== void 0 && (obj.subredditType = message.subredditType);
    message.suggestedCommentSort !== void 0 && (obj.suggestedCommentSort = message.suggestedCommentSort);
    message.bannerImg !== void 0 && (obj.bannerImg = message.bannerImg);
    message.userFlairText !== void 0 && (obj.userFlairText = message.userFlairText);
    message.bannerBackgroundColor !== void 0 && (obj.bannerBackgroundColor = message.bannerBackgroundColor);
    message.showMedia !== void 0 && (obj.showMedia = message.showMedia);
    message.id !== void 0 && (obj.id = message.id);
    message.userIsModerator !== void 0 && (obj.userIsModerator = message.userIsModerator);
    message.over18 !== void 0 && (obj.over18 = message.over18);
    message.headerTitle !== void 0 && (obj.headerTitle = message.headerTitle);
    message.description !== void 0 && (obj.description = message.description);
    message.isChatPostFeatureEnabled !== void 0 && (obj.isChatPostFeatureEnabled = message.isChatPostFeatureEnabled);
    message.submitLinkLabel !== void 0 && (obj.submitLinkLabel = message.submitLinkLabel);
    message.userFlairTextColor !== void 0 && (obj.userFlairTextColor = message.userFlairTextColor);
    message.restrictCommenting !== void 0 && (obj.restrictCommenting = message.restrictCommenting);
    message.userFlairCssClass !== void 0 && (obj.userFlairCssClass = message.userFlairCssClass);
    message.allowImages !== void 0 && (obj.allowImages = message.allowImages);
    message.lang !== void 0 && (obj.lang = message.lang);
    message.whitelistStatus !== void 0 && (obj.whitelistStatus = message.whitelistStatus);
    message.url !== void 0 && (obj.url = message.url);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    message.bannerSize !== void 0 && (obj.bannerSize = message.bannerSize);
    message.mobileBannerImage !== void 0 && (obj.mobileBannerImage = message.mobileBannerImage);
    message.userIsContributor !== void 0 && (obj.userIsContributor = message.userIsContributor);
    message.allowPredictionsTournament !== void 0 && (obj.allowPredictionsTournament = message.allowPredictionsTournament);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutResponse_AboutData();
    message.userFlairBackgroundColor = object.userFlairBackgroundColor ?? void 0;
    message.submitTextHtml = object.submitTextHtml ?? void 0;
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.userIsBanned = object.userIsBanned ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.wikiEnabled = object.wikiEnabled ?? void 0;
    message.userIsMuted = object.userIsMuted ?? void 0;
    message.userCanFlairInSr = object.userCanFlairInSr ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.headerImg = object.headerImg ?? void 0;
    message.title = object.title ?? void 0;
    message.allowGalleries = object.allowGalleries ?? void 0;
    message.iconSize = object.iconSize ?? void 0;
    message.primaryColor = object.primaryColor ?? void 0;
    message.activeUserCount = object.activeUserCount ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.displayNamePrefixed = object.displayNamePrefixed ?? void 0;
    message.accountsActive = object.accountsActive ?? void 0;
    message.publicTraffic = object.publicTraffic ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.userFlairRichtext = object.userFlairRichtext?.map((e) => UserFlairRichtext.fromPartial(e)) || [];
    message.name = object.name ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.hideAds = object.hideAds ?? void 0;
    message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? void 0;
    message.emojisEnabled = object.emojisEnabled ?? void 0;
    message.advertiserCategory = object.advertiserCategory ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.commentScoreHideMins = object.commentScoreHideMins ?? void 0;
    message.allowPredictions = object.allowPredictions ?? void 0;
    message.userHasFavorited = object.userHasFavorited ?? void 0;
    message.userFlairTemplateId = object.userFlairTemplateId ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.bannerBackgroundImage = object.bannerBackgroundImage ?? void 0;
    message.originalContentTagEnabled = object.originalContentTagEnabled ?? void 0;
    message.communityReviewed = object.communityReviewed ?? void 0;
    message.submitText = object.submitText ?? void 0;
    message.descriptionHtml = object.descriptionHtml ?? void 0;
    message.spoilersEnabled = object.spoilersEnabled ?? void 0;
    message.commentContributionSettings = object.commentContributionSettings !== void 0 && object.commentContributionSettings !== null ? CommentContributionSettings.fromPartial(object.commentContributionSettings) : void 0;
    message.allowTalks = object.allowTalks ?? void 0;
    message.headerSize = object.headerSize ?? void 0;
    message.userFlairPosition = object.userFlairPosition ?? void 0;
    message.allOriginalContent = object.allOriginalContent ?? void 0;
    message.collectionsEnabled = object.collectionsEnabled ?? void 0;
    message.isEnrolledInNewModmail = object.isEnrolledInNewModmail ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.eventPostsEnabled = object.eventPostsEnabled ?? void 0;
    message.canAssignUserFlair = object.canAssignUserFlair ?? void 0;
    message.created = object.created ?? void 0;
    message.wls = object.wls ?? void 0;
    message.showMediaPreview = object.showMediaPreview ?? void 0;
    message.submissionType = object.submissionType ?? void 0;
    message.userIsSubscriber = object.userIsSubscriber ?? void 0;
    message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
    message.allowVideogifs = object.allowVideogifs ?? void 0;
    message.shouldArchivePosts = object.shouldArchivePosts ?? void 0;
    message.userFlairType = object.userFlairType ?? void 0;
    message.allowPolls = object.allowPolls ?? void 0;
    message.collapseDeletedComments = object.collapseDeletedComments ?? void 0;
    message.coins = object.coins ?? void 0;
    message.emojisCustomSize = object.emojisCustomSize ?? void 0;
    message.publicDescriptionHtml = object.publicDescriptionHtml ?? void 0;
    message.allowVideos = object.allowVideos ?? void 0;
    message.isCrosspostableSubreddit = object.isCrosspostableSubreddit ?? void 0;
    message.notificationLevel = object.notificationLevel ?? void 0;
    message.shouldShowMediaInCommentsSetting = object.shouldShowMediaInCommentsSetting ?? void 0;
    message.canAssignLinkFlair = object.canAssignLinkFlair ?? void 0;
    message.hasMenuWidget = object.hasMenuWidget ?? void 0;
    message.accountsActiveIsFuzzed = object.accountsActiveIsFuzzed ?? void 0;
    message.allowPredictionContributors = object.allowPredictionContributors ?? void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.linkFlairPosition = object.linkFlairPosition ?? void 0;
    message.userSrFlairEnabled = object.userSrFlairEnabled ?? void 0;
    message.userFlairEnabledInSr = object.userFlairEnabledInSr ?? void 0;
    message.allowChatPostCreation = object.allowChatPostCreation ?? void 0;
    message.allowDiscovery = object.allowDiscovery ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.userSrThemeEnabled = object.userSrThemeEnabled ?? void 0;
    message.linkFlairEnabled = object.linkFlairEnabled ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.suggestedCommentSort = object.suggestedCommentSort ?? void 0;
    message.bannerImg = object.bannerImg ?? void 0;
    message.userFlairText = object.userFlairText ?? void 0;
    message.bannerBackgroundColor = object.bannerBackgroundColor ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.id = object.id ?? void 0;
    message.userIsModerator = object.userIsModerator ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.headerTitle = object.headerTitle ?? void 0;
    message.description = object.description ?? void 0;
    message.isChatPostFeatureEnabled = object.isChatPostFeatureEnabled ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.userFlairTextColor = object.userFlairTextColor ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.userFlairCssClass = object.userFlairCssClass ?? void 0;
    message.allowImages = object.allowImages ?? void 0;
    message.lang = object.lang ?? void 0;
    message.whitelistStatus = object.whitelistStatus ?? void 0;
    message.url = object.url ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.bannerSize = object.bannerSize ?? void 0;
    message.mobileBannerImage = object.mobileBannerImage ?? void 0;
    message.userIsContributor = object.userIsContributor ?? void 0;
    message.allowPredictionsTournament = object.allowPredictionsTournament ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutResponse.AboutData", SubredditAboutResponse_AboutData);
function createBaseSubredditAboutEditResponse() {
  return { kind: void 0, data: void 0 };
}
var SubredditAboutEditResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      SubredditAboutEditResponse_SubredditSettings.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutEditResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = SubredditAboutEditResponse_SubredditSettings.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet91(object.kind) ? String(object.kind) : void 0,
      data: isSet91(object.data) ? SubredditAboutEditResponse_SubredditSettings.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? SubredditAboutEditResponse_SubredditSettings.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutEditResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? SubredditAboutEditResponse_SubredditSettings.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse", SubredditAboutEditResponse);
function createBaseSubredditAboutEditResponse_SubredditSettings() {
  return {
    defaultSet: void 0,
    toxicityThresholdChatLevel: void 0,
    crowdControlChatLevel: void 0,
    restrictPosting: void 0,
    publicDescription: void 0,
    subredditId: void 0,
    allowImages: void 0,
    freeFormReports: void 0,
    domain: void 0,
    originalContentTagEnabled: void 0,
    showMedia: void 0,
    excludeBannedModqueue: void 0,
    shouldArchivePosts: void 0,
    submitText: void 0,
    spamLinks: void 0,
    title: void 0,
    collapseDeletedComments: void 0,
    wikimode: void 0,
    over18: void 0,
    allowVideos: void 0,
    allowGalleries: void 0,
    crowdControlLevel: void 0,
    banEvasionThreshold: void 0,
    crowdControlMode: void 0,
    welcomeMessageEnabled: void 0,
    welcomeMessageText: void 0,
    suggestedCommentSort: void 0,
    disableContributorRequests: void 0,
    allowTalks: void 0,
    description: void 0,
    submitLinkLabel: void 0,
    spoilersEnabled: void 0,
    allowPostCrossposts: void 0,
    spamComments: void 0,
    publicTraffic: void 0,
    restrictCommenting: void 0,
    allowPolls: void 0,
    commentContributionSettings: void 0,
    submitTextLabel: void 0,
    commentScoreHideMins: void 0,
    allOriginalContent: void 0,
    spamSelfposts: void 0,
    keyColor: void 0,
    language: void 0,
    newPinnedPostPnsEnabled: void 0,
    hideAds: void 0,
    predictionLeaderboardEntryType: void 0,
    headerHoverText: void 0,
    wikiEditAge: void 0,
    allowChatPostCreation: void 0,
    allowPredictionContributors: void 0,
    allowDiscovery: void 0,
    acceptFollowers: void 0,
    crowdControlPostLevel: void 0,
    allowPredictionsTournament: void 0,
    wikiEditKarma: void 0,
    showMediaPreview: void 0,
    crowdControlFilter: void 0,
    subredditType: void 0,
    allowPredictions: void 0,
    userFlairPnsEnabled: void 0,
    contentOptions: void 0
  };
}
var SubredditAboutEditResponse_SubredditSettings = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse.SubredditSettings",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.defaultSet !== void 0) {
      BoolValue.encode({ value: message.defaultSet }, writer.uint32(10).fork()).ldelim();
    }
    if (message.toxicityThresholdChatLevel !== void 0) {
      Int32Value.encode({ value: message.toxicityThresholdChatLevel }, writer.uint32(18).fork()).ldelim();
    }
    if (message.crowdControlChatLevel !== void 0) {
      Int32Value.encode({ value: message.crowdControlChatLevel }, writer.uint32(26).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(34).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(42).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(50).fork()).ldelim();
    }
    if (message.allowImages !== void 0) {
      BoolValue.encode({ value: message.allowImages }, writer.uint32(58).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(66).fork()).ldelim();
    }
    if (message.domain !== void 0) {
      StringValue.encode({ value: message.domain }, writer.uint32(74).fork()).ldelim();
    }
    if (message.originalContentTagEnabled !== void 0) {
      BoolValue.encode({ value: message.originalContentTagEnabled }, writer.uint32(82).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(90).fork()).ldelim();
    }
    if (message.excludeBannedModqueue !== void 0) {
      BoolValue.encode({ value: message.excludeBannedModqueue }, writer.uint32(98).fork()).ldelim();
    }
    if (message.shouldArchivePosts !== void 0) {
      BoolValue.encode({ value: message.shouldArchivePosts }, writer.uint32(106).fork()).ldelim();
    }
    if (message.submitText !== void 0) {
      StringValue.encode({ value: message.submitText }, writer.uint32(114).fork()).ldelim();
    }
    if (message.spamLinks !== void 0) {
      StringValue.encode({ value: message.spamLinks }, writer.uint32(122).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(130).fork()).ldelim();
    }
    if (message.collapseDeletedComments !== void 0) {
      BoolValue.encode({ value: message.collapseDeletedComments }, writer.uint32(138).fork()).ldelim();
    }
    if (message.wikimode !== void 0) {
      StringValue.encode({ value: message.wikimode }, writer.uint32(146).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(154).fork()).ldelim();
    }
    if (message.allowVideos !== void 0) {
      BoolValue.encode({ value: message.allowVideos }, writer.uint32(162).fork()).ldelim();
    }
    if (message.allowGalleries !== void 0) {
      BoolValue.encode({ value: message.allowGalleries }, writer.uint32(170).fork()).ldelim();
    }
    if (message.crowdControlLevel !== void 0) {
      Int32Value.encode({ value: message.crowdControlLevel }, writer.uint32(178).fork()).ldelim();
    }
    if (message.banEvasionThreshold !== void 0) {
      Int32Value.encode({ value: message.banEvasionThreshold }, writer.uint32(186).fork()).ldelim();
    }
    if (message.crowdControlMode !== void 0) {
      BoolValue.encode({ value: message.crowdControlMode }, writer.uint32(194).fork()).ldelim();
    }
    if (message.welcomeMessageEnabled !== void 0) {
      BoolValue.encode({ value: message.welcomeMessageEnabled }, writer.uint32(202).fork()).ldelim();
    }
    if (message.welcomeMessageText !== void 0) {
      StringValue.encode({ value: message.welcomeMessageText }, writer.uint32(210).fork()).ldelim();
    }
    if (message.suggestedCommentSort !== void 0) {
      BoolValue.encode({ value: message.suggestedCommentSort }, writer.uint32(218).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(226).fork()).ldelim();
    }
    if (message.allowTalks !== void 0) {
      BoolValue.encode({ value: message.allowTalks }, writer.uint32(234).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(242).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(250).fork()).ldelim();
    }
    if (message.spoilersEnabled !== void 0) {
      BoolValue.encode({ value: message.spoilersEnabled }, writer.uint32(258).fork()).ldelim();
    }
    if (message.allowPostCrossposts !== void 0) {
      BoolValue.encode({ value: message.allowPostCrossposts }, writer.uint32(266).fork()).ldelim();
    }
    if (message.spamComments !== void 0) {
      StringValue.encode({ value: message.spamComments }, writer.uint32(274).fork()).ldelim();
    }
    if (message.publicTraffic !== void 0) {
      BoolValue.encode({ value: message.publicTraffic }, writer.uint32(282).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(290).fork()).ldelim();
    }
    if (message.allowPolls !== void 0) {
      BoolValue.encode({ value: message.allowPolls }, writer.uint32(298).fork()).ldelim();
    }
    if (message.commentContributionSettings !== void 0) {
      CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(306).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(314).fork()).ldelim();
    }
    if (message.commentScoreHideMins !== void 0) {
      Int32Value.encode({ value: message.commentScoreHideMins }, writer.uint32(322).fork()).ldelim();
    }
    if (message.allOriginalContent !== void 0) {
      BoolValue.encode({ value: message.allOriginalContent }, writer.uint32(330).fork()).ldelim();
    }
    if (message.spamSelfposts !== void 0) {
      StringValue.encode({ value: message.spamSelfposts }, writer.uint32(338).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(346).fork()).ldelim();
    }
    if (message.language !== void 0) {
      StringValue.encode({ value: message.language }, writer.uint32(354).fork()).ldelim();
    }
    if (message.newPinnedPostPnsEnabled !== void 0) {
      BoolValue.encode({ value: message.newPinnedPostPnsEnabled }, writer.uint32(362).fork()).ldelim();
    }
    if (message.hideAds !== void 0) {
      BoolValue.encode({ value: message.hideAds }, writer.uint32(370).fork()).ldelim();
    }
    if (message.predictionLeaderboardEntryType !== void 0) {
      Int32Value.encode({ value: message.predictionLeaderboardEntryType }, writer.uint32(378).fork()).ldelim();
    }
    if (message.headerHoverText !== void 0) {
      StringValue.encode({ value: message.headerHoverText }, writer.uint32(386).fork()).ldelim();
    }
    if (message.wikiEditAge !== void 0) {
      Int32Value.encode({ value: message.wikiEditAge }, writer.uint32(394).fork()).ldelim();
    }
    if (message.allowChatPostCreation !== void 0) {
      BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(402).fork()).ldelim();
    }
    if (message.allowPredictionContributors !== void 0) {
      BoolValue.encode({ value: message.allowPredictionContributors }, writer.uint32(410).fork()).ldelim();
    }
    if (message.allowDiscovery !== void 0) {
      BoolValue.encode({ value: message.allowDiscovery }, writer.uint32(418).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(426).fork()).ldelim();
    }
    if (message.crowdControlPostLevel !== void 0) {
      Int32Value.encode({ value: message.crowdControlPostLevel }, writer.uint32(434).fork()).ldelim();
    }
    if (message.allowPredictionsTournament !== void 0) {
      BoolValue.encode({ value: message.allowPredictionsTournament }, writer.uint32(442).fork()).ldelim();
    }
    if (message.wikiEditKarma !== void 0) {
      Int32Value.encode({ value: message.wikiEditKarma }, writer.uint32(450).fork()).ldelim();
    }
    if (message.showMediaPreview !== void 0) {
      BoolValue.encode({ value: message.showMediaPreview }, writer.uint32(458).fork()).ldelim();
    }
    if (message.crowdControlFilter !== void 0) {
      BoolValue.encode({ value: message.crowdControlFilter }, writer.uint32(466).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(474).fork()).ldelim();
    }
    if (message.allowPredictions !== void 0) {
      BoolValue.encode({ value: message.allowPredictions }, writer.uint32(482).fork()).ldelim();
    }
    if (message.userFlairPnsEnabled !== void 0) {
      BoolValue.encode({ value: message.userFlairPnsEnabled }, writer.uint32(490).fork()).ldelim();
    }
    if (message.contentOptions !== void 0) {
      StringValue.encode({ value: message.contentOptions }, writer.uint32(498).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutEditResponse_SubredditSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.toxicityThresholdChatLevel = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.crowdControlChatLevel = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.domain = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.originalContentTagEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.excludeBannedModqueue = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.shouldArchivePosts = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.submitText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.spamLinks = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.collapseDeletedComments = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.wikimode = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.allowVideos = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.allowGalleries = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.crowdControlLevel = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.banEvasionThreshold = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.crowdControlMode = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.welcomeMessageEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.welcomeMessageText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 27:
          message.suggestedCommentSort = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.allowTalks = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.spoilersEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.allowPostCrossposts = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.spamComments = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 35:
          message.publicTraffic = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 37:
          message.allowPolls = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 38:
          message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
          break;
        case 39:
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 40:
          message.commentScoreHideMins = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 41:
          message.allOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 42:
          message.spamSelfposts = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 43:
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 44:
          message.language = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 45:
          message.newPinnedPostPnsEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 46:
          message.hideAds = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 47:
          message.predictionLeaderboardEntryType = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 48:
          message.headerHoverText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 49:
          message.wikiEditAge = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 50:
          message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 51:
          message.allowPredictionContributors = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 52:
          message.allowDiscovery = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 53:
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 54:
          message.crowdControlPostLevel = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 55:
          message.allowPredictionsTournament = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 56:
          message.wikiEditKarma = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 57:
          message.showMediaPreview = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 58:
          message.crowdControlFilter = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 59:
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 60:
          message.allowPredictions = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 61:
          message.userFlairPnsEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 62:
          message.contentOptions = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      defaultSet: isSet91(object.defaultSet) ? Boolean(object.defaultSet) : void 0,
      toxicityThresholdChatLevel: isSet91(object.toxicityThresholdChatLevel) ? Number(object.toxicityThresholdChatLevel) : void 0,
      crowdControlChatLevel: isSet91(object.crowdControlChatLevel) ? Number(object.crowdControlChatLevel) : void 0,
      restrictPosting: isSet91(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      publicDescription: isSet91(object.publicDescription) ? String(object.publicDescription) : void 0,
      subredditId: isSet91(object.subredditId) ? String(object.subredditId) : void 0,
      allowImages: isSet91(object.allowImages) ? Boolean(object.allowImages) : void 0,
      freeFormReports: isSet91(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      domain: isSet91(object.domain) ? String(object.domain) : void 0,
      originalContentTagEnabled: isSet91(object.originalContentTagEnabled) ? Boolean(object.originalContentTagEnabled) : void 0,
      showMedia: isSet91(object.showMedia) ? Boolean(object.showMedia) : void 0,
      excludeBannedModqueue: isSet91(object.excludeBannedModqueue) ? Boolean(object.excludeBannedModqueue) : void 0,
      shouldArchivePosts: isSet91(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : void 0,
      submitText: isSet91(object.submitText) ? String(object.submitText) : void 0,
      spamLinks: isSet91(object.spamLinks) ? String(object.spamLinks) : void 0,
      title: isSet91(object.title) ? String(object.title) : void 0,
      collapseDeletedComments: isSet91(object.collapseDeletedComments) ? Boolean(object.collapseDeletedComments) : void 0,
      wikimode: isSet91(object.wikimode) ? String(object.wikimode) : void 0,
      over18: isSet91(object.over18) ? Boolean(object.over18) : void 0,
      allowVideos: isSet91(object.allowVideos) ? Boolean(object.allowVideos) : void 0,
      allowGalleries: isSet91(object.allowGalleries) ? Boolean(object.allowGalleries) : void 0,
      crowdControlLevel: isSet91(object.crowdControlLevel) ? Number(object.crowdControlLevel) : void 0,
      banEvasionThreshold: isSet91(object.banEvasionThreshold) ? Number(object.banEvasionThreshold) : void 0,
      crowdControlMode: isSet91(object.crowdControlMode) ? Boolean(object.crowdControlMode) : void 0,
      welcomeMessageEnabled: isSet91(object.welcomeMessageEnabled) ? Boolean(object.welcomeMessageEnabled) : void 0,
      welcomeMessageText: isSet91(object.welcomeMessageText) ? String(object.welcomeMessageText) : void 0,
      suggestedCommentSort: isSet91(object.suggestedCommentSort) ? Boolean(object.suggestedCommentSort) : void 0,
      disableContributorRequests: isSet91(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      allowTalks: isSet91(object.allowTalks) ? Boolean(object.allowTalks) : void 0,
      description: isSet91(object.description) ? String(object.description) : void 0,
      submitLinkLabel: isSet91(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      spoilersEnabled: isSet91(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : void 0,
      allowPostCrossposts: isSet91(object.allowPostCrossposts) ? Boolean(object.allowPostCrossposts) : void 0,
      spamComments: isSet91(object.spamComments) ? String(object.spamComments) : void 0,
      publicTraffic: isSet91(object.publicTraffic) ? Boolean(object.publicTraffic) : void 0,
      restrictCommenting: isSet91(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      allowPolls: isSet91(object.allowPolls) ? Boolean(object.allowPolls) : void 0,
      commentContributionSettings: isSet91(object.commentContributionSettings) ? CommentContributionSettings.fromJSON(object.commentContributionSettings) : void 0,
      submitTextLabel: isSet91(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      commentScoreHideMins: isSet91(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : void 0,
      allOriginalContent: isSet91(object.allOriginalContent) ? Boolean(object.allOriginalContent) : void 0,
      spamSelfposts: isSet91(object.spamSelfposts) ? String(object.spamSelfposts) : void 0,
      keyColor: isSet91(object.keyColor) ? String(object.keyColor) : void 0,
      language: isSet91(object.language) ? String(object.language) : void 0,
      newPinnedPostPnsEnabled: isSet91(object.newPinnedPostPnsEnabled) ? Boolean(object.newPinnedPostPnsEnabled) : void 0,
      hideAds: isSet91(object.hideAds) ? Boolean(object.hideAds) : void 0,
      predictionLeaderboardEntryType: isSet91(object.predictionLeaderboardEntryType) ? Number(object.predictionLeaderboardEntryType) : void 0,
      headerHoverText: isSet91(object.headerHoverText) ? String(object.headerHoverText) : void 0,
      wikiEditAge: isSet91(object.wikiEditAge) ? Number(object.wikiEditAge) : void 0,
      allowChatPostCreation: isSet91(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : void 0,
      allowPredictionContributors: isSet91(object.allowPredictionContributors) ? Boolean(object.allowPredictionContributors) : void 0,
      allowDiscovery: isSet91(object.allowDiscovery) ? Boolean(object.allowDiscovery) : void 0,
      acceptFollowers: isSet91(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      crowdControlPostLevel: isSet91(object.crowdControlPostLevel) ? Number(object.crowdControlPostLevel) : void 0,
      allowPredictionsTournament: isSet91(object.allowPredictionsTournament) ? Boolean(object.allowPredictionsTournament) : void 0,
      wikiEditKarma: isSet91(object.wikiEditKarma) ? Number(object.wikiEditKarma) : void 0,
      showMediaPreview: isSet91(object.showMediaPreview) ? Boolean(object.showMediaPreview) : void 0,
      crowdControlFilter: isSet91(object.crowdControlFilter) ? Boolean(object.crowdControlFilter) : void 0,
      subredditType: isSet91(object.subredditType) ? String(object.subredditType) : void 0,
      allowPredictions: isSet91(object.allowPredictions) ? Boolean(object.allowPredictions) : void 0,
      userFlairPnsEnabled: isSet91(object.userFlairPnsEnabled) ? Boolean(object.userFlairPnsEnabled) : void 0,
      contentOptions: isSet91(object.contentOptions) ? String(object.contentOptions) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.defaultSet !== void 0 && (obj.defaultSet = message.defaultSet);
    message.toxicityThresholdChatLevel !== void 0 && (obj.toxicityThresholdChatLevel = message.toxicityThresholdChatLevel);
    message.crowdControlChatLevel !== void 0 && (obj.crowdControlChatLevel = message.crowdControlChatLevel);
    message.restrictPosting !== void 0 && (obj.restrictPosting = message.restrictPosting);
    message.publicDescription !== void 0 && (obj.publicDescription = message.publicDescription);
    message.subredditId !== void 0 && (obj.subredditId = message.subredditId);
    message.allowImages !== void 0 && (obj.allowImages = message.allowImages);
    message.freeFormReports !== void 0 && (obj.freeFormReports = message.freeFormReports);
    message.domain !== void 0 && (obj.domain = message.domain);
    message.originalContentTagEnabled !== void 0 && (obj.originalContentTagEnabled = message.originalContentTagEnabled);
    message.showMedia !== void 0 && (obj.showMedia = message.showMedia);
    message.excludeBannedModqueue !== void 0 && (obj.excludeBannedModqueue = message.excludeBannedModqueue);
    message.shouldArchivePosts !== void 0 && (obj.shouldArchivePosts = message.shouldArchivePosts);
    message.submitText !== void 0 && (obj.submitText = message.submitText);
    message.spamLinks !== void 0 && (obj.spamLinks = message.spamLinks);
    message.title !== void 0 && (obj.title = message.title);
    message.collapseDeletedComments !== void 0 && (obj.collapseDeletedComments = message.collapseDeletedComments);
    message.wikimode !== void 0 && (obj.wikimode = message.wikimode);
    message.over18 !== void 0 && (obj.over18 = message.over18);
    message.allowVideos !== void 0 && (obj.allowVideos = message.allowVideos);
    message.allowGalleries !== void 0 && (obj.allowGalleries = message.allowGalleries);
    message.crowdControlLevel !== void 0 && (obj.crowdControlLevel = message.crowdControlLevel);
    message.banEvasionThreshold !== void 0 && (obj.banEvasionThreshold = message.banEvasionThreshold);
    message.crowdControlMode !== void 0 && (obj.crowdControlMode = message.crowdControlMode);
    message.welcomeMessageEnabled !== void 0 && (obj.welcomeMessageEnabled = message.welcomeMessageEnabled);
    message.welcomeMessageText !== void 0 && (obj.welcomeMessageText = message.welcomeMessageText);
    message.suggestedCommentSort !== void 0 && (obj.suggestedCommentSort = message.suggestedCommentSort);
    message.disableContributorRequests !== void 0 && (obj.disableContributorRequests = message.disableContributorRequests);
    message.allowTalks !== void 0 && (obj.allowTalks = message.allowTalks);
    message.description !== void 0 && (obj.description = message.description);
    message.submitLinkLabel !== void 0 && (obj.submitLinkLabel = message.submitLinkLabel);
    message.spoilersEnabled !== void 0 && (obj.spoilersEnabled = message.spoilersEnabled);
    message.allowPostCrossposts !== void 0 && (obj.allowPostCrossposts = message.allowPostCrossposts);
    message.spamComments !== void 0 && (obj.spamComments = message.spamComments);
    message.publicTraffic !== void 0 && (obj.publicTraffic = message.publicTraffic);
    message.restrictCommenting !== void 0 && (obj.restrictCommenting = message.restrictCommenting);
    message.allowPolls !== void 0 && (obj.allowPolls = message.allowPolls);
    message.commentContributionSettings !== void 0 && (obj.commentContributionSettings = message.commentContributionSettings ? CommentContributionSettings.toJSON(message.commentContributionSettings) : void 0);
    message.submitTextLabel !== void 0 && (obj.submitTextLabel = message.submitTextLabel);
    message.commentScoreHideMins !== void 0 && (obj.commentScoreHideMins = message.commentScoreHideMins);
    message.allOriginalContent !== void 0 && (obj.allOriginalContent = message.allOriginalContent);
    message.spamSelfposts !== void 0 && (obj.spamSelfposts = message.spamSelfposts);
    message.keyColor !== void 0 && (obj.keyColor = message.keyColor);
    message.language !== void 0 && (obj.language = message.language);
    message.newPinnedPostPnsEnabled !== void 0 && (obj.newPinnedPostPnsEnabled = message.newPinnedPostPnsEnabled);
    message.hideAds !== void 0 && (obj.hideAds = message.hideAds);
    message.predictionLeaderboardEntryType !== void 0 && (obj.predictionLeaderboardEntryType = message.predictionLeaderboardEntryType);
    message.headerHoverText !== void 0 && (obj.headerHoverText = message.headerHoverText);
    message.wikiEditAge !== void 0 && (obj.wikiEditAge = message.wikiEditAge);
    message.allowChatPostCreation !== void 0 && (obj.allowChatPostCreation = message.allowChatPostCreation);
    message.allowPredictionContributors !== void 0 && (obj.allowPredictionContributors = message.allowPredictionContributors);
    message.allowDiscovery !== void 0 && (obj.allowDiscovery = message.allowDiscovery);
    message.acceptFollowers !== void 0 && (obj.acceptFollowers = message.acceptFollowers);
    message.crowdControlPostLevel !== void 0 && (obj.crowdControlPostLevel = message.crowdControlPostLevel);
    message.allowPredictionsTournament !== void 0 && (obj.allowPredictionsTournament = message.allowPredictionsTournament);
    message.wikiEditKarma !== void 0 && (obj.wikiEditKarma = message.wikiEditKarma);
    message.showMediaPreview !== void 0 && (obj.showMediaPreview = message.showMediaPreview);
    message.crowdControlFilter !== void 0 && (obj.crowdControlFilter = message.crowdControlFilter);
    message.subredditType !== void 0 && (obj.subredditType = message.subredditType);
    message.allowPredictions !== void 0 && (obj.allowPredictions = message.allowPredictions);
    message.userFlairPnsEnabled !== void 0 && (obj.userFlairPnsEnabled = message.userFlairPnsEnabled);
    message.contentOptions !== void 0 && (obj.contentOptions = message.contentOptions);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutEditResponse_SubredditSettings();
    message.defaultSet = object.defaultSet ?? void 0;
    message.toxicityThresholdChatLevel = object.toxicityThresholdChatLevel ?? void 0;
    message.crowdControlChatLevel = object.crowdControlChatLevel ?? void 0;
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.allowImages = object.allowImages ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.domain = object.domain ?? void 0;
    message.originalContentTagEnabled = object.originalContentTagEnabled ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.excludeBannedModqueue = object.excludeBannedModqueue ?? void 0;
    message.shouldArchivePosts = object.shouldArchivePosts ?? void 0;
    message.submitText = object.submitText ?? void 0;
    message.spamLinks = object.spamLinks ?? void 0;
    message.title = object.title ?? void 0;
    message.collapseDeletedComments = object.collapseDeletedComments ?? void 0;
    message.wikimode = object.wikimode ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.allowVideos = object.allowVideos ?? void 0;
    message.allowGalleries = object.allowGalleries ?? void 0;
    message.crowdControlLevel = object.crowdControlLevel ?? void 0;
    message.banEvasionThreshold = object.banEvasionThreshold ?? void 0;
    message.crowdControlMode = object.crowdControlMode ?? void 0;
    message.welcomeMessageEnabled = object.welcomeMessageEnabled ?? void 0;
    message.welcomeMessageText = object.welcomeMessageText ?? void 0;
    message.suggestedCommentSort = object.suggestedCommentSort ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.allowTalks = object.allowTalks ?? void 0;
    message.description = object.description ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.spoilersEnabled = object.spoilersEnabled ?? void 0;
    message.allowPostCrossposts = object.allowPostCrossposts ?? void 0;
    message.spamComments = object.spamComments ?? void 0;
    message.publicTraffic = object.publicTraffic ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.allowPolls = object.allowPolls ?? void 0;
    message.commentContributionSettings = object.commentContributionSettings !== void 0 && object.commentContributionSettings !== null ? CommentContributionSettings.fromPartial(object.commentContributionSettings) : void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.commentScoreHideMins = object.commentScoreHideMins ?? void 0;
    message.allOriginalContent = object.allOriginalContent ?? void 0;
    message.spamSelfposts = object.spamSelfposts ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.language = object.language ?? void 0;
    message.newPinnedPostPnsEnabled = object.newPinnedPostPnsEnabled ?? void 0;
    message.hideAds = object.hideAds ?? void 0;
    message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? void 0;
    message.headerHoverText = object.headerHoverText ?? void 0;
    message.wikiEditAge = object.wikiEditAge ?? void 0;
    message.allowChatPostCreation = object.allowChatPostCreation ?? void 0;
    message.allowPredictionContributors = object.allowPredictionContributors ?? void 0;
    message.allowDiscovery = object.allowDiscovery ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.crowdControlPostLevel = object.crowdControlPostLevel ?? void 0;
    message.allowPredictionsTournament = object.allowPredictionsTournament ?? void 0;
    message.wikiEditKarma = object.wikiEditKarma ?? void 0;
    message.showMediaPreview = object.showMediaPreview ?? void 0;
    message.crowdControlFilter = object.crowdControlFilter ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.allowPredictions = object.allowPredictions ?? void 0;
    message.userFlairPnsEnabled = object.userFlairPnsEnabled ?? void 0;
    message.contentOptions = object.contentOptions ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutEditResponse.SubredditSettings", SubredditAboutEditResponse_SubredditSettings);
function createBaseSubredditAboutRulesResponse() {
  return { rules: [], siteRules: [], siteRulesFlow: [] };
}
var SubredditAboutRulesResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    for (const v of message.rules) {
      SubredditAboutRulesResponse_SubredditRule.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.siteRules) {
      StringValue.encode({ value: v }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.siteRulesFlow) {
      SubredditAboutRulesResponse_RuleFlow.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutRulesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rules.push(SubredditAboutRulesResponse_SubredditRule.decode(reader, reader.uint32()));
          break;
        case 2:
          message.siteRules.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 3:
          message.siteRulesFlow.push(SubredditAboutRulesResponse_RuleFlow.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      rules: Array.isArray(object?.rules) ? object.rules.map((e) => SubredditAboutRulesResponse_SubredditRule.fromJSON(e)) : [],
      siteRules: Array.isArray(object?.siteRules) ? object.siteRules.map((e) => String(e)) : [],
      siteRulesFlow: Array.isArray(object?.siteRulesFlow) ? object.siteRulesFlow.map((e) => SubredditAboutRulesResponse_RuleFlow.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.rules) {
      obj.rules = message.rules.map((e) => e ? SubredditAboutRulesResponse_SubredditRule.toJSON(e) : void 0);
    } else {
      obj.rules = [];
    }
    if (message.siteRules) {
      obj.siteRules = message.siteRules.map((e) => e);
    } else {
      obj.siteRules = [];
    }
    if (message.siteRulesFlow) {
      obj.siteRulesFlow = message.siteRulesFlow.map((e) => e ? SubredditAboutRulesResponse_RuleFlow.toJSON(e) : void 0);
    } else {
      obj.siteRulesFlow = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutRulesResponse();
    message.rules = object.rules?.map((e) => SubredditAboutRulesResponse_SubredditRule.fromPartial(e)) || [];
    message.siteRules = object.siteRules?.map((e) => e) || [];
    message.siteRulesFlow = object.siteRulesFlow?.map((e) => SubredditAboutRulesResponse_RuleFlow.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse", SubredditAboutRulesResponse);
function createBaseSubredditAboutRulesResponse_SubredditRule() {
  return {
    kind: void 0,
    description: void 0,
    shortName: void 0,
    violationReason: void 0,
    createdUtc: void 0,
    priority: void 0,
    descriptionHtml: void 0
  };
}
var SubredditAboutRulesResponse_SubredditRule = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse.SubredditRule",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(18).fork()).ldelim();
    }
    if (message.shortName !== void 0) {
      StringValue.encode({ value: message.shortName }, writer.uint32(26).fork()).ldelim();
    }
    if (message.violationReason !== void 0) {
      StringValue.encode({ value: message.violationReason }, writer.uint32(34).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(42).fork()).ldelim();
    }
    if (message.priority !== void 0) {
      Int32Value.encode({ value: message.priority }, writer.uint32(50).fork()).ldelim();
    }
    if (message.descriptionHtml !== void 0) {
      StringValue.encode({ value: message.descriptionHtml }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutRulesResponse_SubredditRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.shortName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.violationReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.priority = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.descriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet91(object.kind) ? String(object.kind) : void 0,
      description: isSet91(object.description) ? String(object.description) : void 0,
      shortName: isSet91(object.shortName) ? String(object.shortName) : void 0,
      violationReason: isSet91(object.violationReason) ? String(object.violationReason) : void 0,
      createdUtc: isSet91(object.createdUtc) ? Number(object.createdUtc) : void 0,
      priority: isSet91(object.priority) ? Number(object.priority) : void 0,
      descriptionHtml: isSet91(object.descriptionHtml) ? String(object.descriptionHtml) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.description !== void 0 && (obj.description = message.description);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.violationReason !== void 0 && (obj.violationReason = message.violationReason);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    message.priority !== void 0 && (obj.priority = message.priority);
    message.descriptionHtml !== void 0 && (obj.descriptionHtml = message.descriptionHtml);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutRulesResponse_SubredditRule();
    message.kind = object.kind ?? void 0;
    message.description = object.description ?? void 0;
    message.shortName = object.shortName ?? void 0;
    message.violationReason = object.violationReason ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.priority = object.priority ?? void 0;
    message.descriptionHtml = object.descriptionHtml ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse.SubredditRule", SubredditAboutRulesResponse_SubredditRule);
function createBaseSubredditAboutRulesResponse_RuleFlow() {
  return {
    reasonTextToShow: void 0,
    reasonText: void 0,
    nextStepHeader: void 0,
    nextStepReasons: [],
    complaintButtonText: void 0,
    complaintUrl: void 0,
    complaintPageTitle: void 0,
    fileComplaint: void 0,
    complaintPrompt: void 0,
    canWriteNotes: void 0,
    isAbuseOfReportButton: void 0,
    notesInputTitle: void 0,
    usernamesInputTitle: void 0,
    canSpecifyUsernames: void 0,
    requestCrisisSupport: void 0,
    oneUsername: void 0
  };
}
var SubredditAboutRulesResponse_RuleFlow = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse.RuleFlow",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.reasonTextToShow !== void 0) {
      StringValue.encode({ value: message.reasonTextToShow }, writer.uint32(10).fork()).ldelim();
    }
    if (message.reasonText !== void 0) {
      StringValue.encode({ value: message.reasonText }, writer.uint32(18).fork()).ldelim();
    }
    if (message.nextStepHeader !== void 0) {
      StringValue.encode({ value: message.nextStepHeader }, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.nextStepReasons) {
      SubredditAboutRulesResponse_RuleFlow.encode(v, writer.uint32(34).fork()).ldelim();
    }
    if (message.complaintButtonText !== void 0) {
      StringValue.encode({ value: message.complaintButtonText }, writer.uint32(42).fork()).ldelim();
    }
    if (message.complaintUrl !== void 0) {
      StringValue.encode({ value: message.complaintUrl }, writer.uint32(50).fork()).ldelim();
    }
    if (message.complaintPageTitle !== void 0) {
      StringValue.encode({ value: message.complaintPageTitle }, writer.uint32(58).fork()).ldelim();
    }
    if (message.fileComplaint !== void 0) {
      BoolValue.encode({ value: message.fileComplaint }, writer.uint32(66).fork()).ldelim();
    }
    if (message.complaintPrompt !== void 0) {
      StringValue.encode({ value: message.complaintPrompt }, writer.uint32(74).fork()).ldelim();
    }
    if (message.canWriteNotes !== void 0) {
      BoolValue.encode({ value: message.canWriteNotes }, writer.uint32(82).fork()).ldelim();
    }
    if (message.isAbuseOfReportButton !== void 0) {
      BoolValue.encode({ value: message.isAbuseOfReportButton }, writer.uint32(90).fork()).ldelim();
    }
    if (message.notesInputTitle !== void 0) {
      StringValue.encode({ value: message.notesInputTitle }, writer.uint32(98).fork()).ldelim();
    }
    if (message.usernamesInputTitle !== void 0) {
      StringValue.encode({ value: message.usernamesInputTitle }, writer.uint32(106).fork()).ldelim();
    }
    if (message.canSpecifyUsernames !== void 0) {
      BoolValue.encode({ value: message.canSpecifyUsernames }, writer.uint32(114).fork()).ldelim();
    }
    if (message.requestCrisisSupport !== void 0) {
      BoolValue.encode({ value: message.requestCrisisSupport }, writer.uint32(122).fork()).ldelim();
    }
    if (message.oneUsername !== void 0) {
      BoolValue.encode({ value: message.oneUsername }, writer.uint32(130).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutRulesResponse_RuleFlow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.reasonTextToShow = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.reasonText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.nextStepHeader = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.nextStepReasons.push(SubredditAboutRulesResponse_RuleFlow.decode(reader, reader.uint32()));
          break;
        case 5:
          message.complaintButtonText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.complaintUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.complaintPageTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.fileComplaint = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.complaintPrompt = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.canWriteNotes = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.isAbuseOfReportButton = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.notesInputTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.usernamesInputTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.canSpecifyUsernames = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.requestCrisisSupport = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.oneUsername = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      reasonTextToShow: isSet91(object.reasonTextToShow) ? String(object.reasonTextToShow) : void 0,
      reasonText: isSet91(object.reasonText) ? String(object.reasonText) : void 0,
      nextStepHeader: isSet91(object.nextStepHeader) ? String(object.nextStepHeader) : void 0,
      nextStepReasons: Array.isArray(object?.nextStepReasons) ? object.nextStepReasons.map((e) => SubredditAboutRulesResponse_RuleFlow.fromJSON(e)) : [],
      complaintButtonText: isSet91(object.complaintButtonText) ? String(object.complaintButtonText) : void 0,
      complaintUrl: isSet91(object.complaintUrl) ? String(object.complaintUrl) : void 0,
      complaintPageTitle: isSet91(object.complaintPageTitle) ? String(object.complaintPageTitle) : void 0,
      fileComplaint: isSet91(object.fileComplaint) ? Boolean(object.fileComplaint) : void 0,
      complaintPrompt: isSet91(object.complaintPrompt) ? String(object.complaintPrompt) : void 0,
      canWriteNotes: isSet91(object.canWriteNotes) ? Boolean(object.canWriteNotes) : void 0,
      isAbuseOfReportButton: isSet91(object.isAbuseOfReportButton) ? Boolean(object.isAbuseOfReportButton) : void 0,
      notesInputTitle: isSet91(object.notesInputTitle) ? String(object.notesInputTitle) : void 0,
      usernamesInputTitle: isSet91(object.usernamesInputTitle) ? String(object.usernamesInputTitle) : void 0,
      canSpecifyUsernames: isSet91(object.canSpecifyUsernames) ? Boolean(object.canSpecifyUsernames) : void 0,
      requestCrisisSupport: isSet91(object.requestCrisisSupport) ? Boolean(object.requestCrisisSupport) : void 0,
      oneUsername: isSet91(object.oneUsername) ? Boolean(object.oneUsername) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.reasonTextToShow !== void 0 && (obj.reasonTextToShow = message.reasonTextToShow);
    message.reasonText !== void 0 && (obj.reasonText = message.reasonText);
    message.nextStepHeader !== void 0 && (obj.nextStepHeader = message.nextStepHeader);
    if (message.nextStepReasons) {
      obj.nextStepReasons = message.nextStepReasons.map((e) => e ? SubredditAboutRulesResponse_RuleFlow.toJSON(e) : void 0);
    } else {
      obj.nextStepReasons = [];
    }
    message.complaintButtonText !== void 0 && (obj.complaintButtonText = message.complaintButtonText);
    message.complaintUrl !== void 0 && (obj.complaintUrl = message.complaintUrl);
    message.complaintPageTitle !== void 0 && (obj.complaintPageTitle = message.complaintPageTitle);
    message.fileComplaint !== void 0 && (obj.fileComplaint = message.fileComplaint);
    message.complaintPrompt !== void 0 && (obj.complaintPrompt = message.complaintPrompt);
    message.canWriteNotes !== void 0 && (obj.canWriteNotes = message.canWriteNotes);
    message.isAbuseOfReportButton !== void 0 && (obj.isAbuseOfReportButton = message.isAbuseOfReportButton);
    message.notesInputTitle !== void 0 && (obj.notesInputTitle = message.notesInputTitle);
    message.usernamesInputTitle !== void 0 && (obj.usernamesInputTitle = message.usernamesInputTitle);
    message.canSpecifyUsernames !== void 0 && (obj.canSpecifyUsernames = message.canSpecifyUsernames);
    message.requestCrisisSupport !== void 0 && (obj.requestCrisisSupport = message.requestCrisisSupport);
    message.oneUsername !== void 0 && (obj.oneUsername = message.oneUsername);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutRulesResponse_RuleFlow();
    message.reasonTextToShow = object.reasonTextToShow ?? void 0;
    message.reasonText = object.reasonText ?? void 0;
    message.nextStepHeader = object.nextStepHeader ?? void 0;
    message.nextStepReasons = object.nextStepReasons?.map((e) => SubredditAboutRulesResponse_RuleFlow.fromPartial(e)) || [];
    message.complaintButtonText = object.complaintButtonText ?? void 0;
    message.complaintUrl = object.complaintUrl ?? void 0;
    message.complaintPageTitle = object.complaintPageTitle ?? void 0;
    message.fileComplaint = object.fileComplaint ?? void 0;
    message.complaintPrompt = object.complaintPrompt ?? void 0;
    message.canWriteNotes = object.canWriteNotes ?? void 0;
    message.isAbuseOfReportButton = object.isAbuseOfReportButton ?? void 0;
    message.notesInputTitle = object.notesInputTitle ?? void 0;
    message.usernamesInputTitle = object.usernamesInputTitle ?? void 0;
    message.canSpecifyUsernames = object.canSpecifyUsernames ?? void 0;
    message.requestCrisisSupport = object.requestCrisisSupport ?? void 0;
    message.oneUsername = object.oneUsername ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutRulesResponse.RuleFlow", SubredditAboutRulesResponse_RuleFlow);
function createBaseSubredditAboutTrafficResponse() {
  return { day: [], hour: [], month: [] };
}
var SubredditAboutTrafficResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    for (const v of message.day) {
      SubredditAboutTrafficResponse_Data.encode(v, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.hour) {
      SubredditAboutTrafficResponse_Data.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.month) {
      SubredditAboutTrafficResponse_Data.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutTrafficResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.day.push(SubredditAboutTrafficResponse_Data.decode(reader, reader.uint32()));
          break;
        case 2:
          message.hour.push(SubredditAboutTrafficResponse_Data.decode(reader, reader.uint32()));
          break;
        case 3:
          message.month.push(SubredditAboutTrafficResponse_Data.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      day: Array.isArray(object?.day) ? object.day.map((e) => SubredditAboutTrafficResponse_Data.fromJSON(e)) : [],
      hour: Array.isArray(object?.hour) ? object.hour.map((e) => SubredditAboutTrafficResponse_Data.fromJSON(e)) : [],
      month: Array.isArray(object?.month) ? object.month.map((e) => SubredditAboutTrafficResponse_Data.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.day) {
      obj.day = message.day.map((e) => e ? SubredditAboutTrafficResponse_Data.toJSON(e) : void 0);
    } else {
      obj.day = [];
    }
    if (message.hour) {
      obj.hour = message.hour.map((e) => e ? SubredditAboutTrafficResponse_Data.toJSON(e) : void 0);
    } else {
      obj.hour = [];
    }
    if (message.month) {
      obj.month = message.month.map((e) => e ? SubredditAboutTrafficResponse_Data.toJSON(e) : void 0);
    } else {
      obj.month = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutTrafficResponse();
    message.day = object.day?.map((e) => SubredditAboutTrafficResponse_Data.fromPartial(e)) || [];
    message.hour = object.hour?.map((e) => SubredditAboutTrafficResponse_Data.fromPartial(e)) || [];
    message.month = object.month?.map((e) => SubredditAboutTrafficResponse_Data.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse", SubredditAboutTrafficResponse);
function createBaseSubredditAboutTrafficResponse_Data() {
  return { values: [] };
}
var SubredditAboutTrafficResponse_Data = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse.Data",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    for (const v of message.values) {
      Int64Value.encode({ value: v }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditAboutTrafficResponse_Data();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.values.push(Int64Value.decode(reader, reader.uint32()).value);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { values: Array.isArray(object?.values) ? object.values.map((e) => Number(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.values) {
      obj.values = message.values.map((e) => e);
    } else {
      obj.values = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditAboutTrafficResponse_Data();
    message.values = object.values?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditAboutTrafficResponse.Data", SubredditAboutTrafficResponse_Data);
function createBaseStickyResponse() {
  return { kind: void 0, data: void 0 };
}
var StickyResponse = {
  $type: "devvit.plugin.redditapi.subreddits.StickyResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      StickyResponse_StickyResponseData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStickyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = StickyResponse_StickyResponseData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet91(object.kind) ? String(object.kind) : void 0,
      data: isSet91(object.data) ? StickyResponse_StickyResponseData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? StickyResponse_StickyResponseData.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStickyResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? StickyResponse_StickyResponseData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.StickyResponse", StickyResponse);
function createBaseStickyResponse_LinkData() {
  return {
    authorFlairBackgroundColor: void 0,
    approvedAtUtc: void 0,
    subreddit: void 0,
    selftext: void 0,
    userReports: [],
    saved: void 0,
    modReasonTitle: void 0,
    gilded: void 0,
    clicked: void 0,
    title: void 0,
    linkFlairRichtext: [],
    subredditNamePrefixed: void 0,
    hidden: void 0,
    pwls: void 0,
    linkFlairCssClass: void 0,
    downs: void 0,
    thumbnailHeight: void 0,
    topAwardedType: void 0,
    parentWhitelistStatus: void 0,
    hideScore: void 0,
    name: void 0,
    quarantine: void 0,
    linkFlairTextColor: void 0,
    upvoteRatio: void 0,
    ignoreReports: void 0,
    ups: void 0,
    domain: void 0,
    mediaEmbed: void 0,
    thumbnailWidth: void 0,
    authorFlairTemplateId: void 0,
    isOriginalContent: void 0,
    authorFullname: void 0,
    secureMedia: void 0,
    isRedditMediaDomain: void 0,
    isMeta: void 0,
    category: void 0,
    secureMediaEmbed: void 0,
    linkFlairText: void 0,
    canModPost: void 0,
    score: void 0,
    approvedBy: void 0,
    isCreatedFromAdsUi: void 0,
    authorPremium: void 0,
    thumbnail: void 0,
    edited: void 0,
    authorFlairCssClass: void 0,
    previousVisits: [],
    authorFlairRichtext: [],
    gildings: void 0,
    contentCategories: void 0,
    isSelf: void 0,
    subredditType: void 0,
    created: void 0,
    linkFlairType: void 0,
    wls: void 0,
    removedByCategory: void 0,
    bannedBy: void 0,
    authorFlairType: void 0,
    totalAwardsReceived: void 0,
    allowLiveComments: void 0,
    selftextHtml: void 0,
    likes: void 0,
    suggestedSort: void 0,
    bannedAtUtc: void 0,
    viewCount: void 0,
    archived: void 0,
    noFollow: void 0,
    spam: void 0,
    isCrosspostable: void 0,
    pinned: void 0,
    over18: void 0,
    allAwardings: [],
    awarders: [],
    mediaOnly: void 0,
    canGild: void 0,
    removed: void 0,
    spoiler: void 0,
    locked: void 0,
    authorFlairText: void 0,
    treatmentTags: [],
    rteMode: void 0,
    visited: void 0,
    removedBy: void 0,
    modNote: void 0,
    distinguished: void 0,
    subredditId: void 0,
    authorIsBlocked: void 0,
    modReasonBy: void 0,
    numReports: void 0,
    removalReason: void 0,
    linkFlairBackgroundColor: void 0,
    id: void 0,
    isRobotIndexable: void 0,
    numDuplicates: void 0,
    reportReasons: [],
    author: void 0,
    discussionType: void 0,
    numComments: void 0,
    sendReplies: void 0,
    media: void 0,
    contestMode: void 0,
    authorPatreonFlair: void 0,
    approved: void 0,
    authorFlairTextColor: void 0,
    permalink: void 0,
    whitelistStatus: void 0,
    stickied: void 0,
    url: void 0,
    subredditSubscribers: void 0,
    createdUtc: void 0,
    numCrossposts: void 0,
    modReports: [],
    isVideo: void 0
  };
}
var StickyResponse_LinkData = {
  $type: "devvit.plugin.redditapi.subreddits.StickyResponse.LinkData",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.authorFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.authorFlairBackgroundColor }, writer.uint32(10).fork()).ldelim();
    }
    if (message.approvedAtUtc !== void 0) {
      Int32Value.encode({ value: message.approvedAtUtc }, writer.uint32(18).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(26).fork()).ldelim();
    }
    if (message.selftext !== void 0) {
      StringValue.encode({ value: message.selftext }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.userReports) {
      StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
    }
    if (message.saved !== void 0) {
      BoolValue.encode({ value: message.saved }, writer.uint32(50).fork()).ldelim();
    }
    if (message.modReasonTitle !== void 0) {
      StringValue.encode({ value: message.modReasonTitle }, writer.uint32(58).fork()).ldelim();
    }
    if (message.gilded !== void 0) {
      Int64Value.encode({ value: message.gilded }, writer.uint32(66).fork()).ldelim();
    }
    if (message.clicked !== void 0) {
      BoolValue.encode({ value: message.clicked }, writer.uint32(74).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.linkFlairRichtext) {
      StringValue.encode({ value: v }, writer.uint32(90).fork()).ldelim();
    }
    if (message.subredditNamePrefixed !== void 0) {
      StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(98).fork()).ldelim();
    }
    if (message.hidden !== void 0) {
      BoolValue.encode({ value: message.hidden }, writer.uint32(106).fork()).ldelim();
    }
    if (message.pwls !== void 0) {
      StringValue.encode({ value: message.pwls }, writer.uint32(114).fork()).ldelim();
    }
    if (message.linkFlairCssClass !== void 0) {
      StringValue.encode({ value: message.linkFlairCssClass }, writer.uint32(122).fork()).ldelim();
    }
    if (message.downs !== void 0) {
      Int64Value.encode({ value: message.downs }, writer.uint32(130).fork()).ldelim();
    }
    if (message.thumbnailHeight !== void 0) {
      Int32Value.encode({ value: message.thumbnailHeight }, writer.uint32(138).fork()).ldelim();
    }
    if (message.topAwardedType !== void 0) {
      StringValue.encode({ value: message.topAwardedType }, writer.uint32(146).fork()).ldelim();
    }
    if (message.parentWhitelistStatus !== void 0) {
      BoolValue.encode({ value: message.parentWhitelistStatus }, writer.uint32(154).fork()).ldelim();
    }
    if (message.hideScore !== void 0) {
      BoolValue.encode({ value: message.hideScore }, writer.uint32(162).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(170).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(178).fork()).ldelim();
    }
    if (message.linkFlairTextColor !== void 0) {
      StringValue.encode({ value: message.linkFlairTextColor }, writer.uint32(186).fork()).ldelim();
    }
    if (message.upvoteRatio !== void 0) {
      Int64Value.encode({ value: message.upvoteRatio }, writer.uint32(194).fork()).ldelim();
    }
    if (message.ignoreReports !== void 0) {
      BoolValue.encode({ value: message.ignoreReports }, writer.uint32(202).fork()).ldelim();
    }
    if (message.ups !== void 0) {
      Int64Value.encode({ value: message.ups }, writer.uint32(210).fork()).ldelim();
    }
    if (message.domain !== void 0) {
      StringValue.encode({ value: message.domain }, writer.uint32(218).fork()).ldelim();
    }
    if (message.mediaEmbed !== void 0) {
      MediaEmbed.encode(message.mediaEmbed, writer.uint32(226).fork()).ldelim();
    }
    if (message.thumbnailWidth !== void 0) {
      Int32Value.encode({ value: message.thumbnailWidth }, writer.uint32(234).fork()).ldelim();
    }
    if (message.authorFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.authorFlairTemplateId }, writer.uint32(242).fork()).ldelim();
    }
    if (message.isOriginalContent !== void 0) {
      BoolValue.encode({ value: message.isOriginalContent }, writer.uint32(250).fork()).ldelim();
    }
    if (message.authorFullname !== void 0) {
      StringValue.encode({ value: message.authorFullname }, writer.uint32(258).fork()).ldelim();
    }
    if (message.secureMedia !== void 0) {
      BoolValue.encode({ value: message.secureMedia }, writer.uint32(266).fork()).ldelim();
    }
    if (message.isRedditMediaDomain !== void 0) {
      BoolValue.encode({ value: message.isRedditMediaDomain }, writer.uint32(274).fork()).ldelim();
    }
    if (message.isMeta !== void 0) {
      BoolValue.encode({ value: message.isMeta }, writer.uint32(282).fork()).ldelim();
    }
    if (message.category !== void 0) {
      StringValue.encode({ value: message.category }, writer.uint32(290).fork()).ldelim();
    }
    if (message.secureMediaEmbed !== void 0) {
      MediaEmbed.encode(message.secureMediaEmbed, writer.uint32(298).fork()).ldelim();
    }
    if (message.linkFlairText !== void 0) {
      StringValue.encode({ value: message.linkFlairText }, writer.uint32(306).fork()).ldelim();
    }
    if (message.canModPost !== void 0) {
      BoolValue.encode({ value: message.canModPost }, writer.uint32(314).fork()).ldelim();
    }
    if (message.score !== void 0) {
      Int64Value.encode({ value: message.score }, writer.uint32(322).fork()).ldelim();
    }
    if (message.approvedBy !== void 0) {
      StringValue.encode({ value: message.approvedBy }, writer.uint32(330).fork()).ldelim();
    }
    if (message.isCreatedFromAdsUi !== void 0) {
      BoolValue.encode({ value: message.isCreatedFromAdsUi }, writer.uint32(338).fork()).ldelim();
    }
    if (message.authorPremium !== void 0) {
      BoolValue.encode({ value: message.authorPremium }, writer.uint32(346).fork()).ldelim();
    }
    if (message.thumbnail !== void 0) {
      StringValue.encode({ value: message.thumbnail }, writer.uint32(354).fork()).ldelim();
    }
    if (message.edited !== void 0) {
      BoolValue.encode({ value: message.edited }, writer.uint32(362).fork()).ldelim();
    }
    if (message.authorFlairCssClass !== void 0) {
      StringValue.encode({ value: message.authorFlairCssClass }, writer.uint32(370).fork()).ldelim();
    }
    for (const v of message.previousVisits) {
      Int64Value.encode({ value: v }, writer.uint32(378).fork()).ldelim();
    }
    for (const v of message.authorFlairRichtext) {
      StringValue.encode({ value: v }, writer.uint32(386).fork()).ldelim();
    }
    if (message.gildings !== void 0) {
      Any.encode(message.gildings, writer.uint32(394).fork()).ldelim();
    }
    if (message.contentCategories !== void 0) {
      StringValue.encode({ value: message.contentCategories }, writer.uint32(402).fork()).ldelim();
    }
    if (message.isSelf !== void 0) {
      BoolValue.encode({ value: message.isSelf }, writer.uint32(410).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(418).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int64Value.encode({ value: message.created }, writer.uint32(426).fork()).ldelim();
    }
    if (message.linkFlairType !== void 0) {
      StringValue.encode({ value: message.linkFlairType }, writer.uint32(434).fork()).ldelim();
    }
    if (message.wls !== void 0) {
      StringValue.encode({ value: message.wls }, writer.uint32(442).fork()).ldelim();
    }
    if (message.removedByCategory !== void 0) {
      StringValue.encode({ value: message.removedByCategory }, writer.uint32(450).fork()).ldelim();
    }
    if (message.bannedBy !== void 0) {
      StringValue.encode({ value: message.bannedBy }, writer.uint32(458).fork()).ldelim();
    }
    if (message.authorFlairType !== void 0) {
      StringValue.encode({ value: message.authorFlairType }, writer.uint32(466).fork()).ldelim();
    }
    if (message.totalAwardsReceived !== void 0) {
      Int64Value.encode({ value: message.totalAwardsReceived }, writer.uint32(474).fork()).ldelim();
    }
    if (message.allowLiveComments !== void 0) {
      BoolValue.encode({ value: message.allowLiveComments }, writer.uint32(482).fork()).ldelim();
    }
    if (message.selftextHtml !== void 0) {
      StringValue.encode({ value: message.selftextHtml }, writer.uint32(490).fork()).ldelim();
    }
    if (message.likes !== void 0) {
      BoolValue.encode({ value: message.likes }, writer.uint32(498).fork()).ldelim();
    }
    if (message.suggestedSort !== void 0) {
      StringValue.encode({ value: message.suggestedSort }, writer.uint32(506).fork()).ldelim();
    }
    if (message.bannedAtUtc !== void 0) {
      Int32Value.encode({ value: message.bannedAtUtc }, writer.uint32(514).fork()).ldelim();
    }
    if (message.viewCount !== void 0) {
      Int32Value.encode({ value: message.viewCount }, writer.uint32(522).fork()).ldelim();
    }
    if (message.archived !== void 0) {
      BoolValue.encode({ value: message.archived }, writer.uint32(530).fork()).ldelim();
    }
    if (message.noFollow !== void 0) {
      BoolValue.encode({ value: message.noFollow }, writer.uint32(538).fork()).ldelim();
    }
    if (message.spam !== void 0) {
      BoolValue.encode({ value: message.spam }, writer.uint32(546).fork()).ldelim();
    }
    if (message.isCrosspostable !== void 0) {
      BoolValue.encode({ value: message.isCrosspostable }, writer.uint32(554).fork()).ldelim();
    }
    if (message.pinned !== void 0) {
      BoolValue.encode({ value: message.pinned }, writer.uint32(562).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(570).fork()).ldelim();
    }
    for (const v of message.allAwardings) {
      Any.encode(v, writer.uint32(578).fork()).ldelim();
    }
    for (const v of message.awarders) {
      StringValue.encode({ value: v }, writer.uint32(586).fork()).ldelim();
    }
    if (message.mediaOnly !== void 0) {
      BoolValue.encode({ value: message.mediaOnly }, writer.uint32(594).fork()).ldelim();
    }
    if (message.canGild !== void 0) {
      BoolValue.encode({ value: message.canGild }, writer.uint32(602).fork()).ldelim();
    }
    if (message.removed !== void 0) {
      BoolValue.encode({ value: message.removed }, writer.uint32(610).fork()).ldelim();
    }
    if (message.spoiler !== void 0) {
      BoolValue.encode({ value: message.spoiler }, writer.uint32(618).fork()).ldelim();
    }
    if (message.locked !== void 0) {
      BoolValue.encode({ value: message.locked }, writer.uint32(626).fork()).ldelim();
    }
    if (message.authorFlairText !== void 0) {
      StringValue.encode({ value: message.authorFlairText }, writer.uint32(634).fork()).ldelim();
    }
    for (const v of message.treatmentTags) {
      Any.encode(v, writer.uint32(642).fork()).ldelim();
    }
    if (message.rteMode !== void 0) {
      StringValue.encode({ value: message.rteMode }, writer.uint32(650).fork()).ldelim();
    }
    if (message.visited !== void 0) {
      BoolValue.encode({ value: message.visited }, writer.uint32(658).fork()).ldelim();
    }
    if (message.removedBy !== void 0) {
      StringValue.encode({ value: message.removedBy }, writer.uint32(666).fork()).ldelim();
    }
    if (message.modNote !== void 0) {
      StringValue.encode({ value: message.modNote }, writer.uint32(674).fork()).ldelim();
    }
    if (message.distinguished !== void 0) {
      StringValue.encode({ value: message.distinguished }, writer.uint32(682).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(690).fork()).ldelim();
    }
    if (message.authorIsBlocked !== void 0) {
      BoolValue.encode({ value: message.authorIsBlocked }, writer.uint32(698).fork()).ldelim();
    }
    if (message.modReasonBy !== void 0) {
      StringValue.encode({ value: message.modReasonBy }, writer.uint32(706).fork()).ldelim();
    }
    if (message.numReports !== void 0) {
      Int64Value.encode({ value: message.numReports }, writer.uint32(714).fork()).ldelim();
    }
    if (message.removalReason !== void 0) {
      StringValue.encode({ value: message.removalReason }, writer.uint32(722).fork()).ldelim();
    }
    if (message.linkFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.linkFlairBackgroundColor }, writer.uint32(730).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(738).fork()).ldelim();
    }
    if (message.isRobotIndexable !== void 0) {
      BoolValue.encode({ value: message.isRobotIndexable }, writer.uint32(746).fork()).ldelim();
    }
    if (message.numDuplicates !== void 0) {
      Int32Value.encode({ value: message.numDuplicates }, writer.uint32(754).fork()).ldelim();
    }
    for (const v of message.reportReasons) {
      Any.encode(v, writer.uint32(762).fork()).ldelim();
    }
    if (message.author !== void 0) {
      StringValue.encode({ value: message.author }, writer.uint32(770).fork()).ldelim();
    }
    if (message.discussionType !== void 0) {
      StringValue.encode({ value: message.discussionType }, writer.uint32(778).fork()).ldelim();
    }
    if (message.numComments !== void 0) {
      Int64Value.encode({ value: message.numComments }, writer.uint32(786).fork()).ldelim();
    }
    if (message.sendReplies !== void 0) {
      BoolValue.encode({ value: message.sendReplies }, writer.uint32(794).fork()).ldelim();
    }
    if (message.media !== void 0) {
      StringValue.encode({ value: message.media }, writer.uint32(802).fork()).ldelim();
    }
    if (message.contestMode !== void 0) {
      BoolValue.encode({ value: message.contestMode }, writer.uint32(810).fork()).ldelim();
    }
    if (message.authorPatreonFlair !== void 0) {
      BoolValue.encode({ value: message.authorPatreonFlair }, writer.uint32(818).fork()).ldelim();
    }
    if (message.approved !== void 0) {
      BoolValue.encode({ value: message.approved }, writer.uint32(826).fork()).ldelim();
    }
    if (message.authorFlairTextColor !== void 0) {
      StringValue.encode({ value: message.authorFlairTextColor }, writer.uint32(834).fork()).ldelim();
    }
    if (message.permalink !== void 0) {
      StringValue.encode({ value: message.permalink }, writer.uint32(842).fork()).ldelim();
    }
    if (message.whitelistStatus !== void 0) {
      BoolValue.encode({ value: message.whitelistStatus }, writer.uint32(850).fork()).ldelim();
    }
    if (message.stickied !== void 0) {
      BoolValue.encode({ value: message.stickied }, writer.uint32(858).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(866).fork()).ldelim();
    }
    if (message.subredditSubscribers !== void 0) {
      Int64Value.encode({ value: message.subredditSubscribers }, writer.uint32(874).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(882).fork()).ldelim();
    }
    if (message.numCrossposts !== void 0) {
      Int64Value.encode({ value: message.numCrossposts }, writer.uint32(890).fork()).ldelim();
    }
    for (const v of message.modReports) {
      Any.encode(v, writer.uint32(898).fork()).ldelim();
    }
    if (message.isVideo !== void 0) {
      BoolValue.encode({ value: message.isVideo }, writer.uint32(906).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStickyResponse_LinkData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authorFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.approvedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.selftext = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.userReports.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 6:
          message.saved = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.modReasonTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.gilded = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.clicked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.linkFlairRichtext.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 12:
          message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.hidden = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.pwls = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.linkFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.downs = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.thumbnailHeight = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.topAwardedType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.parentWhitelistStatus = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.hideScore = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.linkFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.upvoteRatio = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.ignoreReports = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.ups = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 27:
          message.domain = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.mediaEmbed = MediaEmbed.decode(reader, reader.uint32());
          break;
        case 29:
          message.thumbnailWidth = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.authorFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.isOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.authorFullname = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.secureMedia = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.isRedditMediaDomain = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 35:
          message.isMeta = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.category = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 37:
          message.secureMediaEmbed = MediaEmbed.decode(reader, reader.uint32());
          break;
        case 38:
          message.linkFlairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 39:
          message.canModPost = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 40:
          message.score = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 41:
          message.approvedBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 42:
          message.isCreatedFromAdsUi = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 43:
          message.authorPremium = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 44:
          message.thumbnail = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 45:
          message.edited = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 46:
          message.authorFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 47:
          message.previousVisits.push(Int64Value.decode(reader, reader.uint32()).value);
          break;
        case 48:
          message.authorFlairRichtext.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 49:
          message.gildings = Any.decode(reader, reader.uint32());
          break;
        case 50:
          message.contentCategories = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 51:
          message.isSelf = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 52:
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 53:
          message.created = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 54:
          message.linkFlairType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 55:
          message.wls = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 56:
          message.removedByCategory = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 57:
          message.bannedBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 58:
          message.authorFlairType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 59:
          message.totalAwardsReceived = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 60:
          message.allowLiveComments = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 61:
          message.selftextHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 62:
          message.likes = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 63:
          message.suggestedSort = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 64:
          message.bannedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 65:
          message.viewCount = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 66:
          message.archived = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 67:
          message.noFollow = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 68:
          message.spam = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 69:
          message.isCrosspostable = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 70:
          message.pinned = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 71:
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 72:
          message.allAwardings.push(Any.decode(reader, reader.uint32()));
          break;
        case 73:
          message.awarders.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 74:
          message.mediaOnly = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 75:
          message.canGild = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 76:
          message.removed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 77:
          message.spoiler = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 78:
          message.locked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 79:
          message.authorFlairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 80:
          message.treatmentTags.push(Any.decode(reader, reader.uint32()));
          break;
        case 81:
          message.rteMode = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 82:
          message.visited = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 83:
          message.removedBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 84:
          message.modNote = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 85:
          message.distinguished = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 86:
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 87:
          message.authorIsBlocked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 88:
          message.modReasonBy = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 89:
          message.numReports = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 90:
          message.removalReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 91:
          message.linkFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 92:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 93:
          message.isRobotIndexable = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 94:
          message.numDuplicates = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 95:
          message.reportReasons.push(Any.decode(reader, reader.uint32()));
          break;
        case 96:
          message.author = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 97:
          message.discussionType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 98:
          message.numComments = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 99:
          message.sendReplies = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 100:
          message.media = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 101:
          message.contestMode = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 102:
          message.authorPatreonFlair = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 103:
          message.approved = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 104:
          message.authorFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 105:
          message.permalink = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 106:
          message.whitelistStatus = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 107:
          message.stickied = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 108:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 109:
          message.subredditSubscribers = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 110:
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 111:
          message.numCrossposts = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 112:
          message.modReports.push(Any.decode(reader, reader.uint32()));
          break;
        case 113:
          message.isVideo = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      authorFlairBackgroundColor: isSet91(object.authorFlairBackgroundColor) ? String(object.authorFlairBackgroundColor) : void 0,
      approvedAtUtc: isSet91(object.approvedAtUtc) ? Number(object.approvedAtUtc) : void 0,
      subreddit: isSet91(object.subreddit) ? String(object.subreddit) : void 0,
      selftext: isSet91(object.selftext) ? String(object.selftext) : void 0,
      userReports: Array.isArray(object?.userReports) ? object.userReports.map((e) => String(e)) : [],
      saved: isSet91(object.saved) ? Boolean(object.saved) : void 0,
      modReasonTitle: isSet91(object.modReasonTitle) ? String(object.modReasonTitle) : void 0,
      gilded: isSet91(object.gilded) ? Number(object.gilded) : void 0,
      clicked: isSet91(object.clicked) ? Boolean(object.clicked) : void 0,
      title: isSet91(object.title) ? String(object.title) : void 0,
      linkFlairRichtext: Array.isArray(object?.linkFlairRichtext) ? object.linkFlairRichtext.map((e) => String(e)) : [],
      subredditNamePrefixed: isSet91(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : void 0,
      hidden: isSet91(object.hidden) ? Boolean(object.hidden) : void 0,
      pwls: isSet91(object.pwls) ? String(object.pwls) : void 0,
      linkFlairCssClass: isSet91(object.linkFlairCssClass) ? String(object.linkFlairCssClass) : void 0,
      downs: isSet91(object.downs) ? Number(object.downs) : void 0,
      thumbnailHeight: isSet91(object.thumbnailHeight) ? Number(object.thumbnailHeight) : void 0,
      topAwardedType: isSet91(object.topAwardedType) ? String(object.topAwardedType) : void 0,
      parentWhitelistStatus: isSet91(object.parentWhitelistStatus) ? Boolean(object.parentWhitelistStatus) : void 0,
      hideScore: isSet91(object.hideScore) ? Boolean(object.hideScore) : void 0,
      name: isSet91(object.name) ? String(object.name) : void 0,
      quarantine: isSet91(object.quarantine) ? Boolean(object.quarantine) : void 0,
      linkFlairTextColor: isSet91(object.linkFlairTextColor) ? String(object.linkFlairTextColor) : void 0,
      upvoteRatio: isSet91(object.upvoteRatio) ? Number(object.upvoteRatio) : void 0,
      ignoreReports: isSet91(object.ignoreReports) ? Boolean(object.ignoreReports) : void 0,
      ups: isSet91(object.ups) ? Number(object.ups) : void 0,
      domain: isSet91(object.domain) ? String(object.domain) : void 0,
      mediaEmbed: isSet91(object.mediaEmbed) ? MediaEmbed.fromJSON(object.mediaEmbed) : void 0,
      thumbnailWidth: isSet91(object.thumbnailWidth) ? Number(object.thumbnailWidth) : void 0,
      authorFlairTemplateId: isSet91(object.authorFlairTemplateId) ? String(object.authorFlairTemplateId) : void 0,
      isOriginalContent: isSet91(object.isOriginalContent) ? Boolean(object.isOriginalContent) : void 0,
      authorFullname: isSet91(object.authorFullname) ? String(object.authorFullname) : void 0,
      secureMedia: isSet91(object.secureMedia) ? Boolean(object.secureMedia) : void 0,
      isRedditMediaDomain: isSet91(object.isRedditMediaDomain) ? Boolean(object.isRedditMediaDomain) : void 0,
      isMeta: isSet91(object.isMeta) ? Boolean(object.isMeta) : void 0,
      category: isSet91(object.category) ? String(object.category) : void 0,
      secureMediaEmbed: isSet91(object.secureMediaEmbed) ? MediaEmbed.fromJSON(object.secureMediaEmbed) : void 0,
      linkFlairText: isSet91(object.linkFlairText) ? String(object.linkFlairText) : void 0,
      canModPost: isSet91(object.canModPost) ? Boolean(object.canModPost) : void 0,
      score: isSet91(object.score) ? Number(object.score) : void 0,
      approvedBy: isSet91(object.approvedBy) ? String(object.approvedBy) : void 0,
      isCreatedFromAdsUi: isSet91(object.isCreatedFromAdsUi) ? Boolean(object.isCreatedFromAdsUi) : void 0,
      authorPremium: isSet91(object.authorPremium) ? Boolean(object.authorPremium) : void 0,
      thumbnail: isSet91(object.thumbnail) ? String(object.thumbnail) : void 0,
      edited: isSet91(object.edited) ? Boolean(object.edited) : void 0,
      authorFlairCssClass: isSet91(object.authorFlairCssClass) ? String(object.authorFlairCssClass) : void 0,
      previousVisits: Array.isArray(object?.previousVisits) ? object.previousVisits.map((e) => Number(e)) : [],
      authorFlairRichtext: Array.isArray(object?.authorFlairRichtext) ? object.authorFlairRichtext.map((e) => String(e)) : [],
      gildings: isSet91(object.gildings) ? Any.fromJSON(object.gildings) : void 0,
      contentCategories: isSet91(object.contentCategories) ? String(object.contentCategories) : void 0,
      isSelf: isSet91(object.isSelf) ? Boolean(object.isSelf) : void 0,
      subredditType: isSet91(object.subredditType) ? String(object.subredditType) : void 0,
      created: isSet91(object.created) ? Number(object.created) : void 0,
      linkFlairType: isSet91(object.linkFlairType) ? String(object.linkFlairType) : void 0,
      wls: isSet91(object.wls) ? String(object.wls) : void 0,
      removedByCategory: isSet91(object.removedByCategory) ? String(object.removedByCategory) : void 0,
      bannedBy: isSet91(object.bannedBy) ? String(object.bannedBy) : void 0,
      authorFlairType: isSet91(object.authorFlairType) ? String(object.authorFlairType) : void 0,
      totalAwardsReceived: isSet91(object.totalAwardsReceived) ? Number(object.totalAwardsReceived) : void 0,
      allowLiveComments: isSet91(object.allowLiveComments) ? Boolean(object.allowLiveComments) : void 0,
      selftextHtml: isSet91(object.selftextHtml) ? String(object.selftextHtml) : void 0,
      likes: isSet91(object.likes) ? Boolean(object.likes) : void 0,
      suggestedSort: isSet91(object.suggestedSort) ? String(object.suggestedSort) : void 0,
      bannedAtUtc: isSet91(object.bannedAtUtc) ? Number(object.bannedAtUtc) : void 0,
      viewCount: isSet91(object.viewCount) ? Number(object.viewCount) : void 0,
      archived: isSet91(object.archived) ? Boolean(object.archived) : void 0,
      noFollow: isSet91(object.noFollow) ? Boolean(object.noFollow) : void 0,
      spam: isSet91(object.spam) ? Boolean(object.spam) : void 0,
      isCrosspostable: isSet91(object.isCrosspostable) ? Boolean(object.isCrosspostable) : void 0,
      pinned: isSet91(object.pinned) ? Boolean(object.pinned) : void 0,
      over18: isSet91(object.over18) ? Boolean(object.over18) : void 0,
      allAwardings: Array.isArray(object?.allAwardings) ? object.allAwardings.map((e) => Any.fromJSON(e)) : [],
      awarders: Array.isArray(object?.awarders) ? object.awarders.map((e) => String(e)) : [],
      mediaOnly: isSet91(object.mediaOnly) ? Boolean(object.mediaOnly) : void 0,
      canGild: isSet91(object.canGild) ? Boolean(object.canGild) : void 0,
      removed: isSet91(object.removed) ? Boolean(object.removed) : void 0,
      spoiler: isSet91(object.spoiler) ? Boolean(object.spoiler) : void 0,
      locked: isSet91(object.locked) ? Boolean(object.locked) : void 0,
      authorFlairText: isSet91(object.authorFlairText) ? String(object.authorFlairText) : void 0,
      treatmentTags: Array.isArray(object?.treatmentTags) ? object.treatmentTags.map((e) => Any.fromJSON(e)) : [],
      rteMode: isSet91(object.rteMode) ? String(object.rteMode) : void 0,
      visited: isSet91(object.visited) ? Boolean(object.visited) : void 0,
      removedBy: isSet91(object.removedBy) ? String(object.removedBy) : void 0,
      modNote: isSet91(object.modNote) ? String(object.modNote) : void 0,
      distinguished: isSet91(object.distinguished) ? String(object.distinguished) : void 0,
      subredditId: isSet91(object.subredditId) ? String(object.subredditId) : void 0,
      authorIsBlocked: isSet91(object.authorIsBlocked) ? Boolean(object.authorIsBlocked) : void 0,
      modReasonBy: isSet91(object.modReasonBy) ? String(object.modReasonBy) : void 0,
      numReports: isSet91(object.numReports) ? Number(object.numReports) : void 0,
      removalReason: isSet91(object.removalReason) ? String(object.removalReason) : void 0,
      linkFlairBackgroundColor: isSet91(object.linkFlairBackgroundColor) ? String(object.linkFlairBackgroundColor) : void 0,
      id: isSet91(object.id) ? String(object.id) : void 0,
      isRobotIndexable: isSet91(object.isRobotIndexable) ? Boolean(object.isRobotIndexable) : void 0,
      numDuplicates: isSet91(object.numDuplicates) ? Number(object.numDuplicates) : void 0,
      reportReasons: Array.isArray(object?.reportReasons) ? object.reportReasons.map((e) => Any.fromJSON(e)) : [],
      author: isSet91(object.author) ? String(object.author) : void 0,
      discussionType: isSet91(object.discussionType) ? String(object.discussionType) : void 0,
      numComments: isSet91(object.numComments) ? Number(object.numComments) : void 0,
      sendReplies: isSet91(object.sendReplies) ? Boolean(object.sendReplies) : void 0,
      media: isSet91(object.media) ? String(object.media) : void 0,
      contestMode: isSet91(object.contestMode) ? Boolean(object.contestMode) : void 0,
      authorPatreonFlair: isSet91(object.authorPatreonFlair) ? Boolean(object.authorPatreonFlair) : void 0,
      approved: isSet91(object.approved) ? Boolean(object.approved) : void 0,
      authorFlairTextColor: isSet91(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : void 0,
      permalink: isSet91(object.permalink) ? String(object.permalink) : void 0,
      whitelistStatus: isSet91(object.whitelistStatus) ? Boolean(object.whitelistStatus) : void 0,
      stickied: isSet91(object.stickied) ? Boolean(object.stickied) : void 0,
      url: isSet91(object.url) ? String(object.url) : void 0,
      subredditSubscribers: isSet91(object.subredditSubscribers) ? Number(object.subredditSubscribers) : void 0,
      createdUtc: isSet91(object.createdUtc) ? Number(object.createdUtc) : void 0,
      numCrossposts: isSet91(object.numCrossposts) ? Number(object.numCrossposts) : void 0,
      modReports: Array.isArray(object?.modReports) ? object.modReports.map((e) => Any.fromJSON(e)) : [],
      isVideo: isSet91(object.isVideo) ? Boolean(object.isVideo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.authorFlairBackgroundColor !== void 0 && (obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor);
    message.approvedAtUtc !== void 0 && (obj.approvedAtUtc = message.approvedAtUtc);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.selftext !== void 0 && (obj.selftext = message.selftext);
    if (message.userReports) {
      obj.userReports = message.userReports.map((e) => e);
    } else {
      obj.userReports = [];
    }
    message.saved !== void 0 && (obj.saved = message.saved);
    message.modReasonTitle !== void 0 && (obj.modReasonTitle = message.modReasonTitle);
    message.gilded !== void 0 && (obj.gilded = message.gilded);
    message.clicked !== void 0 && (obj.clicked = message.clicked);
    message.title !== void 0 && (obj.title = message.title);
    if (message.linkFlairRichtext) {
      obj.linkFlairRichtext = message.linkFlairRichtext.map((e) => e);
    } else {
      obj.linkFlairRichtext = [];
    }
    message.subredditNamePrefixed !== void 0 && (obj.subredditNamePrefixed = message.subredditNamePrefixed);
    message.hidden !== void 0 && (obj.hidden = message.hidden);
    message.pwls !== void 0 && (obj.pwls = message.pwls);
    message.linkFlairCssClass !== void 0 && (obj.linkFlairCssClass = message.linkFlairCssClass);
    message.downs !== void 0 && (obj.downs = message.downs);
    message.thumbnailHeight !== void 0 && (obj.thumbnailHeight = message.thumbnailHeight);
    message.topAwardedType !== void 0 && (obj.topAwardedType = message.topAwardedType);
    message.parentWhitelistStatus !== void 0 && (obj.parentWhitelistStatus = message.parentWhitelistStatus);
    message.hideScore !== void 0 && (obj.hideScore = message.hideScore);
    message.name !== void 0 && (obj.name = message.name);
    message.quarantine !== void 0 && (obj.quarantine = message.quarantine);
    message.linkFlairTextColor !== void 0 && (obj.linkFlairTextColor = message.linkFlairTextColor);
    message.upvoteRatio !== void 0 && (obj.upvoteRatio = message.upvoteRatio);
    message.ignoreReports !== void 0 && (obj.ignoreReports = message.ignoreReports);
    message.ups !== void 0 && (obj.ups = message.ups);
    message.domain !== void 0 && (obj.domain = message.domain);
    message.mediaEmbed !== void 0 && (obj.mediaEmbed = message.mediaEmbed ? MediaEmbed.toJSON(message.mediaEmbed) : void 0);
    message.thumbnailWidth !== void 0 && (obj.thumbnailWidth = message.thumbnailWidth);
    message.authorFlairTemplateId !== void 0 && (obj.authorFlairTemplateId = message.authorFlairTemplateId);
    message.isOriginalContent !== void 0 && (obj.isOriginalContent = message.isOriginalContent);
    message.authorFullname !== void 0 && (obj.authorFullname = message.authorFullname);
    message.secureMedia !== void 0 && (obj.secureMedia = message.secureMedia);
    message.isRedditMediaDomain !== void 0 && (obj.isRedditMediaDomain = message.isRedditMediaDomain);
    message.isMeta !== void 0 && (obj.isMeta = message.isMeta);
    message.category !== void 0 && (obj.category = message.category);
    message.secureMediaEmbed !== void 0 && (obj.secureMediaEmbed = message.secureMediaEmbed ? MediaEmbed.toJSON(message.secureMediaEmbed) : void 0);
    message.linkFlairText !== void 0 && (obj.linkFlairText = message.linkFlairText);
    message.canModPost !== void 0 && (obj.canModPost = message.canModPost);
    message.score !== void 0 && (obj.score = message.score);
    message.approvedBy !== void 0 && (obj.approvedBy = message.approvedBy);
    message.isCreatedFromAdsUi !== void 0 && (obj.isCreatedFromAdsUi = message.isCreatedFromAdsUi);
    message.authorPremium !== void 0 && (obj.authorPremium = message.authorPremium);
    message.thumbnail !== void 0 && (obj.thumbnail = message.thumbnail);
    message.edited !== void 0 && (obj.edited = message.edited);
    message.authorFlairCssClass !== void 0 && (obj.authorFlairCssClass = message.authorFlairCssClass);
    if (message.previousVisits) {
      obj.previousVisits = message.previousVisits.map((e) => e);
    } else {
      obj.previousVisits = [];
    }
    if (message.authorFlairRichtext) {
      obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => e);
    } else {
      obj.authorFlairRichtext = [];
    }
    message.gildings !== void 0 && (obj.gildings = message.gildings ? Any.toJSON(message.gildings) : void 0);
    message.contentCategories !== void 0 && (obj.contentCategories = message.contentCategories);
    message.isSelf !== void 0 && (obj.isSelf = message.isSelf);
    message.subredditType !== void 0 && (obj.subredditType = message.subredditType);
    message.created !== void 0 && (obj.created = message.created);
    message.linkFlairType !== void 0 && (obj.linkFlairType = message.linkFlairType);
    message.wls !== void 0 && (obj.wls = message.wls);
    message.removedByCategory !== void 0 && (obj.removedByCategory = message.removedByCategory);
    message.bannedBy !== void 0 && (obj.bannedBy = message.bannedBy);
    message.authorFlairType !== void 0 && (obj.authorFlairType = message.authorFlairType);
    message.totalAwardsReceived !== void 0 && (obj.totalAwardsReceived = message.totalAwardsReceived);
    message.allowLiveComments !== void 0 && (obj.allowLiveComments = message.allowLiveComments);
    message.selftextHtml !== void 0 && (obj.selftextHtml = message.selftextHtml);
    message.likes !== void 0 && (obj.likes = message.likes);
    message.suggestedSort !== void 0 && (obj.suggestedSort = message.suggestedSort);
    message.bannedAtUtc !== void 0 && (obj.bannedAtUtc = message.bannedAtUtc);
    message.viewCount !== void 0 && (obj.viewCount = message.viewCount);
    message.archived !== void 0 && (obj.archived = message.archived);
    message.noFollow !== void 0 && (obj.noFollow = message.noFollow);
    message.spam !== void 0 && (obj.spam = message.spam);
    message.isCrosspostable !== void 0 && (obj.isCrosspostable = message.isCrosspostable);
    message.pinned !== void 0 && (obj.pinned = message.pinned);
    message.over18 !== void 0 && (obj.over18 = message.over18);
    if (message.allAwardings) {
      obj.allAwardings = message.allAwardings.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.allAwardings = [];
    }
    if (message.awarders) {
      obj.awarders = message.awarders.map((e) => e);
    } else {
      obj.awarders = [];
    }
    message.mediaOnly !== void 0 && (obj.mediaOnly = message.mediaOnly);
    message.canGild !== void 0 && (obj.canGild = message.canGild);
    message.removed !== void 0 && (obj.removed = message.removed);
    message.spoiler !== void 0 && (obj.spoiler = message.spoiler);
    message.locked !== void 0 && (obj.locked = message.locked);
    message.authorFlairText !== void 0 && (obj.authorFlairText = message.authorFlairText);
    if (message.treatmentTags) {
      obj.treatmentTags = message.treatmentTags.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.treatmentTags = [];
    }
    message.rteMode !== void 0 && (obj.rteMode = message.rteMode);
    message.visited !== void 0 && (obj.visited = message.visited);
    message.removedBy !== void 0 && (obj.removedBy = message.removedBy);
    message.modNote !== void 0 && (obj.modNote = message.modNote);
    message.distinguished !== void 0 && (obj.distinguished = message.distinguished);
    message.subredditId !== void 0 && (obj.subredditId = message.subredditId);
    message.authorIsBlocked !== void 0 && (obj.authorIsBlocked = message.authorIsBlocked);
    message.modReasonBy !== void 0 && (obj.modReasonBy = message.modReasonBy);
    message.numReports !== void 0 && (obj.numReports = message.numReports);
    message.removalReason !== void 0 && (obj.removalReason = message.removalReason);
    message.linkFlairBackgroundColor !== void 0 && (obj.linkFlairBackgroundColor = message.linkFlairBackgroundColor);
    message.id !== void 0 && (obj.id = message.id);
    message.isRobotIndexable !== void 0 && (obj.isRobotIndexable = message.isRobotIndexable);
    message.numDuplicates !== void 0 && (obj.numDuplicates = message.numDuplicates);
    if (message.reportReasons) {
      obj.reportReasons = message.reportReasons.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.reportReasons = [];
    }
    message.author !== void 0 && (obj.author = message.author);
    message.discussionType !== void 0 && (obj.discussionType = message.discussionType);
    message.numComments !== void 0 && (obj.numComments = message.numComments);
    message.sendReplies !== void 0 && (obj.sendReplies = message.sendReplies);
    message.media !== void 0 && (obj.media = message.media);
    message.contestMode !== void 0 && (obj.contestMode = message.contestMode);
    message.authorPatreonFlair !== void 0 && (obj.authorPatreonFlair = message.authorPatreonFlair);
    message.approved !== void 0 && (obj.approved = message.approved);
    message.authorFlairTextColor !== void 0 && (obj.authorFlairTextColor = message.authorFlairTextColor);
    message.permalink !== void 0 && (obj.permalink = message.permalink);
    message.whitelistStatus !== void 0 && (obj.whitelistStatus = message.whitelistStatus);
    message.stickied !== void 0 && (obj.stickied = message.stickied);
    message.url !== void 0 && (obj.url = message.url);
    message.subredditSubscribers !== void 0 && (obj.subredditSubscribers = message.subredditSubscribers);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    message.numCrossposts !== void 0 && (obj.numCrossposts = message.numCrossposts);
    if (message.modReports) {
      obj.modReports = message.modReports.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.modReports = [];
    }
    message.isVideo !== void 0 && (obj.isVideo = message.isVideo);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStickyResponse_LinkData();
    message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? void 0;
    message.approvedAtUtc = object.approvedAtUtc ?? void 0;
    message.subreddit = object.subreddit ?? void 0;
    message.selftext = object.selftext ?? void 0;
    message.userReports = object.userReports?.map((e) => e) || [];
    message.saved = object.saved ?? void 0;
    message.modReasonTitle = object.modReasonTitle ?? void 0;
    message.gilded = object.gilded ?? void 0;
    message.clicked = object.clicked ?? void 0;
    message.title = object.title ?? void 0;
    message.linkFlairRichtext = object.linkFlairRichtext?.map((e) => e) || [];
    message.subredditNamePrefixed = object.subredditNamePrefixed ?? void 0;
    message.hidden = object.hidden ?? void 0;
    message.pwls = object.pwls ?? void 0;
    message.linkFlairCssClass = object.linkFlairCssClass ?? void 0;
    message.downs = object.downs ?? void 0;
    message.thumbnailHeight = object.thumbnailHeight ?? void 0;
    message.topAwardedType = object.topAwardedType ?? void 0;
    message.parentWhitelistStatus = object.parentWhitelistStatus ?? void 0;
    message.hideScore = object.hideScore ?? void 0;
    message.name = object.name ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.linkFlairTextColor = object.linkFlairTextColor ?? void 0;
    message.upvoteRatio = object.upvoteRatio ?? void 0;
    message.ignoreReports = object.ignoreReports ?? void 0;
    message.ups = object.ups ?? void 0;
    message.domain = object.domain ?? void 0;
    message.mediaEmbed = object.mediaEmbed !== void 0 && object.mediaEmbed !== null ? MediaEmbed.fromPartial(object.mediaEmbed) : void 0;
    message.thumbnailWidth = object.thumbnailWidth ?? void 0;
    message.authorFlairTemplateId = object.authorFlairTemplateId ?? void 0;
    message.isOriginalContent = object.isOriginalContent ?? void 0;
    message.authorFullname = object.authorFullname ?? void 0;
    message.secureMedia = object.secureMedia ?? void 0;
    message.isRedditMediaDomain = object.isRedditMediaDomain ?? void 0;
    message.isMeta = object.isMeta ?? void 0;
    message.category = object.category ?? void 0;
    message.secureMediaEmbed = object.secureMediaEmbed !== void 0 && object.secureMediaEmbed !== null ? MediaEmbed.fromPartial(object.secureMediaEmbed) : void 0;
    message.linkFlairText = object.linkFlairText ?? void 0;
    message.canModPost = object.canModPost ?? void 0;
    message.score = object.score ?? void 0;
    message.approvedBy = object.approvedBy ?? void 0;
    message.isCreatedFromAdsUi = object.isCreatedFromAdsUi ?? void 0;
    message.authorPremium = object.authorPremium ?? void 0;
    message.thumbnail = object.thumbnail ?? void 0;
    message.edited = object.edited ?? void 0;
    message.authorFlairCssClass = object.authorFlairCssClass ?? void 0;
    message.previousVisits = object.previousVisits?.map((e) => e) || [];
    message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => e) || [];
    message.gildings = object.gildings !== void 0 && object.gildings !== null ? Any.fromPartial(object.gildings) : void 0;
    message.contentCategories = object.contentCategories ?? void 0;
    message.isSelf = object.isSelf ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.created = object.created ?? void 0;
    message.linkFlairType = object.linkFlairType ?? void 0;
    message.wls = object.wls ?? void 0;
    message.removedByCategory = object.removedByCategory ?? void 0;
    message.bannedBy = object.bannedBy ?? void 0;
    message.authorFlairType = object.authorFlairType ?? void 0;
    message.totalAwardsReceived = object.totalAwardsReceived ?? void 0;
    message.allowLiveComments = object.allowLiveComments ?? void 0;
    message.selftextHtml = object.selftextHtml ?? void 0;
    message.likes = object.likes ?? void 0;
    message.suggestedSort = object.suggestedSort ?? void 0;
    message.bannedAtUtc = object.bannedAtUtc ?? void 0;
    message.viewCount = object.viewCount ?? void 0;
    message.archived = object.archived ?? void 0;
    message.noFollow = object.noFollow ?? void 0;
    message.spam = object.spam ?? void 0;
    message.isCrosspostable = object.isCrosspostable ?? void 0;
    message.pinned = object.pinned ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.allAwardings = object.allAwardings?.map((e) => Any.fromPartial(e)) || [];
    message.awarders = object.awarders?.map((e) => e) || [];
    message.mediaOnly = object.mediaOnly ?? void 0;
    message.canGild = object.canGild ?? void 0;
    message.removed = object.removed ?? void 0;
    message.spoiler = object.spoiler ?? void 0;
    message.locked = object.locked ?? void 0;
    message.authorFlairText = object.authorFlairText ?? void 0;
    message.treatmentTags = object.treatmentTags?.map((e) => Any.fromPartial(e)) || [];
    message.rteMode = object.rteMode ?? void 0;
    message.visited = object.visited ?? void 0;
    message.removedBy = object.removedBy ?? void 0;
    message.modNote = object.modNote ?? void 0;
    message.distinguished = object.distinguished ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.authorIsBlocked = object.authorIsBlocked ?? void 0;
    message.modReasonBy = object.modReasonBy ?? void 0;
    message.numReports = object.numReports ?? void 0;
    message.removalReason = object.removalReason ?? void 0;
    message.linkFlairBackgroundColor = object.linkFlairBackgroundColor ?? void 0;
    message.id = object.id ?? void 0;
    message.isRobotIndexable = object.isRobotIndexable ?? void 0;
    message.numDuplicates = object.numDuplicates ?? void 0;
    message.reportReasons = object.reportReasons?.map((e) => Any.fromPartial(e)) || [];
    message.author = object.author ?? void 0;
    message.discussionType = object.discussionType ?? void 0;
    message.numComments = object.numComments ?? void 0;
    message.sendReplies = object.sendReplies ?? void 0;
    message.media = object.media ?? void 0;
    message.contestMode = object.contestMode ?? void 0;
    message.authorPatreonFlair = object.authorPatreonFlair ?? void 0;
    message.approved = object.approved ?? void 0;
    message.authorFlairTextColor = object.authorFlairTextColor ?? void 0;
    message.permalink = object.permalink ?? void 0;
    message.whitelistStatus = object.whitelistStatus ?? void 0;
    message.stickied = object.stickied ?? void 0;
    message.url = object.url ?? void 0;
    message.subredditSubscribers = object.subredditSubscribers ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.numCrossposts = object.numCrossposts ?? void 0;
    message.modReports = object.modReports?.map((e) => Any.fromPartial(e)) || [];
    message.isVideo = object.isVideo ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.StickyResponse.LinkData", StickyResponse_LinkData);
function createBaseStickyResponse_WrappedStickyListing() {
  return { kind: void 0, data: void 0 };
}
var StickyResponse_WrappedStickyListing = {
  $type: "devvit.plugin.redditapi.subreddits.StickyResponse.WrappedStickyListing",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      StickyResponse_LinkData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStickyResponse_WrappedStickyListing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = StickyResponse_LinkData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet91(object.kind) ? String(object.kind) : void 0,
      data: isSet91(object.data) ? StickyResponse_LinkData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? StickyResponse_LinkData.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStickyResponse_WrappedStickyListing();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? StickyResponse_LinkData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.StickyResponse.WrappedStickyListing", StickyResponse_WrappedStickyListing);
function createBaseStickyResponse_StickyResponseData() {
  return {
    after: void 0,
    before: void 0,
    dist: void 0,
    modhash: void 0,
    geoFilter: void 0,
    children: []
  };
}
var StickyResponse_StickyResponseData = {
  $type: "devvit.plugin.redditapi.subreddits.StickyResponse.StickyResponseData",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int32Value.encode({ value: message.dist }, writer.uint32(26).fork()).ldelim();
    }
    if (message.modhash !== void 0) {
      StringValue.encode({ value: message.modhash }, writer.uint32(34).fork()).ldelim();
    }
    if (message.geoFilter !== void 0) {
      StringValue.encode({ value: message.geoFilter }, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.children) {
      StickyResponse_WrappedStickyListing.encode(v, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStickyResponse_StickyResponseData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.dist = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.modhash = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.geoFilter = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.children.push(StickyResponse_WrappedStickyListing.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet91(object.after) ? String(object.after) : void 0,
      before: isSet91(object.before) ? String(object.before) : void 0,
      dist: isSet91(object.dist) ? Number(object.dist) : void 0,
      modhash: isSet91(object.modhash) ? String(object.modhash) : void 0,
      geoFilter: isSet91(object.geoFilter) ? String(object.geoFilter) : void 0,
      children: Array.isArray(object?.children) ? object.children.map((e) => StickyResponse_WrappedStickyListing.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.dist !== void 0 && (obj.dist = message.dist);
    message.modhash !== void 0 && (obj.modhash = message.modhash);
    message.geoFilter !== void 0 && (obj.geoFilter = message.geoFilter);
    if (message.children) {
      obj.children = message.children.map((e) => e ? StickyResponse_WrappedStickyListing.toJSON(e) : void 0);
    } else {
      obj.children = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStickyResponse_StickyResponseData();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.dist = object.dist ?? void 0;
    message.modhash = object.modhash ?? void 0;
    message.geoFilter = object.geoFilter ?? void 0;
    message.children = object.children?.map((e) => StickyResponse_WrappedStickyListing.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.StickyResponse.StickyResponseData", StickyResponse_StickyResponseData);
function createBaseFullSubredditObject() {
  return {
    userFlairBackgroundColor: void 0,
    submitTextHtml: void 0,
    restrictPosting: void 0,
    userIsBanned: void 0,
    freeFormReports: void 0,
    wikiEnabled: void 0,
    userIsMuted: void 0,
    userCanFlairInSr: void 0,
    displayName: void 0,
    headerImg: void 0,
    title: void 0,
    allowGalleries: void 0,
    iconSize: [],
    primaryColor: void 0,
    activeUserCount: void 0,
    iconImg: void 0,
    displayNamePrefixed: void 0,
    accountsActive: void 0,
    publicTraffic: void 0,
    subscribers: void 0,
    userFlairRichtext: [],
    videostreamLinksCount: void 0,
    name: void 0,
    quarantine: void 0,
    hideAds: void 0,
    predictionLeaderboardEntryType: void 0,
    emojisEnabled: void 0,
    advertiserCategory: void 0,
    publicDescription: void 0,
    commentScoreHideMins: void 0,
    allowPredictions: void 0,
    userHasFavorited: void 0,
    userFlairTemplateId: void 0,
    communityIcon: void 0,
    bannerBackgroundImage: void 0,
    originalContentTagEnabled: void 0,
    communityReviewed: void 0,
    submitText: void 0,
    descriptionHtml: void 0,
    spoilersEnabled: void 0,
    commentContributionSettings: void 0,
    allowTalks: void 0,
    headerSize: [],
    userFlairPosition: void 0,
    allOriginalContent: void 0,
    hasMenuWidget: void 0,
    isEnrolledInNewModmail: void 0,
    keyColor: void 0,
    canAssignUserFlair: void 0,
    created: void 0,
    wls: void 0,
    showMediaPreview: void 0,
    submissionType: void 0,
    userIsSubscriber: void 0,
    allowedMediaInComments: [],
    allowVideogifs: void 0,
    shouldArchivePosts: void 0,
    userFlairType: void 0,
    allowPolls: void 0,
    collapseDeletedComments: void 0,
    emojisCustomSize: [],
    publicDescriptionHtml: void 0,
    allowVideos: void 0,
    isCrosspostableSubreddit: void 0,
    notificationLevel: void 0,
    shouldShowMediaInCommentsSetting: void 0,
    canAssignLinkFlair: void 0,
    accountsActiveIsFuzzed: void 0,
    allowPredictionContributors: void 0,
    submitTextLabel: void 0,
    linkFlairPosition: void 0,
    userSrFlairEnabled: void 0,
    userFlairEnabledInSr: void 0,
    allowChatPostCreation: void 0,
    allowDiscovery: void 0,
    acceptFollowers: void 0,
    userSrThemeEnabled: void 0,
    linkFlairEnabled: void 0,
    disableContributorRequests: void 0,
    subredditType: void 0,
    suggestedCommentSort: void 0,
    bannerImg: void 0,
    userFlairText: void 0,
    contentCategory: void 0,
    bannerBackgroundColor: void 0,
    showMedia: void 0,
    id: void 0,
    userIsModerator: void 0,
    over18: void 0,
    headerTitle: void 0,
    description: void 0,
    isChatPostFeatureEnabled: void 0,
    submitLinkLabel: void 0,
    userFlairTextColor: void 0,
    restrictCommenting: void 0,
    userFlairCssClass: void 0,
    allowImages: void 0,
    lang: void 0,
    whitelistStatus: void 0,
    url: void 0,
    createdUtc: void 0,
    bannerSize: [],
    mobileBannerImage: void 0,
    userIsContributor: void 0,
    allowPredictionsTournament: void 0
  };
}
var FullSubredditObject = {
  $type: "devvit.plugin.redditapi.subreddits.FullSubredditObject",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.userFlairBackgroundColor !== void 0) {
      StringValue.encode({ value: message.userFlairBackgroundColor }, writer.uint32(10).fork()).ldelim();
    }
    if (message.submitTextHtml !== void 0) {
      StringValue.encode({ value: message.submitTextHtml }, writer.uint32(18).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(26).fork()).ldelim();
    }
    if (message.userIsBanned !== void 0) {
      BoolValue.encode({ value: message.userIsBanned }, writer.uint32(34).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(42).fork()).ldelim();
    }
    if (message.wikiEnabled !== void 0) {
      BoolValue.encode({ value: message.wikiEnabled }, writer.uint32(50).fork()).ldelim();
    }
    if (message.userIsMuted !== void 0) {
      BoolValue.encode({ value: message.userIsMuted }, writer.uint32(58).fork()).ldelim();
    }
    if (message.userCanFlairInSr !== void 0) {
      BoolValue.encode({ value: message.userCanFlairInSr }, writer.uint32(66).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(74).fork()).ldelim();
    }
    if (message.headerImg !== void 0) {
      StringValue.encode({ value: message.headerImg }, writer.uint32(82).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(90).fork()).ldelim();
    }
    if (message.allowGalleries !== void 0) {
      BoolValue.encode({ value: message.allowGalleries }, writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.iconSize) {
      Int64Value.encode({ value: v }, writer.uint32(106).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(114).fork()).ldelim();
    }
    if (message.activeUserCount !== void 0) {
      Int64Value.encode({ value: message.activeUserCount }, writer.uint32(122).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(130).fork()).ldelim();
    }
    if (message.displayNamePrefixed !== void 0) {
      StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(138).fork()).ldelim();
    }
    if (message.accountsActive !== void 0) {
      Int64Value.encode({ value: message.accountsActive }, writer.uint32(146).fork()).ldelim();
    }
    if (message.publicTraffic !== void 0) {
      BoolValue.encode({ value: message.publicTraffic }, writer.uint32(154).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int64Value.encode({ value: message.subscribers }, writer.uint32(162).fork()).ldelim();
    }
    for (const v of message.userFlairRichtext) {
      StringValue.encode({ value: v }, writer.uint32(170).fork()).ldelim();
    }
    if (message.videostreamLinksCount !== void 0) {
      Int64Value.encode({ value: message.videostreamLinksCount }, writer.uint32(178).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(186).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(194).fork()).ldelim();
    }
    if (message.hideAds !== void 0) {
      BoolValue.encode({ value: message.hideAds }, writer.uint32(202).fork()).ldelim();
    }
    if (message.predictionLeaderboardEntryType !== void 0) {
      StringValue.encode({ value: message.predictionLeaderboardEntryType }, writer.uint32(210).fork()).ldelim();
    }
    if (message.emojisEnabled !== void 0) {
      BoolValue.encode({ value: message.emojisEnabled }, writer.uint32(218).fork()).ldelim();
    }
    if (message.advertiserCategory !== void 0) {
      StringValue.encode({ value: message.advertiserCategory }, writer.uint32(226).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(234).fork()).ldelim();
    }
    if (message.commentScoreHideMins !== void 0) {
      Int32Value.encode({ value: message.commentScoreHideMins }, writer.uint32(242).fork()).ldelim();
    }
    if (message.allowPredictions !== void 0) {
      BoolValue.encode({ value: message.allowPredictions }, writer.uint32(250).fork()).ldelim();
    }
    if (message.userHasFavorited !== void 0) {
      BoolValue.encode({ value: message.userHasFavorited }, writer.uint32(258).fork()).ldelim();
    }
    if (message.userFlairTemplateId !== void 0) {
      StringValue.encode({ value: message.userFlairTemplateId }, writer.uint32(266).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(274).fork()).ldelim();
    }
    if (message.bannerBackgroundImage !== void 0) {
      StringValue.encode({ value: message.bannerBackgroundImage }, writer.uint32(282).fork()).ldelim();
    }
    if (message.originalContentTagEnabled !== void 0) {
      BoolValue.encode({ value: message.originalContentTagEnabled }, writer.uint32(290).fork()).ldelim();
    }
    if (message.communityReviewed !== void 0) {
      BoolValue.encode({ value: message.communityReviewed }, writer.uint32(298).fork()).ldelim();
    }
    if (message.submitText !== void 0) {
      StringValue.encode({ value: message.submitText }, writer.uint32(314).fork()).ldelim();
    }
    if (message.descriptionHtml !== void 0) {
      StringValue.encode({ value: message.descriptionHtml }, writer.uint32(322).fork()).ldelim();
    }
    if (message.spoilersEnabled !== void 0) {
      BoolValue.encode({ value: message.spoilersEnabled }, writer.uint32(330).fork()).ldelim();
    }
    if (message.commentContributionSettings !== void 0) {
      CommentContributionSettings.encode(message.commentContributionSettings, writer.uint32(338).fork()).ldelim();
    }
    if (message.allowTalks !== void 0) {
      BoolValue.encode({ value: message.allowTalks }, writer.uint32(346).fork()).ldelim();
    }
    for (const v of message.headerSize) {
      Int64Value.encode({ value: v }, writer.uint32(354).fork()).ldelim();
    }
    if (message.userFlairPosition !== void 0) {
      StringValue.encode({ value: message.userFlairPosition }, writer.uint32(362).fork()).ldelim();
    }
    if (message.allOriginalContent !== void 0) {
      BoolValue.encode({ value: message.allOriginalContent }, writer.uint32(370).fork()).ldelim();
    }
    if (message.hasMenuWidget !== void 0) {
      BoolValue.encode({ value: message.hasMenuWidget }, writer.uint32(378).fork()).ldelim();
    }
    if (message.isEnrolledInNewModmail !== void 0) {
      BoolValue.encode({ value: message.isEnrolledInNewModmail }, writer.uint32(386).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(394).fork()).ldelim();
    }
    if (message.canAssignUserFlair !== void 0) {
      BoolValue.encode({ value: message.canAssignUserFlair }, writer.uint32(402).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int64Value.encode({ value: message.created }, writer.uint32(410).fork()).ldelim();
    }
    if (message.wls !== void 0) {
      Int32Value.encode({ value: message.wls }, writer.uint32(418).fork()).ldelim();
    }
    if (message.showMediaPreview !== void 0) {
      BoolValue.encode({ value: message.showMediaPreview }, writer.uint32(426).fork()).ldelim();
    }
    if (message.submissionType !== void 0) {
      StringValue.encode({ value: message.submissionType }, writer.uint32(434).fork()).ldelim();
    }
    if (message.userIsSubscriber !== void 0) {
      BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(442).fork()).ldelim();
    }
    for (const v of message.allowedMediaInComments) {
      StringValue.encode({ value: v }, writer.uint32(450).fork()).ldelim();
    }
    if (message.allowVideogifs !== void 0) {
      BoolValue.encode({ value: message.allowVideogifs }, writer.uint32(458).fork()).ldelim();
    }
    if (message.shouldArchivePosts !== void 0) {
      BoolValue.encode({ value: message.shouldArchivePosts }, writer.uint32(466).fork()).ldelim();
    }
    if (message.userFlairType !== void 0) {
      StringValue.encode({ value: message.userFlairType }, writer.uint32(474).fork()).ldelim();
    }
    if (message.allowPolls !== void 0) {
      BoolValue.encode({ value: message.allowPolls }, writer.uint32(482).fork()).ldelim();
    }
    if (message.collapseDeletedComments !== void 0) {
      BoolValue.encode({ value: message.collapseDeletedComments }, writer.uint32(490).fork()).ldelim();
    }
    for (const v of message.emojisCustomSize) {
      Int64Value.encode({ value: v }, writer.uint32(498).fork()).ldelim();
    }
    if (message.publicDescriptionHtml !== void 0) {
      StringValue.encode({ value: message.publicDescriptionHtml }, writer.uint32(506).fork()).ldelim();
    }
    if (message.allowVideos !== void 0) {
      BoolValue.encode({ value: message.allowVideos }, writer.uint32(514).fork()).ldelim();
    }
    if (message.isCrosspostableSubreddit !== void 0) {
      BoolValue.encode({ value: message.isCrosspostableSubreddit }, writer.uint32(522).fork()).ldelim();
    }
    if (message.notificationLevel !== void 0) {
      StringValue.encode({ value: message.notificationLevel }, writer.uint32(530).fork()).ldelim();
    }
    if (message.shouldShowMediaInCommentsSetting !== void 0) {
      BoolValue.encode({ value: message.shouldShowMediaInCommentsSetting }, writer.uint32(538).fork()).ldelim();
    }
    if (message.canAssignLinkFlair !== void 0) {
      BoolValue.encode({ value: message.canAssignLinkFlair }, writer.uint32(546).fork()).ldelim();
    }
    if (message.accountsActiveIsFuzzed !== void 0) {
      BoolValue.encode({ value: message.accountsActiveIsFuzzed }, writer.uint32(554).fork()).ldelim();
    }
    if (message.allowPredictionContributors !== void 0) {
      BoolValue.encode({ value: message.allowPredictionContributors }, writer.uint32(562).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(570).fork()).ldelim();
    }
    if (message.linkFlairPosition !== void 0) {
      StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(578).fork()).ldelim();
    }
    if (message.userSrFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.userSrFlairEnabled }, writer.uint32(586).fork()).ldelim();
    }
    if (message.userFlairEnabledInSr !== void 0) {
      BoolValue.encode({ value: message.userFlairEnabledInSr }, writer.uint32(594).fork()).ldelim();
    }
    if (message.allowChatPostCreation !== void 0) {
      BoolValue.encode({ value: message.allowChatPostCreation }, writer.uint32(602).fork()).ldelim();
    }
    if (message.allowDiscovery !== void 0) {
      BoolValue.encode({ value: message.allowDiscovery }, writer.uint32(610).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(618).fork()).ldelim();
    }
    if (message.userSrThemeEnabled !== void 0) {
      BoolValue.encode({ value: message.userSrThemeEnabled }, writer.uint32(626).fork()).ldelim();
    }
    if (message.linkFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(634).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(642).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(650).fork()).ldelim();
    }
    if (message.suggestedCommentSort !== void 0) {
      StringValue.encode({ value: message.suggestedCommentSort }, writer.uint32(658).fork()).ldelim();
    }
    if (message.bannerImg !== void 0) {
      StringValue.encode({ value: message.bannerImg }, writer.uint32(666).fork()).ldelim();
    }
    if (message.userFlairText !== void 0) {
      StringValue.encode({ value: message.userFlairText }, writer.uint32(674).fork()).ldelim();
    }
    if (message.contentCategory !== void 0) {
      StringValue.encode({ value: message.contentCategory }, writer.uint32(682).fork()).ldelim();
    }
    if (message.bannerBackgroundColor !== void 0) {
      StringValue.encode({ value: message.bannerBackgroundColor }, writer.uint32(690).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(698).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(706).fork()).ldelim();
    }
    if (message.userIsModerator !== void 0) {
      BoolValue.encode({ value: message.userIsModerator }, writer.uint32(714).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(722).fork()).ldelim();
    }
    if (message.headerTitle !== void 0) {
      StringValue.encode({ value: message.headerTitle }, writer.uint32(730).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(738).fork()).ldelim();
    }
    if (message.isChatPostFeatureEnabled !== void 0) {
      BoolValue.encode({ value: message.isChatPostFeatureEnabled }, writer.uint32(746).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(754).fork()).ldelim();
    }
    if (message.userFlairTextColor !== void 0) {
      StringValue.encode({ value: message.userFlairTextColor }, writer.uint32(762).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(770).fork()).ldelim();
    }
    if (message.userFlairCssClass !== void 0) {
      StringValue.encode({ value: message.userFlairCssClass }, writer.uint32(778).fork()).ldelim();
    }
    if (message.allowImages !== void 0) {
      BoolValue.encode({ value: message.allowImages }, writer.uint32(786).fork()).ldelim();
    }
    if (message.lang !== void 0) {
      StringValue.encode({ value: message.lang }, writer.uint32(794).fork()).ldelim();
    }
    if (message.whitelistStatus !== void 0) {
      StringValue.encode({ value: message.whitelistStatus }, writer.uint32(802).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(810).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(818).fork()).ldelim();
    }
    for (const v of message.bannerSize) {
      Int32Value.encode({ value: v }, writer.uint32(826).fork()).ldelim();
    }
    if (message.mobileBannerImage !== void 0) {
      StringValue.encode({ value: message.mobileBannerImage }, writer.uint32(834).fork()).ldelim();
    }
    if (message.userIsContributor !== void 0) {
      BoolValue.encode({ value: message.userIsContributor }, writer.uint32(842).fork()).ldelim();
    }
    if (message.allowPredictionsTournament !== void 0) {
      BoolValue.encode({ value: message.allowPredictionsTournament }, writer.uint32(850).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFullSubredditObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.userFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.submitTextHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.wikiEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.userIsMuted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.userCanFlairInSr = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.headerImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.allowGalleries = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.iconSize.push(Int64Value.decode(reader, reader.uint32()).value);
          break;
        case 14:
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.activeUserCount = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.accountsActive = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.publicTraffic = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.userFlairRichtext.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 22:
          message.videostreamLinksCount = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.hideAds = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.predictionLeaderboardEntryType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 27:
          message.emojisEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.advertiserCategory = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.commentScoreHideMins = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.allowPredictions = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.userHasFavorited = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.userFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 35:
          message.bannerBackgroundImage = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.originalContentTagEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 37:
          message.communityReviewed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 39:
          message.submitText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 40:
          message.descriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 41:
          message.spoilersEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 42:
          message.commentContributionSettings = CommentContributionSettings.decode(reader, reader.uint32());
          break;
        case 43:
          message.allowTalks = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 44:
          message.headerSize.push(Int64Value.decode(reader, reader.uint32()).value);
          break;
        case 45:
          message.userFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 46:
          message.allOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 47:
          message.hasMenuWidget = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 48:
          message.isEnrolledInNewModmail = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 49:
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 50:
          message.canAssignUserFlair = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 51:
          message.created = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 52:
          message.wls = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 53:
          message.showMediaPreview = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 54:
          message.submissionType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 55:
          message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 56:
          message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 57:
          message.allowVideogifs = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 58:
          message.shouldArchivePosts = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 59:
          message.userFlairType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 60:
          message.allowPolls = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 61:
          message.collapseDeletedComments = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 62:
          message.emojisCustomSize.push(Int64Value.decode(reader, reader.uint32()).value);
          break;
        case 63:
          message.publicDescriptionHtml = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 64:
          message.allowVideos = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 65:
          message.isCrosspostableSubreddit = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 66:
          message.notificationLevel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 67:
          message.shouldShowMediaInCommentsSetting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 68:
          message.canAssignLinkFlair = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 69:
          message.accountsActiveIsFuzzed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 70:
          message.allowPredictionContributors = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 71:
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 72:
          message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 73:
          message.userSrFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 74:
          message.userFlairEnabledInSr = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 75:
          message.allowChatPostCreation = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 76:
          message.allowDiscovery = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 77:
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 78:
          message.userSrThemeEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 79:
          message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 80:
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 81:
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 82:
          message.suggestedCommentSort = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 83:
          message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 84:
          message.userFlairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 85:
          message.contentCategory = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 86:
          message.bannerBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 87:
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 88:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 89:
          message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 90:
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 91:
          message.headerTitle = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 92:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 93:
          message.isChatPostFeatureEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 94:
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 95:
          message.userFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 96:
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 97:
          message.userFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 98:
          message.allowImages = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 99:
          message.lang = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 100:
          message.whitelistStatus = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 101:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 102:
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 103:
          message.bannerSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 104:
          message.mobileBannerImage = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 105:
          message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 106:
          message.allowPredictionsTournament = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      userFlairBackgroundColor: isSet91(object.userFlairBackgroundColor) ? String(object.userFlairBackgroundColor) : void 0,
      submitTextHtml: isSet91(object.submitTextHtml) ? String(object.submitTextHtml) : void 0,
      restrictPosting: isSet91(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      userIsBanned: isSet91(object.userIsBanned) ? Boolean(object.userIsBanned) : void 0,
      freeFormReports: isSet91(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      wikiEnabled: isSet91(object.wikiEnabled) ? Boolean(object.wikiEnabled) : void 0,
      userIsMuted: isSet91(object.userIsMuted) ? Boolean(object.userIsMuted) : void 0,
      userCanFlairInSr: isSet91(object.userCanFlairInSr) ? Boolean(object.userCanFlairInSr) : void 0,
      displayName: isSet91(object.displayName) ? String(object.displayName) : void 0,
      headerImg: isSet91(object.headerImg) ? String(object.headerImg) : void 0,
      title: isSet91(object.title) ? String(object.title) : void 0,
      allowGalleries: isSet91(object.allowGalleries) ? Boolean(object.allowGalleries) : void 0,
      iconSize: Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
      primaryColor: isSet91(object.primaryColor) ? String(object.primaryColor) : void 0,
      activeUserCount: isSet91(object.activeUserCount) ? Number(object.activeUserCount) : void 0,
      iconImg: isSet91(object.iconImg) ? String(object.iconImg) : void 0,
      displayNamePrefixed: isSet91(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : void 0,
      accountsActive: isSet91(object.accountsActive) ? Number(object.accountsActive) : void 0,
      publicTraffic: isSet91(object.publicTraffic) ? Boolean(object.publicTraffic) : void 0,
      subscribers: isSet91(object.subscribers) ? Number(object.subscribers) : void 0,
      userFlairRichtext: Array.isArray(object?.userFlairRichtext) ? object.userFlairRichtext.map((e) => String(e)) : [],
      videostreamLinksCount: isSet91(object.videostreamLinksCount) ? Number(object.videostreamLinksCount) : void 0,
      name: isSet91(object.name) ? String(object.name) : void 0,
      quarantine: isSet91(object.quarantine) ? Boolean(object.quarantine) : void 0,
      hideAds: isSet91(object.hideAds) ? Boolean(object.hideAds) : void 0,
      predictionLeaderboardEntryType: isSet91(object.predictionLeaderboardEntryType) ? String(object.predictionLeaderboardEntryType) : void 0,
      emojisEnabled: isSet91(object.emojisEnabled) ? Boolean(object.emojisEnabled) : void 0,
      advertiserCategory: isSet91(object.advertiserCategory) ? String(object.advertiserCategory) : void 0,
      publicDescription: isSet91(object.publicDescription) ? String(object.publicDescription) : void 0,
      commentScoreHideMins: isSet91(object.commentScoreHideMins) ? Number(object.commentScoreHideMins) : void 0,
      allowPredictions: isSet91(object.allowPredictions) ? Boolean(object.allowPredictions) : void 0,
      userHasFavorited: isSet91(object.userHasFavorited) ? Boolean(object.userHasFavorited) : void 0,
      userFlairTemplateId: isSet91(object.userFlairTemplateId) ? String(object.userFlairTemplateId) : void 0,
      communityIcon: isSet91(object.communityIcon) ? String(object.communityIcon) : void 0,
      bannerBackgroundImage: isSet91(object.bannerBackgroundImage) ? String(object.bannerBackgroundImage) : void 0,
      originalContentTagEnabled: isSet91(object.originalContentTagEnabled) ? Boolean(object.originalContentTagEnabled) : void 0,
      communityReviewed: isSet91(object.communityReviewed) ? Boolean(object.communityReviewed) : void 0,
      submitText: isSet91(object.submitText) ? String(object.submitText) : void 0,
      descriptionHtml: isSet91(object.descriptionHtml) ? String(object.descriptionHtml) : void 0,
      spoilersEnabled: isSet91(object.spoilersEnabled) ? Boolean(object.spoilersEnabled) : void 0,
      commentContributionSettings: isSet91(object.commentContributionSettings) ? CommentContributionSettings.fromJSON(object.commentContributionSettings) : void 0,
      allowTalks: isSet91(object.allowTalks) ? Boolean(object.allowTalks) : void 0,
      headerSize: Array.isArray(object?.headerSize) ? object.headerSize.map((e) => Number(e)) : [],
      userFlairPosition: isSet91(object.userFlairPosition) ? String(object.userFlairPosition) : void 0,
      allOriginalContent: isSet91(object.allOriginalContent) ? Boolean(object.allOriginalContent) : void 0,
      hasMenuWidget: isSet91(object.hasMenuWidget) ? Boolean(object.hasMenuWidget) : void 0,
      isEnrolledInNewModmail: isSet91(object.isEnrolledInNewModmail) ? Boolean(object.isEnrolledInNewModmail) : void 0,
      keyColor: isSet91(object.keyColor) ? String(object.keyColor) : void 0,
      canAssignUserFlair: isSet91(object.canAssignUserFlair) ? Boolean(object.canAssignUserFlair) : void 0,
      created: isSet91(object.created) ? Number(object.created) : void 0,
      wls: isSet91(object.wls) ? Number(object.wls) : void 0,
      showMediaPreview: isSet91(object.showMediaPreview) ? Boolean(object.showMediaPreview) : void 0,
      submissionType: isSet91(object.submissionType) ? String(object.submissionType) : void 0,
      userIsSubscriber: isSet91(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : void 0,
      allowedMediaInComments: Array.isArray(object?.allowedMediaInComments) ? object.allowedMediaInComments.map((e) => String(e)) : [],
      allowVideogifs: isSet91(object.allowVideogifs) ? Boolean(object.allowVideogifs) : void 0,
      shouldArchivePosts: isSet91(object.shouldArchivePosts) ? Boolean(object.shouldArchivePosts) : void 0,
      userFlairType: isSet91(object.userFlairType) ? String(object.userFlairType) : void 0,
      allowPolls: isSet91(object.allowPolls) ? Boolean(object.allowPolls) : void 0,
      collapseDeletedComments: isSet91(object.collapseDeletedComments) ? Boolean(object.collapseDeletedComments) : void 0,
      emojisCustomSize: Array.isArray(object?.emojisCustomSize) ? object.emojisCustomSize.map((e) => Number(e)) : [],
      publicDescriptionHtml: isSet91(object.publicDescriptionHtml) ? String(object.publicDescriptionHtml) : void 0,
      allowVideos: isSet91(object.allowVideos) ? Boolean(object.allowVideos) : void 0,
      isCrosspostableSubreddit: isSet91(object.isCrosspostableSubreddit) ? Boolean(object.isCrosspostableSubreddit) : void 0,
      notificationLevel: isSet91(object.notificationLevel) ? String(object.notificationLevel) : void 0,
      shouldShowMediaInCommentsSetting: isSet91(object.shouldShowMediaInCommentsSetting) ? Boolean(object.shouldShowMediaInCommentsSetting) : void 0,
      canAssignLinkFlair: isSet91(object.canAssignLinkFlair) ? Boolean(object.canAssignLinkFlair) : void 0,
      accountsActiveIsFuzzed: isSet91(object.accountsActiveIsFuzzed) ? Boolean(object.accountsActiveIsFuzzed) : void 0,
      allowPredictionContributors: isSet91(object.allowPredictionContributors) ? Boolean(object.allowPredictionContributors) : void 0,
      submitTextLabel: isSet91(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      linkFlairPosition: isSet91(object.linkFlairPosition) ? String(object.linkFlairPosition) : void 0,
      userSrFlairEnabled: isSet91(object.userSrFlairEnabled) ? Boolean(object.userSrFlairEnabled) : void 0,
      userFlairEnabledInSr: isSet91(object.userFlairEnabledInSr) ? Boolean(object.userFlairEnabledInSr) : void 0,
      allowChatPostCreation: isSet91(object.allowChatPostCreation) ? Boolean(object.allowChatPostCreation) : void 0,
      allowDiscovery: isSet91(object.allowDiscovery) ? Boolean(object.allowDiscovery) : void 0,
      acceptFollowers: isSet91(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      userSrThemeEnabled: isSet91(object.userSrThemeEnabled) ? Boolean(object.userSrThemeEnabled) : void 0,
      linkFlairEnabled: isSet91(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : void 0,
      disableContributorRequests: isSet91(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      subredditType: isSet91(object.subredditType) ? String(object.subredditType) : void 0,
      suggestedCommentSort: isSet91(object.suggestedCommentSort) ? String(object.suggestedCommentSort) : void 0,
      bannerImg: isSet91(object.bannerImg) ? String(object.bannerImg) : void 0,
      userFlairText: isSet91(object.userFlairText) ? String(object.userFlairText) : void 0,
      contentCategory: isSet91(object.contentCategory) ? String(object.contentCategory) : void 0,
      bannerBackgroundColor: isSet91(object.bannerBackgroundColor) ? String(object.bannerBackgroundColor) : void 0,
      showMedia: isSet91(object.showMedia) ? Boolean(object.showMedia) : void 0,
      id: isSet91(object.id) ? String(object.id) : void 0,
      userIsModerator: isSet91(object.userIsModerator) ? Boolean(object.userIsModerator) : void 0,
      over18: isSet91(object.over18) ? Boolean(object.over18) : void 0,
      headerTitle: isSet91(object.headerTitle) ? String(object.headerTitle) : void 0,
      description: isSet91(object.description) ? String(object.description) : void 0,
      isChatPostFeatureEnabled: isSet91(object.isChatPostFeatureEnabled) ? Boolean(object.isChatPostFeatureEnabled) : void 0,
      submitLinkLabel: isSet91(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      userFlairTextColor: isSet91(object.userFlairTextColor) ? String(object.userFlairTextColor) : void 0,
      restrictCommenting: isSet91(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      userFlairCssClass: isSet91(object.userFlairCssClass) ? String(object.userFlairCssClass) : void 0,
      allowImages: isSet91(object.allowImages) ? Boolean(object.allowImages) : void 0,
      lang: isSet91(object.lang) ? String(object.lang) : void 0,
      whitelistStatus: isSet91(object.whitelistStatus) ? String(object.whitelistStatus) : void 0,
      url: isSet91(object.url) ? String(object.url) : void 0,
      createdUtc: isSet91(object.createdUtc) ? Number(object.createdUtc) : void 0,
      bannerSize: Array.isArray(object?.bannerSize) ? object.bannerSize.map((e) => Number(e)) : [],
      mobileBannerImage: isSet91(object.mobileBannerImage) ? String(object.mobileBannerImage) : void 0,
      userIsContributor: isSet91(object.userIsContributor) ? Boolean(object.userIsContributor) : void 0,
      allowPredictionsTournament: isSet91(object.allowPredictionsTournament) ? Boolean(object.allowPredictionsTournament) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.userFlairBackgroundColor !== void 0 && (obj.userFlairBackgroundColor = message.userFlairBackgroundColor);
    message.submitTextHtml !== void 0 && (obj.submitTextHtml = message.submitTextHtml);
    message.restrictPosting !== void 0 && (obj.restrictPosting = message.restrictPosting);
    message.userIsBanned !== void 0 && (obj.userIsBanned = message.userIsBanned);
    message.freeFormReports !== void 0 && (obj.freeFormReports = message.freeFormReports);
    message.wikiEnabled !== void 0 && (obj.wikiEnabled = message.wikiEnabled);
    message.userIsMuted !== void 0 && (obj.userIsMuted = message.userIsMuted);
    message.userCanFlairInSr !== void 0 && (obj.userCanFlairInSr = message.userCanFlairInSr);
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    message.headerImg !== void 0 && (obj.headerImg = message.headerImg);
    message.title !== void 0 && (obj.title = message.title);
    message.allowGalleries !== void 0 && (obj.allowGalleries = message.allowGalleries);
    if (message.iconSize) {
      obj.iconSize = message.iconSize.map((e) => e);
    } else {
      obj.iconSize = [];
    }
    message.primaryColor !== void 0 && (obj.primaryColor = message.primaryColor);
    message.activeUserCount !== void 0 && (obj.activeUserCount = message.activeUserCount);
    message.iconImg !== void 0 && (obj.iconImg = message.iconImg);
    message.displayNamePrefixed !== void 0 && (obj.displayNamePrefixed = message.displayNamePrefixed);
    message.accountsActive !== void 0 && (obj.accountsActive = message.accountsActive);
    message.publicTraffic !== void 0 && (obj.publicTraffic = message.publicTraffic);
    message.subscribers !== void 0 && (obj.subscribers = message.subscribers);
    if (message.userFlairRichtext) {
      obj.userFlairRichtext = message.userFlairRichtext.map((e) => e);
    } else {
      obj.userFlairRichtext = [];
    }
    message.videostreamLinksCount !== void 0 && (obj.videostreamLinksCount = message.videostreamLinksCount);
    message.name !== void 0 && (obj.name = message.name);
    message.quarantine !== void 0 && (obj.quarantine = message.quarantine);
    message.hideAds !== void 0 && (obj.hideAds = message.hideAds);
    message.predictionLeaderboardEntryType !== void 0 && (obj.predictionLeaderboardEntryType = message.predictionLeaderboardEntryType);
    message.emojisEnabled !== void 0 && (obj.emojisEnabled = message.emojisEnabled);
    message.advertiserCategory !== void 0 && (obj.advertiserCategory = message.advertiserCategory);
    message.publicDescription !== void 0 && (obj.publicDescription = message.publicDescription);
    message.commentScoreHideMins !== void 0 && (obj.commentScoreHideMins = message.commentScoreHideMins);
    message.allowPredictions !== void 0 && (obj.allowPredictions = message.allowPredictions);
    message.userHasFavorited !== void 0 && (obj.userHasFavorited = message.userHasFavorited);
    message.userFlairTemplateId !== void 0 && (obj.userFlairTemplateId = message.userFlairTemplateId);
    message.communityIcon !== void 0 && (obj.communityIcon = message.communityIcon);
    message.bannerBackgroundImage !== void 0 && (obj.bannerBackgroundImage = message.bannerBackgroundImage);
    message.originalContentTagEnabled !== void 0 && (obj.originalContentTagEnabled = message.originalContentTagEnabled);
    message.communityReviewed !== void 0 && (obj.communityReviewed = message.communityReviewed);
    message.submitText !== void 0 && (obj.submitText = message.submitText);
    message.descriptionHtml !== void 0 && (obj.descriptionHtml = message.descriptionHtml);
    message.spoilersEnabled !== void 0 && (obj.spoilersEnabled = message.spoilersEnabled);
    message.commentContributionSettings !== void 0 && (obj.commentContributionSettings = message.commentContributionSettings ? CommentContributionSettings.toJSON(message.commentContributionSettings) : void 0);
    message.allowTalks !== void 0 && (obj.allowTalks = message.allowTalks);
    if (message.headerSize) {
      obj.headerSize = message.headerSize.map((e) => e);
    } else {
      obj.headerSize = [];
    }
    message.userFlairPosition !== void 0 && (obj.userFlairPosition = message.userFlairPosition);
    message.allOriginalContent !== void 0 && (obj.allOriginalContent = message.allOriginalContent);
    message.hasMenuWidget !== void 0 && (obj.hasMenuWidget = message.hasMenuWidget);
    message.isEnrolledInNewModmail !== void 0 && (obj.isEnrolledInNewModmail = message.isEnrolledInNewModmail);
    message.keyColor !== void 0 && (obj.keyColor = message.keyColor);
    message.canAssignUserFlair !== void 0 && (obj.canAssignUserFlair = message.canAssignUserFlair);
    message.created !== void 0 && (obj.created = message.created);
    message.wls !== void 0 && (obj.wls = message.wls);
    message.showMediaPreview !== void 0 && (obj.showMediaPreview = message.showMediaPreview);
    message.submissionType !== void 0 && (obj.submissionType = message.submissionType);
    message.userIsSubscriber !== void 0 && (obj.userIsSubscriber = message.userIsSubscriber);
    if (message.allowedMediaInComments) {
      obj.allowedMediaInComments = message.allowedMediaInComments.map((e) => e);
    } else {
      obj.allowedMediaInComments = [];
    }
    message.allowVideogifs !== void 0 && (obj.allowVideogifs = message.allowVideogifs);
    message.shouldArchivePosts !== void 0 && (obj.shouldArchivePosts = message.shouldArchivePosts);
    message.userFlairType !== void 0 && (obj.userFlairType = message.userFlairType);
    message.allowPolls !== void 0 && (obj.allowPolls = message.allowPolls);
    message.collapseDeletedComments !== void 0 && (obj.collapseDeletedComments = message.collapseDeletedComments);
    if (message.emojisCustomSize) {
      obj.emojisCustomSize = message.emojisCustomSize.map((e) => e);
    } else {
      obj.emojisCustomSize = [];
    }
    message.publicDescriptionHtml !== void 0 && (obj.publicDescriptionHtml = message.publicDescriptionHtml);
    message.allowVideos !== void 0 && (obj.allowVideos = message.allowVideos);
    message.isCrosspostableSubreddit !== void 0 && (obj.isCrosspostableSubreddit = message.isCrosspostableSubreddit);
    message.notificationLevel !== void 0 && (obj.notificationLevel = message.notificationLevel);
    message.shouldShowMediaInCommentsSetting !== void 0 && (obj.shouldShowMediaInCommentsSetting = message.shouldShowMediaInCommentsSetting);
    message.canAssignLinkFlair !== void 0 && (obj.canAssignLinkFlair = message.canAssignLinkFlair);
    message.accountsActiveIsFuzzed !== void 0 && (obj.accountsActiveIsFuzzed = message.accountsActiveIsFuzzed);
    message.allowPredictionContributors !== void 0 && (obj.allowPredictionContributors = message.allowPredictionContributors);
    message.submitTextLabel !== void 0 && (obj.submitTextLabel = message.submitTextLabel);
    message.linkFlairPosition !== void 0 && (obj.linkFlairPosition = message.linkFlairPosition);
    message.userSrFlairEnabled !== void 0 && (obj.userSrFlairEnabled = message.userSrFlairEnabled);
    message.userFlairEnabledInSr !== void 0 && (obj.userFlairEnabledInSr = message.userFlairEnabledInSr);
    message.allowChatPostCreation !== void 0 && (obj.allowChatPostCreation = message.allowChatPostCreation);
    message.allowDiscovery !== void 0 && (obj.allowDiscovery = message.allowDiscovery);
    message.acceptFollowers !== void 0 && (obj.acceptFollowers = message.acceptFollowers);
    message.userSrThemeEnabled !== void 0 && (obj.userSrThemeEnabled = message.userSrThemeEnabled);
    message.linkFlairEnabled !== void 0 && (obj.linkFlairEnabled = message.linkFlairEnabled);
    message.disableContributorRequests !== void 0 && (obj.disableContributorRequests = message.disableContributorRequests);
    message.subredditType !== void 0 && (obj.subredditType = message.subredditType);
    message.suggestedCommentSort !== void 0 && (obj.suggestedCommentSort = message.suggestedCommentSort);
    message.bannerImg !== void 0 && (obj.bannerImg = message.bannerImg);
    message.userFlairText !== void 0 && (obj.userFlairText = message.userFlairText);
    message.contentCategory !== void 0 && (obj.contentCategory = message.contentCategory);
    message.bannerBackgroundColor !== void 0 && (obj.bannerBackgroundColor = message.bannerBackgroundColor);
    message.showMedia !== void 0 && (obj.showMedia = message.showMedia);
    message.id !== void 0 && (obj.id = message.id);
    message.userIsModerator !== void 0 && (obj.userIsModerator = message.userIsModerator);
    message.over18 !== void 0 && (obj.over18 = message.over18);
    message.headerTitle !== void 0 && (obj.headerTitle = message.headerTitle);
    message.description !== void 0 && (obj.description = message.description);
    message.isChatPostFeatureEnabled !== void 0 && (obj.isChatPostFeatureEnabled = message.isChatPostFeatureEnabled);
    message.submitLinkLabel !== void 0 && (obj.submitLinkLabel = message.submitLinkLabel);
    message.userFlairTextColor !== void 0 && (obj.userFlairTextColor = message.userFlairTextColor);
    message.restrictCommenting !== void 0 && (obj.restrictCommenting = message.restrictCommenting);
    message.userFlairCssClass !== void 0 && (obj.userFlairCssClass = message.userFlairCssClass);
    message.allowImages !== void 0 && (obj.allowImages = message.allowImages);
    message.lang !== void 0 && (obj.lang = message.lang);
    message.whitelistStatus !== void 0 && (obj.whitelistStatus = message.whitelistStatus);
    message.url !== void 0 && (obj.url = message.url);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    if (message.bannerSize) {
      obj.bannerSize = message.bannerSize.map((e) => e);
    } else {
      obj.bannerSize = [];
    }
    message.mobileBannerImage !== void 0 && (obj.mobileBannerImage = message.mobileBannerImage);
    message.userIsContributor !== void 0 && (obj.userIsContributor = message.userIsContributor);
    message.allowPredictionsTournament !== void 0 && (obj.allowPredictionsTournament = message.allowPredictionsTournament);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFullSubredditObject();
    message.userFlairBackgroundColor = object.userFlairBackgroundColor ?? void 0;
    message.submitTextHtml = object.submitTextHtml ?? void 0;
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.userIsBanned = object.userIsBanned ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.wikiEnabled = object.wikiEnabled ?? void 0;
    message.userIsMuted = object.userIsMuted ?? void 0;
    message.userCanFlairInSr = object.userCanFlairInSr ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.headerImg = object.headerImg ?? void 0;
    message.title = object.title ?? void 0;
    message.allowGalleries = object.allowGalleries ?? void 0;
    message.iconSize = object.iconSize?.map((e) => e) || [];
    message.primaryColor = object.primaryColor ?? void 0;
    message.activeUserCount = object.activeUserCount ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.displayNamePrefixed = object.displayNamePrefixed ?? void 0;
    message.accountsActive = object.accountsActive ?? void 0;
    message.publicTraffic = object.publicTraffic ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.userFlairRichtext = object.userFlairRichtext?.map((e) => e) || [];
    message.videostreamLinksCount = object.videostreamLinksCount ?? void 0;
    message.name = object.name ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.hideAds = object.hideAds ?? void 0;
    message.predictionLeaderboardEntryType = object.predictionLeaderboardEntryType ?? void 0;
    message.emojisEnabled = object.emojisEnabled ?? void 0;
    message.advertiserCategory = object.advertiserCategory ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.commentScoreHideMins = object.commentScoreHideMins ?? void 0;
    message.allowPredictions = object.allowPredictions ?? void 0;
    message.userHasFavorited = object.userHasFavorited ?? void 0;
    message.userFlairTemplateId = object.userFlairTemplateId ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.bannerBackgroundImage = object.bannerBackgroundImage ?? void 0;
    message.originalContentTagEnabled = object.originalContentTagEnabled ?? void 0;
    message.communityReviewed = object.communityReviewed ?? void 0;
    message.submitText = object.submitText ?? void 0;
    message.descriptionHtml = object.descriptionHtml ?? void 0;
    message.spoilersEnabled = object.spoilersEnabled ?? void 0;
    message.commentContributionSettings = object.commentContributionSettings !== void 0 && object.commentContributionSettings !== null ? CommentContributionSettings.fromPartial(object.commentContributionSettings) : void 0;
    message.allowTalks = object.allowTalks ?? void 0;
    message.headerSize = object.headerSize?.map((e) => e) || [];
    message.userFlairPosition = object.userFlairPosition ?? void 0;
    message.allOriginalContent = object.allOriginalContent ?? void 0;
    message.hasMenuWidget = object.hasMenuWidget ?? void 0;
    message.isEnrolledInNewModmail = object.isEnrolledInNewModmail ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.canAssignUserFlair = object.canAssignUserFlair ?? void 0;
    message.created = object.created ?? void 0;
    message.wls = object.wls ?? void 0;
    message.showMediaPreview = object.showMediaPreview ?? void 0;
    message.submissionType = object.submissionType ?? void 0;
    message.userIsSubscriber = object.userIsSubscriber ?? void 0;
    message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
    message.allowVideogifs = object.allowVideogifs ?? void 0;
    message.shouldArchivePosts = object.shouldArchivePosts ?? void 0;
    message.userFlairType = object.userFlairType ?? void 0;
    message.allowPolls = object.allowPolls ?? void 0;
    message.collapseDeletedComments = object.collapseDeletedComments ?? void 0;
    message.emojisCustomSize = object.emojisCustomSize?.map((e) => e) || [];
    message.publicDescriptionHtml = object.publicDescriptionHtml ?? void 0;
    message.allowVideos = object.allowVideos ?? void 0;
    message.isCrosspostableSubreddit = object.isCrosspostableSubreddit ?? void 0;
    message.notificationLevel = object.notificationLevel ?? void 0;
    message.shouldShowMediaInCommentsSetting = object.shouldShowMediaInCommentsSetting ?? void 0;
    message.canAssignLinkFlair = object.canAssignLinkFlair ?? void 0;
    message.accountsActiveIsFuzzed = object.accountsActiveIsFuzzed ?? void 0;
    message.allowPredictionContributors = object.allowPredictionContributors ?? void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.linkFlairPosition = object.linkFlairPosition ?? void 0;
    message.userSrFlairEnabled = object.userSrFlairEnabled ?? void 0;
    message.userFlairEnabledInSr = object.userFlairEnabledInSr ?? void 0;
    message.allowChatPostCreation = object.allowChatPostCreation ?? void 0;
    message.allowDiscovery = object.allowDiscovery ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.userSrThemeEnabled = object.userSrThemeEnabled ?? void 0;
    message.linkFlairEnabled = object.linkFlairEnabled ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.suggestedCommentSort = object.suggestedCommentSort ?? void 0;
    message.bannerImg = object.bannerImg ?? void 0;
    message.userFlairText = object.userFlairText ?? void 0;
    message.contentCategory = object.contentCategory ?? void 0;
    message.bannerBackgroundColor = object.bannerBackgroundColor ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.id = object.id ?? void 0;
    message.userIsModerator = object.userIsModerator ?? void 0;
    message.over18 = object.over18 ?? void 0;
    message.headerTitle = object.headerTitle ?? void 0;
    message.description = object.description ?? void 0;
    message.isChatPostFeatureEnabled = object.isChatPostFeatureEnabled ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.userFlairTextColor = object.userFlairTextColor ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.userFlairCssClass = object.userFlairCssClass ?? void 0;
    message.allowImages = object.allowImages ?? void 0;
    message.lang = object.lang ?? void 0;
    message.whitelistStatus = object.whitelistStatus ?? void 0;
    message.url = object.url ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.bannerSize = object.bannerSize?.map((e) => e) || [];
    message.mobileBannerImage = object.mobileBannerImage ?? void 0;
    message.userIsContributor = object.userIsContributor ?? void 0;
    message.allowPredictionsTournament = object.allowPredictionsTournament ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.FullSubredditObject", FullSubredditObject);
function createBaseSubredditsSearchResponse() {
  return { kind: void 0, data: void 0 };
}
var SubredditsSearchResponse = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      SubredditsSearchResponse_WrappedSubredditObject.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = SubredditsSearchResponse_WrappedSubredditObject.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet91(object.kind) ? String(object.kind) : void 0,
      data: isSet91(object.data) ? SubredditsSearchResponse_WrappedSubredditObject.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? SubredditsSearchResponse_WrappedSubredditObject.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditsSearchResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? SubredditsSearchResponse_WrappedSubredditObject.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditsSearchResponse", SubredditsSearchResponse);
function createBaseSubredditsSearchResponse_WrappedSubredditObject() {
  return { after: void 0, before: void 0, dist: void 0, geoFilter: void 0, children: [] };
}
var SubredditsSearchResponse_WrappedSubredditObject = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse.WrappedSubredditObject",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int32Value.encode({ value: message.dist }, writer.uint32(26).fork()).ldelim();
    }
    if (message.geoFilter !== void 0) {
      StringValue.encode({ value: message.geoFilter }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.children) {
      SubredditsSearchResponse_WrappedSubredditObject_SubredditData.encode(v, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsSearchResponse_WrappedSubredditObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.dist = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.geoFilter = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.children.push(SubredditsSearchResponse_WrappedSubredditObject_SubredditData.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet91(object.after) ? String(object.after) : void 0,
      before: isSet91(object.before) ? String(object.before) : void 0,
      dist: isSet91(object.dist) ? Number(object.dist) : void 0,
      geoFilter: isSet91(object.geoFilter) ? String(object.geoFilter) : void 0,
      children: Array.isArray(object?.children) ? object.children.map((e) => SubredditsSearchResponse_WrappedSubredditObject_SubredditData.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.dist !== void 0 && (obj.dist = message.dist);
    message.geoFilter !== void 0 && (obj.geoFilter = message.geoFilter);
    if (message.children) {
      obj.children = message.children.map((e) => e ? SubredditsSearchResponse_WrappedSubredditObject_SubredditData.toJSON(e) : void 0);
    } else {
      obj.children = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditsSearchResponse_WrappedSubredditObject();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.dist = object.dist ?? void 0;
    message.geoFilter = object.geoFilter ?? void 0;
    message.children = object.children?.map((e) => SubredditsSearchResponse_WrappedSubredditObject_SubredditData.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditsSearchResponse.WrappedSubredditObject", SubredditsSearchResponse_WrappedSubredditObject);
function createBaseSubredditsSearchResponse_WrappedSubredditObject_SubredditData() {
  return { kind: void 0, data: void 0 };
}
var SubredditsSearchResponse_WrappedSubredditObject_SubredditData = {
  $type: "devvit.plugin.redditapi.subreddits.SubredditsSearchResponse.WrappedSubredditObject.SubredditData",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      FullSubredditObject.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubredditsSearchResponse_WrappedSubredditObject_SubredditData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = FullSubredditObject.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet91(object.kind) ? String(object.kind) : void 0,
      data: isSet91(object.data) ? FullSubredditObject.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? FullSubredditObject.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSubredditsSearchResponse_WrappedSubredditObject_SubredditData();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? FullSubredditObject.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.SubredditsSearchResponse.WrappedSubredditObject.SubredditData", SubredditsSearchResponse_WrappedSubredditObject_SubredditData);
function createBaseUserSearchResponse() {
  return { kind: void 0, data: void 0 };
}
var UserSearchResponse = {
  $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      UserSearchResponse_AccData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = UserSearchResponse_AccData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet91(object.kind) ? String(object.kind) : void 0,
      data: isSet91(object.data) ? UserSearchResponse_AccData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? UserSearchResponse_AccData.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserSearchResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? UserSearchResponse_AccData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UserSearchResponse", UserSearchResponse);
function createBaseUserSearchResponse_AccData() {
  return {
    after: void 0,
    dist: void 0,
    modhash: void 0,
    geoFilter: void 0,
    children: [],
    before: void 0
  };
}
var UserSearchResponse_AccData = {
  $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.AccData",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int64Value.encode({ value: message.dist }, writer.uint32(18).fork()).ldelim();
    }
    if (message.modhash !== void 0) {
      StringValue.encode({ value: message.modhash }, writer.uint32(26).fork()).ldelim();
    }
    if (message.geoFilter !== void 0) {
      StringValue.encode({ value: message.geoFilter }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.children) {
      UserSearchResponse_Account.encode(v, writer.uint32(42).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserSearchResponse_AccData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.dist = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.modhash = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.geoFilter = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.children.push(UserSearchResponse_Account.decode(reader, reader.uint32()));
          break;
        case 6:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet91(object.after) ? String(object.after) : void 0,
      dist: isSet91(object.dist) ? Number(object.dist) : void 0,
      modhash: isSet91(object.modhash) ? String(object.modhash) : void 0,
      geoFilter: isSet91(object.geoFilter) ? String(object.geoFilter) : void 0,
      children: Array.isArray(object?.children) ? object.children.map((e) => UserSearchResponse_Account.fromJSON(e)) : [],
      before: isSet91(object.before) ? String(object.before) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.dist !== void 0 && (obj.dist = message.dist);
    message.modhash !== void 0 && (obj.modhash = message.modhash);
    message.geoFilter !== void 0 && (obj.geoFilter = message.geoFilter);
    if (message.children) {
      obj.children = message.children.map((e) => e ? UserSearchResponse_Account.toJSON(e) : void 0);
    } else {
      obj.children = [];
    }
    message.before !== void 0 && (obj.before = message.before);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserSearchResponse_AccData();
    message.after = object.after ?? void 0;
    message.dist = object.dist ?? void 0;
    message.modhash = object.modhash ?? void 0;
    message.geoFilter = object.geoFilter ?? void 0;
    message.children = object.children?.map((e) => UserSearchResponse_Account.fromPartial(e)) || [];
    message.before = object.before ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UserSearchResponse.AccData", UserSearchResponse_AccData);
function createBaseUserSearchResponse_Account() {
  return { kind: void 0, data: void 0 };
}
var UserSearchResponse_Account = {
  $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.Account",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      UserSearchResponse_AccountData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserSearchResponse_Account();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = UserSearchResponse_AccountData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet91(object.kind) ? String(object.kind) : void 0,
      data: isSet91(object.data) ? UserSearchResponse_AccountData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? UserSearchResponse_AccountData.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserSearchResponse_Account();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? UserSearchResponse_AccountData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UserSearchResponse.Account", UserSearchResponse_Account);
function createBaseUserSearchResponse_AccountData() {
  return {
    isEmployee: void 0,
    isFriend: void 0,
    snoovatarSize: [],
    id: void 0,
    verified: void 0,
    isGold: void 0,
    isMod: void 0,
    hasVerifiedEmail: void 0,
    iconImg: void 0,
    hideFromRobots: void 0,
    linkKarma: void 0,
    acceptChats: void 0,
    isBlocked: void 0,
    prefShowSnoovatar: void 0,
    name: void 0,
    created: void 0,
    createdUtc: void 0,
    snoovatarImg: void 0,
    commentKarma: void 0,
    acceptFollowers: void 0,
    hasSubscribed: void 0,
    acceptPms: void 0,
    isSuspended: void 0,
    subreddit: void 0
  };
}
var UserSearchResponse_AccountData = {
  $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.AccountData",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.isEmployee !== void 0) {
      BoolValue.encode({ value: message.isEmployee }, writer.uint32(10).fork()).ldelim();
    }
    if (message.isFriend !== void 0) {
      BoolValue.encode({ value: message.isFriend }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.snoovatarSize) {
      Int32Value.encode({ value: v }, writer.uint32(26).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(34).fork()).ldelim();
    }
    if (message.verified !== void 0) {
      BoolValue.encode({ value: message.verified }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isGold !== void 0) {
      BoolValue.encode({ value: message.isGold }, writer.uint32(50).fork()).ldelim();
    }
    if (message.isMod !== void 0) {
      BoolValue.encode({ value: message.isMod }, writer.uint32(58).fork()).ldelim();
    }
    if (message.hasVerifiedEmail !== void 0) {
      BoolValue.encode({ value: message.hasVerifiedEmail }, writer.uint32(66).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(74).fork()).ldelim();
    }
    if (message.hideFromRobots !== void 0) {
      BoolValue.encode({ value: message.hideFromRobots }, writer.uint32(82).fork()).ldelim();
    }
    if (message.linkKarma !== void 0) {
      Int32Value.encode({ value: message.linkKarma }, writer.uint32(90).fork()).ldelim();
    }
    if (message.acceptChats !== void 0) {
      BoolValue.encode({ value: message.acceptChats }, writer.uint32(98).fork()).ldelim();
    }
    if (message.isBlocked !== void 0) {
      BoolValue.encode({ value: message.isBlocked }, writer.uint32(106).fork()).ldelim();
    }
    if (message.prefShowSnoovatar !== void 0) {
      BoolValue.encode({ value: message.prefShowSnoovatar }, writer.uint32(114).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(122).fork()).ldelim();
    }
    if (message.created !== void 0) {
      Int64Value.encode({ value: message.created }, writer.uint32(130).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(138).fork()).ldelim();
    }
    if (message.snoovatarImg !== void 0) {
      StringValue.encode({ value: message.snoovatarImg }, writer.uint32(146).fork()).ldelim();
    }
    if (message.commentKarma !== void 0) {
      Int64Value.encode({ value: message.commentKarma }, writer.uint32(154).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(162).fork()).ldelim();
    }
    if (message.hasSubscribed !== void 0) {
      BoolValue.encode({ value: message.hasSubscribed }, writer.uint32(170).fork()).ldelim();
    }
    if (message.acceptPms !== void 0) {
      BoolValue.encode({ value: message.acceptPms }, writer.uint32(178).fork()).ldelim();
    }
    if (message.isSuspended !== void 0) {
      BoolValue.encode({ value: message.isSuspended }, writer.uint32(186).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      UserSearchResponse_AccountData_Subreddit.encode(message.subreddit, writer.uint32(194).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserSearchResponse_AccountData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isEmployee = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.isFriend = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.snoovatarSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 4:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.verified = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.isGold = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.isMod = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.hasVerifiedEmail = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.hideFromRobots = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.linkKarma = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.acceptChats = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.isBlocked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.prefShowSnoovatar = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.created = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.snoovatarImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.commentKarma = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.hasSubscribed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.acceptPms = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.isSuspended = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.subreddit = UserSearchResponse_AccountData_Subreddit.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      isEmployee: isSet91(object.isEmployee) ? Boolean(object.isEmployee) : void 0,
      isFriend: isSet91(object.isFriend) ? Boolean(object.isFriend) : void 0,
      snoovatarSize: Array.isArray(object?.snoovatarSize) ? object.snoovatarSize.map((e) => Number(e)) : [],
      id: isSet91(object.id) ? String(object.id) : void 0,
      verified: isSet91(object.verified) ? Boolean(object.verified) : void 0,
      isGold: isSet91(object.isGold) ? Boolean(object.isGold) : void 0,
      isMod: isSet91(object.isMod) ? Boolean(object.isMod) : void 0,
      hasVerifiedEmail: isSet91(object.hasVerifiedEmail) ? Boolean(object.hasVerifiedEmail) : void 0,
      iconImg: isSet91(object.iconImg) ? String(object.iconImg) : void 0,
      hideFromRobots: isSet91(object.hideFromRobots) ? Boolean(object.hideFromRobots) : void 0,
      linkKarma: isSet91(object.linkKarma) ? Number(object.linkKarma) : void 0,
      acceptChats: isSet91(object.acceptChats) ? Boolean(object.acceptChats) : void 0,
      isBlocked: isSet91(object.isBlocked) ? Boolean(object.isBlocked) : void 0,
      prefShowSnoovatar: isSet91(object.prefShowSnoovatar) ? Boolean(object.prefShowSnoovatar) : void 0,
      name: isSet91(object.name) ? String(object.name) : void 0,
      created: isSet91(object.created) ? Number(object.created) : void 0,
      createdUtc: isSet91(object.createdUtc) ? Number(object.createdUtc) : void 0,
      snoovatarImg: isSet91(object.snoovatarImg) ? String(object.snoovatarImg) : void 0,
      commentKarma: isSet91(object.commentKarma) ? Number(object.commentKarma) : void 0,
      acceptFollowers: isSet91(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      hasSubscribed: isSet91(object.hasSubscribed) ? Boolean(object.hasSubscribed) : void 0,
      acceptPms: isSet91(object.acceptPms) ? Boolean(object.acceptPms) : void 0,
      isSuspended: isSet91(object.isSuspended) ? Boolean(object.isSuspended) : void 0,
      subreddit: isSet91(object.subreddit) ? UserSearchResponse_AccountData_Subreddit.fromJSON(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.isEmployee !== void 0 && (obj.isEmployee = message.isEmployee);
    message.isFriend !== void 0 && (obj.isFriend = message.isFriend);
    if (message.snoovatarSize) {
      obj.snoovatarSize = message.snoovatarSize.map((e) => e);
    } else {
      obj.snoovatarSize = [];
    }
    message.id !== void 0 && (obj.id = message.id);
    message.verified !== void 0 && (obj.verified = message.verified);
    message.isGold !== void 0 && (obj.isGold = message.isGold);
    message.isMod !== void 0 && (obj.isMod = message.isMod);
    message.hasVerifiedEmail !== void 0 && (obj.hasVerifiedEmail = message.hasVerifiedEmail);
    message.iconImg !== void 0 && (obj.iconImg = message.iconImg);
    message.hideFromRobots !== void 0 && (obj.hideFromRobots = message.hideFromRobots);
    message.linkKarma !== void 0 && (obj.linkKarma = message.linkKarma);
    message.acceptChats !== void 0 && (obj.acceptChats = message.acceptChats);
    message.isBlocked !== void 0 && (obj.isBlocked = message.isBlocked);
    message.prefShowSnoovatar !== void 0 && (obj.prefShowSnoovatar = message.prefShowSnoovatar);
    message.name !== void 0 && (obj.name = message.name);
    message.created !== void 0 && (obj.created = message.created);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    message.snoovatarImg !== void 0 && (obj.snoovatarImg = message.snoovatarImg);
    message.commentKarma !== void 0 && (obj.commentKarma = message.commentKarma);
    message.acceptFollowers !== void 0 && (obj.acceptFollowers = message.acceptFollowers);
    message.hasSubscribed !== void 0 && (obj.hasSubscribed = message.hasSubscribed);
    message.acceptPms !== void 0 && (obj.acceptPms = message.acceptPms);
    message.isSuspended !== void 0 && (obj.isSuspended = message.isSuspended);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit ? UserSearchResponse_AccountData_Subreddit.toJSON(message.subreddit) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserSearchResponse_AccountData();
    message.isEmployee = object.isEmployee ?? void 0;
    message.isFriend = object.isFriend ?? void 0;
    message.snoovatarSize = object.snoovatarSize?.map((e) => e) || [];
    message.id = object.id ?? void 0;
    message.verified = object.verified ?? void 0;
    message.isGold = object.isGold ?? void 0;
    message.isMod = object.isMod ?? void 0;
    message.hasVerifiedEmail = object.hasVerifiedEmail ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.hideFromRobots = object.hideFromRobots ?? void 0;
    message.linkKarma = object.linkKarma ?? void 0;
    message.acceptChats = object.acceptChats ?? void 0;
    message.isBlocked = object.isBlocked ?? void 0;
    message.prefShowSnoovatar = object.prefShowSnoovatar ?? void 0;
    message.name = object.name ?? void 0;
    message.created = object.created ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.snoovatarImg = object.snoovatarImg ?? void 0;
    message.commentKarma = object.commentKarma ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.hasSubscribed = object.hasSubscribed ?? void 0;
    message.acceptPms = object.acceptPms ?? void 0;
    message.isSuspended = object.isSuspended ?? void 0;
    message.subreddit = object.subreddit !== void 0 && object.subreddit !== null ? UserSearchResponse_AccountData_Subreddit.fromPartial(object.subreddit) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UserSearchResponse.AccountData", UserSearchResponse_AccountData);
function createBaseUserSearchResponse_AccountData_Subreddit() {
  return {
    defaultSet: void 0,
    userIsContributor: void 0,
    bannerImg: void 0,
    allowedMediaInComments: [],
    userIsBanned: void 0,
    freeFormReports: void 0,
    communityIcon: void 0,
    showMedia: void 0,
    iconColor: void 0,
    userIsMuted: void 0,
    displayName: void 0,
    headerImg: void 0,
    title: void 0,
    previousNames: [],
    over18: void 0,
    iconSize: [],
    primaryColor: void 0,
    iconImg: void 0,
    description: void 0,
    submitLinkLabel: void 0,
    headerSize: [],
    restrictPosting: void 0,
    restrictCommenting: void 0,
    subscribers: void 0,
    submitTextLabel: void 0,
    isDefaultIcon: void 0,
    linkFlairPosition: void 0,
    displayNamePrefixed: void 0,
    keyColor: void 0,
    name: void 0,
    isDefaultBanner: void 0,
    url: void 0,
    quarantine: void 0,
    bannerSize: [],
    userIsModerator: void 0,
    acceptFollowers: void 0,
    publicDescription: void 0,
    linkFlairEnabled: void 0,
    disableContributorRequests: void 0,
    subredditType: void 0,
    userIsSubscriber: void 0
  };
}
var UserSearchResponse_AccountData_Subreddit = {
  $type: "devvit.plugin.redditapi.subreddits.UserSearchResponse.AccountData.Subreddit",
  encode(message, writer = import_minimal106.default.Writer.create()) {
    if (message.defaultSet !== void 0) {
      BoolValue.encode({ value: message.defaultSet }, writer.uint32(10).fork()).ldelim();
    }
    if (message.userIsContributor !== void 0) {
      BoolValue.encode({ value: message.userIsContributor }, writer.uint32(18).fork()).ldelim();
    }
    if (message.bannerImg !== void 0) {
      StringValue.encode({ value: message.bannerImg }, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.allowedMediaInComments) {
      StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
    }
    if (message.userIsBanned !== void 0) {
      BoolValue.encode({ value: message.userIsBanned }, writer.uint32(42).fork()).ldelim();
    }
    if (message.freeFormReports !== void 0) {
      BoolValue.encode({ value: message.freeFormReports }, writer.uint32(50).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(58).fork()).ldelim();
    }
    if (message.showMedia !== void 0) {
      BoolValue.encode({ value: message.showMedia }, writer.uint32(66).fork()).ldelim();
    }
    if (message.iconColor !== void 0) {
      StringValue.encode({ value: message.iconColor }, writer.uint32(74).fork()).ldelim();
    }
    if (message.userIsMuted !== void 0) {
      BoolValue.encode({ value: message.userIsMuted }, writer.uint32(82).fork()).ldelim();
    }
    if (message.displayName !== void 0) {
      StringValue.encode({ value: message.displayName }, writer.uint32(90).fork()).ldelim();
    }
    if (message.headerImg !== void 0) {
      StringValue.encode({ value: message.headerImg }, writer.uint32(98).fork()).ldelim();
    }
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(106).fork()).ldelim();
    }
    for (const v of message.previousNames) {
      StringValue.encode({ value: v }, writer.uint32(114).fork()).ldelim();
    }
    if (message.over18 !== void 0) {
      BoolValue.encode({ value: message.over18 }, writer.uint32(122).fork()).ldelim();
    }
    for (const v of message.iconSize) {
      Int32Value.encode({ value: v }, writer.uint32(130).fork()).ldelim();
    }
    if (message.primaryColor !== void 0) {
      StringValue.encode({ value: message.primaryColor }, writer.uint32(138).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(146).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(154).fork()).ldelim();
    }
    if (message.submitLinkLabel !== void 0) {
      StringValue.encode({ value: message.submitLinkLabel }, writer.uint32(162).fork()).ldelim();
    }
    for (const v of message.headerSize) {
      Int32Value.encode({ value: v }, writer.uint32(170).fork()).ldelim();
    }
    if (message.restrictPosting !== void 0) {
      BoolValue.encode({ value: message.restrictPosting }, writer.uint32(178).fork()).ldelim();
    }
    if (message.restrictCommenting !== void 0) {
      BoolValue.encode({ value: message.restrictCommenting }, writer.uint32(186).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int64Value.encode({ value: message.subscribers }, writer.uint32(194).fork()).ldelim();
    }
    if (message.submitTextLabel !== void 0) {
      StringValue.encode({ value: message.submitTextLabel }, writer.uint32(202).fork()).ldelim();
    }
    if (message.isDefaultIcon !== void 0) {
      BoolValue.encode({ value: message.isDefaultIcon }, writer.uint32(210).fork()).ldelim();
    }
    if (message.linkFlairPosition !== void 0) {
      StringValue.encode({ value: message.linkFlairPosition }, writer.uint32(218).fork()).ldelim();
    }
    if (message.displayNamePrefixed !== void 0) {
      StringValue.encode({ value: message.displayNamePrefixed }, writer.uint32(226).fork()).ldelim();
    }
    if (message.keyColor !== void 0) {
      StringValue.encode({ value: message.keyColor }, writer.uint32(234).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(242).fork()).ldelim();
    }
    if (message.isDefaultBanner !== void 0) {
      BoolValue.encode({ value: message.isDefaultBanner }, writer.uint32(250).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(258).fork()).ldelim();
    }
    if (message.quarantine !== void 0) {
      BoolValue.encode({ value: message.quarantine }, writer.uint32(266).fork()).ldelim();
    }
    for (const v of message.bannerSize) {
      Int32Value.encode({ value: v }, writer.uint32(274).fork()).ldelim();
    }
    if (message.userIsModerator !== void 0) {
      BoolValue.encode({ value: message.userIsModerator }, writer.uint32(282).fork()).ldelim();
    }
    if (message.acceptFollowers !== void 0) {
      BoolValue.encode({ value: message.acceptFollowers }, writer.uint32(290).fork()).ldelim();
    }
    if (message.publicDescription !== void 0) {
      StringValue.encode({ value: message.publicDescription }, writer.uint32(298).fork()).ldelim();
    }
    if (message.linkFlairEnabled !== void 0) {
      BoolValue.encode({ value: message.linkFlairEnabled }, writer.uint32(306).fork()).ldelim();
    }
    if (message.disableContributorRequests !== void 0) {
      BoolValue.encode({ value: message.disableContributorRequests }, writer.uint32(314).fork()).ldelim();
    }
    if (message.subredditType !== void 0) {
      StringValue.encode({ value: message.subredditType }, writer.uint32(322).fork()).ldelim();
    }
    if (message.userIsSubscriber !== void 0) {
      BoolValue.encode({ value: message.userIsSubscriber }, writer.uint32(330).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal106.default.Reader ? input : new import_minimal106.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserSearchResponse_AccountData_Subreddit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.defaultSet = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.userIsContributor = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.bannerImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.allowedMediaInComments.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 5:
          message.userIsBanned = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.freeFormReports = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.showMedia = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.iconColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.userIsMuted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.displayName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.headerImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.previousNames.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 15:
          message.over18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 16:
          message.iconSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 17:
          message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.submitLinkLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 21:
          message.headerSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 22:
          message.restrictPosting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.restrictCommenting = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.submitTextLabel = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 26:
          message.isDefaultIcon = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 27:
          message.linkFlairPosition = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 28:
          message.displayNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 29:
          message.keyColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 30:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 31:
          message.isDefaultBanner = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 32:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 33:
          message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 34:
          message.bannerSize.push(Int32Value.decode(reader, reader.uint32()).value);
          break;
        case 35:
          message.userIsModerator = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 36:
          message.acceptFollowers = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 37:
          message.publicDescription = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 38:
          message.linkFlairEnabled = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 39:
          message.disableContributorRequests = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 40:
          message.subredditType = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 41:
          message.userIsSubscriber = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      defaultSet: isSet91(object.defaultSet) ? Boolean(object.defaultSet) : void 0,
      userIsContributor: isSet91(object.userIsContributor) ? Boolean(object.userIsContributor) : void 0,
      bannerImg: isSet91(object.bannerImg) ? String(object.bannerImg) : void 0,
      allowedMediaInComments: Array.isArray(object?.allowedMediaInComments) ? object.allowedMediaInComments.map((e) => String(e)) : [],
      userIsBanned: isSet91(object.userIsBanned) ? Boolean(object.userIsBanned) : void 0,
      freeFormReports: isSet91(object.freeFormReports) ? Boolean(object.freeFormReports) : void 0,
      communityIcon: isSet91(object.communityIcon) ? String(object.communityIcon) : void 0,
      showMedia: isSet91(object.showMedia) ? Boolean(object.showMedia) : void 0,
      iconColor: isSet91(object.iconColor) ? String(object.iconColor) : void 0,
      userIsMuted: isSet91(object.userIsMuted) ? Boolean(object.userIsMuted) : void 0,
      displayName: isSet91(object.displayName) ? String(object.displayName) : void 0,
      headerImg: isSet91(object.headerImg) ? String(object.headerImg) : void 0,
      title: isSet91(object.title) ? String(object.title) : void 0,
      previousNames: Array.isArray(object?.previousNames) ? object.previousNames.map((e) => String(e)) : [],
      over18: isSet91(object.over18) ? Boolean(object.over18) : void 0,
      iconSize: Array.isArray(object?.iconSize) ? object.iconSize.map((e) => Number(e)) : [],
      primaryColor: isSet91(object.primaryColor) ? String(object.primaryColor) : void 0,
      iconImg: isSet91(object.iconImg) ? String(object.iconImg) : void 0,
      description: isSet91(object.description) ? String(object.description) : void 0,
      submitLinkLabel: isSet91(object.submitLinkLabel) ? String(object.submitLinkLabel) : void 0,
      headerSize: Array.isArray(object?.headerSize) ? object.headerSize.map((e) => Number(e)) : [],
      restrictPosting: isSet91(object.restrictPosting) ? Boolean(object.restrictPosting) : void 0,
      restrictCommenting: isSet91(object.restrictCommenting) ? Boolean(object.restrictCommenting) : void 0,
      subscribers: isSet91(object.subscribers) ? Number(object.subscribers) : void 0,
      submitTextLabel: isSet91(object.submitTextLabel) ? String(object.submitTextLabel) : void 0,
      isDefaultIcon: isSet91(object.isDefaultIcon) ? Boolean(object.isDefaultIcon) : void 0,
      linkFlairPosition: isSet91(object.linkFlairPosition) ? String(object.linkFlairPosition) : void 0,
      displayNamePrefixed: isSet91(object.displayNamePrefixed) ? String(object.displayNamePrefixed) : void 0,
      keyColor: isSet91(object.keyColor) ? String(object.keyColor) : void 0,
      name: isSet91(object.name) ? String(object.name) : void 0,
      isDefaultBanner: isSet91(object.isDefaultBanner) ? Boolean(object.isDefaultBanner) : void 0,
      url: isSet91(object.url) ? String(object.url) : void 0,
      quarantine: isSet91(object.quarantine) ? Boolean(object.quarantine) : void 0,
      bannerSize: Array.isArray(object?.bannerSize) ? object.bannerSize.map((e) => Number(e)) : [],
      userIsModerator: isSet91(object.userIsModerator) ? Boolean(object.userIsModerator) : void 0,
      acceptFollowers: isSet91(object.acceptFollowers) ? Boolean(object.acceptFollowers) : void 0,
      publicDescription: isSet91(object.publicDescription) ? String(object.publicDescription) : void 0,
      linkFlairEnabled: isSet91(object.linkFlairEnabled) ? Boolean(object.linkFlairEnabled) : void 0,
      disableContributorRequests: isSet91(object.disableContributorRequests) ? Boolean(object.disableContributorRequests) : void 0,
      subredditType: isSet91(object.subredditType) ? String(object.subredditType) : void 0,
      userIsSubscriber: isSet91(object.userIsSubscriber) ? Boolean(object.userIsSubscriber) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.defaultSet !== void 0 && (obj.defaultSet = message.defaultSet);
    message.userIsContributor !== void 0 && (obj.userIsContributor = message.userIsContributor);
    message.bannerImg !== void 0 && (obj.bannerImg = message.bannerImg);
    if (message.allowedMediaInComments) {
      obj.allowedMediaInComments = message.allowedMediaInComments.map((e) => e);
    } else {
      obj.allowedMediaInComments = [];
    }
    message.userIsBanned !== void 0 && (obj.userIsBanned = message.userIsBanned);
    message.freeFormReports !== void 0 && (obj.freeFormReports = message.freeFormReports);
    message.communityIcon !== void 0 && (obj.communityIcon = message.communityIcon);
    message.showMedia !== void 0 && (obj.showMedia = message.showMedia);
    message.iconColor !== void 0 && (obj.iconColor = message.iconColor);
    message.userIsMuted !== void 0 && (obj.userIsMuted = message.userIsMuted);
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    message.headerImg !== void 0 && (obj.headerImg = message.headerImg);
    message.title !== void 0 && (obj.title = message.title);
    if (message.previousNames) {
      obj.previousNames = message.previousNames.map((e) => e);
    } else {
      obj.previousNames = [];
    }
    message.over18 !== void 0 && (obj.over18 = message.over18);
    if (message.iconSize) {
      obj.iconSize = message.iconSize.map((e) => e);
    } else {
      obj.iconSize = [];
    }
    message.primaryColor !== void 0 && (obj.primaryColor = message.primaryColor);
    message.iconImg !== void 0 && (obj.iconImg = message.iconImg);
    message.description !== void 0 && (obj.description = message.description);
    message.submitLinkLabel !== void 0 && (obj.submitLinkLabel = message.submitLinkLabel);
    if (message.headerSize) {
      obj.headerSize = message.headerSize.map((e) => e);
    } else {
      obj.headerSize = [];
    }
    message.restrictPosting !== void 0 && (obj.restrictPosting = message.restrictPosting);
    message.restrictCommenting !== void 0 && (obj.restrictCommenting = message.restrictCommenting);
    message.subscribers !== void 0 && (obj.subscribers = message.subscribers);
    message.submitTextLabel !== void 0 && (obj.submitTextLabel = message.submitTextLabel);
    message.isDefaultIcon !== void 0 && (obj.isDefaultIcon = message.isDefaultIcon);
    message.linkFlairPosition !== void 0 && (obj.linkFlairPosition = message.linkFlairPosition);
    message.displayNamePrefixed !== void 0 && (obj.displayNamePrefixed = message.displayNamePrefixed);
    message.keyColor !== void 0 && (obj.keyColor = message.keyColor);
    message.name !== void 0 && (obj.name = message.name);
    message.isDefaultBanner !== void 0 && (obj.isDefaultBanner = message.isDefaultBanner);
    message.url !== void 0 && (obj.url = message.url);
    message.quarantine !== void 0 && (obj.quarantine = message.quarantine);
    if (message.bannerSize) {
      obj.bannerSize = message.bannerSize.map((e) => e);
    } else {
      obj.bannerSize = [];
    }
    message.userIsModerator !== void 0 && (obj.userIsModerator = message.userIsModerator);
    message.acceptFollowers !== void 0 && (obj.acceptFollowers = message.acceptFollowers);
    message.publicDescription !== void 0 && (obj.publicDescription = message.publicDescription);
    message.linkFlairEnabled !== void 0 && (obj.linkFlairEnabled = message.linkFlairEnabled);
    message.disableContributorRequests !== void 0 && (obj.disableContributorRequests = message.disableContributorRequests);
    message.subredditType !== void 0 && (obj.subredditType = message.subredditType);
    message.userIsSubscriber !== void 0 && (obj.userIsSubscriber = message.userIsSubscriber);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserSearchResponse_AccountData_Subreddit();
    message.defaultSet = object.defaultSet ?? void 0;
    message.userIsContributor = object.userIsContributor ?? void 0;
    message.bannerImg = object.bannerImg ?? void 0;
    message.allowedMediaInComments = object.allowedMediaInComments?.map((e) => e) || [];
    message.userIsBanned = object.userIsBanned ?? void 0;
    message.freeFormReports = object.freeFormReports ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.showMedia = object.showMedia ?? void 0;
    message.iconColor = object.iconColor ?? void 0;
    message.userIsMuted = object.userIsMuted ?? void 0;
    message.displayName = object.displayName ?? void 0;
    message.headerImg = object.headerImg ?? void 0;
    message.title = object.title ?? void 0;
    message.previousNames = object.previousNames?.map((e) => e) || [];
    message.over18 = object.over18 ?? void 0;
    message.iconSize = object.iconSize?.map((e) => e) || [];
    message.primaryColor = object.primaryColor ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.description = object.description ?? void 0;
    message.submitLinkLabel = object.submitLinkLabel ?? void 0;
    message.headerSize = object.headerSize?.map((e) => e) || [];
    message.restrictPosting = object.restrictPosting ?? void 0;
    message.restrictCommenting = object.restrictCommenting ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.submitTextLabel = object.submitTextLabel ?? void 0;
    message.isDefaultIcon = object.isDefaultIcon ?? void 0;
    message.linkFlairPosition = object.linkFlairPosition ?? void 0;
    message.displayNamePrefixed = object.displayNamePrefixed ?? void 0;
    message.keyColor = object.keyColor ?? void 0;
    message.name = object.name ?? void 0;
    message.isDefaultBanner = object.isDefaultBanner ?? void 0;
    message.url = object.url ?? void 0;
    message.quarantine = object.quarantine ?? void 0;
    message.bannerSize = object.bannerSize?.map((e) => e) || [];
    message.userIsModerator = object.userIsModerator ?? void 0;
    message.acceptFollowers = object.acceptFollowers ?? void 0;
    message.publicDescription = object.publicDescription ?? void 0;
    message.linkFlairEnabled = object.linkFlairEnabled ?? void 0;
    message.disableContributorRequests = object.disableContributorRequests ?? void 0;
    message.subredditType = object.subredditType ?? void 0;
    message.userIsSubscriber = object.userIsSubscriber ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.subreddits.UserSearchResponse.AccountData.Subreddit", UserSearchResponse_AccountData_Subreddit);
var globalThis11 = (() => {
  if (typeof globalThis11 !== "undefined") {
    return globalThis11;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function longToNumber8(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis11.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal106.default.util.Long !== import_long8.default) {
  import_minimal106.default.util.Long = import_long8.default;
  import_minimal106.default.configure();
}
function isSet91(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/subreddits/subreddits_svc.js
var import_minimal107 = __toESM(require_minimal2(), 1);
var SubredditsDefinition = {
  name: "Subreddits",
  fullName: "devvit.plugin.redditapi.subreddits.Subreddits",
  methods: {
    /** https://www.reddit.com/dev/api#GET_about_\{where\} */
    aboutWhere: {
      name: "AboutWhere",
      requestType: AboutWhereRequest,
      requestStream: false,
      responseType: Listing,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_delete_sr_banner */
    deleteSrBanner: {
      name: "DeleteSrBanner",
      requestType: BasicSubredditRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_delete_sr_header */
    deleteSrHeader: {
      name: "DeleteSrHeader",
      requestType: BasicSubredditRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_delete_sr_icon */
    deleteSrIcon: {
      name: "DeleteSrIcon",
      requestType: BasicSubredditRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_delete_sr_img */
    deleteSrImg: {
      name: "DeleteSrImg",
      requestType: DeleteSrImgRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_search_reddit_names */
    searchRedditNames: {
      name: "SearchRedditNames",
      requestType: BasicSearchRequest,
      requestStream: false,
      responseType: SearchRedditNamesResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_search_subreddits */
    searchSubreddits: {
      name: "SearchSubreddits",
      requestType: BasicSearchRequest,
      requestStream: false,
      responseType: SearchSubredditsResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_site_admin */
    siteAdmin: {
      name: "SiteAdmin",
      requestType: SiteAdminRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_submit_text */
    submitText: {
      name: "SubmitText",
      requestType: BasicSubredditRequest,
      requestStream: false,
      responseType: SubmitTextResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_subreddit_autocomplete_v2 */
    subredditAutocomplete: {
      name: "SubredditAutocomplete",
      requestType: SubredditAutocompleteRequest,
      requestStream: false,
      responseType: SubredditAutocompleteResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_subreddit_stylesheet */
    subredditStylesheet: {
      name: "SubredditStylesheet",
      requestType: SubredditStylesheetRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_subscribe */
    subscribe: {
      name: "Subscribe",
      requestType: SubscribeRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_upload_sr_img */
    uploadSrImg: {
      name: "UploadSrImg",
      requestType: UploadSrImgRequest,
      requestStream: false,
      responseType: UploadSrImgResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_v1_\{subreddit\}_post_requirements */
    subredditPostRequirements: {
      name: "SubredditPostRequirements",
      requestType: BasicSubredditRequest,
      requestStream: false,
      responseType: SubredditPostRequirementsResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_r_\{subreddit\}_about */
    subredditAbout: {
      name: "SubredditAbout",
      requestType: BasicSubredditRequest,
      requestStream: false,
      responseType: SubredditAboutResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_r_\{subreddit\}_about_edit */
    subredditAboutEdit: {
      name: "SubredditAboutEdit",
      requestType: SubredditAboutEditRequest,
      requestStream: false,
      responseType: SubredditAboutEditResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_r_\{subreddit\}_about_rules */
    subredditAboutRules: {
      name: "SubredditAboutRules",
      requestType: BasicSubredditRequest,
      requestStream: false,
      responseType: SubredditAboutRulesResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_r_\{subreddit\}_about_traffic */
    subredditAboutTraffic: {
      name: "SubredditAboutTraffic",
      requestType: BasicSubredditRequest,
      requestStream: false,
      responseType: SubredditAboutTrafficResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_sidebar */
    sidebar: {
      name: "Sidebar",
      requestType: BasicSubredditRequest,
      requestStream: false,
      responseType: StringValue,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_sticky */
    sticky: {
      name: "Sticky",
      requestType: StickyRequest,
      requestStream: false,
      responseType: StickyResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_subreddits_mine_\{where\} */
    subredditsMineWhere: {
      name: "SubredditsMineWhere",
      requestType: BasicWhereRequest,
      requestStream: false,
      responseType: Listing,
      responseStream: false,
      options: {}
    },
    /**
     * https://www.reddit.com/dev/api#GET_subreddits_search
     * Make Wrapped
     */
    subredditsSearch: {
      name: "SubredditsSearch",
      requestType: SubredditsSearchRequest,
      requestStream: false,
      responseType: SubredditsSearchResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_subreddits_\{where\} */
    subredditsWhere: {
      name: "SubredditsWhere",
      requestType: BasicWhereRequest,
      requestStream: false,
      responseType: SubredditsSearchResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_users_search */
    usersSearch: {
      name: "UsersSearch",
      requestType: UsersSearchRequest,
      requestStream: false,
      responseType: UserSearchResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_users_\{where\} */
    usersWhere: {
      name: "UsersWhere",
      requestType: BasicWhereRequest,
      requestStream: false,
      responseType: SubredditsSearchResponse,
      responseStream: false,
      options: {}
    }
  }
};

// ../protos/dist/types/devvit/plugin/redditapi/users/users_msg.js
var import_minimal108 = __toESM(require_minimal2(), 1);
function createBaseGenericUsersRequest() {
  return { id: void 0, username: "" };
}
var GenericUsersRequest = {
  $type: "devvit.plugin.redditapi.users.GenericUsersRequest",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenericUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet92(object.id) ? String(object.id) : void 0,
      username: isSet92(object.username) ? String(object.username) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.username !== void 0 && (obj.username = message.username);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGenericUsersRequest();
    message.id = object.id ?? void 0;
    message.username = object.username ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.GenericUsersRequest", GenericUsersRequest);
function createBaseBlockUserRequest() {
  return { accountId: void 0, name: void 0 };
}
var BlockUserRequest = {
  $type: "devvit.plugin.redditapi.users.BlockUserRequest",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.accountId !== void 0) {
      StringValue.encode({ value: message.accountId }, writer.uint32(10).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      accountId: isSet92(object.accountId) ? String(object.accountId) : void 0,
      name: isSet92(object.name) ? String(object.name) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.accountId !== void 0 && (obj.accountId = message.accountId);
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockUserRequest();
    message.accountId = object.accountId ?? void 0;
    message.name = object.name ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.BlockUserRequest", BlockUserRequest);
function createBaseFriendRequest() {
  return {
    banContext: void 0,
    banMessage: void 0,
    banReason: void 0,
    duration: void 0,
    name: "",
    note: void 0,
    permissions: void 0,
    type: "",
    subreddit: void 0
  };
}
var FriendRequest = {
  $type: "devvit.plugin.redditapi.users.FriendRequest",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.banContext !== void 0) {
      StringValue.encode({ value: message.banContext }, writer.uint32(10).fork()).ldelim();
    }
    if (message.banMessage !== void 0) {
      StringValue.encode({ value: message.banMessage }, writer.uint32(18).fork()).ldelim();
    }
    if (message.banReason !== void 0) {
      StringValue.encode({ value: message.banReason }, writer.uint32(26).fork()).ldelim();
    }
    if (message.duration !== void 0) {
      Int32Value.encode({ value: message.duration }, writer.uint32(34).fork()).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.note !== void 0) {
      StringValue.encode({ value: message.note }, writer.uint32(50).fork()).ldelim();
    }
    if (message.permissions !== void 0) {
      StringValue.encode({ value: message.permissions }, writer.uint32(58).fork()).ldelim();
    }
    if (message.type !== "") {
      writer.uint32(66).string(message.type);
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFriendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.banContext = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.banMessage = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.banReason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.duration = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.name = reader.string();
          break;
        case 6:
          message.note = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.permissions = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.type = reader.string();
          break;
        case 9:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      banContext: isSet92(object.banContext) ? String(object.banContext) : void 0,
      banMessage: isSet92(object.banMessage) ? String(object.banMessage) : void 0,
      banReason: isSet92(object.banReason) ? String(object.banReason) : void 0,
      duration: isSet92(object.duration) ? Number(object.duration) : void 0,
      name: isSet92(object.name) ? String(object.name) : "",
      note: isSet92(object.note) ? String(object.note) : void 0,
      permissions: isSet92(object.permissions) ? String(object.permissions) : void 0,
      type: isSet92(object.type) ? String(object.type) : "",
      subreddit: isSet92(object.subreddit) ? String(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.banContext !== void 0 && (obj.banContext = message.banContext);
    message.banMessage !== void 0 && (obj.banMessage = message.banMessage);
    message.banReason !== void 0 && (obj.banReason = message.banReason);
    message.duration !== void 0 && (obj.duration = message.duration);
    message.name !== void 0 && (obj.name = message.name);
    message.note !== void 0 && (obj.note = message.note);
    message.permissions !== void 0 && (obj.permissions = message.permissions);
    message.type !== void 0 && (obj.type = message.type);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFriendRequest();
    message.banContext = object.banContext ?? void 0;
    message.banMessage = object.banMessage ?? void 0;
    message.banReason = object.banReason ?? void 0;
    message.duration = object.duration ?? void 0;
    message.name = object.name ?? "";
    message.note = object.note ?? void 0;
    message.permissions = object.permissions ?? void 0;
    message.type = object.type ?? "";
    message.subreddit = object.subreddit ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.FriendRequest", FriendRequest);
function createBaseReportUserRequest() {
  return { details: "", reason: "", user: "" };
}
var ReportUserRequest = {
  $type: "devvit.plugin.redditapi.users.ReportUserRequest",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.details !== "") {
      writer.uint32(10).string(message.details);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReportUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.details = reader.string();
          break;
        case 2:
          message.reason = reader.string();
          break;
        case 3:
          message.user = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      details: isSet92(object.details) ? String(object.details) : "",
      reason: isSet92(object.reason) ? String(object.reason) : "",
      user: isSet92(object.user) ? String(object.user) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.details !== void 0 && (obj.details = message.details);
    message.reason !== void 0 && (obj.reason = message.reason);
    message.user !== void 0 && (obj.user = message.user);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseReportUserRequest();
    message.details = object.details ?? "";
    message.reason = object.reason ?? "";
    message.user = object.user ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.ReportUserRequest", ReportUserRequest);
function createBaseSetPermissionsRequest() {
  return { name: "", subreddit: "", permissions: "", type: "" };
}
var SetPermissionsRequest = {
  $type: "devvit.plugin.redditapi.users.SetPermissionsRequest",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.subreddit !== "") {
      writer.uint32(18).string(message.subreddit);
    }
    if (message.permissions !== "") {
      writer.uint32(26).string(message.permissions);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetPermissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.subreddit = reader.string();
          break;
        case 3:
          message.permissions = reader.string();
          break;
        case 4:
          message.type = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet92(object.name) ? String(object.name) : "",
      subreddit: isSet92(object.subreddit) ? String(object.subreddit) : "",
      permissions: isSet92(object.permissions) ? String(object.permissions) : "",
      type: isSet92(object.type) ? String(object.type) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.permissions !== void 0 && (obj.permissions = message.permissions);
    message.type !== void 0 && (obj.type = message.type);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSetPermissionsRequest();
    message.name = object.name ?? "";
    message.subreddit = object.subreddit ?? "";
    message.permissions = object.permissions ?? "";
    message.type = object.type ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.SetPermissionsRequest", SetPermissionsRequest);
function createBaseUnfriendRequest() {
  return { id: void 0, name: void 0, type: "", subreddit: void 0 };
}
var UnfriendRequest = {
  $type: "devvit.plugin.redditapi.users.UnfriendRequest",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(18).fork()).ldelim();
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnfriendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.type = reader.string();
          break;
        case 4:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet92(object.id) ? String(object.id) : void 0,
      name: isSet92(object.name) ? String(object.name) : void 0,
      type: isSet92(object.type) ? String(object.type) : "",
      subreddit: isSet92(object.subreddit) ? String(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.name !== void 0 && (obj.name = message.name);
    message.type !== void 0 && (obj.type = message.type);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUnfriendRequest();
    message.id = object.id ?? void 0;
    message.name = object.name ?? void 0;
    message.type = object.type ?? "";
    message.subreddit = object.subreddit ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UnfriendRequest", UnfriendRequest);
function createBaseUserDataByAccountIdsRequest() {
  return { ids: "" };
}
var UserDataByAccountIdsRequest = {
  $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsRequest",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.ids !== "") {
      writer.uint32(10).string(message.ids);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserDataByAccountIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ids = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { ids: isSet92(object.ids) ? String(object.ids) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.ids !== void 0 && (obj.ids = message.ids);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserDataByAccountIdsRequest();
    message.ids = object.ids ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UserDataByAccountIdsRequest", UserDataByAccountIdsRequest);
function createBaseUsernameAvailableRequest() {
  return { user: "" };
}
var UsernameAvailableRequest = {
  $type: "devvit.plugin.redditapi.users.UsernameAvailableRequest",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUsernameAvailableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { user: isSet92(object.user) ? String(object.user) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.user !== void 0 && (obj.user = message.user);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUsernameAvailableRequest();
    message.user = object.user ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UsernameAvailableRequest", UsernameAvailableRequest);
function createBaseUpdateFriendRelationshipRequest() {
  return { name: "", note: "" };
}
var UpdateFriendRelationshipRequest = {
  $type: "devvit.plugin.redditapi.users.UpdateFriendRelationshipRequest",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.note !== "") {
      writer.uint32(18).string(message.note);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateFriendRelationshipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.note = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { name: isSet92(object.name) ? String(object.name) : "", note: isSet92(object.note) ? String(object.note) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.note !== void 0 && (obj.note = message.note);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateFriendRelationshipRequest();
    message.name = object.name ?? "";
    message.note = object.note ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UpdateFriendRelationshipRequest", UpdateFriendRelationshipRequest);
function createBaseUserAboutRequest() {
  return { username: "" };
}
var UserAboutRequest = {
  $type: "devvit.plugin.redditapi.users.UserAboutRequest",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserAboutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { username: isSet92(object.username) ? String(object.username) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.username !== void 0 && (obj.username = message.username);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserAboutRequest();
    message.username = object.username ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UserAboutRequest", UserAboutRequest);
function createBaseUserWhereRequest() {
  return {
    context: void 0,
    show: void 0,
    sort: void 0,
    t: void 0,
    type: void 0,
    after: void 0,
    before: void 0,
    count: void 0,
    limit: void 0,
    username: void 0,
    where: ""
  };
}
var UserWhereRequest = {
  $type: "devvit.plugin.redditapi.users.UserWhereRequest",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.context !== void 0) {
      Int32Value.encode({ value: message.context }, writer.uint32(10).fork()).ldelim();
    }
    if (message.show !== void 0) {
      StringValue.encode({ value: message.show }, writer.uint32(18).fork()).ldelim();
    }
    if (message.sort !== void 0) {
      StringValue.encode({ value: message.sort }, writer.uint32(26).fork()).ldelim();
    }
    if (message.t !== void 0) {
      StringValue.encode({ value: message.t }, writer.uint32(34).fork()).ldelim();
    }
    if (message.type !== void 0) {
      StringValue.encode({ value: message.type }, writer.uint32(42).fork()).ldelim();
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(50).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(58).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(66).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int32Value.encode({ value: message.limit }, writer.uint32(74).fork()).ldelim();
    }
    if (message.username !== void 0) {
      StringValue.encode({ value: message.username }, writer.uint32(90).fork()).ldelim();
    }
    if (message.where !== "") {
      writer.uint32(98).string(message.where);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserWhereRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.context = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.show = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.sort = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.t = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.type = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.username = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.where = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      context: isSet92(object.context) ? Number(object.context) : void 0,
      show: isSet92(object.show) ? String(object.show) : void 0,
      sort: isSet92(object.sort) ? String(object.sort) : void 0,
      t: isSet92(object.t) ? String(object.t) : void 0,
      type: isSet92(object.type) ? String(object.type) : void 0,
      after: isSet92(object.after) ? String(object.after) : void 0,
      before: isSet92(object.before) ? String(object.before) : void 0,
      count: isSet92(object.count) ? Number(object.count) : void 0,
      limit: isSet92(object.limit) ? Number(object.limit) : void 0,
      username: isSet92(object.username) ? String(object.username) : void 0,
      where: isSet92(object.where) ? String(object.where) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.context !== void 0 && (obj.context = message.context);
    message.show !== void 0 && (obj.show = message.show);
    message.sort !== void 0 && (obj.sort = message.sort);
    message.t !== void 0 && (obj.t = message.t);
    message.type !== void 0 && (obj.type = message.type);
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.count !== void 0 && (obj.count = message.count);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.username !== void 0 && (obj.username = message.username);
    message.where !== void 0 && (obj.where = message.where);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserWhereRequest();
    message.context = object.context ?? void 0;
    message.show = object.show ?? void 0;
    message.sort = object.sort ?? void 0;
    message.t = object.t ?? void 0;
    message.type = object.type ?? void 0;
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.count = object.count ?? void 0;
    message.limit = object.limit ?? void 0;
    message.username = object.username ?? void 0;
    message.where = object.where ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UserWhereRequest", UserWhereRequest);
function createBaseGeneralFriendResponse() {
  return {
    date: void 0,
    relId: void 0,
    name: void 0,
    id: void 0,
    fields: [],
    explanation: void 0,
    message: void 0,
    reason: void 0
  };
}
var GeneralFriendResponse = {
  $type: "devvit.plugin.redditapi.users.GeneralFriendResponse",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.date !== void 0) {
      Int64Value.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
    }
    if (message.relId !== void 0) {
      StringValue.encode({ value: message.relId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.fields) {
      StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
    }
    if (message.explanation !== void 0) {
      StringValue.encode({ value: message.explanation }, writer.uint32(50).fork()).ldelim();
    }
    if (message.message !== void 0) {
      StringValue.encode({ value: message.message }, writer.uint32(58).fork()).ldelim();
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeneralFriendResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.date = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.relId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.fields.push(StringValue.decode(reader, reader.uint32()).value);
          break;
        case 6:
          message.explanation = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.message = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      date: isSet92(object.date) ? Number(object.date) : void 0,
      relId: isSet92(object.relId) ? String(object.relId) : void 0,
      name: isSet92(object.name) ? String(object.name) : void 0,
      id: isSet92(object.id) ? String(object.id) : void 0,
      fields: Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
      explanation: isSet92(object.explanation) ? String(object.explanation) : void 0,
      message: isSet92(object.message) ? String(object.message) : void 0,
      reason: isSet92(object.reason) ? String(object.reason) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.date !== void 0 && (obj.date = message.date);
    message.relId !== void 0 && (obj.relId = message.relId);
    message.name !== void 0 && (obj.name = message.name);
    message.id !== void 0 && (obj.id = message.id);
    if (message.fields) {
      obj.fields = message.fields.map((e) => e);
    } else {
      obj.fields = [];
    }
    message.explanation !== void 0 && (obj.explanation = message.explanation);
    message.message !== void 0 && (obj.message = message.message);
    message.reason !== void 0 && (obj.reason = message.reason);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGeneralFriendResponse();
    message.date = object.date ?? void 0;
    message.relId = object.relId ?? void 0;
    message.name = object.name ?? void 0;
    message.id = object.id ?? void 0;
    message.fields = object.fields?.map((e) => e) || [];
    message.explanation = object.explanation ?? void 0;
    message.message = object.message ?? void 0;
    message.reason = object.reason ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.GeneralFriendResponse", GeneralFriendResponse);
function createBaseBlockUserResponse() {
  return { date: void 0, iconImg: void 0, id: void 0, name: void 0 };
}
var BlockUserResponse = {
  $type: "devvit.plugin.redditapi.users.BlockUserResponse",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.date !== void 0) {
      Int64Value.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
    }
    if (message.iconImg !== void 0) {
      StringValue.encode({ value: message.iconImg }, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.date = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.iconImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      date: isSet92(object.date) ? Number(object.date) : void 0,
      iconImg: isSet92(object.iconImg) ? String(object.iconImg) : void 0,
      id: isSet92(object.id) ? String(object.id) : void 0,
      name: isSet92(object.name) ? String(object.name) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.date !== void 0 && (obj.date = message.date);
    message.iconImg !== void 0 && (obj.iconImg = message.iconImg);
    message.id !== void 0 && (obj.id = message.id);
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockUserResponse();
    message.date = object.date ?? void 0;
    message.iconImg = object.iconImg ?? void 0;
    message.id = object.id ?? void 0;
    message.name = object.name ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.BlockUserResponse", BlockUserResponse);
function createBaseUserDataByAccountIdsResponse() {
  return { users: {} };
}
var UserDataByAccountIdsResponse = {
  $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    Object.entries(message.users).forEach(([key, value]) => {
      UserDataByAccountIdsResponse_UsersEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserDataByAccountIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = UserDataByAccountIdsResponse_UsersEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.users[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      users: isObject17(object.users) ? Object.entries(object.users).reduce((acc, [key, value]) => {
        acc[key] = UserDataByAccountIdsResponse_UserAccountData.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    obj.users = {};
    if (message.users) {
      Object.entries(message.users).forEach(([k, v]) => {
        obj.users[k] = UserDataByAccountIdsResponse_UserAccountData.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserDataByAccountIdsResponse();
    message.users = Object.entries(object.users ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = UserDataByAccountIdsResponse_UserAccountData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UserDataByAccountIdsResponse", UserDataByAccountIdsResponse);
function createBaseUserDataByAccountIdsResponse_UserAccountData() {
  return {
    name: void 0,
    createdUtc: void 0,
    linkKarma: void 0,
    commentKarma: void 0,
    profileImg: void 0,
    profileColor: void 0,
    profileOver18: void 0
  };
}
var UserDataByAccountIdsResponse_UserAccountData = {
  $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse.UserAccountData",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(10).fork()).ldelim();
    }
    if (message.createdUtc !== void 0) {
      Int64Value.encode({ value: message.createdUtc }, writer.uint32(18).fork()).ldelim();
    }
    if (message.linkKarma !== void 0) {
      Int64Value.encode({ value: message.linkKarma }, writer.uint32(26).fork()).ldelim();
    }
    if (message.commentKarma !== void 0) {
      Int64Value.encode({ value: message.commentKarma }, writer.uint32(34).fork()).ldelim();
    }
    if (message.profileImg !== void 0) {
      StringValue.encode({ value: message.profileImg }, writer.uint32(42).fork()).ldelim();
    }
    if (message.profileColor !== void 0) {
      StringValue.encode({ value: message.profileColor }, writer.uint32(50).fork()).ldelim();
    }
    if (message.profileOver18 !== void 0) {
      BoolValue.encode({ value: message.profileOver18 }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserDataByAccountIdsResponse_UserAccountData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.createdUtc = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.linkKarma = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.commentKarma = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.profileImg = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.profileColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.profileOver18 = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet92(object.name) ? String(object.name) : void 0,
      createdUtc: isSet92(object.createdUtc) ? Number(object.createdUtc) : void 0,
      linkKarma: isSet92(object.linkKarma) ? Number(object.linkKarma) : void 0,
      commentKarma: isSet92(object.commentKarma) ? Number(object.commentKarma) : void 0,
      profileImg: isSet92(object.profileImg) ? String(object.profileImg) : void 0,
      profileColor: isSet92(object.profileColor) ? String(object.profileColor) : void 0,
      profileOver18: isSet92(object.profileOver18) ? Boolean(object.profileOver18) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.createdUtc !== void 0 && (obj.createdUtc = message.createdUtc);
    message.linkKarma !== void 0 && (obj.linkKarma = message.linkKarma);
    message.commentKarma !== void 0 && (obj.commentKarma = message.commentKarma);
    message.profileImg !== void 0 && (obj.profileImg = message.profileImg);
    message.profileColor !== void 0 && (obj.profileColor = message.profileColor);
    message.profileOver18 !== void 0 && (obj.profileOver18 = message.profileOver18);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserDataByAccountIdsResponse_UserAccountData();
    message.name = object.name ?? void 0;
    message.createdUtc = object.createdUtc ?? void 0;
    message.linkKarma = object.linkKarma ?? void 0;
    message.commentKarma = object.commentKarma ?? void 0;
    message.profileImg = object.profileImg ?? void 0;
    message.profileColor = object.profileColor ?? void 0;
    message.profileOver18 = object.profileOver18 ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UserDataByAccountIdsResponse.UserAccountData", UserDataByAccountIdsResponse_UserAccountData);
function createBaseUserDataByAccountIdsResponse_UsersEntry() {
  return { key: "", value: void 0 };
}
var UserDataByAccountIdsResponse_UsersEntry = {
  $type: "devvit.plugin.redditapi.users.UserDataByAccountIdsResponse.UsersEntry",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      UserDataByAccountIdsResponse_UserAccountData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserDataByAccountIdsResponse_UsersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = UserDataByAccountIdsResponse_UserAccountData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet92(object.key) ? String(object.key) : "",
      value: isSet92(object.value) ? UserDataByAccountIdsResponse_UserAccountData.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? UserDataByAccountIdsResponse_UserAccountData.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserDataByAccountIdsResponse_UsersEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? UserDataByAccountIdsResponse_UserAccountData.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UserDataByAccountIdsResponse.UsersEntry", UserDataByAccountIdsResponse_UsersEntry);
function createBaseUserTrophiesResponse() {
  return { kind: void 0, data: void 0 };
}
var UserTrophiesResponse = {
  $type: "devvit.plugin.redditapi.users.UserTrophiesResponse",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      UserTrophiesResponse_UserTrophiesData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserTrophiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = UserTrophiesResponse_UserTrophiesData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet92(object.kind) ? String(object.kind) : void 0,
      data: isSet92(object.data) ? UserTrophiesResponse_UserTrophiesData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? UserTrophiesResponse_UserTrophiesData.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserTrophiesResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? UserTrophiesResponse_UserTrophiesData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UserTrophiesResponse", UserTrophiesResponse);
function createBaseUserTrophiesResponse_TrophiesData() {
  return {
    icon70: void 0,
    grantedAt: void 0,
    url: void 0,
    icon40: void 0,
    name: void 0,
    awardId: void 0,
    id: void 0,
    description: void 0
  };
}
var UserTrophiesResponse_TrophiesData = {
  $type: "devvit.plugin.redditapi.users.UserTrophiesResponse.TrophiesData",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.icon70 !== void 0) {
      StringValue.encode({ value: message.icon70 }, writer.uint32(10).fork()).ldelim();
    }
    if (message.grantedAt !== void 0) {
      Int64Value.encode({ value: message.grantedAt }, writer.uint32(18).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(26).fork()).ldelim();
    }
    if (message.icon40 !== void 0) {
      StringValue.encode({ value: message.icon40 }, writer.uint32(34).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(42).fork()).ldelim();
    }
    if (message.awardId !== void 0) {
      StringValue.encode({ value: message.awardId }, writer.uint32(50).fork()).ldelim();
    }
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(58).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserTrophiesResponse_TrophiesData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.icon70 = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.grantedAt = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.icon40 = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.awardId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      icon70: isSet92(object.icon70) ? String(object.icon70) : void 0,
      grantedAt: isSet92(object.grantedAt) ? Number(object.grantedAt) : void 0,
      url: isSet92(object.url) ? String(object.url) : void 0,
      icon40: isSet92(object.icon40) ? String(object.icon40) : void 0,
      name: isSet92(object.name) ? String(object.name) : void 0,
      awardId: isSet92(object.awardId) ? String(object.awardId) : void 0,
      id: isSet92(object.id) ? String(object.id) : void 0,
      description: isSet92(object.description) ? String(object.description) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.icon70 !== void 0 && (obj.icon70 = message.icon70);
    message.grantedAt !== void 0 && (obj.grantedAt = message.grantedAt);
    message.url !== void 0 && (obj.url = message.url);
    message.icon40 !== void 0 && (obj.icon40 = message.icon40);
    message.name !== void 0 && (obj.name = message.name);
    message.awardId !== void 0 && (obj.awardId = message.awardId);
    message.id !== void 0 && (obj.id = message.id);
    message.description !== void 0 && (obj.description = message.description);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserTrophiesResponse_TrophiesData();
    message.icon70 = object.icon70 ?? void 0;
    message.grantedAt = object.grantedAt ?? void 0;
    message.url = object.url ?? void 0;
    message.icon40 = object.icon40 ?? void 0;
    message.name = object.name ?? void 0;
    message.awardId = object.awardId ?? void 0;
    message.id = object.id ?? void 0;
    message.description = object.description ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UserTrophiesResponse.TrophiesData", UserTrophiesResponse_TrophiesData);
function createBaseUserTrophiesResponse_TrophiesType() {
  return { kind: void 0, data: void 0 };
}
var UserTrophiesResponse_TrophiesType = {
  $type: "devvit.plugin.redditapi.users.UserTrophiesResponse.TrophiesType",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      UserTrophiesResponse_TrophiesData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserTrophiesResponse_TrophiesType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = UserTrophiesResponse_TrophiesData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet92(object.kind) ? String(object.kind) : void 0,
      data: isSet92(object.data) ? UserTrophiesResponse_TrophiesData.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? UserTrophiesResponse_TrophiesData.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserTrophiesResponse_TrophiesType();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? UserTrophiesResponse_TrophiesData.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UserTrophiesResponse.TrophiesType", UserTrophiesResponse_TrophiesType);
function createBaseUserTrophiesResponse_UserTrophiesData() {
  return { trophies: [] };
}
var UserTrophiesResponse_UserTrophiesData = {
  $type: "devvit.plugin.redditapi.users.UserTrophiesResponse.UserTrophiesData",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    for (const v of message.trophies) {
      UserTrophiesResponse_TrophiesType.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserTrophiesResponse_UserTrophiesData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trophies.push(UserTrophiesResponse_TrophiesType.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      trophies: Array.isArray(object?.trophies) ? object.trophies.map((e) => UserTrophiesResponse_TrophiesType.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.trophies) {
      obj.trophies = message.trophies.map((e) => e ? UserTrophiesResponse_TrophiesType.toJSON(e) : void 0);
    } else {
      obj.trophies = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserTrophiesResponse_UserTrophiesData();
    message.trophies = object.trophies?.map((e) => UserTrophiesResponse_TrophiesType.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UserTrophiesResponse.UserTrophiesData", UserTrophiesResponse_UserTrophiesData);
function createBaseUserAboutResponse() {
  return { kind: void 0, data: void 0 };
}
var UserAboutResponse = {
  $type: "devvit.plugin.redditapi.users.UserAboutResponse",
  encode(message, writer = import_minimal108.default.Writer.create()) {
    if (message.kind !== void 0) {
      StringValue.encode({ value: message.kind }, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== void 0) {
      User.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal108.default.Reader ? input : new import_minimal108.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserAboutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.data = User.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet92(object.kind) ? String(object.kind) : void 0,
      data: isSet92(object.data) ? User.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? User.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUserAboutResponse();
    message.kind = object.kind ?? void 0;
    message.data = object.data !== void 0 && object.data !== null ? User.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.users.UserAboutResponse", UserAboutResponse);
function isObject17(value) {
  return typeof value === "object" && value !== null;
}
function isSet92(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/users/users_svc.js
var import_minimal109 = __toESM(require_minimal2(), 1);
var UsersDefinition = {
  name: "Users",
  fullName: "devvit.plugin.redditapi.users.Users",
  methods: {
    /** https://www.reddit.com/dev/api#POST_api_block_user */
    blockUser: {
      name: "BlockUser",
      requestType: BlockUserRequest,
      requestStream: false,
      responseType: BlockUserResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_friend */
    friend: {
      name: "Friend",
      requestType: FriendRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_report_user */
    reportUser: {
      name: "ReportUser",
      requestType: ReportUserRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_setpermissions */
    setPermissions: {
      name: "SetPermissions",
      requestType: SetPermissionsRequest,
      requestStream: false,
      responseType: JsonStatus,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#POST_api_unfriend */
    unfriend: {
      name: "Unfriend",
      requestType: UnfriendRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_user_data_by_account_ids */
    userDataByAccountIds: {
      name: "UserDataByAccountIds",
      requestType: UserDataByAccountIdsRequest,
      requestStream: false,
      responseType: UserDataByAccountIdsResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_username_available */
    usernameAvailable: {
      name: "UsernameAvailable",
      requestType: UsernameAvailableRequest,
      requestStream: false,
      responseType: BoolValue,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#DELETE_api_v1_me_friends_username */
    unfriendUser: {
      name: "UnfriendUser",
      requestType: GenericUsersRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_v1_me_friends_username */
    getFriendInformation: {
      name: "GetFriendInformation",
      requestType: GenericUsersRequest,
      requestStream: false,
      responseType: GeneralFriendResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#PUT_api_v1_me_friends_username */
    updateFriendRelationship: {
      name: "UpdateFriendRelationship",
      requestType: UpdateFriendRelationshipRequest,
      requestStream: false,
      responseType: GeneralFriendResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_api_v1_user_username_trophies */
    userTrophies: {
      name: "UserTrophies",
      requestType: GenericUsersRequest,
      requestStream: false,
      responseType: UserTrophiesResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_user_username_about */
    userAbout: {
      name: "UserAbout",
      requestType: UserAboutRequest,
      requestStream: false,
      responseType: UserAboutResponse,
      responseStream: false,
      options: {}
    },
    /** https://www.reddit.com/dev/api#GET_user_username_where */
    userWhere: {
      name: "UserWhere",
      requestType: UserWhereRequest,
      requestStream: false,
      responseType: Listing,
      responseStream: false,
      options: {}
    }
  }
};

// ../protos/dist/types/devvit/plugin/redditapi/widgets/widgets_msg.js
var import_minimal110 = __toESM(require_minimal2(), 1);
function createBaseWidgetStyles() {
  return { backgroundColor: void 0, headerColor: void 0 };
}
var WidgetStyles = {
  $type: "devvit.plugin.redditapi.widgets.WidgetStyles",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.backgroundColor !== void 0) {
      StringValue.encode({ value: message.backgroundColor }, writer.uint32(10).fork()).ldelim();
    }
    if (message.headerColor !== void 0) {
      StringValue.encode({ value: message.headerColor }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWidgetStyles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.backgroundColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.headerColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      backgroundColor: isSet93(object.backgroundColor) ? String(object.backgroundColor) : void 0,
      headerColor: isSet93(object.headerColor) ? String(object.headerColor) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.backgroundColor !== void 0 && (obj.backgroundColor = message.backgroundColor);
    message.headerColor !== void 0 && (obj.headerColor = message.headerColor);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWidgetStyles();
    message.backgroundColor = object.backgroundColor ?? void 0;
    message.headerColor = object.headerColor ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.WidgetStyles", WidgetStyles);
function createBaseWidgetImage() {
  return { url: "", linkUrl: "", height: 0, width: 0 };
}
var WidgetImage = {
  $type: "devvit.plugin.redditapi.widgets.WidgetImage",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.linkUrl !== "") {
      writer.uint32(18).string(message.linkUrl);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(32).int32(message.width);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWidgetImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.url = reader.string();
          break;
        case 2:
          message.linkUrl = reader.string();
          break;
        case 3:
          message.height = reader.int32();
          break;
        case 4:
          message.width = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet93(object.url) ? String(object.url) : "",
      linkUrl: isSet93(object.linkUrl) ? String(object.linkUrl) : "",
      height: isSet93(object.height) ? Number(object.height) : 0,
      width: isSet93(object.width) ? Number(object.width) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    message.linkUrl !== void 0 && (obj.linkUrl = message.linkUrl);
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.width !== void 0 && (obj.width = Math.round(message.width));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWidgetImage();
    message.url = object.url ?? "";
    message.linkUrl = object.linkUrl ?? "";
    message.height = object.height ?? 0;
    message.width = object.width ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.WidgetImage", WidgetImage);
function createBaseImageWidget() {
  return { id: "", kind: "", data: [], shortName: "", styles: void 0, subreddit: void 0 };
}
var ImageWidget = {
  $type: "devvit.plugin.redditapi.widgets.ImageWidget",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    for (const v of message.data) {
      WidgetImage.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.shortName !== "") {
      writer.uint32(34).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.kind = reader.string();
          break;
        case 3:
          message.data.push(WidgetImage.decode(reader, reader.uint32()));
          break;
        case 4:
          message.shortName = reader.string();
          break;
        case 5:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        case 6:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet93(object.id) ? String(object.id) : "",
      kind: isSet93(object.kind) ? String(object.kind) : "",
      data: Array.isArray(object?.data) ? object.data.map((e) => WidgetImage.fromJSON(e)) : [],
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0,
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.kind !== void 0 && (obj.kind = message.kind);
    if (message.data) {
      obj.data = message.data.map((e) => e ? WidgetImage.toJSON(e) : void 0);
    } else {
      obj.data = [];
    }
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseImageWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.data = object.data?.map((e) => WidgetImage.fromPartial(e)) || [];
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    message.subreddit = object.subreddit ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.ImageWidget", ImageWidget);
function createBaseAddImageWidgetRequest() {
  return { subreddit: "", data: [], shortName: "", styles: void 0 };
}
var AddImageWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddImageWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    for (const v of message.data) {
      WidgetImage.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddImageWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.data.push(WidgetImage.decode(reader, reader.uint32()));
          break;
        case 3:
          message.shortName = reader.string();
          break;
        case 4:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      data: Array.isArray(object?.data) ? object.data.map((e) => WidgetImage.fromJSON(e)) : [],
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    if (message.data) {
      obj.data = message.data.map((e) => e ? WidgetImage.toJSON(e) : void 0);
    } else {
      obj.data = [];
    }
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAddImageWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.data = object.data?.map((e) => WidgetImage.fromPartial(e)) || [];
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddImageWidgetRequest", AddImageWidgetRequest);
function createBaseUpdateImageWidgetRequest() {
  return { subreddit: "", id: "", data: [], shortName: "", styles: void 0 };
}
var UpdateImageWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdateImageWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    for (const v of message.data) {
      WidgetImage.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.shortName !== "") {
      writer.uint32(34).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateImageWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.data.push(WidgetImage.decode(reader, reader.uint32()));
          break;
        case 4:
          message.shortName = reader.string();
          break;
        case 5:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      id: isSet93(object.id) ? String(object.id) : "",
      data: Array.isArray(object?.data) ? object.data.map((e) => WidgetImage.fromJSON(e)) : [],
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.id !== void 0 && (obj.id = message.id);
    if (message.data) {
      obj.data = message.data.map((e) => e ? WidgetImage.toJSON(e) : void 0);
    } else {
      obj.data = [];
    }
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateImageWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.data = object.data?.map((e) => WidgetImage.fromPartial(e)) || [];
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateImageWidgetRequest", UpdateImageWidgetRequest);
function createBaseCalendarWidgetConfiguration() {
  return {
    numEvents: 0,
    showDate: false,
    showDescription: false,
    showLocation: false,
    showTime: false,
    showTitle: false
  };
}
var CalendarWidgetConfiguration = {
  $type: "devvit.plugin.redditapi.widgets.CalendarWidgetConfiguration",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.numEvents !== 0) {
      writer.uint32(8).int32(message.numEvents);
    }
    if (message.showDate === true) {
      writer.uint32(16).bool(message.showDate);
    }
    if (message.showDescription === true) {
      writer.uint32(24).bool(message.showDescription);
    }
    if (message.showLocation === true) {
      writer.uint32(32).bool(message.showLocation);
    }
    if (message.showTime === true) {
      writer.uint32(40).bool(message.showTime);
    }
    if (message.showTitle === true) {
      writer.uint32(48).bool(message.showTitle);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCalendarWidgetConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.numEvents = reader.int32();
          break;
        case 2:
          message.showDate = reader.bool();
          break;
        case 3:
          message.showDescription = reader.bool();
          break;
        case 4:
          message.showLocation = reader.bool();
          break;
        case 5:
          message.showTime = reader.bool();
          break;
        case 6:
          message.showTitle = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      numEvents: isSet93(object.numEvents) ? Number(object.numEvents) : 0,
      showDate: isSet93(object.showDate) ? Boolean(object.showDate) : false,
      showDescription: isSet93(object.showDescription) ? Boolean(object.showDescription) : false,
      showLocation: isSet93(object.showLocation) ? Boolean(object.showLocation) : false,
      showTime: isSet93(object.showTime) ? Boolean(object.showTime) : false,
      showTitle: isSet93(object.showTitle) ? Boolean(object.showTitle) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.numEvents !== void 0 && (obj.numEvents = Math.round(message.numEvents));
    message.showDate !== void 0 && (obj.showDate = message.showDate);
    message.showDescription !== void 0 && (obj.showDescription = message.showDescription);
    message.showLocation !== void 0 && (obj.showLocation = message.showLocation);
    message.showTime !== void 0 && (obj.showTime = message.showTime);
    message.showTitle !== void 0 && (obj.showTitle = message.showTitle);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCalendarWidgetConfiguration();
    message.numEvents = object.numEvents ?? 0;
    message.showDate = object.showDate ?? false;
    message.showDescription = object.showDescription ?? false;
    message.showLocation = object.showLocation ?? false;
    message.showTime = object.showTime ?? false;
    message.showTitle = object.showTitle ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.CalendarWidgetConfiguration", CalendarWidgetConfiguration);
function createBaseCalendarWidget() {
  return {
    id: "",
    kind: "",
    configuration: void 0,
    googleCalendarId: "",
    requiresSync: false,
    shortName: "",
    styles: void 0
  };
}
var CalendarWidget = {
  $type: "devvit.plugin.redditapi.widgets.CalendarWidget",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.configuration !== void 0) {
      CalendarWidgetConfiguration.encode(message.configuration, writer.uint32(26).fork()).ldelim();
    }
    if (message.googleCalendarId !== "") {
      writer.uint32(34).string(message.googleCalendarId);
    }
    if (message.requiresSync === true) {
      writer.uint32(40).bool(message.requiresSync);
    }
    if (message.shortName !== "") {
      writer.uint32(50).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCalendarWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.kind = reader.string();
          break;
        case 3:
          message.configuration = CalendarWidgetConfiguration.decode(reader, reader.uint32());
          break;
        case 4:
          message.googleCalendarId = reader.string();
          break;
        case 5:
          message.requiresSync = reader.bool();
          break;
        case 6:
          message.shortName = reader.string();
          break;
        case 7:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet93(object.id) ? String(object.id) : "",
      kind: isSet93(object.kind) ? String(object.kind) : "",
      configuration: isSet93(object.configuration) ? CalendarWidgetConfiguration.fromJSON(object.configuration) : void 0,
      googleCalendarId: isSet93(object.googleCalendarId) ? String(object.googleCalendarId) : "",
      requiresSync: isSet93(object.requiresSync) ? Boolean(object.requiresSync) : false,
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.kind !== void 0 && (obj.kind = message.kind);
    message.configuration !== void 0 && (obj.configuration = message.configuration ? CalendarWidgetConfiguration.toJSON(message.configuration) : void 0);
    message.googleCalendarId !== void 0 && (obj.googleCalendarId = message.googleCalendarId);
    message.requiresSync !== void 0 && (obj.requiresSync = message.requiresSync);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCalendarWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.configuration = object.configuration !== void 0 && object.configuration !== null ? CalendarWidgetConfiguration.fromPartial(object.configuration) : void 0;
    message.googleCalendarId = object.googleCalendarId ?? "";
    message.requiresSync = object.requiresSync ?? false;
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.CalendarWidget", CalendarWidget);
function createBaseAddCalendarWidgetRequest() {
  return {
    subreddit: "",
    configuration: void 0,
    googleCalendarId: "",
    requiresSync: false,
    shortName: "",
    styles: void 0
  };
}
var AddCalendarWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddCalendarWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.configuration !== void 0) {
      CalendarWidgetConfiguration.encode(message.configuration, writer.uint32(18).fork()).ldelim();
    }
    if (message.googleCalendarId !== "") {
      writer.uint32(26).string(message.googleCalendarId);
    }
    if (message.requiresSync === true) {
      writer.uint32(32).bool(message.requiresSync);
    }
    if (message.shortName !== "") {
      writer.uint32(42).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddCalendarWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.configuration = CalendarWidgetConfiguration.decode(reader, reader.uint32());
          break;
        case 3:
          message.googleCalendarId = reader.string();
          break;
        case 4:
          message.requiresSync = reader.bool();
          break;
        case 5:
          message.shortName = reader.string();
          break;
        case 6:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      configuration: isSet93(object.configuration) ? CalendarWidgetConfiguration.fromJSON(object.configuration) : void 0,
      googleCalendarId: isSet93(object.googleCalendarId) ? String(object.googleCalendarId) : "",
      requiresSync: isSet93(object.requiresSync) ? Boolean(object.requiresSync) : false,
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.configuration !== void 0 && (obj.configuration = message.configuration ? CalendarWidgetConfiguration.toJSON(message.configuration) : void 0);
    message.googleCalendarId !== void 0 && (obj.googleCalendarId = message.googleCalendarId);
    message.requiresSync !== void 0 && (obj.requiresSync = message.requiresSync);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAddCalendarWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.configuration = object.configuration !== void 0 && object.configuration !== null ? CalendarWidgetConfiguration.fromPartial(object.configuration) : void 0;
    message.googleCalendarId = object.googleCalendarId ?? "";
    message.requiresSync = object.requiresSync ?? false;
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddCalendarWidgetRequest", AddCalendarWidgetRequest);
function createBaseUpdateCalendarWidgetRequest() {
  return {
    subreddit: "",
    id: "",
    configuration: void 0,
    googleCalendarId: "",
    requiresSync: false,
    shortName: "",
    styles: void 0
  };
}
var UpdateCalendarWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdateCalendarWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.configuration !== void 0) {
      CalendarWidgetConfiguration.encode(message.configuration, writer.uint32(26).fork()).ldelim();
    }
    if (message.googleCalendarId !== "") {
      writer.uint32(34).string(message.googleCalendarId);
    }
    if (message.requiresSync === true) {
      writer.uint32(40).bool(message.requiresSync);
    }
    if (message.shortName !== "") {
      writer.uint32(50).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCalendarWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.configuration = CalendarWidgetConfiguration.decode(reader, reader.uint32());
          break;
        case 4:
          message.googleCalendarId = reader.string();
          break;
        case 5:
          message.requiresSync = reader.bool();
          break;
        case 6:
          message.shortName = reader.string();
          break;
        case 7:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      id: isSet93(object.id) ? String(object.id) : "",
      configuration: isSet93(object.configuration) ? CalendarWidgetConfiguration.fromJSON(object.configuration) : void 0,
      googleCalendarId: isSet93(object.googleCalendarId) ? String(object.googleCalendarId) : "",
      requiresSync: isSet93(object.requiresSync) ? Boolean(object.requiresSync) : false,
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.id !== void 0 && (obj.id = message.id);
    message.configuration !== void 0 && (obj.configuration = message.configuration ? CalendarWidgetConfiguration.toJSON(message.configuration) : void 0);
    message.googleCalendarId !== void 0 && (obj.googleCalendarId = message.googleCalendarId);
    message.requiresSync !== void 0 && (obj.requiresSync = message.requiresSync);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateCalendarWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.configuration = object.configuration !== void 0 && object.configuration !== null ? CalendarWidgetConfiguration.fromPartial(object.configuration) : void 0;
    message.googleCalendarId = object.googleCalendarId ?? "";
    message.requiresSync = object.requiresSync ?? false;
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateCalendarWidgetRequest", UpdateCalendarWidgetRequest);
function createBaseTextAreaWidget() {
  return { id: "", kind: "", shortName: "", text: "", styles: void 0 };
}
var TextAreaWidget = {
  $type: "devvit.plugin.redditapi.widgets.TextAreaWidget",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTextAreaWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.kind = reader.string();
          break;
        case 3:
          message.shortName = reader.string();
          break;
        case 4:
          message.text = reader.string();
          break;
        case 5:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet93(object.id) ? String(object.id) : "",
      kind: isSet93(object.kind) ? String(object.kind) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      text: isSet93(object.text) ? String(object.text) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.kind !== void 0 && (obj.kind = message.kind);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.text !== void 0 && (obj.text = message.text);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTextAreaWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.shortName = object.shortName ?? "";
    message.text = object.text ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.TextAreaWidget", TextAreaWidget);
function createBaseAddTextAreaWidgetRequest() {
  return { subreddit: "", shortName: "", text: "", styles: void 0 };
}
var AddTextAreaWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddTextAreaWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.shortName !== "") {
      writer.uint32(18).string(message.shortName);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddTextAreaWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.shortName = reader.string();
          break;
        case 3:
          message.text = reader.string();
          break;
        case 4:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      text: isSet93(object.text) ? String(object.text) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.text !== void 0 && (obj.text = message.text);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAddTextAreaWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.shortName = object.shortName ?? "";
    message.text = object.text ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddTextAreaWidgetRequest", AddTextAreaWidgetRequest);
function createBaseUpdateTextAreaWidgetRequest() {
  return { subreddit: "", id: "", shortName: "", text: "", styles: void 0 };
}
var UpdateTextAreaWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdateTextAreaWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateTextAreaWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.shortName = reader.string();
          break;
        case 4:
          message.text = reader.string();
          break;
        case 5:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      id: isSet93(object.id) ? String(object.id) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      text: isSet93(object.text) ? String(object.text) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.id !== void 0 && (obj.id = message.id);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.text !== void 0 && (obj.text = message.text);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateTextAreaWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.shortName = object.shortName ?? "";
    message.text = object.text ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateTextAreaWidgetRequest", UpdateTextAreaWidgetRequest);
function createBaseWidgetButton() {
  return {
    kind: "",
    text: "",
    url: void 0,
    imageUrl: void 0,
    linkUrl: void 0,
    color: void 0,
    fillColor: void 0,
    textColor: void 0,
    height: void 0,
    width: void 0,
    hoverState: void 0
  };
}
var WidgetButton = {
  $type: "devvit.plugin.redditapi.widgets.WidgetButton",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(26).fork()).ldelim();
    }
    if (message.imageUrl !== void 0) {
      StringValue.encode({ value: message.imageUrl }, writer.uint32(34).fork()).ldelim();
    }
    if (message.linkUrl !== void 0) {
      StringValue.encode({ value: message.linkUrl }, writer.uint32(42).fork()).ldelim();
    }
    if (message.color !== void 0) {
      StringValue.encode({ value: message.color }, writer.uint32(50).fork()).ldelim();
    }
    if (message.fillColor !== void 0) {
      StringValue.encode({ value: message.fillColor }, writer.uint32(58).fork()).ldelim();
    }
    if (message.textColor !== void 0) {
      StringValue.encode({ value: message.textColor }, writer.uint32(66).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(74).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(82).fork()).ldelim();
    }
    if (message.hoverState !== void 0) {
      WidgetButton_HoverState.encode(message.hoverState, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWidgetButton();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.text = reader.string();
          break;
        case 3:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.imageUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.linkUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.color = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.fillColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.textColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.hoverState = WidgetButton_HoverState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet93(object.kind) ? String(object.kind) : "",
      text: isSet93(object.text) ? String(object.text) : "",
      url: isSet93(object.url) ? String(object.url) : void 0,
      imageUrl: isSet93(object.imageUrl) ? String(object.imageUrl) : void 0,
      linkUrl: isSet93(object.linkUrl) ? String(object.linkUrl) : void 0,
      color: isSet93(object.color) ? String(object.color) : void 0,
      fillColor: isSet93(object.fillColor) ? String(object.fillColor) : void 0,
      textColor: isSet93(object.textColor) ? String(object.textColor) : void 0,
      height: isSet93(object.height) ? Number(object.height) : void 0,
      width: isSet93(object.width) ? Number(object.width) : void 0,
      hoverState: isSet93(object.hoverState) ? WidgetButton_HoverState.fromJSON(object.hoverState) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.text !== void 0 && (obj.text = message.text);
    message.url !== void 0 && (obj.url = message.url);
    message.imageUrl !== void 0 && (obj.imageUrl = message.imageUrl);
    message.linkUrl !== void 0 && (obj.linkUrl = message.linkUrl);
    message.color !== void 0 && (obj.color = message.color);
    message.fillColor !== void 0 && (obj.fillColor = message.fillColor);
    message.textColor !== void 0 && (obj.textColor = message.textColor);
    message.height !== void 0 && (obj.height = message.height);
    message.width !== void 0 && (obj.width = message.width);
    message.hoverState !== void 0 && (obj.hoverState = message.hoverState ? WidgetButton_HoverState.toJSON(message.hoverState) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWidgetButton();
    message.kind = object.kind ?? "";
    message.text = object.text ?? "";
    message.url = object.url ?? void 0;
    message.imageUrl = object.imageUrl ?? void 0;
    message.linkUrl = object.linkUrl ?? void 0;
    message.color = object.color ?? void 0;
    message.fillColor = object.fillColor ?? void 0;
    message.textColor = object.textColor ?? void 0;
    message.height = object.height ?? void 0;
    message.width = object.width ?? void 0;
    message.hoverState = object.hoverState !== void 0 && object.hoverState !== null ? WidgetButton_HoverState.fromPartial(object.hoverState) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.WidgetButton", WidgetButton);
function createBaseWidgetButton_HoverState() {
  return {
    kind: "",
    color: void 0,
    fillColor: void 0,
    text: void 0,
    textColor: void 0,
    imageUrl: void 0,
    height: void 0,
    width: void 0
  };
}
var WidgetButton_HoverState = {
  $type: "devvit.plugin.redditapi.widgets.WidgetButton.HoverState",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.color !== void 0) {
      StringValue.encode({ value: message.color }, writer.uint32(18).fork()).ldelim();
    }
    if (message.fillColor !== void 0) {
      StringValue.encode({ value: message.fillColor }, writer.uint32(26).fork()).ldelim();
    }
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(34).fork()).ldelim();
    }
    if (message.textColor !== void 0) {
      StringValue.encode({ value: message.textColor }, writer.uint32(42).fork()).ldelim();
    }
    if (message.imageUrl !== void 0) {
      StringValue.encode({ value: message.imageUrl }, writer.uint32(50).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(58).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWidgetButton_HoverState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.color = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.fillColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.text = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.textColor = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.imageUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet93(object.kind) ? String(object.kind) : "",
      color: isSet93(object.color) ? String(object.color) : void 0,
      fillColor: isSet93(object.fillColor) ? String(object.fillColor) : void 0,
      text: isSet93(object.text) ? String(object.text) : void 0,
      textColor: isSet93(object.textColor) ? String(object.textColor) : void 0,
      imageUrl: isSet93(object.imageUrl) ? String(object.imageUrl) : void 0,
      height: isSet93(object.height) ? Number(object.height) : void 0,
      width: isSet93(object.width) ? Number(object.width) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.color !== void 0 && (obj.color = message.color);
    message.fillColor !== void 0 && (obj.fillColor = message.fillColor);
    message.text !== void 0 && (obj.text = message.text);
    message.textColor !== void 0 && (obj.textColor = message.textColor);
    message.imageUrl !== void 0 && (obj.imageUrl = message.imageUrl);
    message.height !== void 0 && (obj.height = message.height);
    message.width !== void 0 && (obj.width = message.width);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWidgetButton_HoverState();
    message.kind = object.kind ?? "";
    message.color = object.color ?? void 0;
    message.fillColor = object.fillColor ?? void 0;
    message.text = object.text ?? void 0;
    message.textColor = object.textColor ?? void 0;
    message.imageUrl = object.imageUrl ?? void 0;
    message.height = object.height ?? void 0;
    message.width = object.width ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.WidgetButton.HoverState", WidgetButton_HoverState);
function createBaseButtonWidget() {
  return { id: "", kind: "", shortName: "", description: "", buttons: [], styles: void 0 };
}
var ButtonWidget = {
  $type: "devvit.plugin.redditapi.widgets.ButtonWidget",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.buttons) {
      WidgetButton.encode(v, writer.uint32(42).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseButtonWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.kind = reader.string();
          break;
        case 3:
          message.shortName = reader.string();
          break;
        case 4:
          message.description = reader.string();
          break;
        case 5:
          message.buttons.push(WidgetButton.decode(reader, reader.uint32()));
          break;
        case 6:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet93(object.id) ? String(object.id) : "",
      kind: isSet93(object.kind) ? String(object.kind) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      description: isSet93(object.description) ? String(object.description) : "",
      buttons: Array.isArray(object?.buttons) ? object.buttons.map((e) => WidgetButton.fromJSON(e)) : [],
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.kind !== void 0 && (obj.kind = message.kind);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.description !== void 0 && (obj.description = message.description);
    if (message.buttons) {
      obj.buttons = message.buttons.map((e) => e ? WidgetButton.toJSON(e) : void 0);
    } else {
      obj.buttons = [];
    }
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseButtonWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.shortName = object.shortName ?? "";
    message.description = object.description ?? "";
    message.buttons = object.buttons?.map((e) => WidgetButton.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.ButtonWidget", ButtonWidget);
function createBaseAddButtonWidgetRequest() {
  return { subreddit: "", shortName: "", description: "", buttons: [], styles: void 0 };
}
var AddButtonWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddButtonWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.shortName !== "") {
      writer.uint32(18).string(message.shortName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.buttons) {
      WidgetButton.encode(v, writer.uint32(34).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddButtonWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.shortName = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          message.buttons.push(WidgetButton.decode(reader, reader.uint32()));
          break;
        case 5:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      description: isSet93(object.description) ? String(object.description) : "",
      buttons: Array.isArray(object?.buttons) ? object.buttons.map((e) => WidgetButton.fromJSON(e)) : [],
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.description !== void 0 && (obj.description = message.description);
    if (message.buttons) {
      obj.buttons = message.buttons.map((e) => e ? WidgetButton.toJSON(e) : void 0);
    } else {
      obj.buttons = [];
    }
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAddButtonWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.shortName = object.shortName ?? "";
    message.description = object.description ?? "";
    message.buttons = object.buttons?.map((e) => WidgetButton.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddButtonWidgetRequest", AddButtonWidgetRequest);
function createBaseUpdateButtonWidgetRequest() {
  return { subreddit: "", id: "", shortName: "", description: "", buttons: [], styles: void 0 };
}
var UpdateButtonWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdateButtonWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.buttons) {
      WidgetButton.encode(v, writer.uint32(42).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateButtonWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.shortName = reader.string();
          break;
        case 4:
          message.description = reader.string();
          break;
        case 5:
          message.buttons.push(WidgetButton.decode(reader, reader.uint32()));
          break;
        case 6:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      id: isSet93(object.id) ? String(object.id) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      description: isSet93(object.description) ? String(object.description) : "",
      buttons: Array.isArray(object?.buttons) ? object.buttons.map((e) => WidgetButton.fromJSON(e)) : [],
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.id !== void 0 && (obj.id = message.id);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.description !== void 0 && (obj.description = message.description);
    if (message.buttons) {
      obj.buttons = message.buttons.map((e) => e ? WidgetButton.toJSON(e) : void 0);
    } else {
      obj.buttons = [];
    }
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateButtonWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.shortName = object.shortName ?? "";
    message.description = object.description ?? "";
    message.buttons = object.buttons?.map((e) => WidgetButton.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateButtonWidgetRequest", UpdateButtonWidgetRequest);
function createBaseCommunityListWidget() {
  return { id: "", kind: "", shortName: "", data: [], styles: void 0 };
}
var CommunityListWidget = {
  $type: "devvit.plugin.redditapi.widgets.CommunityListWidget",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    for (const v of message.data) {
      CommunityListWidget_CommunityData.encode(v, writer.uint32(34).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommunityListWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.kind = reader.string();
          break;
        case 3:
          message.shortName = reader.string();
          break;
        case 4:
          message.data.push(CommunityListWidget_CommunityData.decode(reader, reader.uint32()));
          break;
        case 5:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet93(object.id) ? String(object.id) : "",
      kind: isSet93(object.kind) ? String(object.kind) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      data: Array.isArray(object?.data) ? object.data.map((e) => CommunityListWidget_CommunityData.fromJSON(e)) : [],
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.kind !== void 0 && (obj.kind = message.kind);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    if (message.data) {
      obj.data = message.data.map((e) => e ? CommunityListWidget_CommunityData.toJSON(e) : void 0);
    } else {
      obj.data = [];
    }
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommunityListWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.shortName = object.shortName ?? "";
    message.data = object.data?.map((e) => CommunityListWidget_CommunityData.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.CommunityListWidget", CommunityListWidget);
function createBaseCommunityListWidget_CommunityData() {
  return {
    communityIcon: "",
    iconUrl: "",
    isNsfw: false,
    isSubscribed: false,
    name: "",
    prefixedName: "",
    primaryColor: "",
    subscribers: 0,
    type: ""
  };
}
var CommunityListWidget_CommunityData = {
  $type: "devvit.plugin.redditapi.widgets.CommunityListWidget.CommunityData",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.communityIcon !== "") {
      writer.uint32(10).string(message.communityIcon);
    }
    if (message.iconUrl !== "") {
      writer.uint32(18).string(message.iconUrl);
    }
    if (message.isNsfw === true) {
      writer.uint32(24).bool(message.isNsfw);
    }
    if (message.isSubscribed === true) {
      writer.uint32(32).bool(message.isSubscribed);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.prefixedName !== "") {
      writer.uint32(50).string(message.prefixedName);
    }
    if (message.primaryColor !== "") {
      writer.uint32(58).string(message.primaryColor);
    }
    if (message.subscribers !== 0) {
      writer.uint32(64).int32(message.subscribers);
    }
    if (message.type !== "") {
      writer.uint32(74).string(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommunityListWidget_CommunityData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.communityIcon = reader.string();
          break;
        case 2:
          message.iconUrl = reader.string();
          break;
        case 3:
          message.isNsfw = reader.bool();
          break;
        case 4:
          message.isSubscribed = reader.bool();
          break;
        case 5:
          message.name = reader.string();
          break;
        case 6:
          message.prefixedName = reader.string();
          break;
        case 7:
          message.primaryColor = reader.string();
          break;
        case 8:
          message.subscribers = reader.int32();
          break;
        case 9:
          message.type = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      communityIcon: isSet93(object.communityIcon) ? String(object.communityIcon) : "",
      iconUrl: isSet93(object.iconUrl) ? String(object.iconUrl) : "",
      isNsfw: isSet93(object.isNsfw) ? Boolean(object.isNsfw) : false,
      isSubscribed: isSet93(object.isSubscribed) ? Boolean(object.isSubscribed) : false,
      name: isSet93(object.name) ? String(object.name) : "",
      prefixedName: isSet93(object.prefixedName) ? String(object.prefixedName) : "",
      primaryColor: isSet93(object.primaryColor) ? String(object.primaryColor) : "",
      subscribers: isSet93(object.subscribers) ? Number(object.subscribers) : 0,
      type: isSet93(object.type) ? String(object.type) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.communityIcon !== void 0 && (obj.communityIcon = message.communityIcon);
    message.iconUrl !== void 0 && (obj.iconUrl = message.iconUrl);
    message.isNsfw !== void 0 && (obj.isNsfw = message.isNsfw);
    message.isSubscribed !== void 0 && (obj.isSubscribed = message.isSubscribed);
    message.name !== void 0 && (obj.name = message.name);
    message.prefixedName !== void 0 && (obj.prefixedName = message.prefixedName);
    message.primaryColor !== void 0 && (obj.primaryColor = message.primaryColor);
    message.subscribers !== void 0 && (obj.subscribers = Math.round(message.subscribers));
    message.type !== void 0 && (obj.type = message.type);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCommunityListWidget_CommunityData();
    message.communityIcon = object.communityIcon ?? "";
    message.iconUrl = object.iconUrl ?? "";
    message.isNsfw = object.isNsfw ?? false;
    message.isSubscribed = object.isSubscribed ?? false;
    message.name = object.name ?? "";
    message.prefixedName = object.prefixedName ?? "";
    message.primaryColor = object.primaryColor ?? "";
    message.subscribers = object.subscribers ?? 0;
    message.type = object.type ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.CommunityListWidget.CommunityData", CommunityListWidget_CommunityData);
function createBaseAddCommunityListWidgetRequest() {
  return { subreddit: "", shortName: "", data: [], styles: void 0 };
}
var AddCommunityListWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddCommunityListWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.shortName !== "") {
      writer.uint32(18).string(message.shortName);
    }
    for (const v of message.data) {
      writer.uint32(26).string(v);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddCommunityListWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.shortName = reader.string();
          break;
        case 3:
          message.data.push(reader.string());
          break;
        case 4:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      data: Array.isArray(object?.data) ? object.data.map((e) => String(e)) : [],
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    if (message.data) {
      obj.data = message.data.map((e) => e);
    } else {
      obj.data = [];
    }
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAddCommunityListWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.shortName = object.shortName ?? "";
    message.data = object.data?.map((e) => e) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddCommunityListWidgetRequest", AddCommunityListWidgetRequest);
function createBaseUpdateCommunityListWidgetRequest() {
  return { subreddit: "", id: "", shortName: "", data: [], styles: void 0 };
}
var UpdateCommunityListWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    for (const v of message.data) {
      writer.uint32(34).string(v);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCommunityListWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.shortName = reader.string();
          break;
        case 4:
          message.data.push(reader.string());
          break;
        case 5:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      id: isSet93(object.id) ? String(object.id) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      data: Array.isArray(object?.data) ? object.data.map((e) => String(e)) : [],
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.id !== void 0 && (obj.id = message.id);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    if (message.data) {
      obj.data = message.data.map((e) => e);
    } else {
      obj.data = [];
    }
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateCommunityListWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.shortName = object.shortName ?? "";
    message.data = object.data?.map((e) => e) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetRequest", UpdateCommunityListWidgetRequest);
function createBaseUpdateCommunityListWidgetResponse() {
  return { kind: "", shortName: "", data: [], styles: void 0 };
}
var UpdateCommunityListWidgetResponse = {
  $type: "devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetResponse",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.shortName !== "") {
      writer.uint32(18).string(message.shortName);
    }
    for (const v of message.data) {
      writer.uint32(26).string(v);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCommunityListWidgetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.shortName = reader.string();
          break;
        case 3:
          message.data.push(reader.string());
          break;
        case 4:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet93(object.kind) ? String(object.kind) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      data: Array.isArray(object?.data) ? object.data.map((e) => String(e)) : [],
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    if (message.data) {
      obj.data = message.data.map((e) => e);
    } else {
      obj.data = [];
    }
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateCommunityListWidgetResponse();
    message.kind = object.kind ?? "";
    message.shortName = object.shortName ?? "";
    message.data = object.data?.map((e) => e) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateCommunityListWidgetResponse", UpdateCommunityListWidgetResponse);
function createBasePostFlairWidget() {
  return { id: "", kind: "", display: "", order: [], shortName: "", styles: void 0, subreddit: void 0 };
}
var PostFlairWidget = {
  $type: "devvit.plugin.redditapi.widgets.PostFlairWidget",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.display !== "") {
      writer.uint32(26).string(message.display);
    }
    for (const v of message.order) {
      writer.uint32(34).string(v);
    }
    if (message.shortName !== "") {
      writer.uint32(42).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
    }
    if (message.subreddit !== void 0) {
      StringValue.encode({ value: message.subreddit }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostFlairWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.kind = reader.string();
          break;
        case 3:
          message.display = reader.string();
          break;
        case 4:
          message.order.push(reader.string());
          break;
        case 5:
          message.shortName = reader.string();
          break;
        case 6:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        case 7:
          message.subreddit = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet93(object.id) ? String(object.id) : "",
      kind: isSet93(object.kind) ? String(object.kind) : "",
      display: isSet93(object.display) ? String(object.display) : "",
      order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : [],
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0,
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.kind !== void 0 && (obj.kind = message.kind);
    message.display !== void 0 && (obj.display = message.display);
    if (message.order) {
      obj.order = message.order.map((e) => e);
    } else {
      obj.order = [];
    }
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePostFlairWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.display = object.display ?? "";
    message.order = object.order?.map((e) => e) || [];
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    message.subreddit = object.subreddit ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.PostFlairWidget", PostFlairWidget);
function createBaseAddPostFlairWidgetRequest() {
  return { subreddit: "", display: "", order: [], shortName: "", styles: void 0 };
}
var AddPostFlairWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddPostFlairWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.display !== "") {
      writer.uint32(18).string(message.display);
    }
    for (const v of message.order) {
      writer.uint32(26).string(v);
    }
    if (message.shortName !== "") {
      writer.uint32(34).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddPostFlairWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.display = reader.string();
          break;
        case 3:
          message.order.push(reader.string());
          break;
        case 4:
          message.shortName = reader.string();
          break;
        case 5:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      display: isSet93(object.display) ? String(object.display) : "",
      order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : [],
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.display !== void 0 && (obj.display = message.display);
    if (message.order) {
      obj.order = message.order.map((e) => e);
    } else {
      obj.order = [];
    }
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAddPostFlairWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.display = object.display ?? "";
    message.order = object.order?.map((e) => e) || [];
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddPostFlairWidgetRequest", AddPostFlairWidgetRequest);
function createBaseUpdatePostFlairWidgetRequest() {
  return { subreddit: "", id: "", display: "", order: [], shortName: "", styles: void 0 };
}
var UpdatePostFlairWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdatePostFlairWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.display !== "") {
      writer.uint32(26).string(message.display);
    }
    for (const v of message.order) {
      writer.uint32(34).string(v);
    }
    if (message.shortName !== "") {
      writer.uint32(42).string(message.shortName);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdatePostFlairWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.display = reader.string();
          break;
        case 4:
          message.order.push(reader.string());
          break;
        case 5:
          message.shortName = reader.string();
          break;
        case 6:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      id: isSet93(object.id) ? String(object.id) : "",
      display: isSet93(object.display) ? String(object.display) : "",
      order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : [],
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.id !== void 0 && (obj.id = message.id);
    message.display !== void 0 && (obj.display = message.display);
    if (message.order) {
      obj.order = message.order.map((e) => e);
    } else {
      obj.order = [];
    }
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdatePostFlairWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.display = object.display ?? "";
    message.order = object.order?.map((e) => e) || [];
    message.shortName = object.shortName ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdatePostFlairWidgetRequest", UpdatePostFlairWidgetRequest);
function createBaseDeleteWidgetRequest() {
  return { id: "", subreddit: "" };
}
var DeleteWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.DeleteWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.subreddit !== "") {
      writer.uint32(18).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDeleteWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet93(object.id) ? String(object.id) : "",
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDeleteWidgetRequest();
    message.id = object.id ?? "";
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.DeleteWidgetRequest", DeleteWidgetRequest);
function createBaseGetWidgetsRequest() {
  return { subreddit: "", progressiveImages: void 0 };
}
var GetWidgetsRequest = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.progressiveImages !== void 0) {
      BoolValue.encode({ value: message.progressiveImages }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.progressiveImages = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      progressiveImages: isSet93(object.progressiveImages) ? Boolean(object.progressiveImages) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.progressiveImages !== void 0 && (obj.progressiveImages = message.progressiveImages);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsRequest();
    message.subreddit = object.subreddit ?? "";
    message.progressiveImages = object.progressiveImages ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsRequest", GetWidgetsRequest);
function createBaseGetWidgetsResponse() {
  return { layout: void 0, items: {} };
}
var GetWidgetsResponse = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.layout !== void 0) {
      GetWidgetsResponse_Layout.encode(message.layout, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.items).forEach(([key, value]) => {
      GetWidgetsResponse_ItemsEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layout = GetWidgetsResponse_Layout.decode(reader, reader.uint32());
          break;
        case 2:
          const entry2 = GetWidgetsResponse_ItemsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.items[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      layout: isSet93(object.layout) ? GetWidgetsResponse_Layout.fromJSON(object.layout) : void 0,
      items: isObject18(object.items) ? Object.entries(object.items).reduce((acc, [key, value]) => {
        acc[key] = GetWidgetsResponse_WidgetItem.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.layout !== void 0 && (obj.layout = message.layout ? GetWidgetsResponse_Layout.toJSON(message.layout) : void 0);
    obj.items = {};
    if (message.items) {
      Object.entries(message.items).forEach(([k, v]) => {
        obj.items[k] = GetWidgetsResponse_WidgetItem.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse();
    message.layout = object.layout !== void 0 && object.layout !== null ? GetWidgetsResponse_Layout.fromPartial(object.layout) : void 0;
    message.items = Object.entries(object.items ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = GetWidgetsResponse_WidgetItem.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse", GetWidgetsResponse);
function createBaseGetWidgetsResponse_WidgetOrdering() {
  return { order: [] };
}
var GetWidgetsResponse_WidgetOrdering = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetOrdering",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    for (const v of message.order) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_WidgetOrdering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.order.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.order) {
      obj.order = message.order.map((e) => e);
    } else {
      obj.order = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_WidgetOrdering();
    message.order = object.order?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetOrdering", GetWidgetsResponse_WidgetOrdering);
function createBaseGetWidgetsResponse_Layout() {
  return { idCardWidget: "", topbar: void 0, sidebar: void 0, moderatorWidget: "" };
}
var GetWidgetsResponse_Layout = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.Layout",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.idCardWidget !== "") {
      writer.uint32(10).string(message.idCardWidget);
    }
    if (message.topbar !== void 0) {
      GetWidgetsResponse_WidgetOrdering.encode(message.topbar, writer.uint32(18).fork()).ldelim();
    }
    if (message.sidebar !== void 0) {
      GetWidgetsResponse_WidgetOrdering.encode(message.sidebar, writer.uint32(26).fork()).ldelim();
    }
    if (message.moderatorWidget !== "") {
      writer.uint32(34).string(message.moderatorWidget);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_Layout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.idCardWidget = reader.string();
          break;
        case 2:
          message.topbar = GetWidgetsResponse_WidgetOrdering.decode(reader, reader.uint32());
          break;
        case 3:
          message.sidebar = GetWidgetsResponse_WidgetOrdering.decode(reader, reader.uint32());
          break;
        case 4:
          message.moderatorWidget = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      idCardWidget: isSet93(object.idCardWidget) ? String(object.idCardWidget) : "",
      topbar: isSet93(object.topbar) ? GetWidgetsResponse_WidgetOrdering.fromJSON(object.topbar) : void 0,
      sidebar: isSet93(object.sidebar) ? GetWidgetsResponse_WidgetOrdering.fromJSON(object.sidebar) : void 0,
      moderatorWidget: isSet93(object.moderatorWidget) ? String(object.moderatorWidget) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.idCardWidget !== void 0 && (obj.idCardWidget = message.idCardWidget);
    message.topbar !== void 0 && (obj.topbar = message.topbar ? GetWidgetsResponse_WidgetOrdering.toJSON(message.topbar) : void 0);
    message.sidebar !== void 0 && (obj.sidebar = message.sidebar ? GetWidgetsResponse_WidgetOrdering.toJSON(message.sidebar) : void 0);
    message.moderatorWidget !== void 0 && (obj.moderatorWidget = message.moderatorWidget);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_Layout();
    message.idCardWidget = object.idCardWidget ?? "";
    message.topbar = object.topbar !== void 0 && object.topbar !== null ? GetWidgetsResponse_WidgetOrdering.fromPartial(object.topbar) : void 0;
    message.sidebar = object.sidebar !== void 0 && object.sidebar !== null ? GetWidgetsResponse_WidgetOrdering.fromPartial(object.sidebar) : void 0;
    message.moderatorWidget = object.moderatorWidget ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.Layout", GetWidgetsResponse_Layout);
function createBaseGetWidgetsResponse_WidgetItem() {
  return {
    id: "",
    kind: "",
    styles: void 0,
    shortName: "",
    description: void 0,
    data: [],
    buttons: [],
    subscribersCount: void 0,
    currentlyViewingText: void 0,
    currentlyViewingCount: void 0,
    subscribersText: void 0,
    showWiki: void 0,
    templates: {},
    display: void 0,
    order: [],
    mods: [],
    totalMods: void 0,
    googleCalendarId: void 0,
    requiresSync: void 0,
    configuration: void 0,
    text: void 0,
    css: void 0,
    stylesheetUrl: void 0,
    height: void 0,
    imageData: []
  };
}
var GetWidgetsResponse_WidgetItem = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(26).fork()).ldelim();
    }
    if (message.shortName !== "") {
      writer.uint32(34).string(message.shortName);
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.data) {
      GetWidgetsResponse_WidgetItem_Data.encode(v, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.buttons) {
      WidgetButton.encode(v, writer.uint32(58).fork()).ldelim();
    }
    if (message.subscribersCount !== void 0) {
      Int64Value.encode({ value: message.subscribersCount }, writer.uint32(66).fork()).ldelim();
    }
    if (message.currentlyViewingText !== void 0) {
      StringValue.encode({ value: message.currentlyViewingText }, writer.uint32(74).fork()).ldelim();
    }
    if (message.currentlyViewingCount !== void 0) {
      Int64Value.encode({ value: message.currentlyViewingCount }, writer.uint32(82).fork()).ldelim();
    }
    if (message.subscribersText !== void 0) {
      StringValue.encode({ value: message.subscribersText }, writer.uint32(90).fork()).ldelim();
    }
    if (message.showWiki !== void 0) {
      BoolValue.encode({ value: message.showWiki }, writer.uint32(98).fork()).ldelim();
    }
    Object.entries(message.templates).forEach(([key, value]) => {
      GetWidgetsResponse_WidgetItem_TemplatesEntry.encode({ key, value }, writer.uint32(106).fork()).ldelim();
    });
    if (message.display !== void 0) {
      StringValue.encode({ value: message.display }, writer.uint32(114).fork()).ldelim();
    }
    for (const v of message.order) {
      writer.uint32(122).string(v);
    }
    for (const v of message.mods) {
      GetWidgetsResponse_WidgetItem_Moderator.encode(v, writer.uint32(130).fork()).ldelim();
    }
    if (message.totalMods !== void 0) {
      Int64Value.encode({ value: message.totalMods }, writer.uint32(138).fork()).ldelim();
    }
    if (message.googleCalendarId !== void 0) {
      StringValue.encode({ value: message.googleCalendarId }, writer.uint32(146).fork()).ldelim();
    }
    if (message.requiresSync !== void 0) {
      BoolValue.encode({ value: message.requiresSync }, writer.uint32(154).fork()).ldelim();
    }
    if (message.configuration !== void 0) {
      CalendarWidgetConfiguration.encode(message.configuration, writer.uint32(162).fork()).ldelim();
    }
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(170).fork()).ldelim();
    }
    if (message.css !== void 0) {
      StringValue.encode({ value: message.css }, writer.uint32(178).fork()).ldelim();
    }
    if (message.stylesheetUrl !== void 0) {
      StringValue.encode({ value: message.stylesheetUrl }, writer.uint32(186).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int64Value.encode({ value: message.height }, writer.uint32(194).fork()).ldelim();
    }
    for (const v of message.imageData) {
      WidgetImage.encode(v, writer.uint32(202).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_WidgetItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.kind = reader.string();
          break;
        case 3:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        case 4:
          message.shortName = reader.string();
          break;
        case 5:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.data.push(GetWidgetsResponse_WidgetItem_Data.decode(reader, reader.uint32()));
          break;
        case 7:
          message.buttons.push(WidgetButton.decode(reader, reader.uint32()));
          break;
        case 8:
          message.subscribersCount = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.currentlyViewingText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.currentlyViewingCount = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.subscribersText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.showWiki = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          const entry13 = GetWidgetsResponse_WidgetItem_TemplatesEntry.decode(reader, reader.uint32());
          if (entry13.value !== void 0) {
            message.templates[entry13.key] = entry13.value;
          }
          break;
        case 14:
          message.display = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.order.push(reader.string());
          break;
        case 16:
          message.mods.push(GetWidgetsResponse_WidgetItem_Moderator.decode(reader, reader.uint32()));
          break;
        case 17:
          message.totalMods = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.googleCalendarId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 19:
          message.requiresSync = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 20:
          message.configuration = CalendarWidgetConfiguration.decode(reader, reader.uint32());
          break;
        case 21:
          message.text = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 22:
          message.css = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 23:
          message.stylesheetUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 24:
          message.height = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 25:
          message.imageData.push(WidgetImage.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet93(object.id) ? String(object.id) : "",
      kind: isSet93(object.kind) ? String(object.kind) : "",
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0,
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      description: isSet93(object.description) ? String(object.description) : void 0,
      data: Array.isArray(object?.data) ? object.data.map((e) => GetWidgetsResponse_WidgetItem_Data.fromJSON(e)) : [],
      buttons: Array.isArray(object?.buttons) ? object.buttons.map((e) => WidgetButton.fromJSON(e)) : [],
      subscribersCount: isSet93(object.subscribersCount) ? Number(object.subscribersCount) : void 0,
      currentlyViewingText: isSet93(object.currentlyViewingText) ? String(object.currentlyViewingText) : void 0,
      currentlyViewingCount: isSet93(object.currentlyViewingCount) ? Number(object.currentlyViewingCount) : void 0,
      subscribersText: isSet93(object.subscribersText) ? String(object.subscribersText) : void 0,
      showWiki: isSet93(object.showWiki) ? Boolean(object.showWiki) : void 0,
      templates: isObject18(object.templates) ? Object.entries(object.templates).reduce((acc, [key, value]) => {
        acc[key] = GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromJSON(value);
        return acc;
      }, {}) : {},
      display: isSet93(object.display) ? String(object.display) : void 0,
      order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : [],
      mods: Array.isArray(object?.mods) ? object.mods.map((e) => GetWidgetsResponse_WidgetItem_Moderator.fromJSON(e)) : [],
      totalMods: isSet93(object.totalMods) ? Number(object.totalMods) : void 0,
      googleCalendarId: isSet93(object.googleCalendarId) ? String(object.googleCalendarId) : void 0,
      requiresSync: isSet93(object.requiresSync) ? Boolean(object.requiresSync) : void 0,
      configuration: isSet93(object.configuration) ? CalendarWidgetConfiguration.fromJSON(object.configuration) : void 0,
      text: isSet93(object.text) ? String(object.text) : void 0,
      css: isSet93(object.css) ? String(object.css) : void 0,
      stylesheetUrl: isSet93(object.stylesheetUrl) ? String(object.stylesheetUrl) : void 0,
      height: isSet93(object.height) ? Number(object.height) : void 0,
      imageData: Array.isArray(object?.imageData) ? object.imageData.map((e) => WidgetImage.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.kind !== void 0 && (obj.kind = message.kind);
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.description !== void 0 && (obj.description = message.description);
    if (message.data) {
      obj.data = message.data.map((e) => e ? GetWidgetsResponse_WidgetItem_Data.toJSON(e) : void 0);
    } else {
      obj.data = [];
    }
    if (message.buttons) {
      obj.buttons = message.buttons.map((e) => e ? WidgetButton.toJSON(e) : void 0);
    } else {
      obj.buttons = [];
    }
    message.subscribersCount !== void 0 && (obj.subscribersCount = message.subscribersCount);
    message.currentlyViewingText !== void 0 && (obj.currentlyViewingText = message.currentlyViewingText);
    message.currentlyViewingCount !== void 0 && (obj.currentlyViewingCount = message.currentlyViewingCount);
    message.subscribersText !== void 0 && (obj.subscribersText = message.subscribersText);
    message.showWiki !== void 0 && (obj.showWiki = message.showWiki);
    obj.templates = {};
    if (message.templates) {
      Object.entries(message.templates).forEach(([k, v]) => {
        obj.templates[k] = GetWidgetsResponse_WidgetItem_PostFlairTemplate.toJSON(v);
      });
    }
    message.display !== void 0 && (obj.display = message.display);
    if (message.order) {
      obj.order = message.order.map((e) => e);
    } else {
      obj.order = [];
    }
    if (message.mods) {
      obj.mods = message.mods.map((e) => e ? GetWidgetsResponse_WidgetItem_Moderator.toJSON(e) : void 0);
    } else {
      obj.mods = [];
    }
    message.totalMods !== void 0 && (obj.totalMods = message.totalMods);
    message.googleCalendarId !== void 0 && (obj.googleCalendarId = message.googleCalendarId);
    message.requiresSync !== void 0 && (obj.requiresSync = message.requiresSync);
    message.configuration !== void 0 && (obj.configuration = message.configuration ? CalendarWidgetConfiguration.toJSON(message.configuration) : void 0);
    message.text !== void 0 && (obj.text = message.text);
    message.css !== void 0 && (obj.css = message.css);
    message.stylesheetUrl !== void 0 && (obj.stylesheetUrl = message.stylesheetUrl);
    message.height !== void 0 && (obj.height = message.height);
    if (message.imageData) {
      obj.imageData = message.imageData.map((e) => e ? WidgetImage.toJSON(e) : void 0);
    } else {
      obj.imageData = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_WidgetItem();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    message.shortName = object.shortName ?? "";
    message.description = object.description ?? void 0;
    message.data = object.data?.map((e) => GetWidgetsResponse_WidgetItem_Data.fromPartial(e)) || [];
    message.buttons = object.buttons?.map((e) => WidgetButton.fromPartial(e)) || [];
    message.subscribersCount = object.subscribersCount ?? void 0;
    message.currentlyViewingText = object.currentlyViewingText ?? void 0;
    message.currentlyViewingCount = object.currentlyViewingCount ?? void 0;
    message.subscribersText = object.subscribersText ?? void 0;
    message.showWiki = object.showWiki ?? void 0;
    message.templates = Object.entries(object.templates ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromPartial(value);
      }
      return acc;
    }, {});
    message.display = object.display ?? void 0;
    message.order = object.order?.map((e) => e) || [];
    message.mods = object.mods?.map((e) => GetWidgetsResponse_WidgetItem_Moderator.fromPartial(e)) || [];
    message.totalMods = object.totalMods ?? void 0;
    message.googleCalendarId = object.googleCalendarId ?? void 0;
    message.requiresSync = object.requiresSync ?? void 0;
    message.configuration = object.configuration !== void 0 && object.configuration !== null ? CalendarWidgetConfiguration.fromPartial(object.configuration) : void 0;
    message.text = object.text ?? void 0;
    message.css = object.css ?? void 0;
    message.stylesheetUrl = object.stylesheetUrl ?? void 0;
    message.height = object.height ?? void 0;
    message.imageData = object.imageData?.map((e) => WidgetImage.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem", GetWidgetsResponse_WidgetItem);
function createBaseGetWidgetsResponse_WidgetItem_Data() {
  return {
    url: void 0,
    linkUrl: void 0,
    height: void 0,
    width: void 0,
    iconUrl: void 0,
    name: void 0,
    prefixedName: void 0,
    isSubscribed: void 0,
    type: void 0,
    subscribers: void 0,
    communityIcon: void 0,
    isNsfw: void 0,
    text: void 0,
    children: []
  };
}
var GetWidgetsResponse_WidgetItem_Data = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.Data",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(10).fork()).ldelim();
    }
    if (message.linkUrl !== void 0) {
      StringValue.encode({ value: message.linkUrl }, writer.uint32(18).fork()).ldelim();
    }
    if (message.height !== void 0) {
      Int32Value.encode({ value: message.height }, writer.uint32(26).fork()).ldelim();
    }
    if (message.width !== void 0) {
      Int32Value.encode({ value: message.width }, writer.uint32(34).fork()).ldelim();
    }
    if (message.iconUrl !== void 0) {
      StringValue.encode({ value: message.iconUrl }, writer.uint32(42).fork()).ldelim();
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(50).fork()).ldelim();
    }
    if (message.prefixedName !== void 0) {
      StringValue.encode({ value: message.prefixedName }, writer.uint32(58).fork()).ldelim();
    }
    if (message.isSubscribed !== void 0) {
      BoolValue.encode({ value: message.isSubscribed }, writer.uint32(66).fork()).ldelim();
    }
    if (message.type !== void 0) {
      StringValue.encode({ value: message.type }, writer.uint32(74).fork()).ldelim();
    }
    if (message.subscribers !== void 0) {
      Int64Value.encode({ value: message.subscribers }, writer.uint32(82).fork()).ldelim();
    }
    if (message.communityIcon !== void 0) {
      StringValue.encode({ value: message.communityIcon }, writer.uint32(90).fork()).ldelim();
    }
    if (message.isNsfw !== void 0) {
      BoolValue.encode({ value: message.isNsfw }, writer.uint32(98).fork()).ldelim();
    }
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(106).fork()).ldelim();
    }
    for (const v of message.children) {
      MenuWidgetItem.encode(v, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_WidgetItem_Data();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.linkUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.height = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.width = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.iconUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.prefixedName = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.isSubscribed = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.type = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.subscribers = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.isNsfw = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.text = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.children.push(MenuWidgetItem.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet93(object.url) ? String(object.url) : void 0,
      linkUrl: isSet93(object.linkUrl) ? String(object.linkUrl) : void 0,
      height: isSet93(object.height) ? Number(object.height) : void 0,
      width: isSet93(object.width) ? Number(object.width) : void 0,
      iconUrl: isSet93(object.iconUrl) ? String(object.iconUrl) : void 0,
      name: isSet93(object.name) ? String(object.name) : void 0,
      prefixedName: isSet93(object.prefixedName) ? String(object.prefixedName) : void 0,
      isSubscribed: isSet93(object.isSubscribed) ? Boolean(object.isSubscribed) : void 0,
      type: isSet93(object.type) ? String(object.type) : void 0,
      subscribers: isSet93(object.subscribers) ? Number(object.subscribers) : void 0,
      communityIcon: isSet93(object.communityIcon) ? String(object.communityIcon) : void 0,
      isNsfw: isSet93(object.isNsfw) ? Boolean(object.isNsfw) : void 0,
      text: isSet93(object.text) ? String(object.text) : void 0,
      children: Array.isArray(object?.children) ? object.children.map((e) => MenuWidgetItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    message.linkUrl !== void 0 && (obj.linkUrl = message.linkUrl);
    message.height !== void 0 && (obj.height = message.height);
    message.width !== void 0 && (obj.width = message.width);
    message.iconUrl !== void 0 && (obj.iconUrl = message.iconUrl);
    message.name !== void 0 && (obj.name = message.name);
    message.prefixedName !== void 0 && (obj.prefixedName = message.prefixedName);
    message.isSubscribed !== void 0 && (obj.isSubscribed = message.isSubscribed);
    message.type !== void 0 && (obj.type = message.type);
    message.subscribers !== void 0 && (obj.subscribers = message.subscribers);
    message.communityIcon !== void 0 && (obj.communityIcon = message.communityIcon);
    message.isNsfw !== void 0 && (obj.isNsfw = message.isNsfw);
    message.text !== void 0 && (obj.text = message.text);
    if (message.children) {
      obj.children = message.children.map((e) => e ? MenuWidgetItem.toJSON(e) : void 0);
    } else {
      obj.children = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_WidgetItem_Data();
    message.url = object.url ?? void 0;
    message.linkUrl = object.linkUrl ?? void 0;
    message.height = object.height ?? void 0;
    message.width = object.width ?? void 0;
    message.iconUrl = object.iconUrl ?? void 0;
    message.name = object.name ?? void 0;
    message.prefixedName = object.prefixedName ?? void 0;
    message.isSubscribed = object.isSubscribed ?? void 0;
    message.type = object.type ?? void 0;
    message.subscribers = object.subscribers ?? void 0;
    message.communityIcon = object.communityIcon ?? void 0;
    message.isNsfw = object.isNsfw ?? void 0;
    message.text = object.text ?? void 0;
    message.children = object.children?.map((e) => MenuWidgetItem.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.Data", GetWidgetsResponse_WidgetItem_Data);
function createBaseGetWidgetsResponse_WidgetItem_Moderator() {
  return {
    name: "",
    authorFlairType: "",
    authorFlairTextColor: "",
    authorFlairBackgroundColor: "",
    authorFalirText: "",
    authorFlairRichtext: []
  };
}
var GetWidgetsResponse_WidgetItem_Moderator = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.Moderator",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.authorFlairType !== "") {
      writer.uint32(18).string(message.authorFlairType);
    }
    if (message.authorFlairTextColor !== "") {
      writer.uint32(26).string(message.authorFlairTextColor);
    }
    if (message.authorFlairBackgroundColor !== "") {
      writer.uint32(34).string(message.authorFlairBackgroundColor);
    }
    if (message.authorFalirText !== "") {
      writer.uint32(42).string(message.authorFalirText);
    }
    for (const v of message.authorFlairRichtext) {
      AuthorFlairRichText.encode(v, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_WidgetItem_Moderator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.authorFlairType = reader.string();
          break;
        case 3:
          message.authorFlairTextColor = reader.string();
          break;
        case 4:
          message.authorFlairBackgroundColor = reader.string();
          break;
        case 5:
          message.authorFalirText = reader.string();
          break;
        case 6:
          message.authorFlairRichtext.push(AuthorFlairRichText.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet93(object.name) ? String(object.name) : "",
      authorFlairType: isSet93(object.authorFlairType) ? String(object.authorFlairType) : "",
      authorFlairTextColor: isSet93(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : "",
      authorFlairBackgroundColor: isSet93(object.authorFlairBackgroundColor) ? String(object.authorFlairBackgroundColor) : "",
      authorFalirText: isSet93(object.authorFalirText) ? String(object.authorFalirText) : "",
      authorFlairRichtext: Array.isArray(object?.authorFlairRichtext) ? object.authorFlairRichtext.map((e) => AuthorFlairRichText.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.authorFlairType !== void 0 && (obj.authorFlairType = message.authorFlairType);
    message.authorFlairTextColor !== void 0 && (obj.authorFlairTextColor = message.authorFlairTextColor);
    message.authorFlairBackgroundColor !== void 0 && (obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor);
    message.authorFalirText !== void 0 && (obj.authorFalirText = message.authorFalirText);
    if (message.authorFlairRichtext) {
      obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => e ? AuthorFlairRichText.toJSON(e) : void 0);
    } else {
      obj.authorFlairRichtext = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_WidgetItem_Moderator();
    message.name = object.name ?? "";
    message.authorFlairType = object.authorFlairType ?? "";
    message.authorFlairTextColor = object.authorFlairTextColor ?? "";
    message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? "";
    message.authorFalirText = object.authorFalirText ?? "";
    message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => AuthorFlairRichText.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.Moderator", GetWidgetsResponse_WidgetItem_Moderator);
function createBaseGetWidgetsResponse_WidgetItem_PostFlairTemplate() {
  return { text: "", richtext: [], backgroundColor: "", templateId: "", textColor: "", type: "" };
}
var GetWidgetsResponse_WidgetItem_PostFlairTemplate = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.PostFlairTemplate",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    for (const v of message.richtext) {
      AuthorFlairRichText.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.backgroundColor !== "") {
      writer.uint32(26).string(message.backgroundColor);
    }
    if (message.templateId !== "") {
      writer.uint32(34).string(message.templateId);
    }
    if (message.textColor !== "") {
      writer.uint32(42).string(message.textColor);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_WidgetItem_PostFlairTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.text = reader.string();
          break;
        case 2:
          message.richtext.push(AuthorFlairRichText.decode(reader, reader.uint32()));
          break;
        case 3:
          message.backgroundColor = reader.string();
          break;
        case 4:
          message.templateId = reader.string();
          break;
        case 5:
          message.textColor = reader.string();
          break;
        case 6:
          message.type = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet93(object.text) ? String(object.text) : "",
      richtext: Array.isArray(object?.richtext) ? object.richtext.map((e) => AuthorFlairRichText.fromJSON(e)) : [],
      backgroundColor: isSet93(object.backgroundColor) ? String(object.backgroundColor) : "",
      templateId: isSet93(object.templateId) ? String(object.templateId) : "",
      textColor: isSet93(object.textColor) ? String(object.textColor) : "",
      type: isSet93(object.type) ? String(object.type) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.text !== void 0 && (obj.text = message.text);
    if (message.richtext) {
      obj.richtext = message.richtext.map((e) => e ? AuthorFlairRichText.toJSON(e) : void 0);
    } else {
      obj.richtext = [];
    }
    message.backgroundColor !== void 0 && (obj.backgroundColor = message.backgroundColor);
    message.templateId !== void 0 && (obj.templateId = message.templateId);
    message.textColor !== void 0 && (obj.textColor = message.textColor);
    message.type !== void 0 && (obj.type = message.type);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_WidgetItem_PostFlairTemplate();
    message.text = object.text ?? "";
    message.richtext = object.richtext?.map((e) => AuthorFlairRichText.fromPartial(e)) || [];
    message.backgroundColor = object.backgroundColor ?? "";
    message.templateId = object.templateId ?? "";
    message.textColor = object.textColor ?? "";
    message.type = object.type ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.PostFlairTemplate", GetWidgetsResponse_WidgetItem_PostFlairTemplate);
function createBaseGetWidgetsResponse_WidgetItem_TemplatesEntry() {
  return { key: "", value: void 0 };
}
var GetWidgetsResponse_WidgetItem_TemplatesEntry = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.TemplatesEntry",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      GetWidgetsResponse_WidgetItem_PostFlairTemplate.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_WidgetItem_TemplatesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = GetWidgetsResponse_WidgetItem_PostFlairTemplate.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet93(object.key) ? String(object.key) : "",
      value: isSet93(object.value) ? GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? GetWidgetsResponse_WidgetItem_PostFlairTemplate.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_WidgetItem_TemplatesEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? GetWidgetsResponse_WidgetItem_PostFlairTemplate.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.WidgetItem.TemplatesEntry", GetWidgetsResponse_WidgetItem_TemplatesEntry);
function createBaseGetWidgetsResponse_ItemsEntry() {
  return { key: "", value: void 0 };
}
var GetWidgetsResponse_ItemsEntry = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetsResponse.ItemsEntry",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      GetWidgetsResponse_WidgetItem.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetsResponse_ItemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = GetWidgetsResponse_WidgetItem.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet93(object.key) ? String(object.key) : "",
      value: isSet93(object.value) ? GetWidgetsResponse_WidgetItem.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? GetWidgetsResponse_WidgetItem.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetsResponse_ItemsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? GetWidgetsResponse_WidgetItem.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetsResponse.ItemsEntry", GetWidgetsResponse_ItemsEntry);
function createBaseMenuWidgetItem() {
  return { text: void 0, url: void 0, children: [] };
}
var MenuWidgetItem = {
  $type: "devvit.plugin.redditapi.widgets.MenuWidgetItem",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.text !== void 0) {
      StringValue.encode({ value: message.text }, writer.uint32(10).fork()).ldelim();
    }
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.children) {
      MenuWidgetItem.encode(v, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMenuWidgetItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.text = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.children.push(MenuWidgetItem.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet93(object.text) ? String(object.text) : void 0,
      url: isSet93(object.url) ? String(object.url) : void 0,
      children: Array.isArray(object?.children) ? object.children.map((e) => MenuWidgetItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.text !== void 0 && (obj.text = message.text);
    message.url !== void 0 && (obj.url = message.url);
    if (message.children) {
      obj.children = message.children.map((e) => e ? MenuWidgetItem.toJSON(e) : void 0);
    } else {
      obj.children = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMenuWidgetItem();
    message.text = object.text ?? void 0;
    message.url = object.url ?? void 0;
    message.children = object.children?.map((e) => MenuWidgetItem.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.MenuWidgetItem", MenuWidgetItem);
function createBaseOrderWidgetsRequest() {
  return { subreddit: "", order: [] };
}
var OrderWidgetsRequest = {
  $type: "devvit.plugin.redditapi.widgets.OrderWidgetsRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    for (const v of message.order) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOrderWidgetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.order.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      order: Array.isArray(object?.order) ? object.order.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    if (message.order) {
      obj.order = message.order.map((e) => e);
    } else {
      obj.order = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseOrderWidgetsRequest();
    message.subreddit = object.subreddit ?? "";
    message.order = object.order?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.OrderWidgetsRequest", OrderWidgetsRequest);
function createBaseGetWidgetImageUploadLeaseRequest() {
  return { subreddit: "", filepath: "", mimetype: "" };
}
var GetWidgetImageUploadLeaseRequest = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.filepath !== "") {
      writer.uint32(18).string(message.filepath);
    }
    if (message.mimetype !== "") {
      writer.uint32(26).string(message.mimetype);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetImageUploadLeaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.filepath = reader.string();
          break;
        case 3:
          message.mimetype = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      filepath: isSet93(object.filepath) ? String(object.filepath) : "",
      mimetype: isSet93(object.mimetype) ? String(object.mimetype) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.filepath !== void 0 && (obj.filepath = message.filepath);
    message.mimetype !== void 0 && (obj.mimetype = message.mimetype);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetImageUploadLeaseRequest();
    message.subreddit = object.subreddit ?? "";
    message.filepath = object.filepath ?? "";
    message.mimetype = object.mimetype ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseRequest", GetWidgetImageUploadLeaseRequest);
function createBaseGetWidgetImageUploadLeaseResponse() {
  return { s3UploadLease: void 0, websocketUrl: "" };
}
var GetWidgetImageUploadLeaseResponse = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.s3UploadLease !== void 0) {
      GetWidgetImageUploadLeaseResponse_S3UploadLease.encode(message.s3UploadLease, writer.uint32(10).fork()).ldelim();
    }
    if (message.websocketUrl !== "") {
      writer.uint32(18).string(message.websocketUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetImageUploadLeaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.s3UploadLease = GetWidgetImageUploadLeaseResponse_S3UploadLease.decode(reader, reader.uint32());
          break;
        case 2:
          message.websocketUrl = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      s3UploadLease: isSet93(object.s3UploadLease) ? GetWidgetImageUploadLeaseResponse_S3UploadLease.fromJSON(object.s3UploadLease) : void 0,
      websocketUrl: isSet93(object.websocketUrl) ? String(object.websocketUrl) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.s3UploadLease !== void 0 && (obj.s3UploadLease = message.s3UploadLease ? GetWidgetImageUploadLeaseResponse_S3UploadLease.toJSON(message.s3UploadLease) : void 0);
    message.websocketUrl !== void 0 && (obj.websocketUrl = message.websocketUrl);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetImageUploadLeaseResponse();
    message.s3UploadLease = object.s3UploadLease !== void 0 && object.s3UploadLease !== null ? GetWidgetImageUploadLeaseResponse_S3UploadLease.fromPartial(object.s3UploadLease) : void 0;
    message.websocketUrl = object.websocketUrl ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse", GetWidgetImageUploadLeaseResponse);
function createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease() {
  return { action: "", fields: [] };
}
var GetWidgetImageUploadLeaseResponse_S3UploadLease = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse.S3UploadLease",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    for (const v of message.fields) {
      GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.action = reader.string();
          break;
        case 2:
          message.fields.push(GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      action: isSet93(object.action) ? String(object.action) : "",
      fields: Array.isArray(object?.fields) ? object.fields.map((e) => GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.action !== void 0 && (obj.action = message.action);
    if (message.fields) {
      obj.fields = message.fields.map((e) => e ? GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.toJSON(e) : void 0);
    } else {
      obj.fields = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease();
    message.action = object.action ?? "";
    message.fields = object.fields?.map((e) => GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse.S3UploadLease", GetWidgetImageUploadLeaseResponse_S3UploadLease);
function createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair() {
  return { name: "", value: "" };
}
var GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair = {
  $type: "devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse.S3UploadLease.NameValuePair",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet93(object.name) ? String(object.name) : "",
      value: isSet93(object.value) ? String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.GetWidgetImageUploadLeaseResponse.S3UploadLease.NameValuePair", GetWidgetImageUploadLeaseResponse_S3UploadLease_NameValuePair);
function createBaseCustomWidget() {
  return { id: "", kind: "", shortName: "", text: "", height: 0, css: "", imageData: [], styles: void 0 };
}
var CustomWidget = {
  $type: "devvit.plugin.redditapi.widgets.CustomWidget",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.height !== 0) {
      writer.uint32(48).int32(message.height);
    }
    if (message.css !== "") {
      writer.uint32(58).string(message.css);
    }
    for (const v of message.imageData) {
      WidgetImage.encode(v, writer.uint32(66).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.kind = reader.string();
          break;
        case 3:
          message.shortName = reader.string();
          break;
        case 4:
          message.text = reader.string();
          break;
        case 6:
          message.height = reader.int32();
          break;
        case 7:
          message.css = reader.string();
          break;
        case 8:
          message.imageData.push(WidgetImage.decode(reader, reader.uint32()));
          break;
        case 9:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet93(object.id) ? String(object.id) : "",
      kind: isSet93(object.kind) ? String(object.kind) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      text: isSet93(object.text) ? String(object.text) : "",
      height: isSet93(object.height) ? Number(object.height) : 0,
      css: isSet93(object.css) ? String(object.css) : "",
      imageData: Array.isArray(object?.imageData) ? object.imageData.map((e) => WidgetImage.fromJSON(e)) : [],
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.kind !== void 0 && (obj.kind = message.kind);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.text !== void 0 && (obj.text = message.text);
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.css !== void 0 && (obj.css = message.css);
    if (message.imageData) {
      obj.imageData = message.imageData.map((e) => e ? WidgetImage.toJSON(e) : void 0);
    } else {
      obj.imageData = [];
    }
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCustomWidget();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.shortName = object.shortName ?? "";
    message.text = object.text ?? "";
    message.height = object.height ?? 0;
    message.css = object.css ?? "";
    message.imageData = object.imageData?.map((e) => WidgetImage.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.CustomWidget", CustomWidget);
function createBaseAddCustomWidgetRequest() {
  return { subreddit: "", shortName: "", text: "", height: 0, css: "", imageData: [], styles: void 0 };
}
var AddCustomWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.AddCustomWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.shortName !== "") {
      writer.uint32(18).string(message.shortName);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.height !== 0) {
      writer.uint32(32).int32(message.height);
    }
    if (message.css !== "") {
      writer.uint32(42).string(message.css);
    }
    for (const v of message.imageData) {
      WidgetImage.encode(v, writer.uint32(50).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddCustomWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.shortName = reader.string();
          break;
        case 3:
          message.text = reader.string();
          break;
        case 4:
          message.height = reader.int32();
          break;
        case 5:
          message.css = reader.string();
          break;
        case 6:
          message.imageData.push(WidgetImage.decode(reader, reader.uint32()));
          break;
        case 7:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      text: isSet93(object.text) ? String(object.text) : "",
      height: isSet93(object.height) ? Number(object.height) : 0,
      css: isSet93(object.css) ? String(object.css) : "",
      imageData: Array.isArray(object?.imageData) ? object.imageData.map((e) => WidgetImage.fromJSON(e)) : [],
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.text !== void 0 && (obj.text = message.text);
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.css !== void 0 && (obj.css = message.css);
    if (message.imageData) {
      obj.imageData = message.imageData.map((e) => e ? WidgetImage.toJSON(e) : void 0);
    } else {
      obj.imageData = [];
    }
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAddCustomWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.shortName = object.shortName ?? "";
    message.text = object.text ?? "";
    message.height = object.height ?? 0;
    message.css = object.css ?? "";
    message.imageData = object.imageData?.map((e) => WidgetImage.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.AddCustomWidgetRequest", AddCustomWidgetRequest);
function createBaseUpdateCustomWidgetRequest() {
  return { subreddit: "", id: "", shortName: "", text: "", height: 0, css: "", imageData: [], styles: void 0 };
}
var UpdateCustomWidgetRequest = {
  $type: "devvit.plugin.redditapi.widgets.UpdateCustomWidgetRequest",
  encode(message, writer = import_minimal110.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.shortName !== "") {
      writer.uint32(26).string(message.shortName);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.height !== 0) {
      writer.uint32(40).int32(message.height);
    }
    if (message.css !== "") {
      writer.uint32(50).string(message.css);
    }
    for (const v of message.imageData) {
      WidgetImage.encode(v, writer.uint32(58).fork()).ldelim();
    }
    if (message.styles !== void 0) {
      WidgetStyles.encode(message.styles, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal110.default.Reader ? input : new import_minimal110.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustomWidgetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.shortName = reader.string();
          break;
        case 4:
          message.text = reader.string();
          break;
        case 5:
          message.height = reader.int32();
          break;
        case 6:
          message.css = reader.string();
          break;
        case 7:
          message.imageData.push(WidgetImage.decode(reader, reader.uint32()));
          break;
        case 8:
          message.styles = WidgetStyles.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet93(object.subreddit) ? String(object.subreddit) : "",
      id: isSet93(object.id) ? String(object.id) : "",
      shortName: isSet93(object.shortName) ? String(object.shortName) : "",
      text: isSet93(object.text) ? String(object.text) : "",
      height: isSet93(object.height) ? Number(object.height) : 0,
      css: isSet93(object.css) ? String(object.css) : "",
      imageData: Array.isArray(object?.imageData) ? object.imageData.map((e) => WidgetImage.fromJSON(e)) : [],
      styles: isSet93(object.styles) ? WidgetStyles.fromJSON(object.styles) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.id !== void 0 && (obj.id = message.id);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    message.text !== void 0 && (obj.text = message.text);
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.css !== void 0 && (obj.css = message.css);
    if (message.imageData) {
      obj.imageData = message.imageData.map((e) => e ? WidgetImage.toJSON(e) : void 0);
    } else {
      obj.imageData = [];
    }
    message.styles !== void 0 && (obj.styles = message.styles ? WidgetStyles.toJSON(message.styles) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateCustomWidgetRequest();
    message.subreddit = object.subreddit ?? "";
    message.id = object.id ?? "";
    message.shortName = object.shortName ?? "";
    message.text = object.text ?? "";
    message.height = object.height ?? 0;
    message.css = object.css ?? "";
    message.imageData = object.imageData?.map((e) => WidgetImage.fromPartial(e)) || [];
    message.styles = object.styles !== void 0 && object.styles !== null ? WidgetStyles.fromPartial(object.styles) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.widgets.UpdateCustomWidgetRequest", UpdateCustomWidgetRequest);
function isObject18(value) {
  return typeof value === "object" && value !== null;
}
function isSet93(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/widgets/widgets_svc.js
var import_minimal111 = __toESM(require_minimal2(), 1);
var WidgetsDefinition = {
  name: "Widgets",
  fullName: "devvit.plugin.redditapi.widgets.Widgets",
  methods: {
    /**
     * Add a button widget to a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    addButtonWidget: {
      name: "AddButtonWidget",
      requestType: AddButtonWidgetRequest,
      requestStream: false,
      responseType: ButtonWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Add an image widget to a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    addImageWidget: {
      name: "AddImageWidget",
      requestType: AddImageWidgetRequest,
      requestStream: false,
      responseType: ImageWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Add a calendar widget to a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    addCalendarWidget: {
      name: "AddCalendarWidget",
      requestType: AddCalendarWidgetRequest,
      requestStream: false,
      responseType: CalendarWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Add a text widget to a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    addTextAreaWidget: {
      name: "AddTextAreaWidget",
      requestType: AddTextAreaWidgetRequest,
      requestStream: false,
      responseType: TextAreaWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Add a community list widget to a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    addCommunityListWidget: {
      name: "AddCommunityListWidget",
      requestType: AddCommunityListWidgetRequest,
      requestStream: false,
      responseType: CommunityListWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Add a post flair widget to a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    addPostFlairWidget: {
      name: "AddPostFlairWidget",
      requestType: AddPostFlairWidgetRequest,
      requestStream: false,
      responseType: PostFlairWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Add a custom widget to a subreddit. This is an experimental feature.
     * Custom widgets don't display on mobile devices. Customizations can break at any time
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget}
     */
    addCustomWidget: {
      name: "AddCustomWidget",
      requestType: AddCustomWidgetRequest,
      requestStream: false,
      responseType: CustomWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Delete a widget from a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#DELETE_api_widget_\{widget_id\}}
     */
    deleteWidget: {
      name: "DeleteWidget",
      requestType: DeleteWidgetRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Update a button widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    updateButtonWidget: {
      name: "UpdateButtonWidget",
      requestType: UpdateButtonWidgetRequest,
      requestStream: false,
      responseType: ButtonWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Update an image widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    updateImageWidget: {
      name: "UpdateImageWidget",
      requestType: UpdateImageWidgetRequest,
      requestStream: false,
      responseType: ImageWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Update a calendar widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    updateCalendarWidget: {
      name: "UpdateCalendarWidget",
      requestType: UpdateCalendarWidgetRequest,
      requestStream: false,
      responseType: CalendarWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Update a text widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    updateTextAreaWidget: {
      name: "UpdateTextAreaWidget",
      requestType: UpdateTextAreaWidgetRequest,
      requestStream: false,
      responseType: TextAreaWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Update a community list widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    updateCommunityListWidget: {
      name: "UpdateCommunityListWidget",
      requestType: UpdateCommunityListWidgetRequest,
      requestStream: false,
      responseType: UpdateCommunityListWidgetResponse,
      responseStream: false,
      options: {}
    },
    /**
     * Update a post flair widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    updatePostFlairWidget: {
      name: "UpdatePostFlairWidget",
      requestType: UpdatePostFlairWidgetRequest,
      requestStream: false,
      responseType: PostFlairWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Update a custom widget on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PUT_api_widget_\{widget_id\}}
     */
    updateCustomWidget: {
      name: "UpdateCustomWidget",
      requestType: UpdateCustomWidgetRequest,
      requestStream: false,
      responseType: CustomWidget,
      responseStream: false,
      options: {}
    },
    /**
     * Get an S3 upload lease for a widget image. This is used to upload images for image widgets.
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_widget_image_upload_s3}
     */
    getWidgetImageUploadLease: {
      name: "GetWidgetImageUploadLease",
      requestType: GetWidgetImageUploadLeaseRequest,
      requestStream: false,
      responseType: GetWidgetImageUploadLeaseResponse,
      responseStream: false,
      options: {}
    },
    /**
     * Update the order of widgets on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#PATCH_api_widget_order_\{section\}}
     */
    orderWidgets: {
      name: "OrderWidgets",
      requestType: OrderWidgetsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Get a list of widgets on a subreddit.
     *
     * @see {@link https://www.reddit.com/dev/api#GET_api_widgets}
     */
    getWidgets: {
      name: "GetWidgets",
      requestType: GetWidgetsRequest,
      requestStream: false,
      responseType: GetWidgetsResponse,
      responseStream: false,
      options: {}
    }
  }
};

// ../protos/dist/types/devvit/plugin/redditapi/wiki/wiki_msg.js
var import_long9 = __toESM(require_long(), 1);
var import_minimal112 = __toESM(require_minimal2(), 1);
function createBaseGetWikiPagesRequest() {
  return { subreddit: "" };
}
var GetWikiPagesRequest = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiPagesRequest",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiPagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { subreddit: isSet94(object.subreddit) ? String(object.subreddit) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWikiPagesRequest();
    message.subreddit = object.subreddit ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiPagesRequest", GetWikiPagesRequest);
function createBaseGetWikiPagesResponse() {
  return { kind: "", data: [] };
}
var GetWikiPagesResponse = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiPagesResponse",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    for (const v of message.data) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiPagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.data.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet94(object.kind) ? String(object.kind) : "",
      data: Array.isArray(object?.data) ? object.data.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    if (message.data) {
      obj.data = message.data.map((e) => e);
    } else {
      obj.data = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWikiPagesResponse();
    message.kind = object.kind ?? "";
    message.data = object.data?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiPagesResponse", GetWikiPagesResponse);
function createBaseGetWikiPageRequest() {
  return { subreddit: "", page: "" };
}
var GetWikiPageRequest = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiPageRequest",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiPageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.page = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet94(object.subreddit) ? String(object.subreddit) : "",
      page: isSet94(object.page) ? String(object.page) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.page !== void 0 && (obj.page = message.page);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWikiPageRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiPageRequest", GetWikiPageRequest);
function createBaseWikiPage() {
  return {
    contentMd: "",
    contentHtml: "",
    revisionId: "",
    revisionDate: 0,
    mayRevise: false,
    reason: void 0,
    revisionBy: void 0
  };
}
var WikiPage = {
  $type: "devvit.plugin.redditapi.wiki.WikiPage",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.contentMd !== "") {
      writer.uint32(10).string(message.contentMd);
    }
    if (message.contentHtml !== "") {
      writer.uint32(18).string(message.contentHtml);
    }
    if (message.revisionId !== "") {
      writer.uint32(26).string(message.revisionId);
    }
    if (message.revisionDate !== 0) {
      writer.uint32(32).int64(message.revisionDate);
    }
    if (message.mayRevise === true) {
      writer.uint32(40).bool(message.mayRevise);
    }
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(50).fork()).ldelim();
    }
    if (message.revisionBy !== void 0) {
      WrappedUserObject.encode(message.revisionBy, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWikiPage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.contentMd = reader.string();
          break;
        case 2:
          message.contentHtml = reader.string();
          break;
        case 3:
          message.revisionId = reader.string();
          break;
        case 4:
          message.revisionDate = longToNumber9(reader.int64());
          break;
        case 5:
          message.mayRevise = reader.bool();
          break;
        case 6:
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.revisionBy = WrappedUserObject.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      contentMd: isSet94(object.contentMd) ? String(object.contentMd) : "",
      contentHtml: isSet94(object.contentHtml) ? String(object.contentHtml) : "",
      revisionId: isSet94(object.revisionId) ? String(object.revisionId) : "",
      revisionDate: isSet94(object.revisionDate) ? Number(object.revisionDate) : 0,
      mayRevise: isSet94(object.mayRevise) ? Boolean(object.mayRevise) : false,
      reason: isSet94(object.reason) ? String(object.reason) : void 0,
      revisionBy: isSet94(object.revisionBy) ? WrappedUserObject.fromJSON(object.revisionBy) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.contentMd !== void 0 && (obj.contentMd = message.contentMd);
    message.contentHtml !== void 0 && (obj.contentHtml = message.contentHtml);
    message.revisionId !== void 0 && (obj.revisionId = message.revisionId);
    message.revisionDate !== void 0 && (obj.revisionDate = Math.round(message.revisionDate));
    message.mayRevise !== void 0 && (obj.mayRevise = message.mayRevise);
    message.reason !== void 0 && (obj.reason = message.reason);
    message.revisionBy !== void 0 && (obj.revisionBy = message.revisionBy ? WrappedUserObject.toJSON(message.revisionBy) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWikiPage();
    message.contentMd = object.contentMd ?? "";
    message.contentHtml = object.contentHtml ?? "";
    message.revisionId = object.revisionId ?? "";
    message.revisionDate = object.revisionDate ?? 0;
    message.mayRevise = object.mayRevise ?? false;
    message.reason = object.reason ?? void 0;
    message.revisionBy = object.revisionBy !== void 0 && object.revisionBy !== null ? WrappedUserObject.fromPartial(object.revisionBy) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.WikiPage", WikiPage);
function createBaseGetWikiPageResponse() {
  return { kind: "", data: void 0 };
}
var GetWikiPageResponse = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiPageResponse",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      WikiPage.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiPageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.data = WikiPage.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet94(object.kind) ? String(object.kind) : "",
      data: isSet94(object.data) ? WikiPage.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? WikiPage.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWikiPageResponse();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? WikiPage.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiPageResponse", GetWikiPageResponse);
function createBaseEditWikiPageRequest() {
  return { subreddit: "", page: "", content: "", reason: "" };
}
var EditWikiPageRequest = {
  $type: "devvit.plugin.redditapi.wiki.EditWikiPageRequest",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEditWikiPageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.page = reader.string();
          break;
        case 3:
          message.content = reader.string();
          break;
        case 4:
          message.reason = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet94(object.subreddit) ? String(object.subreddit) : "",
      page: isSet94(object.page) ? String(object.page) : "",
      content: isSet94(object.content) ? String(object.content) : "",
      reason: isSet94(object.reason) ? String(object.reason) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.page !== void 0 && (obj.page = message.page);
    message.content !== void 0 && (obj.content = message.content);
    message.reason !== void 0 && (obj.reason = message.reason);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEditWikiPageRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    message.content = object.content ?? "";
    message.reason = object.reason ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.EditWikiPageRequest", EditWikiPageRequest);
function createBaseHideWikiPageRevisionRequest() {
  return { subreddit: "", page: "", revision: "" };
}
var HideWikiPageRevisionRequest = {
  $type: "devvit.plugin.redditapi.wiki.HideWikiPageRevisionRequest",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.revision !== "") {
      writer.uint32(26).string(message.revision);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHideWikiPageRevisionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.page = reader.string();
          break;
        case 3:
          message.revision = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet94(object.subreddit) ? String(object.subreddit) : "",
      page: isSet94(object.page) ? String(object.page) : "",
      revision: isSet94(object.revision) ? String(object.revision) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.page !== void 0 && (obj.page = message.page);
    message.revision !== void 0 && (obj.revision = message.revision);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseHideWikiPageRevisionRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    message.revision = object.revision ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.HideWikiPageRevisionRequest", HideWikiPageRevisionRequest);
function createBaseHideWikiPageRevisionResponse() {
  return { status: false };
}
var HideWikiPageRevisionResponse = {
  $type: "devvit.plugin.redditapi.wiki.HideWikiPageRevisionResponse",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.status === true) {
      writer.uint32(8).bool(message.status);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHideWikiPageRevisionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.status = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { status: isSet94(object.status) ? Boolean(object.status) : false };
  },
  toJSON(message) {
    const obj = {};
    message.status !== void 0 && (obj.status = message.status);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseHideWikiPageRevisionResponse();
    message.status = object.status ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.HideWikiPageRevisionResponse", HideWikiPageRevisionResponse);
function createBaseGetWikiPageRevisionsRequest() {
  return {
    subreddit: "",
    page: "",
    after: void 0,
    before: void 0,
    limit: void 0,
    count: void 0,
    show: void 0,
    srDetail: void 0
  };
}
var GetWikiPageRevisionsRequest = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiPageRevisionsRequest",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(34).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
    }
    if (message.show !== void 0) {
      BoolValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
    }
    if (message.srDetail !== void 0) {
      BoolValue.encode({ value: message.srDetail }, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiPageRevisionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.page = reader.string();
          break;
        case 3:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.show = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.srDetail = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet94(object.subreddit) ? String(object.subreddit) : "",
      page: isSet94(object.page) ? String(object.page) : "",
      after: isSet94(object.after) ? String(object.after) : void 0,
      before: isSet94(object.before) ? String(object.before) : void 0,
      limit: isSet94(object.limit) ? Number(object.limit) : void 0,
      count: isSet94(object.count) ? Number(object.count) : void 0,
      show: isSet94(object.show) ? Boolean(object.show) : void 0,
      srDetail: isSet94(object.srDetail) ? Boolean(object.srDetail) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.page !== void 0 && (obj.page = message.page);
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.count !== void 0 && (obj.count = message.count);
    message.show !== void 0 && (obj.show = message.show);
    message.srDetail !== void 0 && (obj.srDetail = message.srDetail);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWikiPageRevisionsRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.limit = object.limit ?? void 0;
    message.count = object.count ?? void 0;
    message.show = object.show ?? void 0;
    message.srDetail = object.srDetail ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiPageRevisionsRequest", GetWikiPageRevisionsRequest);
function createBaseWikiPageRevision() {
  return { id: "", page: "", timestamp: 0, reason: "", revisionHidden: false, author: void 0 };
}
var WikiPageRevision = {
  $type: "devvit.plugin.redditapi.wiki.WikiPageRevision",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).int64(message.timestamp);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    if (message.revisionHidden === true) {
      writer.uint32(40).bool(message.revisionHidden);
    }
    if (message.author !== void 0) {
      WrappedUserObject.encode(message.author, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWikiPageRevision();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.page = reader.string();
          break;
        case 3:
          message.timestamp = longToNumber9(reader.int64());
          break;
        case 4:
          message.reason = reader.string();
          break;
        case 5:
          message.revisionHidden = reader.bool();
          break;
        case 6:
          message.author = WrappedUserObject.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet94(object.id) ? String(object.id) : "",
      page: isSet94(object.page) ? String(object.page) : "",
      timestamp: isSet94(object.timestamp) ? Number(object.timestamp) : 0,
      reason: isSet94(object.reason) ? String(object.reason) : "",
      revisionHidden: isSet94(object.revisionHidden) ? Boolean(object.revisionHidden) : false,
      author: isSet94(object.author) ? WrappedUserObject.fromJSON(object.author) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.page !== void 0 && (obj.page = message.page);
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    message.reason !== void 0 && (obj.reason = message.reason);
    message.revisionHidden !== void 0 && (obj.revisionHidden = message.revisionHidden);
    message.author !== void 0 && (obj.author = message.author ? WrappedUserObject.toJSON(message.author) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWikiPageRevision();
    message.id = object.id ?? "";
    message.page = object.page ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.reason = object.reason ?? "";
    message.revisionHidden = object.revisionHidden ?? false;
    message.author = object.author !== void 0 && object.author !== null ? WrappedUserObject.fromPartial(object.author) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.WikiPageRevision", WikiPageRevision);
function createBaseWikiPageRevisionListing() {
  return { kind: "", data: void 0 };
}
var WikiPageRevisionListing = {
  $type: "devvit.plugin.redditapi.wiki.WikiPageRevisionListing",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      WikiPageRevisionListing_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWikiPageRevisionListing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.data = WikiPageRevisionListing_Data.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet94(object.kind) ? String(object.kind) : "",
      data: isSet94(object.data) ? WikiPageRevisionListing_Data.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? WikiPageRevisionListing_Data.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWikiPageRevisionListing();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? WikiPageRevisionListing_Data.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.WikiPageRevisionListing", WikiPageRevisionListing);
function createBaseWikiPageRevisionListing_Data() {
  return { after: void 0, before: void 0, children: [], dist: void 0 };
}
var WikiPageRevisionListing_Data = {
  $type: "devvit.plugin.redditapi.wiki.WikiPageRevisionListing.Data",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.children) {
      WikiPageRevision.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.dist !== void 0) {
      Int64Value.encode({ value: message.dist }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWikiPageRevisionListing_Data();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.children.push(WikiPageRevision.decode(reader, reader.uint32()));
          break;
        case 4:
          message.dist = Int64Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      after: isSet94(object.after) ? String(object.after) : void 0,
      before: isSet94(object.before) ? String(object.before) : void 0,
      children: Array.isArray(object?.children) ? object.children.map((e) => WikiPageRevision.fromJSON(e)) : [],
      dist: isSet94(object.dist) ? Number(object.dist) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    if (message.children) {
      obj.children = message.children.map((e) => e ? WikiPageRevision.toJSON(e) : void 0);
    } else {
      obj.children = [];
    }
    message.dist !== void 0 && (obj.dist = message.dist);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWikiPageRevisionListing_Data();
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.children = object.children?.map((e) => WikiPageRevision.fromPartial(e)) || [];
    message.dist = object.dist ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.WikiPageRevisionListing.Data", WikiPageRevisionListing_Data);
function createBaseGetWikiRevisionsRequest() {
  return {
    subreddit: "",
    after: void 0,
    before: void 0,
    limit: void 0,
    count: void 0,
    show: void 0,
    srDetail: void 0
  };
}
var GetWikiRevisionsRequest = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiRevisionsRequest",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.after !== void 0) {
      StringValue.encode({ value: message.after }, writer.uint32(18).fork()).ldelim();
    }
    if (message.before !== void 0) {
      StringValue.encode({ value: message.before }, writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== void 0) {
      Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
    }
    if (message.count !== void 0) {
      Int64Value.encode({ value: message.count }, writer.uint32(42).fork()).ldelim();
    }
    if (message.show !== void 0) {
      BoolValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
    }
    if (message.srDetail !== void 0) {
      BoolValue.encode({ value: message.srDetail }, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiRevisionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.after = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.before = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.limit = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.count = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.show = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.srDetail = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet94(object.subreddit) ? String(object.subreddit) : "",
      after: isSet94(object.after) ? String(object.after) : void 0,
      before: isSet94(object.before) ? String(object.before) : void 0,
      limit: isSet94(object.limit) ? Number(object.limit) : void 0,
      count: isSet94(object.count) ? Number(object.count) : void 0,
      show: isSet94(object.show) ? Boolean(object.show) : void 0,
      srDetail: isSet94(object.srDetail) ? Boolean(object.srDetail) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.after !== void 0 && (obj.after = message.after);
    message.before !== void 0 && (obj.before = message.before);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.count !== void 0 && (obj.count = message.count);
    message.show !== void 0 && (obj.show = message.show);
    message.srDetail !== void 0 && (obj.srDetail = message.srDetail);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWikiRevisionsRequest();
    message.subreddit = object.subreddit ?? "";
    message.after = object.after ?? void 0;
    message.before = object.before ?? void 0;
    message.limit = object.limit ?? void 0;
    message.count = object.count ?? void 0;
    message.show = object.show ?? void 0;
    message.srDetail = object.srDetail ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiRevisionsRequest", GetWikiRevisionsRequest);
function createBaseRevertWikiPageRequest() {
  return { subreddit: "", page: "", revision: "" };
}
var RevertWikiPageRequest = {
  $type: "devvit.plugin.redditapi.wiki.RevertWikiPageRequest",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.revision !== "") {
      writer.uint32(26).string(message.revision);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRevertWikiPageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.page = reader.string();
          break;
        case 3:
          message.revision = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet94(object.subreddit) ? String(object.subreddit) : "",
      page: isSet94(object.page) ? String(object.page) : "",
      revision: isSet94(object.revision) ? String(object.revision) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.page !== void 0 && (obj.page = message.page);
    message.revision !== void 0 && (obj.revision = message.revision);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRevertWikiPageRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    message.revision = object.revision ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.RevertWikiPageRequest", RevertWikiPageRequest);
function createBaseGetWikiPageSettingsRequest() {
  return { subreddit: "", page: "" };
}
var GetWikiPageSettingsRequest = {
  $type: "devvit.plugin.redditapi.wiki.GetWikiPageSettingsRequest",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWikiPageSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.page = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet94(object.subreddit) ? String(object.subreddit) : "",
      page: isSet94(object.page) ? String(object.page) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.page !== void 0 && (obj.page = message.page);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetWikiPageSettingsRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.GetWikiPageSettingsRequest", GetWikiPageSettingsRequest);
function createBaseWikiPageSettings() {
  return { kind: "", data: void 0 };
}
var WikiPageSettings = {
  $type: "devvit.plugin.redditapi.wiki.WikiPageSettings",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.data !== void 0) {
      WikiPageSettings_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWikiPageSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.data = WikiPageSettings_Data.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet94(object.kind) ? String(object.kind) : "",
      data: isSet94(object.data) ? WikiPageSettings_Data.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = message.kind);
    message.data !== void 0 && (obj.data = message.data ? WikiPageSettings_Data.toJSON(message.data) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWikiPageSettings();
    message.kind = object.kind ?? "";
    message.data = object.data !== void 0 && object.data !== null ? WikiPageSettings_Data.fromPartial(object.data) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.WikiPageSettings", WikiPageSettings);
function createBaseWikiPageSettings_Data() {
  return { permLevel: 0, editors: [], listed: false };
}
var WikiPageSettings_Data = {
  $type: "devvit.plugin.redditapi.wiki.WikiPageSettings.Data",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.permLevel !== 0) {
      writer.uint32(8).int32(message.permLevel);
    }
    for (const v of message.editors) {
      WrappedUserObject.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.listed === true) {
      writer.uint32(24).bool(message.listed);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWikiPageSettings_Data();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.permLevel = reader.int32();
          break;
        case 2:
          message.editors.push(WrappedUserObject.decode(reader, reader.uint32()));
          break;
        case 3:
          message.listed = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      permLevel: isSet94(object.permLevel) ? Number(object.permLevel) : 0,
      editors: Array.isArray(object?.editors) ? object.editors.map((e) => WrappedUserObject.fromJSON(e)) : [],
      listed: isSet94(object.listed) ? Boolean(object.listed) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.permLevel !== void 0 && (obj.permLevel = Math.round(message.permLevel));
    if (message.editors) {
      obj.editors = message.editors.map((e) => e ? WrappedUserObject.toJSON(e) : void 0);
    } else {
      obj.editors = [];
    }
    message.listed !== void 0 && (obj.listed = message.listed);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWikiPageSettings_Data();
    message.permLevel = object.permLevel ?? 0;
    message.editors = object.editors?.map((e) => WrappedUserObject.fromPartial(e)) || [];
    message.listed = object.listed ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.WikiPageSettings.Data", WikiPageSettings_Data);
function createBaseUpdateWikiPageSettingsRequest() {
  return { subreddit: "", page: "", permlevel: 0, listed: "" };
}
var UpdateWikiPageSettingsRequest = {
  $type: "devvit.plugin.redditapi.wiki.UpdateWikiPageSettingsRequest",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.permlevel !== 0) {
      writer.uint32(24).int32(message.permlevel);
    }
    if (message.listed !== "") {
      writer.uint32(34).string(message.listed);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateWikiPageSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.page = reader.string();
          break;
        case 3:
          message.permlevel = reader.int32();
          break;
        case 4:
          message.listed = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet94(object.subreddit) ? String(object.subreddit) : "",
      page: isSet94(object.page) ? String(object.page) : "",
      permlevel: isSet94(object.permlevel) ? Number(object.permlevel) : 0,
      listed: isSet94(object.listed) ? String(object.listed) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.page !== void 0 && (obj.page = message.page);
    message.permlevel !== void 0 && (obj.permlevel = Math.round(message.permlevel));
    message.listed !== void 0 && (obj.listed = message.listed);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUpdateWikiPageSettingsRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    message.permlevel = object.permlevel ?? 0;
    message.listed = object.listed ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.UpdateWikiPageSettingsRequest", UpdateWikiPageSettingsRequest);
function createBaseAllowEditorRequest() {
  return { subreddit: "", page: "", act: "", username: "" };
}
var AllowEditorRequest = {
  $type: "devvit.plugin.redditapi.wiki.AllowEditorRequest",
  encode(message, writer = import_minimal112.default.Writer.create()) {
    if (message.subreddit !== "") {
      writer.uint32(10).string(message.subreddit);
    }
    if (message.page !== "") {
      writer.uint32(18).string(message.page);
    }
    if (message.act !== "") {
      writer.uint32(26).string(message.act);
    }
    if (message.username !== "") {
      writer.uint32(34).string(message.username);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal112.default.Reader ? input : new import_minimal112.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAllowEditorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.string();
          break;
        case 2:
          message.page = reader.string();
          break;
        case 3:
          message.act = reader.string();
          break;
        case 4:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet94(object.subreddit) ? String(object.subreddit) : "",
      page: isSet94(object.page) ? String(object.page) : "",
      act: isSet94(object.act) ? String(object.act) : "",
      username: isSet94(object.username) ? String(object.username) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.page !== void 0 && (obj.page = message.page);
    message.act !== void 0 && (obj.act = message.act);
    message.username !== void 0 && (obj.username = message.username);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAllowEditorRequest();
    message.subreddit = object.subreddit ?? "";
    message.page = object.page ?? "";
    message.act = object.act ?? "";
    message.username = object.username ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.redditapi.wiki.AllowEditorRequest", AllowEditorRequest);
var globalThis12 = (() => {
  if (typeof globalThis12 !== "undefined") {
    return globalThis12;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function longToNumber9(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis12.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal112.default.util.Long !== import_long9.default) {
  import_minimal112.default.util.Long = import_long9.default;
  import_minimal112.default.configure();
}
function isSet94(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/redditapi/wiki/wiki_svc.js
var import_minimal113 = __toESM(require_minimal2(), 1);
var WikiDefinition = {
  name: "Wiki",
  fullName: "devvit.plugin.redditapi.wiki.Wiki",
  methods: {
    /**
     * Get a list of wiki pages for a subreddit
     *
     * @see {@link https://www.reddit.com/dev/api#GET_wiki_pages}
     */
    getWikiPages: {
      name: "GetWikiPages",
      requestType: GetWikiPagesRequest,
      requestStream: false,
      responseType: GetWikiPagesResponse,
      responseStream: false,
      options: {}
    },
    /**
     * Get a wiki page
     *
     * @see {@link https://www.reddit.com/dev/api#GET_wiki_\{page\}}
     */
    getWikiPage: {
      name: "GetWikiPage",
      requestType: GetWikiPageRequest,
      requestStream: false,
      responseType: GetWikiPageResponse,
      responseStream: false,
      options: {}
    },
    /**
     * Edit wiki page
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_wiki_edit}
     */
    editWikiPage: {
      name: "EditWikiPage",
      requestType: EditWikiPageRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Hide a wiki page revision
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_wiki_hide}
     */
    hideWikiPageRevision: {
      name: "HideWikiPageRevision",
      requestType: HideWikiPageRevisionRequest,
      requestStream: false,
      responseType: HideWikiPageRevisionResponse,
      responseStream: false,
      options: {}
    },
    /**
     * Get a list of revisions of a wiki page
     *
     * @see {@link https://www.reddit.com/dev/api#GET_wiki_revisions_\{page\}}
     */
    getWikiPageRevisions: {
      name: "GetWikiPageRevisions",
      requestType: GetWikiPageRevisionsRequest,
      requestStream: false,
      responseType: WikiPageRevisionListing,
      responseStream: false,
      options: {}
    },
    /**
     * Retrieve a list of recently changed wiki pages in this subreddit
     *
     * @see {@link https://www.reddit.com/dev/api#GET_wiki_revisions}
     */
    getWikiRevisions: {
      name: "GetWikiRevisions",
      requestType: GetWikiRevisionsRequest,
      requestStream: false,
      responseType: WikiPageRevisionListing,
      responseStream: false,
      options: {}
    },
    /**
     * Revert a wiki page to revision
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_wiki_revert}
     */
    revertWikiPage: {
      name: "RevertWikiPage",
      requestType: RevertWikiPageRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /**
     * Retrieve the current permission settings for page
     *
     * @see {@link https://www.reddit.com/dev/api#GET_wiki_settings_\{page\}}
     */
    getWikiPageSettings: {
      name: "GetWikiPageSettings",
      requestType: GetWikiPageSettingsRequest,
      requestStream: false,
      responseType: WikiPageSettings,
      responseStream: false,
      options: {}
    },
    /**
     * Update the permissions and visibility of wiki page
     *
     * @see {@link https://www.reddit.com/dev/api#POST_wiki_settings_\{page\}}
     */
    updateWikiPageSettings: {
      name: "UpdateWikiPageSettings",
      requestType: UpdateWikiPageSettingsRequest,
      requestStream: false,
      responseType: WikiPageSettings,
      responseStream: false,
      options: {}
    },
    /**
     * Allow/deny username to edit this wiki page
     * Note act must be either "add" or "del"
     *
     * @see {@link https://www.reddit.com/dev/api#POST_api_wiki_alloweditor_\{act\}}
     */
    allowEditor: {
      name: "AllowEditor",
      requestType: AllowEditorRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    }
  }
};

// ../protos/dist/types/devvit/plugin/scheduler/scheduler.js
var import_minimal115 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/runtime/runtime_common.js
var import_minimal114 = __toESM(require_minimal2(), 1);
function createBaseAck() {
  return { success: false, messages: [] };
}
var Ack = {
  $type: "devvit.runtime.Ack",
  encode(message, writer = import_minimal114.default.Writer.create()) {
    if (message.success === true) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.messages) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal114.default.Reader ? input : new import_minimal114.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.success = reader.bool();
          break;
        case 2:
          message.messages.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      success: isSet95(object.success) ? Boolean(object.success) : false,
      messages: Array.isArray(object?.messages) ? object.messages.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.success !== void 0 && (obj.success = message.success);
    if (message.messages) {
      obj.messages = message.messages.map((e) => e);
    } else {
      obj.messages = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAck();
    message.success = object.success ?? false;
    message.messages = object.messages?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.Ack", Ack);
function createBaseDebug() {
  return { message: void 0 };
}
var Debug = {
  $type: "devvit.runtime.Debug",
  encode(message, writer = import_minimal114.default.Writer.create()) {
    if (message.message !== void 0) {
      Value.encode(Value.wrap(message.message), writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal114.default.Reader ? input : new import_minimal114.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDebug();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = Value.unwrap(Value.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { message: isSet95(object?.message) ? object.message : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDebug();
    message.message = object.message ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.Debug", Debug);
function createBaseStrings() {
  return { values: [] };
}
var Strings = {
  $type: "devvit.runtime.Strings",
  encode(message, writer = import_minimal114.default.Writer.create()) {
    for (const v of message.values) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal114.default.Reader ? input : new import_minimal114.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStrings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.values.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { values: Array.isArray(object?.values) ? object.values.map((e) => String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.values) {
      obj.values = message.values.map((e) => e);
    } else {
      obj.values = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStrings();
    message.values = object.values?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.Strings", Strings);
function createBaseStr() {
  return { value: "" };
}
var Str = {
  $type: "devvit.runtime.Str",
  encode(message, writer = import_minimal114.default.Writer.create()) {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal114.default.Reader ? input : new import_minimal114.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet95(object.value) ? String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStr();
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.Str", Str);
function isSet95(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/scheduler/scheduler.js
var StorableAction_State;
(function(StorableAction_State2) {
  StorableAction_State2[StorableAction_State2["WAITING"] = 0] = "WAITING";
  StorableAction_State2[StorableAction_State2["CANCELED"] = 1] = "CANCELED";
  StorableAction_State2[StorableAction_State2["FAILED"] = 2] = "FAILED";
  StorableAction_State2[StorableAction_State2["DELIVERED"] = 3] = "DELIVERED";
  StorableAction_State2[StorableAction_State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(StorableAction_State || (StorableAction_State = {}));
function storableAction_StateFromJSON(object) {
  switch (object) {
    case 0:
    case "WAITING":
      return StorableAction_State.WAITING;
    case 1:
    case "CANCELED":
      return StorableAction_State.CANCELED;
    case 2:
    case "FAILED":
      return StorableAction_State.FAILED;
    case 3:
    case "DELIVERED":
      return StorableAction_State.DELIVERED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StorableAction_State.UNRECOGNIZED;
  }
}
function storableAction_StateToJSON(object) {
  switch (object) {
    case StorableAction_State.WAITING:
      return 0;
    case StorableAction_State.CANCELED:
      return 1;
    case StorableAction_State.FAILED:
      return 2;
    case StorableAction_State.DELIVERED:
      return 3;
    case StorableAction_State.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseScheduledActionRequest() {
  return { when: void 0, cron: void 0, action: void 0 };
}
var ScheduledActionRequest = {
  $type: "devvit.plugin.scheduler.ScheduledActionRequest",
  encode(message, writer = import_minimal115.default.Writer.create()) {
    if (message.when !== void 0) {
      Timestamp.encode(toTimestamp12(message.when), writer.uint32(10).fork()).ldelim();
    }
    if (message.cron !== void 0) {
      writer.uint32(18).string(message.cron);
    }
    if (message.action !== void 0) {
      ScheduledAction.encode(message.action, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal115.default.Reader ? input : new import_minimal115.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseScheduledActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.when = fromTimestamp12(Timestamp.decode(reader, reader.uint32()));
          break;
        case 2:
          message.cron = reader.string();
          break;
        case 3:
          message.action = ScheduledAction.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      when: isSet96(object.when) ? fromJsonTimestamp12(object.when) : void 0,
      cron: isSet96(object.cron) ? String(object.cron) : void 0,
      action: isSet96(object.action) ? ScheduledAction.fromJSON(object.action) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.when !== void 0 && (obj.when = message.when.toISOString());
    message.cron !== void 0 && (obj.cron = message.cron);
    message.action !== void 0 && (obj.action = message.action ? ScheduledAction.toJSON(message.action) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseScheduledActionRequest();
    message.when = object.when ?? void 0;
    message.cron = object.cron ?? void 0;
    message.action = object.action !== void 0 && object.action !== null ? ScheduledAction.fromPartial(object.action) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.scheduler.ScheduledActionRequest", ScheduledActionRequest);
function createBaseScheduledActionResponse() {
  return { id: "" };
}
var ScheduledActionResponse = {
  $type: "devvit.plugin.scheduler.ScheduledActionResponse",
  encode(message, writer = import_minimal115.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal115.default.Reader ? input : new import_minimal115.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseScheduledActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet96(object.id) ? String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseScheduledActionResponse();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.scheduler.ScheduledActionResponse", ScheduledActionResponse);
function createBaseCancelActionRequest() {
  return { id: "" };
}
var CancelActionRequest = {
  $type: "devvit.plugin.scheduler.CancelActionRequest",
  encode(message, writer = import_minimal115.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal115.default.Reader ? input : new import_minimal115.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCancelActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet96(object.id) ? String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCancelActionRequest();
    message.id = object.id ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.scheduler.CancelActionRequest", CancelActionRequest);
function createBaseStorableAction() {
  return { id: "", actorHostname: "", request: void 0, metadata: {}, state: void 0 };
}
var StorableAction = {
  $type: "devvit.plugin.scheduler.StorableAction",
  encode(message, writer = import_minimal115.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.actorHostname !== "") {
      writer.uint32(18).string(message.actorHostname);
    }
    if (message.request !== void 0) {
      ScheduledActionRequest.encode(message.request, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      StorableAction_MetadataEntry.encode({ key, value }, writer.uint32(74).fork()).ldelim();
    });
    if (message.state !== void 0) {
      writer.uint32(80).int32(message.state);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal115.default.Reader ? input : new import_minimal115.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStorableAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.actorHostname = reader.string();
          break;
        case 3:
          message.request = ScheduledActionRequest.decode(reader, reader.uint32());
          break;
        case 9:
          const entry9 = StorableAction_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== void 0) {
            message.metadata[entry9.key] = entry9.value;
          }
          break;
        case 10:
          message.state = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet96(object.id) ? String(object.id) : "",
      actorHostname: isSet96(object.actorHostname) ? String(object.actorHostname) : "",
      request: isSet96(object.request) ? ScheduledActionRequest.fromJSON(object.request) : void 0,
      metadata: isObject19(object.metadata) ? Object.entries(object.metadata).reduce((acc, [key, value]) => {
        acc[key] = Strings.fromJSON(value);
        return acc;
      }, {}) : {},
      state: isSet96(object.state) ? storableAction_StateFromJSON(object.state) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.actorHostname !== void 0 && (obj.actorHostname = message.actorHostname);
    message.request !== void 0 && (obj.request = message.request ? ScheduledActionRequest.toJSON(message.request) : void 0);
    obj.metadata = {};
    if (message.metadata) {
      Object.entries(message.metadata).forEach(([k, v]) => {
        obj.metadata[k] = Strings.toJSON(v);
      });
    }
    message.state !== void 0 && (obj.state = message.state !== void 0 ? storableAction_StateToJSON(message.state) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStorableAction();
    message.id = object.id ?? "";
    message.actorHostname = object.actorHostname ?? "";
    message.request = object.request !== void 0 && object.request !== null ? ScheduledActionRequest.fromPartial(object.request) : void 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = Strings.fromPartial(value);
      }
      return acc;
    }, {});
    message.state = object.state ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.scheduler.StorableAction", StorableAction);
function createBaseStorableAction_MetadataEntry() {
  return { key: "", value: void 0 };
}
var StorableAction_MetadataEntry = {
  $type: "devvit.plugin.scheduler.StorableAction.MetadataEntry",
  encode(message, writer = import_minimal115.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Strings.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal115.default.Reader ? input : new import_minimal115.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStorableAction_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Strings.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet96(object.key) ? String(object.key) : "",
      value: isSet96(object.value) ? Strings.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? Strings.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStorableAction_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? Strings.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.scheduler.StorableAction.MetadataEntry", StorableAction_MetadataEntry);
function createBaseListActionRequest() {
  return { before: void 0, after: void 0 };
}
var ListActionRequest = {
  $type: "devvit.plugin.scheduler.ListActionRequest",
  encode(message, writer = import_minimal115.default.Writer.create()) {
    if (message.before !== void 0) {
      Timestamp.encode(toTimestamp12(message.before), writer.uint32(10).fork()).ldelim();
    }
    if (message.after !== void 0) {
      Timestamp.encode(toTimestamp12(message.after), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal115.default.Reader ? input : new import_minimal115.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.before = fromTimestamp12(Timestamp.decode(reader, reader.uint32()));
          break;
        case 2:
          message.after = fromTimestamp12(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      before: isSet96(object.before) ? fromJsonTimestamp12(object.before) : void 0,
      after: isSet96(object.after) ? fromJsonTimestamp12(object.after) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.before !== void 0 && (obj.before = message.before.toISOString());
    message.after !== void 0 && (obj.after = message.after.toISOString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseListActionRequest();
    message.before = object.before ?? void 0;
    message.after = object.after ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.scheduler.ListActionRequest", ListActionRequest);
function createBaseGetActionResponse() {
  return { id: "", request: void 0 };
}
var GetActionResponse = {
  $type: "devvit.plugin.scheduler.GetActionResponse",
  encode(message, writer = import_minimal115.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.request !== void 0) {
      ScheduledActionRequest.encode(message.request, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal115.default.Reader ? input : new import_minimal115.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.request = ScheduledActionRequest.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet96(object.id) ? String(object.id) : "",
      request: isSet96(object.request) ? ScheduledActionRequest.fromJSON(object.request) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.request !== void 0 && (obj.request = message.request ? ScheduledActionRequest.toJSON(message.request) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetActionResponse();
    message.id = object.id ?? "";
    message.request = object.request !== void 0 && object.request !== null ? ScheduledActionRequest.fromPartial(object.request) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.scheduler.GetActionResponse", GetActionResponse);
function createBaseListActionResponse() {
  return { actions: [] };
}
var ListActionResponse = {
  $type: "devvit.plugin.scheduler.ListActionResponse",
  encode(message, writer = import_minimal115.default.Writer.create()) {
    for (const v of message.actions) {
      GetActionResponse.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal115.default.Reader ? input : new import_minimal115.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actions.push(GetActionResponse.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actions: Array.isArray(object?.actions) ? object.actions.map((e) => GetActionResponse.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.actions) {
      obj.actions = message.actions.map((e) => e ? GetActionResponse.toJSON(e) : void 0);
    } else {
      obj.actions = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseListActionResponse();
    message.actions = object.actions?.map((e) => GetActionResponse.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.scheduler.ListActionResponse", ListActionResponse);
function toTimestamp12(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp12(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp12(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp12(Timestamp.fromJSON(o));
  }
}
function isObject19(value) {
  return typeof value === "object" && value !== null;
}
function isSet96(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/streambroker/streambroker.js
var import_long10 = __toESM(require_long(), 1);
var import_minimal116 = __toESM(require_minimal2(), 1);
function createBaseMessage() {
  return { topic: "", value: "" };
}
var Message = {
  $type: "devvit.plugin.streambroker.Message",
  encode(message, writer = import_minimal116.default.Writer.create()) {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal116.default.Reader ? input : new import_minimal116.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.topic = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      topic: isSet97(object.topic) ? String(object.topic) : "",
      value: isSet97(object.value) ? String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.topic !== void 0 && (obj.topic = message.topic);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMessage();
    message.topic = object.topic ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.streambroker.Message", Message);
function createBaseCursor() {
  return { topic: "", offset: 0, closeAtEnd: false };
}
var Cursor = {
  $type: "devvit.plugin.streambroker.Cursor",
  encode(message, writer = import_minimal116.default.Writer.create()) {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.offset !== 0) {
      writer.uint32(16).int64(message.offset);
    }
    if (message.closeAtEnd === true) {
      writer.uint32(24).bool(message.closeAtEnd);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal116.default.Reader ? input : new import_minimal116.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCursor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.topic = reader.string();
          break;
        case 2:
          message.offset = longToNumber10(reader.int64());
          break;
        case 3:
          message.closeAtEnd = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      topic: isSet97(object.topic) ? String(object.topic) : "",
      offset: isSet97(object.offset) ? Number(object.offset) : 0,
      closeAtEnd: isSet97(object.closeAtEnd) ? Boolean(object.closeAtEnd) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.topic !== void 0 && (obj.topic = message.topic);
    message.offset !== void 0 && (obj.offset = Math.round(message.offset));
    message.closeAtEnd !== void 0 && (obj.closeAtEnd = message.closeAtEnd);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCursor();
    message.topic = object.topic ?? "";
    message.offset = object.offset ?? 0;
    message.closeAtEnd = object.closeAtEnd ?? false;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.streambroker.Cursor", Cursor);
var globalThis13 = (() => {
  if (typeof globalThis13 !== "undefined") {
    return globalThis13;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function longToNumber10(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis13.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal116.default.util.Long !== import_long10.default) {
  import_minimal116.default.util.Long = import_long10.default;
  import_minimal116.default.configure();
}
function isSet97(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/timer/timer.js
var import_minimal117 = __toESM(require_minimal2(), 1);
function createBaseTimerMessage() {
  return { durationMillis: 0 };
}
var TimerMessage = {
  $type: "devvit.plugin.timer.TimerMessage",
  encode(message, writer = import_minimal117.default.Writer.create()) {
    if (message.durationMillis !== 0) {
      writer.uint32(8).int32(message.durationMillis);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal117.default.Reader ? input : new import_minimal117.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTimerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.durationMillis = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { durationMillis: isSet98(object.durationMillis) ? Number(object.durationMillis) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.durationMillis !== void 0 && (obj.durationMillis = Math.round(message.durationMillis));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTimerMessage();
    message.durationMillis = object.durationMillis ?? 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.timer.TimerMessage", TimerMessage);
function isSet98(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/plugin/v2events/v2events.js
var import_minimal118 = __toESM(require_minimal2(), 1);
function createBaseV2EventsActionInfo() {
  return { pageType: "", paneName: "" };
}
var V2EventsActionInfo = {
  $type: "devvit.plugin.v2events.V2EventsActionInfo",
  encode(message, writer = import_minimal118.default.Writer.create()) {
    if (message.pageType !== "") {
      writer.uint32(10).string(message.pageType);
    }
    if (message.paneName !== "") {
      writer.uint32(18).string(message.paneName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal118.default.Reader ? input : new import_minimal118.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseV2EventsActionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pageType = reader.string();
          break;
        case 2:
          message.paneName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      pageType: isSet99(object.pageType) ? String(object.pageType) : "",
      paneName: isSet99(object.paneName) ? String(object.paneName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.pageType !== void 0 && (obj.pageType = message.pageType);
    message.paneName !== void 0 && (obj.paneName = message.paneName);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseV2EventsActionInfo();
    message.pageType = object.pageType ?? "";
    message.paneName = object.paneName ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.v2events.V2EventsActionInfo", V2EventsActionInfo);
function createBaseV2EventsPostGuidanceCreate() {
  return { actionInfo: void 0 };
}
var V2EventsPostGuidanceCreate = {
  $type: "devvit.plugin.v2events.V2EventsPostGuidanceCreate",
  encode(message, writer = import_minimal118.default.Writer.create()) {
    if (message.actionInfo !== void 0) {
      V2EventsActionInfo.encode(message.actionInfo, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal118.default.Reader ? input : new import_minimal118.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseV2EventsPostGuidanceCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actionInfo = V2EventsActionInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { actionInfo: isSet99(object.actionInfo) ? V2EventsActionInfo.fromJSON(object.actionInfo) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.actionInfo !== void 0 && (obj.actionInfo = message.actionInfo ? V2EventsActionInfo.toJSON(message.actionInfo) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseV2EventsPostGuidanceCreate();
    message.actionInfo = object.actionInfo !== void 0 && object.actionInfo !== null ? V2EventsActionInfo.fromPartial(object.actionInfo) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.v2events.V2EventsPostGuidanceCreate", V2EventsPostGuidanceCreate);
function createBaseV2EventsPostGuidanceUpdate() {
  return { actionInfo: void 0 };
}
var V2EventsPostGuidanceUpdate = {
  $type: "devvit.plugin.v2events.V2EventsPostGuidanceUpdate",
  encode(message, writer = import_minimal118.default.Writer.create()) {
    if (message.actionInfo !== void 0) {
      V2EventsActionInfo.encode(message.actionInfo, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal118.default.Reader ? input : new import_minimal118.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseV2EventsPostGuidanceUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actionInfo = V2EventsActionInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { actionInfo: isSet99(object.actionInfo) ? V2EventsActionInfo.fromJSON(object.actionInfo) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.actionInfo !== void 0 && (obj.actionInfo = message.actionInfo ? V2EventsActionInfo.toJSON(message.actionInfo) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseV2EventsPostGuidanceUpdate();
    message.actionInfo = object.actionInfo !== void 0 && object.actionInfo !== null ? V2EventsActionInfo.fromPartial(object.actionInfo) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.v2events.V2EventsPostGuidanceUpdate", V2EventsPostGuidanceUpdate);
function createBaseV2EventsPublishRequest() {
  return { postGuidanceCreate: void 0, postGuidanceUpdate: void 0 };
}
var V2EventsPublishRequest = {
  $type: "devvit.plugin.v2events.V2EventsPublishRequest",
  encode(message, writer = import_minimal118.default.Writer.create()) {
    if (message.postGuidanceCreate !== void 0) {
      V2EventsPostGuidanceCreate.encode(message.postGuidanceCreate, writer.uint32(10).fork()).ldelim();
    }
    if (message.postGuidanceUpdate !== void 0) {
      V2EventsPostGuidanceUpdate.encode(message.postGuidanceUpdate, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal118.default.Reader ? input : new import_minimal118.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseV2EventsPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.postGuidanceCreate = V2EventsPostGuidanceCreate.decode(reader, reader.uint32());
          break;
        case 2:
          message.postGuidanceUpdate = V2EventsPostGuidanceUpdate.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      postGuidanceCreate: isSet99(object.postGuidanceCreate) ? V2EventsPostGuidanceCreate.fromJSON(object.postGuidanceCreate) : void 0,
      postGuidanceUpdate: isSet99(object.postGuidanceUpdate) ? V2EventsPostGuidanceUpdate.fromJSON(object.postGuidanceUpdate) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.postGuidanceCreate !== void 0 && (obj.postGuidanceCreate = message.postGuidanceCreate ? V2EventsPostGuidanceCreate.toJSON(message.postGuidanceCreate) : void 0);
    message.postGuidanceUpdate !== void 0 && (obj.postGuidanceUpdate = message.postGuidanceUpdate ? V2EventsPostGuidanceUpdate.toJSON(message.postGuidanceUpdate) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseV2EventsPublishRequest();
    message.postGuidanceCreate = object.postGuidanceCreate !== void 0 && object.postGuidanceCreate !== null ? V2EventsPostGuidanceCreate.fromPartial(object.postGuidanceCreate) : void 0;
    message.postGuidanceUpdate = object.postGuidanceUpdate !== void 0 && object.postGuidanceUpdate !== null ? V2EventsPostGuidanceUpdate.fromPartial(object.postGuidanceUpdate) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.v2events.V2EventsPublishRequest", V2EventsPublishRequest);
function createBaseV2EventsPublishResponse() {
  return {};
}
var V2EventsPublishResponse = {
  $type: "devvit.plugin.v2events.V2EventsPublishResponse",
  encode(_, writer = import_minimal118.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal118.default.Reader ? input : new import_minimal118.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseV2EventsPublishResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseV2EventsPublishResponse();
    return message;
  }
};
messageTypeRegistry.set("devvit.plugin.v2events.V2EventsPublishResponse", V2EventsPublishResponse);
function isSet99(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/custom_actions/v2alpha/custom_actions.js
var import_minimal119 = __toESM(require_minimal2(), 1);
function createBaseCustomAction() {
  return { actionId: "", label: "", shortDescription: "", menus: void 0, options: void 0 };
}
var CustomAction = {
  $type: "devvit.reddit.custom_actions.v2alpha.CustomAction",
  encode(message, writer = import_minimal119.default.Writer.create()) {
    if (message.actionId !== "") {
      writer.uint32(10).string(message.actionId);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.shortDescription !== "") {
      writer.uint32(26).string(message.shortDescription);
    }
    if (message.menus !== void 0) {
      CustomAction_Menus.encode(message.menus, writer.uint32(34).fork()).ldelim();
    }
    if (message.options !== void 0) {
      CustomAction_Options.encode(message.options, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal119.default.Reader ? input : new import_minimal119.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actionId = reader.string();
          break;
        case 2:
          message.label = reader.string();
          break;
        case 3:
          message.shortDescription = reader.string();
          break;
        case 4:
          message.menus = CustomAction_Menus.decode(reader, reader.uint32());
          break;
        case 5:
          message.options = CustomAction_Options.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actionId: isSet100(object.actionId) ? String(object.actionId) : "",
      label: isSet100(object.label) ? String(object.label) : "",
      shortDescription: isSet100(object.shortDescription) ? String(object.shortDescription) : "",
      menus: isSet100(object.menus) ? CustomAction_Menus.fromJSON(object.menus) : void 0,
      options: isSet100(object.options) ? CustomAction_Options.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.actionId !== void 0 && (obj.actionId = message.actionId);
    message.label !== void 0 && (obj.label = message.label);
    message.shortDescription !== void 0 && (obj.shortDescription = message.shortDescription);
    message.menus !== void 0 && (obj.menus = message.menus ? CustomAction_Menus.toJSON(message.menus) : void 0);
    message.options !== void 0 && (obj.options = message.options ? CustomAction_Options.toJSON(message.options) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCustomAction();
    message.actionId = object.actionId ?? "";
    message.label = object.label ?? "";
    message.shortDescription = object.shortDescription ?? "";
    message.menus = object.menus !== void 0 && object.menus !== null ? CustomAction_Menus.fromPartial(object.menus) : void 0;
    message.options = object.options !== void 0 && object.options !== null ? CustomAction_Options.fromPartial(object.options) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.CustomAction", CustomAction);
function createBaseCustomAction_Menus() {
  return { subreddit: void 0, post: void 0, comment: void 0 };
}
var CustomAction_Menus = {
  $type: "devvit.reddit.custom_actions.v2alpha.CustomAction.Menus",
  encode(message, writer = import_minimal119.default.Writer.create()) {
    if (message.subreddit !== void 0) {
      writer.uint32(8).bool(message.subreddit);
    }
    if (message.post !== void 0) {
      writer.uint32(16).bool(message.post);
    }
    if (message.comment !== void 0) {
      writer.uint32(24).bool(message.comment);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal119.default.Reader ? input : new import_minimal119.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomAction_Menus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subreddit = reader.bool();
          break;
        case 2:
          message.post = reader.bool();
          break;
        case 3:
          message.comment = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      subreddit: isSet100(object.subreddit) ? Boolean(object.subreddit) : void 0,
      post: isSet100(object.post) ? Boolean(object.post) : void 0,
      comment: isSet100(object.comment) ? Boolean(object.comment) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.subreddit !== void 0 && (obj.subreddit = message.subreddit);
    message.post !== void 0 && (obj.post = message.post);
    message.comment !== void 0 && (obj.comment = message.comment);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCustomAction_Menus();
    message.subreddit = object.subreddit ?? void 0;
    message.post = object.post ?? void 0;
    message.comment = object.comment ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.CustomAction.Menus", CustomAction_Menus);
function createBaseCustomAction_Options() {
  return { modTool: void 0, icon: void 0 };
}
var CustomAction_Options = {
  $type: "devvit.reddit.custom_actions.v2alpha.CustomAction.Options",
  encode(message, writer = import_minimal119.default.Writer.create()) {
    if (message.modTool !== void 0) {
      writer.uint32(8).bool(message.modTool);
    }
    if (message.icon !== void 0) {
      writer.uint32(18).string(message.icon);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal119.default.Reader ? input : new import_minimal119.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomAction_Options();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.modTool = reader.bool();
          break;
        case 2:
          message.icon = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      modTool: isSet100(object.modTool) ? Boolean(object.modTool) : void 0,
      icon: isSet100(object.icon) ? String(object.icon) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.modTool !== void 0 && (obj.modTool = message.modTool);
    message.icon !== void 0 && (obj.icon = message.icon);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCustomAction_Options();
    message.modTool = object.modTool ?? void 0;
    message.icon = object.icon ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.CustomAction.Options", CustomAction_Options);
function createBaseGetActionsRequest() {
  return {};
}
var GetActionsRequest = {
  $type: "devvit.reddit.custom_actions.v2alpha.GetActionsRequest",
  encode(_, writer = import_minimal119.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal119.default.Reader ? input : new import_minimal119.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetActionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseGetActionsRequest();
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.GetActionsRequest", GetActionsRequest);
function createBaseGetActionsResponse() {
  return { actions: [] };
}
var GetActionsResponse = {
  $type: "devvit.reddit.custom_actions.v2alpha.GetActionsResponse",
  encode(message, writer = import_minimal119.default.Writer.create()) {
    for (const v of message.actions) {
      CustomAction.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal119.default.Reader ? input : new import_minimal119.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetActionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actions.push(CustomAction.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { actions: Array.isArray(object?.actions) ? object.actions.map((e) => CustomAction.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.actions) {
      obj.actions = message.actions.map((e) => e ? CustomAction.toJSON(e) : void 0);
    } else {
      obj.actions = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetActionsResponse();
    message.actions = object.actions?.map((e) => CustomAction.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.GetActionsResponse", GetActionsResponse);
function createBaseOnActionRequest() {
  return { actionId: "", thingType: 0, thingId: "" };
}
var OnActionRequest = {
  $type: "devvit.reddit.custom_actions.v2alpha.OnActionRequest",
  encode(message, writer = import_minimal119.default.Writer.create()) {
    if (message.actionId !== "") {
      writer.uint32(10).string(message.actionId);
    }
    if (message.thingType !== 0) {
      writer.uint32(16).int32(message.thingType);
    }
    if (message.thingId !== "") {
      writer.uint32(26).string(message.thingId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal119.default.Reader ? input : new import_minimal119.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOnActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.actionId = reader.string();
          break;
        case 2:
          message.thingType = reader.int32();
          break;
        case 3:
          message.thingId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      actionId: isSet100(object.actionId) ? String(object.actionId) : "",
      thingType: isSet100(object.thingType) ? thingTypeFromJSON(object.thingType) : 0,
      thingId: isSet100(object.thingId) ? String(object.thingId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.actionId !== void 0 && (obj.actionId = message.actionId);
    message.thingType !== void 0 && (obj.thingType = thingTypeToJSON(message.thingType));
    message.thingId !== void 0 && (obj.thingId = message.thingId);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseOnActionRequest();
    message.actionId = object.actionId ?? "";
    message.thingType = object.thingType ?? 0;
    message.thingId = object.thingId ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.OnActionRequest", OnActionRequest);
function createBaseOnActionResponse() {
  return { state: void 0, effects: [] };
}
var OnActionResponse = {
  $type: "devvit.reddit.custom_actions.v2alpha.OnActionResponse",
  encode(message, writer = import_minimal119.default.Writer.create()) {
    if (message.state !== void 0) {
      Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.effects) {
      Effect.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal119.default.Reader ? input : new import_minimal119.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOnActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        case 2:
          message.effects.push(Effect.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      state: isObject20(object.state) ? object.state : void 0,
      effects: Array.isArray(object?.effects) ? object.effects.map((e) => Effect.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.state !== void 0 && (obj.state = message.state);
    if (message.effects) {
      obj.effects = message.effects.map((e) => e ? Effect.toJSON(e) : void 0);
    } else {
      obj.effects = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseOnActionResponse();
    message.state = object.state ?? void 0;
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.custom_actions.v2alpha.OnActionResponse", OnActionResponse);
function isObject20(value) {
  return typeof value === "object" && value !== null;
}
function isSet100(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/custom_post/v1alpha/custom_post.js
var import_minimal123 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/block_kit/v1beta/rendering.js
var import_minimal122 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/block_kit/v1beta/block.js
var import_minimal121 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/block_kit/v1beta/attributes.js
var import_minimal120 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/block_kit/v1beta/enums.js
var BlockType;
(function(BlockType2) {
  BlockType2[BlockType2["BLOCK_ROOT"] = 0] = "BLOCK_ROOT";
  BlockType2[BlockType2["BLOCK_STACK"] = 1] = "BLOCK_STACK";
  BlockType2[BlockType2["BLOCK_TEXT"] = 2] = "BLOCK_TEXT";
  BlockType2[BlockType2["BLOCK_BUTTON"] = 3] = "BLOCK_BUTTON";
  BlockType2[BlockType2["BLOCK_IMAGE"] = 4] = "BLOCK_IMAGE";
  BlockType2[BlockType2["BLOCK_SPACER"] = 5] = "BLOCK_SPACER";
  BlockType2[BlockType2["BLOCK_ICON"] = 6] = "BLOCK_ICON";
  BlockType2[BlockType2["BLOCK_AVATAR"] = 7] = "BLOCK_AVATAR";
  BlockType2[BlockType2["BLOCK_FULLSNOO"] = 8] = "BLOCK_FULLSNOO";
  BlockType2[BlockType2["BLOCK_ANIMATION"] = 9] = "BLOCK_ANIMATION";
  BlockType2[BlockType2["BLOCK_WEBVIEW"] = 100] = "BLOCK_WEBVIEW";
  BlockType2[BlockType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockType || (BlockType = {}));
function blockTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "BLOCK_ROOT":
      return BlockType.BLOCK_ROOT;
    case 1:
    case "BLOCK_STACK":
      return BlockType.BLOCK_STACK;
    case 2:
    case "BLOCK_TEXT":
      return BlockType.BLOCK_TEXT;
    case 3:
    case "BLOCK_BUTTON":
      return BlockType.BLOCK_BUTTON;
    case 4:
    case "BLOCK_IMAGE":
      return BlockType.BLOCK_IMAGE;
    case 5:
    case "BLOCK_SPACER":
      return BlockType.BLOCK_SPACER;
    case 6:
    case "BLOCK_ICON":
      return BlockType.BLOCK_ICON;
    case 7:
    case "BLOCK_AVATAR":
      return BlockType.BLOCK_AVATAR;
    case 8:
    case "BLOCK_FULLSNOO":
      return BlockType.BLOCK_FULLSNOO;
    case 9:
    case "BLOCK_ANIMATION":
      return BlockType.BLOCK_ANIMATION;
    case 100:
    case "BLOCK_WEBVIEW":
      return BlockType.BLOCK_WEBVIEW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockType.UNRECOGNIZED;
  }
}
function blockTypeToJSON(object) {
  switch (object) {
    case BlockType.BLOCK_ROOT:
      return 0;
    case BlockType.BLOCK_STACK:
      return 1;
    case BlockType.BLOCK_TEXT:
      return 2;
    case BlockType.BLOCK_BUTTON:
      return 3;
    case BlockType.BLOCK_IMAGE:
      return 4;
    case BlockType.BLOCK_SPACER:
      return 5;
    case BlockType.BLOCK_ICON:
      return 6;
    case BlockType.BLOCK_AVATAR:
      return 7;
    case BlockType.BLOCK_FULLSNOO:
      return 8;
    case BlockType.BLOCK_ANIMATION:
      return 9;
    case BlockType.BLOCK_WEBVIEW:
      return 100;
    case BlockType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockActionType;
(function(BlockActionType2) {
  BlockActionType2[BlockActionType2["ACTION_CLICK"] = 0] = "ACTION_CLICK";
  BlockActionType2[BlockActionType2["ACTION_WEBVIEW"] = 100] = "ACTION_WEBVIEW";
  BlockActionType2[BlockActionType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockActionType || (BlockActionType = {}));
function blockActionTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ACTION_CLICK":
      return BlockActionType.ACTION_CLICK;
    case 100:
    case "ACTION_WEBVIEW":
      return BlockActionType.ACTION_WEBVIEW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockActionType.UNRECOGNIZED;
  }
}
function blockActionTypeToJSON(object) {
  switch (object) {
    case BlockActionType.ACTION_CLICK:
      return 0;
    case BlockActionType.ACTION_WEBVIEW:
      return 100;
    case BlockActionType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockRenderEventType;
(function(BlockRenderEventType2) {
  BlockRenderEventType2[BlockRenderEventType2["RENDER_INITIAL"] = 0] = "RENDER_INITIAL";
  BlockRenderEventType2[BlockRenderEventType2["RENDER_USER_ACTION"] = 1] = "RENDER_USER_ACTION";
  BlockRenderEventType2[BlockRenderEventType2["RENDER_EFFECT_EVENT"] = 2] = "RENDER_EFFECT_EVENT";
  BlockRenderEventType2[BlockRenderEventType2["RENDER_CACHED"] = 3] = "RENDER_CACHED";
  BlockRenderEventType2[BlockRenderEventType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockRenderEventType || (BlockRenderEventType = {}));
function blockRenderEventTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "RENDER_INITIAL":
      return BlockRenderEventType.RENDER_INITIAL;
    case 1:
    case "RENDER_USER_ACTION":
      return BlockRenderEventType.RENDER_USER_ACTION;
    case 2:
    case "RENDER_EFFECT_EVENT":
      return BlockRenderEventType.RENDER_EFFECT_EVENT;
    case 3:
    case "RENDER_CACHED":
      return BlockRenderEventType.RENDER_CACHED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockRenderEventType.UNRECOGNIZED;
  }
}
function blockRenderEventTypeToJSON(object) {
  switch (object) {
    case BlockRenderEventType.RENDER_INITIAL:
      return 0;
    case BlockRenderEventType.RENDER_USER_ACTION:
      return 1;
    case BlockRenderEventType.RENDER_EFFECT_EVENT:
      return 2;
    case BlockRenderEventType.RENDER_CACHED:
      return 3;
    case BlockRenderEventType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockStackDirection;
(function(BlockStackDirection2) {
  BlockStackDirection2[BlockStackDirection2["STACK_HORIZONTAL"] = 0] = "STACK_HORIZONTAL";
  BlockStackDirection2[BlockStackDirection2["STACK_VERTICAL"] = 1] = "STACK_VERTICAL";
  BlockStackDirection2[BlockStackDirection2["STACK_DEPTH"] = 2] = "STACK_DEPTH";
  BlockStackDirection2[BlockStackDirection2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockStackDirection || (BlockStackDirection = {}));
function blockStackDirectionFromJSON(object) {
  switch (object) {
    case 0:
    case "STACK_HORIZONTAL":
      return BlockStackDirection.STACK_HORIZONTAL;
    case 1:
    case "STACK_VERTICAL":
      return BlockStackDirection.STACK_VERTICAL;
    case 2:
    case "STACK_DEPTH":
      return BlockStackDirection.STACK_DEPTH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockStackDirection.UNRECOGNIZED;
  }
}
function blockStackDirectionToJSON(object) {
  switch (object) {
    case BlockStackDirection.STACK_HORIZONTAL:
      return 0;
    case BlockStackDirection.STACK_VERTICAL:
      return 1;
    case BlockStackDirection.STACK_DEPTH:
      return 2;
    case BlockStackDirection.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockBorderWidth;
(function(BlockBorderWidth2) {
  BlockBorderWidth2[BlockBorderWidth2["BORDER_WIDTH_NONE"] = 0] = "BORDER_WIDTH_NONE";
  BlockBorderWidth2[BlockBorderWidth2["BORDER_WIDTH_THIN"] = 1] = "BORDER_WIDTH_THIN";
  BlockBorderWidth2[BlockBorderWidth2["BORDER_WIDTH_THICK"] = 2] = "BORDER_WIDTH_THICK";
  BlockBorderWidth2[BlockBorderWidth2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockBorderWidth || (BlockBorderWidth = {}));
function blockBorderWidthFromJSON(object) {
  switch (object) {
    case 0:
    case "BORDER_WIDTH_NONE":
      return BlockBorderWidth.BORDER_WIDTH_NONE;
    case 1:
    case "BORDER_WIDTH_THIN":
      return BlockBorderWidth.BORDER_WIDTH_THIN;
    case 2:
    case "BORDER_WIDTH_THICK":
      return BlockBorderWidth.BORDER_WIDTH_THICK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockBorderWidth.UNRECOGNIZED;
  }
}
function blockBorderWidthToJSON(object) {
  switch (object) {
    case BlockBorderWidth.BORDER_WIDTH_NONE:
      return 0;
    case BlockBorderWidth.BORDER_WIDTH_THIN:
      return 1;
    case BlockBorderWidth.BORDER_WIDTH_THICK:
      return 2;
    case BlockBorderWidth.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockVerticalAlignment;
(function(BlockVerticalAlignment2) {
  BlockVerticalAlignment2[BlockVerticalAlignment2["ALIGN_TOP"] = 0] = "ALIGN_TOP";
  BlockVerticalAlignment2[BlockVerticalAlignment2["ALIGN_MIDDLE"] = 1] = "ALIGN_MIDDLE";
  BlockVerticalAlignment2[BlockVerticalAlignment2["ALIGN_BOTTOM"] = 2] = "ALIGN_BOTTOM";
  BlockVerticalAlignment2[BlockVerticalAlignment2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockVerticalAlignment || (BlockVerticalAlignment = {}));
function blockVerticalAlignmentFromJSON(object) {
  switch (object) {
    case 0:
    case "ALIGN_TOP":
      return BlockVerticalAlignment.ALIGN_TOP;
    case 1:
    case "ALIGN_MIDDLE":
      return BlockVerticalAlignment.ALIGN_MIDDLE;
    case 2:
    case "ALIGN_BOTTOM":
      return BlockVerticalAlignment.ALIGN_BOTTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockVerticalAlignment.UNRECOGNIZED;
  }
}
function blockVerticalAlignmentToJSON(object) {
  switch (object) {
    case BlockVerticalAlignment.ALIGN_TOP:
      return 0;
    case BlockVerticalAlignment.ALIGN_MIDDLE:
      return 1;
    case BlockVerticalAlignment.ALIGN_BOTTOM:
      return 2;
    case BlockVerticalAlignment.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockHorizontalAlignment;
(function(BlockHorizontalAlignment2) {
  BlockHorizontalAlignment2[BlockHorizontalAlignment2["ALIGN_START"] = 0] = "ALIGN_START";
  BlockHorizontalAlignment2[BlockHorizontalAlignment2["ALIGN_CENTER"] = 1] = "ALIGN_CENTER";
  BlockHorizontalAlignment2[BlockHorizontalAlignment2["ALIGN_END"] = 2] = "ALIGN_END";
  BlockHorizontalAlignment2[BlockHorizontalAlignment2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockHorizontalAlignment || (BlockHorizontalAlignment = {}));
function blockHorizontalAlignmentFromJSON(object) {
  switch (object) {
    case 0:
    case "ALIGN_START":
      return BlockHorizontalAlignment.ALIGN_START;
    case 1:
    case "ALIGN_CENTER":
      return BlockHorizontalAlignment.ALIGN_CENTER;
    case 2:
    case "ALIGN_END":
      return BlockHorizontalAlignment.ALIGN_END;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockHorizontalAlignment.UNRECOGNIZED;
  }
}
function blockHorizontalAlignmentToJSON(object) {
  switch (object) {
    case BlockHorizontalAlignment.ALIGN_START:
      return 0;
    case BlockHorizontalAlignment.ALIGN_CENTER:
      return 1;
    case BlockHorizontalAlignment.ALIGN_END:
      return 2;
    case BlockHorizontalAlignment.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockPadding;
(function(BlockPadding2) {
  BlockPadding2[BlockPadding2["PADDING_NONE"] = 0] = "PADDING_NONE";
  BlockPadding2[BlockPadding2["PADDING_XSMALL"] = 1] = "PADDING_XSMALL";
  BlockPadding2[BlockPadding2["PADDING_SMALL"] = 2] = "PADDING_SMALL";
  BlockPadding2[BlockPadding2["PADDING_MEDIUM"] = 3] = "PADDING_MEDIUM";
  BlockPadding2[BlockPadding2["PADDING_LARGE"] = 4] = "PADDING_LARGE";
  BlockPadding2[BlockPadding2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockPadding || (BlockPadding = {}));
function blockPaddingFromJSON(object) {
  switch (object) {
    case 0:
    case "PADDING_NONE":
      return BlockPadding.PADDING_NONE;
    case 1:
    case "PADDING_XSMALL":
      return BlockPadding.PADDING_XSMALL;
    case 2:
    case "PADDING_SMALL":
      return BlockPadding.PADDING_SMALL;
    case 3:
    case "PADDING_MEDIUM":
      return BlockPadding.PADDING_MEDIUM;
    case 4:
    case "PADDING_LARGE":
      return BlockPadding.PADDING_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockPadding.UNRECOGNIZED;
  }
}
function blockPaddingToJSON(object) {
  switch (object) {
    case BlockPadding.PADDING_NONE:
      return 0;
    case BlockPadding.PADDING_XSMALL:
      return 1;
    case BlockPadding.PADDING_SMALL:
      return 2;
    case BlockPadding.PADDING_MEDIUM:
      return 3;
    case BlockPadding.PADDING_LARGE:
      return 4;
    case BlockPadding.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockGap;
(function(BlockGap2) {
  BlockGap2[BlockGap2["GAP_NONE"] = 0] = "GAP_NONE";
  BlockGap2[BlockGap2["GAP_SMALL"] = 1] = "GAP_SMALL";
  BlockGap2[BlockGap2["GAP_MEDIUM"] = 2] = "GAP_MEDIUM";
  BlockGap2[BlockGap2["GAP_LARGE"] = 3] = "GAP_LARGE";
  BlockGap2[BlockGap2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockGap || (BlockGap = {}));
function blockGapFromJSON(object) {
  switch (object) {
    case 0:
    case "GAP_NONE":
      return BlockGap.GAP_NONE;
    case 1:
    case "GAP_SMALL":
      return BlockGap.GAP_SMALL;
    case 2:
    case "GAP_MEDIUM":
      return BlockGap.GAP_MEDIUM;
    case 3:
    case "GAP_LARGE":
      return BlockGap.GAP_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockGap.UNRECOGNIZED;
  }
}
function blockGapToJSON(object) {
  switch (object) {
    case BlockGap.GAP_NONE:
      return 0;
    case BlockGap.GAP_SMALL:
      return 1;
    case BlockGap.GAP_MEDIUM:
      return 2;
    case BlockGap.GAP_LARGE:
      return 3;
    case BlockGap.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockRadius;
(function(BlockRadius2) {
  BlockRadius2[BlockRadius2["RADIUS_NONE"] = 0] = "RADIUS_NONE";
  BlockRadius2[BlockRadius2["RADIUS_SMALL"] = 1] = "RADIUS_SMALL";
  BlockRadius2[BlockRadius2["RADIUS_MEDIUM"] = 2] = "RADIUS_MEDIUM";
  BlockRadius2[BlockRadius2["RADIUS_LARGE"] = 3] = "RADIUS_LARGE";
  BlockRadius2[BlockRadius2["RADIUS_FULL"] = 100] = "RADIUS_FULL";
  BlockRadius2[BlockRadius2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockRadius || (BlockRadius = {}));
function blockRadiusFromJSON(object) {
  switch (object) {
    case 0:
    case "RADIUS_NONE":
      return BlockRadius.RADIUS_NONE;
    case 1:
    case "RADIUS_SMALL":
      return BlockRadius.RADIUS_SMALL;
    case 2:
    case "RADIUS_MEDIUM":
      return BlockRadius.RADIUS_MEDIUM;
    case 3:
    case "RADIUS_LARGE":
      return BlockRadius.RADIUS_LARGE;
    case 100:
    case "RADIUS_FULL":
      return BlockRadius.RADIUS_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockRadius.UNRECOGNIZED;
  }
}
function blockRadiusToJSON(object) {
  switch (object) {
    case BlockRadius.RADIUS_NONE:
      return 0;
    case BlockRadius.RADIUS_SMALL:
      return 1;
    case BlockRadius.RADIUS_MEDIUM:
      return 2;
    case BlockRadius.RADIUS_LARGE:
      return 3;
    case BlockRadius.RADIUS_FULL:
      return 100;
    case BlockRadius.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockTextSize;
(function(BlockTextSize2) {
  BlockTextSize2[BlockTextSize2["TEXT_SIZE_MEDIUM"] = 0] = "TEXT_SIZE_MEDIUM";
  BlockTextSize2[BlockTextSize2["TEXT_SIZE_XSMALL"] = 1] = "TEXT_SIZE_XSMALL";
  BlockTextSize2[BlockTextSize2["TEXT_SIZE_SMALL"] = 2] = "TEXT_SIZE_SMALL";
  BlockTextSize2[BlockTextSize2["TEXT_SIZE_LARGE"] = 3] = "TEXT_SIZE_LARGE";
  BlockTextSize2[BlockTextSize2["TEXT_SIZE_XLARGE"] = 4] = "TEXT_SIZE_XLARGE";
  BlockTextSize2[BlockTextSize2["TEXT_SIZE_XXLARGE"] = 5] = "TEXT_SIZE_XXLARGE";
  BlockTextSize2[BlockTextSize2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockTextSize || (BlockTextSize = {}));
function blockTextSizeFromJSON(object) {
  switch (object) {
    case 0:
    case "TEXT_SIZE_MEDIUM":
      return BlockTextSize.TEXT_SIZE_MEDIUM;
    case 1:
    case "TEXT_SIZE_XSMALL":
      return BlockTextSize.TEXT_SIZE_XSMALL;
    case 2:
    case "TEXT_SIZE_SMALL":
      return BlockTextSize.TEXT_SIZE_SMALL;
    case 3:
    case "TEXT_SIZE_LARGE":
      return BlockTextSize.TEXT_SIZE_LARGE;
    case 4:
    case "TEXT_SIZE_XLARGE":
      return BlockTextSize.TEXT_SIZE_XLARGE;
    case 5:
    case "TEXT_SIZE_XXLARGE":
      return BlockTextSize.TEXT_SIZE_XXLARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockTextSize.UNRECOGNIZED;
  }
}
function blockTextSizeToJSON(object) {
  switch (object) {
    case BlockTextSize.TEXT_SIZE_MEDIUM:
      return 0;
    case BlockTextSize.TEXT_SIZE_XSMALL:
      return 1;
    case BlockTextSize.TEXT_SIZE_SMALL:
      return 2;
    case BlockTextSize.TEXT_SIZE_LARGE:
      return 3;
    case BlockTextSize.TEXT_SIZE_XLARGE:
      return 4;
    case BlockTextSize.TEXT_SIZE_XXLARGE:
      return 5;
    case BlockTextSize.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockTextWeight;
(function(BlockTextWeight2) {
  BlockTextWeight2[BlockTextWeight2["TEXT_WEIGHT_REGULAR"] = 0] = "TEXT_WEIGHT_REGULAR";
  BlockTextWeight2[BlockTextWeight2["TEXT_WEIGHT_BOLD"] = 1] = "TEXT_WEIGHT_BOLD";
  BlockTextWeight2[BlockTextWeight2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockTextWeight || (BlockTextWeight = {}));
function blockTextWeightFromJSON(object) {
  switch (object) {
    case 0:
    case "TEXT_WEIGHT_REGULAR":
      return BlockTextWeight.TEXT_WEIGHT_REGULAR;
    case 1:
    case "TEXT_WEIGHT_BOLD":
      return BlockTextWeight.TEXT_WEIGHT_BOLD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockTextWeight.UNRECOGNIZED;
  }
}
function blockTextWeightToJSON(object) {
  switch (object) {
    case BlockTextWeight.TEXT_WEIGHT_REGULAR:
      return 0;
    case BlockTextWeight.TEXT_WEIGHT_BOLD:
      return 1;
    case BlockTextWeight.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockTextOutline;
(function(BlockTextOutline2) {
  BlockTextOutline2[BlockTextOutline2["TEXT_OUTLINE_NONE"] = 0] = "TEXT_OUTLINE_NONE";
  BlockTextOutline2[BlockTextOutline2["TEXT_OUTLINE_THIN"] = 1] = "TEXT_OUTLINE_THIN";
  BlockTextOutline2[BlockTextOutline2["TEXT_OUTLINE_THICK"] = 2] = "TEXT_OUTLINE_THICK";
  BlockTextOutline2[BlockTextOutline2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockTextOutline || (BlockTextOutline = {}));
function blockTextOutlineFromJSON(object) {
  switch (object) {
    case 0:
    case "TEXT_OUTLINE_NONE":
      return BlockTextOutline.TEXT_OUTLINE_NONE;
    case 1:
    case "TEXT_OUTLINE_THIN":
      return BlockTextOutline.TEXT_OUTLINE_THIN;
    case 2:
    case "TEXT_OUTLINE_THICK":
      return BlockTextOutline.TEXT_OUTLINE_THICK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockTextOutline.UNRECOGNIZED;
  }
}
function blockTextOutlineToJSON(object) {
  switch (object) {
    case BlockTextOutline.TEXT_OUTLINE_NONE:
      return 0;
    case BlockTextOutline.TEXT_OUTLINE_THIN:
      return 1;
    case BlockTextOutline.TEXT_OUTLINE_THICK:
      return 2;
    case BlockTextOutline.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockTextStyle;
(function(BlockTextStyle2) {
  BlockTextStyle2[BlockTextStyle2["TEXT_STYLE_BODY"] = 0] = "TEXT_STYLE_BODY";
  BlockTextStyle2[BlockTextStyle2["TEXT_STYLE_METADATA"] = 1] = "TEXT_STYLE_METADATA";
  BlockTextStyle2[BlockTextStyle2["TEXT_STYLE_HEADING"] = 2] = "TEXT_STYLE_HEADING";
  BlockTextStyle2[BlockTextStyle2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockTextStyle || (BlockTextStyle = {}));
function blockTextStyleFromJSON(object) {
  switch (object) {
    case 0:
    case "TEXT_STYLE_BODY":
      return BlockTextStyle.TEXT_STYLE_BODY;
    case 1:
    case "TEXT_STYLE_METADATA":
      return BlockTextStyle.TEXT_STYLE_METADATA;
    case 2:
    case "TEXT_STYLE_HEADING":
      return BlockTextStyle.TEXT_STYLE_HEADING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockTextStyle.UNRECOGNIZED;
  }
}
function blockTextStyleToJSON(object) {
  switch (object) {
    case BlockTextStyle.TEXT_STYLE_BODY:
      return 0;
    case BlockTextStyle.TEXT_STYLE_METADATA:
      return 1;
    case BlockTextStyle.TEXT_STYLE_HEADING:
      return 2;
    case BlockTextStyle.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockButtonSize;
(function(BlockButtonSize2) {
  BlockButtonSize2[BlockButtonSize2["BUTTON_SIZE_MEDIUM"] = 0] = "BUTTON_SIZE_MEDIUM";
  BlockButtonSize2[BlockButtonSize2["BUTTON_SIZE_SMALL"] = 1] = "BUTTON_SIZE_SMALL";
  BlockButtonSize2[BlockButtonSize2["BUTTON_SIZE_LARGE"] = 2] = "BUTTON_SIZE_LARGE";
  BlockButtonSize2[BlockButtonSize2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockButtonSize || (BlockButtonSize = {}));
function blockButtonSizeFromJSON(object) {
  switch (object) {
    case 0:
    case "BUTTON_SIZE_MEDIUM":
      return BlockButtonSize.BUTTON_SIZE_MEDIUM;
    case 1:
    case "BUTTON_SIZE_SMALL":
      return BlockButtonSize.BUTTON_SIZE_SMALL;
    case 2:
    case "BUTTON_SIZE_LARGE":
      return BlockButtonSize.BUTTON_SIZE_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockButtonSize.UNRECOGNIZED;
  }
}
function blockButtonSizeToJSON(object) {
  switch (object) {
    case BlockButtonSize.BUTTON_SIZE_MEDIUM:
      return 0;
    case BlockButtonSize.BUTTON_SIZE_SMALL:
      return 1;
    case BlockButtonSize.BUTTON_SIZE_LARGE:
      return 2;
    case BlockButtonSize.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockButtonAppearance;
(function(BlockButtonAppearance2) {
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_SECONDARY"] = 0] = "BUTTON_APPEARANCE_SECONDARY";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_PRIMARY"] = 1] = "BUTTON_APPEARANCE_PRIMARY";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_PLAIN"] = 2] = "BUTTON_APPEARANCE_PLAIN";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_BORDERED"] = 3] = "BUTTON_APPEARANCE_BORDERED";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_MEDIA"] = 4] = "BUTTON_APPEARANCE_MEDIA";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_DESTRUCTIVE"] = 5] = "BUTTON_APPEARANCE_DESTRUCTIVE";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_CAUTION"] = 6] = "BUTTON_APPEARANCE_CAUTION";
  BlockButtonAppearance2[BlockButtonAppearance2["BUTTON_APPEARANCE_SUCCESS"] = 7] = "BUTTON_APPEARANCE_SUCCESS";
  BlockButtonAppearance2[BlockButtonAppearance2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockButtonAppearance || (BlockButtonAppearance = {}));
function blockButtonAppearanceFromJSON(object) {
  switch (object) {
    case 0:
    case "BUTTON_APPEARANCE_SECONDARY":
      return BlockButtonAppearance.BUTTON_APPEARANCE_SECONDARY;
    case 1:
    case "BUTTON_APPEARANCE_PRIMARY":
      return BlockButtonAppearance.BUTTON_APPEARANCE_PRIMARY;
    case 2:
    case "BUTTON_APPEARANCE_PLAIN":
      return BlockButtonAppearance.BUTTON_APPEARANCE_PLAIN;
    case 3:
    case "BUTTON_APPEARANCE_BORDERED":
      return BlockButtonAppearance.BUTTON_APPEARANCE_BORDERED;
    case 4:
    case "BUTTON_APPEARANCE_MEDIA":
      return BlockButtonAppearance.BUTTON_APPEARANCE_MEDIA;
    case 5:
    case "BUTTON_APPEARANCE_DESTRUCTIVE":
      return BlockButtonAppearance.BUTTON_APPEARANCE_DESTRUCTIVE;
    case 6:
    case "BUTTON_APPEARANCE_CAUTION":
      return BlockButtonAppearance.BUTTON_APPEARANCE_CAUTION;
    case 7:
    case "BUTTON_APPEARANCE_SUCCESS":
      return BlockButtonAppearance.BUTTON_APPEARANCE_SUCCESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockButtonAppearance.UNRECOGNIZED;
  }
}
function blockButtonAppearanceToJSON(object) {
  switch (object) {
    case BlockButtonAppearance.BUTTON_APPEARANCE_SECONDARY:
      return 0;
    case BlockButtonAppearance.BUTTON_APPEARANCE_PRIMARY:
      return 1;
    case BlockButtonAppearance.BUTTON_APPEARANCE_PLAIN:
      return 2;
    case BlockButtonAppearance.BUTTON_APPEARANCE_BORDERED:
      return 3;
    case BlockButtonAppearance.BUTTON_APPEARANCE_MEDIA:
      return 4;
    case BlockButtonAppearance.BUTTON_APPEARANCE_DESTRUCTIVE:
      return 5;
    case BlockButtonAppearance.BUTTON_APPEARANCE_CAUTION:
      return 6;
    case BlockButtonAppearance.BUTTON_APPEARANCE_SUCCESS:
      return 7;
    case BlockButtonAppearance.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockImageResizeMode;
(function(BlockImageResizeMode2) {
  BlockImageResizeMode2[BlockImageResizeMode2["IMAGE_RESIZE_FIT"] = 0] = "IMAGE_RESIZE_FIT";
  BlockImageResizeMode2[BlockImageResizeMode2["IMAGE_RESIZE_FILL"] = 1] = "IMAGE_RESIZE_FILL";
  BlockImageResizeMode2[BlockImageResizeMode2["IMAGE_RESIZE_COVER"] = 2] = "IMAGE_RESIZE_COVER";
  BlockImageResizeMode2[BlockImageResizeMode2["IMAGE_RESIZE_NONE"] = 3] = "IMAGE_RESIZE_NONE";
  BlockImageResizeMode2[BlockImageResizeMode2["IMAGE_RESIZE_SCALE_DOWN"] = 4] = "IMAGE_RESIZE_SCALE_DOWN";
  BlockImageResizeMode2[BlockImageResizeMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockImageResizeMode || (BlockImageResizeMode = {}));
function blockImageResizeModeFromJSON(object) {
  switch (object) {
    case 0:
    case "IMAGE_RESIZE_FIT":
      return BlockImageResizeMode.IMAGE_RESIZE_FIT;
    case 1:
    case "IMAGE_RESIZE_FILL":
      return BlockImageResizeMode.IMAGE_RESIZE_FILL;
    case 2:
    case "IMAGE_RESIZE_COVER":
      return BlockImageResizeMode.IMAGE_RESIZE_COVER;
    case 3:
    case "IMAGE_RESIZE_NONE":
      return BlockImageResizeMode.IMAGE_RESIZE_NONE;
    case 4:
    case "IMAGE_RESIZE_SCALE_DOWN":
      return BlockImageResizeMode.IMAGE_RESIZE_SCALE_DOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockImageResizeMode.UNRECOGNIZED;
  }
}
function blockImageResizeModeToJSON(object) {
  switch (object) {
    case BlockImageResizeMode.IMAGE_RESIZE_FIT:
      return 0;
    case BlockImageResizeMode.IMAGE_RESIZE_FILL:
      return 1;
    case BlockImageResizeMode.IMAGE_RESIZE_COVER:
      return 2;
    case BlockImageResizeMode.IMAGE_RESIZE_NONE:
      return 3;
    case BlockImageResizeMode.IMAGE_RESIZE_SCALE_DOWN:
      return 4;
    case BlockImageResizeMode.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockSpacerSize;
(function(BlockSpacerSize2) {
  BlockSpacerSize2[BlockSpacerSize2["SPACER_SMALL"] = 0] = "SPACER_SMALL";
  BlockSpacerSize2[BlockSpacerSize2["SPACER_XSMALL"] = 1] = "SPACER_XSMALL";
  BlockSpacerSize2[BlockSpacerSize2["SPACER_MEDIUM"] = 2] = "SPACER_MEDIUM";
  BlockSpacerSize2[BlockSpacerSize2["SPACER_LARGE"] = 3] = "SPACER_LARGE";
  BlockSpacerSize2[BlockSpacerSize2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockSpacerSize || (BlockSpacerSize = {}));
function blockSpacerSizeFromJSON(object) {
  switch (object) {
    case 0:
    case "SPACER_SMALL":
      return BlockSpacerSize.SPACER_SMALL;
    case 1:
    case "SPACER_XSMALL":
      return BlockSpacerSize.SPACER_XSMALL;
    case 2:
    case "SPACER_MEDIUM":
      return BlockSpacerSize.SPACER_MEDIUM;
    case 3:
    case "SPACER_LARGE":
      return BlockSpacerSize.SPACER_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockSpacerSize.UNRECOGNIZED;
  }
}
function blockSpacerSizeToJSON(object) {
  switch (object) {
    case BlockSpacerSize.SPACER_SMALL:
      return 0;
    case BlockSpacerSize.SPACER_XSMALL:
      return 1;
    case BlockSpacerSize.SPACER_MEDIUM:
      return 2;
    case BlockSpacerSize.SPACER_LARGE:
      return 3;
    case BlockSpacerSize.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockIconSize;
(function(BlockIconSize2) {
  BlockIconSize2[BlockIconSize2["ICON_SIZE_MEDIUM"] = 0] = "ICON_SIZE_MEDIUM";
  BlockIconSize2[BlockIconSize2["ICON_SIZE_XSMALL"] = 1] = "ICON_SIZE_XSMALL";
  BlockIconSize2[BlockIconSize2["ICON_SIZE_SMALL"] = 2] = "ICON_SIZE_SMALL";
  BlockIconSize2[BlockIconSize2["ICON_SIZE_LARGE"] = 3] = "ICON_SIZE_LARGE";
  BlockIconSize2[BlockIconSize2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockIconSize || (BlockIconSize = {}));
function blockIconSizeFromJSON(object) {
  switch (object) {
    case 0:
    case "ICON_SIZE_MEDIUM":
      return BlockIconSize.ICON_SIZE_MEDIUM;
    case 1:
    case "ICON_SIZE_XSMALL":
      return BlockIconSize.ICON_SIZE_XSMALL;
    case 2:
    case "ICON_SIZE_SMALL":
      return BlockIconSize.ICON_SIZE_SMALL;
    case 3:
    case "ICON_SIZE_LARGE":
      return BlockIconSize.ICON_SIZE_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockIconSize.UNRECOGNIZED;
  }
}
function blockIconSizeToJSON(object) {
  switch (object) {
    case BlockIconSize.ICON_SIZE_MEDIUM:
      return 0;
    case BlockIconSize.ICON_SIZE_XSMALL:
      return 1;
    case BlockIconSize.ICON_SIZE_SMALL:
      return 2;
    case BlockIconSize.ICON_SIZE_LARGE:
      return 3;
    case BlockIconSize.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockAvatarFacing;
(function(BlockAvatarFacing2) {
  BlockAvatarFacing2[BlockAvatarFacing2["AVATAR_FACING_LEFT"] = 0] = "AVATAR_FACING_LEFT";
  BlockAvatarFacing2[BlockAvatarFacing2["AVATAR_FACING_RIGHT"] = 1] = "AVATAR_FACING_RIGHT";
  BlockAvatarFacing2[BlockAvatarFacing2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockAvatarFacing || (BlockAvatarFacing = {}));
function blockAvatarFacingFromJSON(object) {
  switch (object) {
    case 0:
    case "AVATAR_FACING_LEFT":
      return BlockAvatarFacing.AVATAR_FACING_LEFT;
    case 1:
    case "AVATAR_FACING_RIGHT":
      return BlockAvatarFacing.AVATAR_FACING_RIGHT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockAvatarFacing.UNRECOGNIZED;
  }
}
function blockAvatarFacingToJSON(object) {
  switch (object) {
    case BlockAvatarFacing.AVATAR_FACING_LEFT:
      return 0;
    case BlockAvatarFacing.AVATAR_FACING_RIGHT:
      return 1;
    case BlockAvatarFacing.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockAvatarSize;
(function(BlockAvatarSize2) {
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_SMALL"] = 0] = "AVATAR_SIZE_SMALL";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_XXSMALL"] = 1] = "AVATAR_SIZE_XXSMALL";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_XSMALL"] = 2] = "AVATAR_SIZE_XSMALL";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_MEDIUM"] = 3] = "AVATAR_SIZE_MEDIUM";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_LARGE"] = 4] = "AVATAR_SIZE_LARGE";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_XLARGE"] = 5] = "AVATAR_SIZE_XLARGE";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_XXLARGE"] = 6] = "AVATAR_SIZE_XXLARGE";
  BlockAvatarSize2[BlockAvatarSize2["AVATAR_SIZE_XXXLARGE"] = 7] = "AVATAR_SIZE_XXXLARGE";
  BlockAvatarSize2[BlockAvatarSize2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockAvatarSize || (BlockAvatarSize = {}));
function blockAvatarSizeFromJSON(object) {
  switch (object) {
    case 0:
    case "AVATAR_SIZE_SMALL":
      return BlockAvatarSize.AVATAR_SIZE_SMALL;
    case 1:
    case "AVATAR_SIZE_XXSMALL":
      return BlockAvatarSize.AVATAR_SIZE_XXSMALL;
    case 2:
    case "AVATAR_SIZE_XSMALL":
      return BlockAvatarSize.AVATAR_SIZE_XSMALL;
    case 3:
    case "AVATAR_SIZE_MEDIUM":
      return BlockAvatarSize.AVATAR_SIZE_MEDIUM;
    case 4:
    case "AVATAR_SIZE_LARGE":
      return BlockAvatarSize.AVATAR_SIZE_LARGE;
    case 5:
    case "AVATAR_SIZE_XLARGE":
      return BlockAvatarSize.AVATAR_SIZE_XLARGE;
    case 6:
    case "AVATAR_SIZE_XXLARGE":
      return BlockAvatarSize.AVATAR_SIZE_XXLARGE;
    case 7:
    case "AVATAR_SIZE_XXXLARGE":
      return BlockAvatarSize.AVATAR_SIZE_XXXLARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockAvatarSize.UNRECOGNIZED;
  }
}
function blockAvatarSizeToJSON(object) {
  switch (object) {
    case BlockAvatarSize.AVATAR_SIZE_SMALL:
      return 0;
    case BlockAvatarSize.AVATAR_SIZE_XXSMALL:
      return 1;
    case BlockAvatarSize.AVATAR_SIZE_XSMALL:
      return 2;
    case BlockAvatarSize.AVATAR_SIZE_MEDIUM:
      return 3;
    case BlockAvatarSize.AVATAR_SIZE_LARGE:
      return 4;
    case BlockAvatarSize.AVATAR_SIZE_XLARGE:
      return 5;
    case BlockAvatarSize.AVATAR_SIZE_XXLARGE:
      return 6;
    case BlockAvatarSize.AVATAR_SIZE_XXXLARGE:
      return 7;
    case BlockAvatarSize.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockAvatarBackground;
(function(BlockAvatarBackground2) {
  BlockAvatarBackground2[BlockAvatarBackground2["AVATAR_BG_LIGHT"] = 0] = "AVATAR_BG_LIGHT";
  BlockAvatarBackground2[BlockAvatarBackground2["AVATAR_BG_DARK"] = 1] = "AVATAR_BG_DARK";
  BlockAvatarBackground2[BlockAvatarBackground2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockAvatarBackground || (BlockAvatarBackground = {}));
function blockAvatarBackgroundFromJSON(object) {
  switch (object) {
    case 0:
    case "AVATAR_BG_LIGHT":
      return BlockAvatarBackground.AVATAR_BG_LIGHT;
    case 1:
    case "AVATAR_BG_DARK":
      return BlockAvatarBackground.AVATAR_BG_DARK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockAvatarBackground.UNRECOGNIZED;
  }
}
function blockAvatarBackgroundToJSON(object) {
  switch (object) {
    case BlockAvatarBackground.AVATAR_BG_LIGHT:
      return 0;
    case BlockAvatarBackground.AVATAR_BG_DARK:
      return 1;
    case BlockAvatarBackground.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockFullSnooSize;
(function(BlockFullSnooSize2) {
  BlockFullSnooSize2[BlockFullSnooSize2["FULLSNOO_SMALL"] = 0] = "FULLSNOO_SMALL";
  BlockFullSnooSize2[BlockFullSnooSize2["FULLSNOO_XSMALL"] = 1] = "FULLSNOO_XSMALL";
  BlockFullSnooSize2[BlockFullSnooSize2["FULLSNOO_MEDIUM"] = 2] = "FULLSNOO_MEDIUM";
  BlockFullSnooSize2[BlockFullSnooSize2["FULLSNOO_LARGE"] = 3] = "FULLSNOO_LARGE";
  BlockFullSnooSize2[BlockFullSnooSize2["FULLSNOO_XLARGE"] = 4] = "FULLSNOO_XLARGE";
  BlockFullSnooSize2[BlockFullSnooSize2["FULLSNOO_XXLARGE"] = 5] = "FULLSNOO_XXLARGE";
  BlockFullSnooSize2[BlockFullSnooSize2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockFullSnooSize || (BlockFullSnooSize = {}));
function blockFullSnooSizeFromJSON(object) {
  switch (object) {
    case 0:
    case "FULLSNOO_SMALL":
      return BlockFullSnooSize.FULLSNOO_SMALL;
    case 1:
    case "FULLSNOO_XSMALL":
      return BlockFullSnooSize.FULLSNOO_XSMALL;
    case 2:
    case "FULLSNOO_MEDIUM":
      return BlockFullSnooSize.FULLSNOO_MEDIUM;
    case 3:
    case "FULLSNOO_LARGE":
      return BlockFullSnooSize.FULLSNOO_LARGE;
    case 4:
    case "FULLSNOO_XLARGE":
      return BlockFullSnooSize.FULLSNOO_XLARGE;
    case 5:
    case "FULLSNOO_XXLARGE":
      return BlockFullSnooSize.FULLSNOO_XXLARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockFullSnooSize.UNRECOGNIZED;
  }
}
function blockFullSnooSizeToJSON(object) {
  switch (object) {
    case BlockFullSnooSize.FULLSNOO_SMALL:
      return 0;
    case BlockFullSnooSize.FULLSNOO_XSMALL:
      return 1;
    case BlockFullSnooSize.FULLSNOO_MEDIUM:
      return 2;
    case BlockFullSnooSize.FULLSNOO_LARGE:
      return 3;
    case BlockFullSnooSize.FULLSNOO_XLARGE:
      return 4;
    case BlockFullSnooSize.FULLSNOO_XXLARGE:
      return 5;
    case BlockFullSnooSize.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockAnimationType;
(function(BlockAnimationType2) {
  BlockAnimationType2[BlockAnimationType2["ANIM_LOTTIE"] = 0] = "ANIM_LOTTIE";
  BlockAnimationType2[BlockAnimationType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockAnimationType || (BlockAnimationType = {}));
function blockAnimationTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ANIM_LOTTIE":
      return BlockAnimationType.ANIM_LOTTIE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockAnimationType.UNRECOGNIZED;
  }
}
function blockAnimationTypeToJSON(object) {
  switch (object) {
    case BlockAnimationType.ANIM_LOTTIE:
      return 0;
    case BlockAnimationType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockAnimationLoopMode;
(function(BlockAnimationLoopMode2) {
  BlockAnimationLoopMode2[BlockAnimationLoopMode2["ANIM_LOOP_REPEAT"] = 0] = "ANIM_LOOP_REPEAT";
  BlockAnimationLoopMode2[BlockAnimationLoopMode2["ANIM_LOOP_BOUNCE"] = 1] = "ANIM_LOOP_BOUNCE";
  BlockAnimationLoopMode2[BlockAnimationLoopMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockAnimationLoopMode || (BlockAnimationLoopMode = {}));
function blockAnimationLoopModeFromJSON(object) {
  switch (object) {
    case 0:
    case "ANIM_LOOP_REPEAT":
      return BlockAnimationLoopMode.ANIM_LOOP_REPEAT;
    case 1:
    case "ANIM_LOOP_BOUNCE":
      return BlockAnimationLoopMode.ANIM_LOOP_BOUNCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockAnimationLoopMode.UNRECOGNIZED;
  }
}
function blockAnimationLoopModeToJSON(object) {
  switch (object) {
    case BlockAnimationLoopMode.ANIM_LOOP_REPEAT:
      return 0;
    case BlockAnimationLoopMode.ANIM_LOOP_BOUNCE:
      return 1;
    case BlockAnimationLoopMode.UNRECOGNIZED:
    default:
      return -1;
  }
}
var BlockAnimationDirection;
(function(BlockAnimationDirection2) {
  BlockAnimationDirection2[BlockAnimationDirection2["ANIM_DIR_FORWARD"] = 0] = "ANIM_DIR_FORWARD";
  BlockAnimationDirection2[BlockAnimationDirection2["ANIM_DIR_BACKWARD"] = 1] = "ANIM_DIR_BACKWARD";
  BlockAnimationDirection2[BlockAnimationDirection2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockAnimationDirection || (BlockAnimationDirection = {}));
function blockAnimationDirectionFromJSON(object) {
  switch (object) {
    case 0:
    case "ANIM_DIR_FORWARD":
      return BlockAnimationDirection.ANIM_DIR_FORWARD;
    case 1:
    case "ANIM_DIR_BACKWARD":
      return BlockAnimationDirection.ANIM_DIR_BACKWARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockAnimationDirection.UNRECOGNIZED;
  }
}
function blockAnimationDirectionToJSON(object) {
  switch (object) {
    case BlockAnimationDirection.ANIM_DIR_FORWARD:
      return 0;
    case BlockAnimationDirection.ANIM_DIR_BACKWARD:
      return 1;
    case BlockAnimationDirection.UNRECOGNIZED:
    default:
      return -1;
  }
}

// ../protos/dist/types/devvit/ui/block_kit/v1beta/attributes.js
function createBaseBlockAlignment() {
  return { vertical: void 0, horizontal: void 0 };
}
var BlockAlignment = {
  $type: "devvit.ui.block_kit.v1beta.BlockAlignment",
  encode(message, writer = import_minimal120.default.Writer.create()) {
    if (message.vertical !== void 0) {
      writer.uint32(8).int32(message.vertical);
    }
    if (message.horizontal !== void 0) {
      writer.uint32(16).int32(message.horizontal);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal120.default.Reader ? input : new import_minimal120.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockAlignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.vertical = reader.int32();
          break;
        case 2:
          message.horizontal = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      vertical: isSet101(object.vertical) ? blockVerticalAlignmentFromJSON(object.vertical) : void 0,
      horizontal: isSet101(object.horizontal) ? blockHorizontalAlignmentFromJSON(object.horizontal) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.vertical !== void 0 && (obj.vertical = message.vertical !== void 0 ? blockVerticalAlignmentToJSON(message.vertical) : void 0);
    message.horizontal !== void 0 && (obj.horizontal = message.horizontal !== void 0 ? blockHorizontalAlignmentToJSON(message.horizontal) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockAlignment();
    message.vertical = object.vertical ?? void 0;
    message.horizontal = object.horizontal ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockAlignment", BlockAlignment);
function createBaseBlockBorder() {
  return { color: void 0, width: void 0 };
}
var BlockBorder = {
  $type: "devvit.ui.block_kit.v1beta.BlockBorder",
  encode(message, writer = import_minimal120.default.Writer.create()) {
    if (message.color !== void 0) {
      writer.uint32(10).string(message.color);
    }
    if (message.width !== void 0) {
      writer.uint32(16).int32(message.width);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal120.default.Reader ? input : new import_minimal120.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockBorder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.color = reader.string();
          break;
        case 2:
          message.width = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      color: isSet101(object.color) ? String(object.color) : void 0,
      width: isSet101(object.width) ? blockBorderWidthFromJSON(object.width) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.color !== void 0 && (obj.color = message.color);
    message.width !== void 0 && (obj.width = message.width !== void 0 ? blockBorderWidthToJSON(message.width) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockBorder();
    message.color = object.color ?? void 0;
    message.width = object.width ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockBorder", BlockBorder);
function createBaseBlockSize() {
  return { grow: void 0, width: void 0, height: void 0 };
}
var BlockSize = {
  $type: "devvit.ui.block_kit.v1beta.BlockSize",
  encode(message, writer = import_minimal120.default.Writer.create()) {
    if (message.grow !== void 0) {
      writer.uint32(8).bool(message.grow);
    }
    if (message.width !== void 0) {
      writer.uint32(21).float(message.width);
    }
    if (message.height !== void 0) {
      writer.uint32(29).float(message.height);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal120.default.Reader ? input : new import_minimal120.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockSize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.grow = reader.bool();
          break;
        case 2:
          message.width = reader.float();
          break;
        case 3:
          message.height = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      grow: isSet101(object.grow) ? Boolean(object.grow) : void 0,
      width: isSet101(object.width) ? Number(object.width) : void 0,
      height: isSet101(object.height) ? Number(object.height) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.grow !== void 0 && (obj.grow = message.grow);
    message.width !== void 0 && (obj.width = message.width);
    message.height !== void 0 && (obj.height = message.height);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockSize();
    message.grow = object.grow ?? void 0;
    message.width = object.width ?? void 0;
    message.height = object.height ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockSize", BlockSize);
function createBaseBlockAction() {
  return { type: 0, id: "", data: void 0 };
}
var BlockAction = {
  $type: "devvit.ui.block_kit.v1beta.BlockAction",
  encode(message, writer = import_minimal120.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.data !== void 0) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal120.default.Reader ? input : new import_minimal120.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet101(object.type) ? blockActionTypeFromJSON(object.type) : 0,
      id: isSet101(object.id) ? String(object.id) : "",
      data: isObject21(object.data) ? object.data : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = blockActionTypeToJSON(message.type));
    message.id !== void 0 && (obj.id = message.id);
    message.data !== void 0 && (obj.data = message.data);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockAction();
    message.type = object.type ?? 0;
    message.id = object.id ?? "";
    message.data = object.data ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockAction", BlockAction);
function isObject21(value) {
  return typeof value === "object" && value !== null;
}
function isSet101(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/block_kit/v1beta/block.js
function createBaseBlock() {
  return { type: 0, size: void 0, config: void 0, actions: [] };
}
var Block = {
  $type: "devvit.ui.block_kit.v1beta.Block",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.size !== void 0) {
      BlockSize.encode(message.size, writer.uint32(18).fork()).ldelim();
    }
    if (message.config !== void 0) {
      BlockConfig.encode(message.config, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.actions) {
      BlockAction.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;
        case 2:
          message.size = BlockSize.decode(reader, reader.uint32());
          break;
        case 3:
          message.config = BlockConfig.decode(reader, reader.uint32());
          break;
        case 4:
          message.actions.push(BlockAction.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet102(object.type) ? blockTypeFromJSON(object.type) : 0,
      size: isSet102(object.size) ? BlockSize.fromJSON(object.size) : void 0,
      config: isSet102(object.config) ? BlockConfig.fromJSON(object.config) : void 0,
      actions: Array.isArray(object?.actions) ? object.actions.map((e) => BlockAction.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = blockTypeToJSON(message.type));
    message.size !== void 0 && (obj.size = message.size ? BlockSize.toJSON(message.size) : void 0);
    message.config !== void 0 && (obj.config = message.config ? BlockConfig.toJSON(message.config) : void 0);
    if (message.actions) {
      obj.actions = message.actions.map((e) => e ? BlockAction.toJSON(e) : void 0);
    } else {
      obj.actions = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlock();
    message.type = object.type ?? 0;
    message.size = object.size !== void 0 && object.size !== null ? BlockSize.fromPartial(object.size) : void 0;
    message.config = object.config !== void 0 && object.config !== null ? BlockConfig.fromPartial(object.config) : void 0;
    message.actions = object.actions?.map((e) => BlockAction.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.Block", Block);
function createBaseBlockConfig() {
  return {
    rootConfig: void 0,
    stackConfig: void 0,
    textConfig: void 0,
    buttonConfig: void 0,
    imageConfig: void 0,
    spacerConfig: void 0,
    iconConfig: void 0,
    avatarConfig: void 0,
    fullsnooConfig: void 0,
    animationConfig: void 0,
    webviewConfig: void 0
  };
}
var BlockConfig = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.rootConfig !== void 0) {
      BlockConfig_Root.encode(message.rootConfig, writer.uint32(10).fork()).ldelim();
    }
    if (message.stackConfig !== void 0) {
      BlockConfig_Stack.encode(message.stackConfig, writer.uint32(18).fork()).ldelim();
    }
    if (message.textConfig !== void 0) {
      BlockConfig_Text.encode(message.textConfig, writer.uint32(26).fork()).ldelim();
    }
    if (message.buttonConfig !== void 0) {
      BlockConfig_Button.encode(message.buttonConfig, writer.uint32(34).fork()).ldelim();
    }
    if (message.imageConfig !== void 0) {
      BlockConfig_Image.encode(message.imageConfig, writer.uint32(42).fork()).ldelim();
    }
    if (message.spacerConfig !== void 0) {
      BlockConfig_Spacer.encode(message.spacerConfig, writer.uint32(50).fork()).ldelim();
    }
    if (message.iconConfig !== void 0) {
      BlockConfig_Icon.encode(message.iconConfig, writer.uint32(58).fork()).ldelim();
    }
    if (message.avatarConfig !== void 0) {
      BlockConfig_Avatar.encode(message.avatarConfig, writer.uint32(66).fork()).ldelim();
    }
    if (message.fullsnooConfig !== void 0) {
      BlockConfig_FullSnoo.encode(message.fullsnooConfig, writer.uint32(74).fork()).ldelim();
    }
    if (message.animationConfig !== void 0) {
      BlockConfig_Animation.encode(message.animationConfig, writer.uint32(82).fork()).ldelim();
    }
    if (message.webviewConfig !== void 0) {
      BlockConfig_WebView.encode(message.webviewConfig, writer.uint32(802).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rootConfig = BlockConfig_Root.decode(reader, reader.uint32());
          break;
        case 2:
          message.stackConfig = BlockConfig_Stack.decode(reader, reader.uint32());
          break;
        case 3:
          message.textConfig = BlockConfig_Text.decode(reader, reader.uint32());
          break;
        case 4:
          message.buttonConfig = BlockConfig_Button.decode(reader, reader.uint32());
          break;
        case 5:
          message.imageConfig = BlockConfig_Image.decode(reader, reader.uint32());
          break;
        case 6:
          message.spacerConfig = BlockConfig_Spacer.decode(reader, reader.uint32());
          break;
        case 7:
          message.iconConfig = BlockConfig_Icon.decode(reader, reader.uint32());
          break;
        case 8:
          message.avatarConfig = BlockConfig_Avatar.decode(reader, reader.uint32());
          break;
        case 9:
          message.fullsnooConfig = BlockConfig_FullSnoo.decode(reader, reader.uint32());
          break;
        case 10:
          message.animationConfig = BlockConfig_Animation.decode(reader, reader.uint32());
          break;
        case 100:
          message.webviewConfig = BlockConfig_WebView.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      rootConfig: isSet102(object.rootConfig) ? BlockConfig_Root.fromJSON(object.rootConfig) : void 0,
      stackConfig: isSet102(object.stackConfig) ? BlockConfig_Stack.fromJSON(object.stackConfig) : void 0,
      textConfig: isSet102(object.textConfig) ? BlockConfig_Text.fromJSON(object.textConfig) : void 0,
      buttonConfig: isSet102(object.buttonConfig) ? BlockConfig_Button.fromJSON(object.buttonConfig) : void 0,
      imageConfig: isSet102(object.imageConfig) ? BlockConfig_Image.fromJSON(object.imageConfig) : void 0,
      spacerConfig: isSet102(object.spacerConfig) ? BlockConfig_Spacer.fromJSON(object.spacerConfig) : void 0,
      iconConfig: isSet102(object.iconConfig) ? BlockConfig_Icon.fromJSON(object.iconConfig) : void 0,
      avatarConfig: isSet102(object.avatarConfig) ? BlockConfig_Avatar.fromJSON(object.avatarConfig) : void 0,
      fullsnooConfig: isSet102(object.fullsnooConfig) ? BlockConfig_FullSnoo.fromJSON(object.fullsnooConfig) : void 0,
      animationConfig: isSet102(object.animationConfig) ? BlockConfig_Animation.fromJSON(object.animationConfig) : void 0,
      webviewConfig: isSet102(object.webviewConfig) ? BlockConfig_WebView.fromJSON(object.webviewConfig) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.rootConfig !== void 0 && (obj.rootConfig = message.rootConfig ? BlockConfig_Root.toJSON(message.rootConfig) : void 0);
    message.stackConfig !== void 0 && (obj.stackConfig = message.stackConfig ? BlockConfig_Stack.toJSON(message.stackConfig) : void 0);
    message.textConfig !== void 0 && (obj.textConfig = message.textConfig ? BlockConfig_Text.toJSON(message.textConfig) : void 0);
    message.buttonConfig !== void 0 && (obj.buttonConfig = message.buttonConfig ? BlockConfig_Button.toJSON(message.buttonConfig) : void 0);
    message.imageConfig !== void 0 && (obj.imageConfig = message.imageConfig ? BlockConfig_Image.toJSON(message.imageConfig) : void 0);
    message.spacerConfig !== void 0 && (obj.spacerConfig = message.spacerConfig ? BlockConfig_Spacer.toJSON(message.spacerConfig) : void 0);
    message.iconConfig !== void 0 && (obj.iconConfig = message.iconConfig ? BlockConfig_Icon.toJSON(message.iconConfig) : void 0);
    message.avatarConfig !== void 0 && (obj.avatarConfig = message.avatarConfig ? BlockConfig_Avatar.toJSON(message.avatarConfig) : void 0);
    message.fullsnooConfig !== void 0 && (obj.fullsnooConfig = message.fullsnooConfig ? BlockConfig_FullSnoo.toJSON(message.fullsnooConfig) : void 0);
    message.animationConfig !== void 0 && (obj.animationConfig = message.animationConfig ? BlockConfig_Animation.toJSON(message.animationConfig) : void 0);
    message.webviewConfig !== void 0 && (obj.webviewConfig = message.webviewConfig ? BlockConfig_WebView.toJSON(message.webviewConfig) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockConfig();
    message.rootConfig = object.rootConfig !== void 0 && object.rootConfig !== null ? BlockConfig_Root.fromPartial(object.rootConfig) : void 0;
    message.stackConfig = object.stackConfig !== void 0 && object.stackConfig !== null ? BlockConfig_Stack.fromPartial(object.stackConfig) : void 0;
    message.textConfig = object.textConfig !== void 0 && object.textConfig !== null ? BlockConfig_Text.fromPartial(object.textConfig) : void 0;
    message.buttonConfig = object.buttonConfig !== void 0 && object.buttonConfig !== null ? BlockConfig_Button.fromPartial(object.buttonConfig) : void 0;
    message.imageConfig = object.imageConfig !== void 0 && object.imageConfig !== null ? BlockConfig_Image.fromPartial(object.imageConfig) : void 0;
    message.spacerConfig = object.spacerConfig !== void 0 && object.spacerConfig !== null ? BlockConfig_Spacer.fromPartial(object.spacerConfig) : void 0;
    message.iconConfig = object.iconConfig !== void 0 && object.iconConfig !== null ? BlockConfig_Icon.fromPartial(object.iconConfig) : void 0;
    message.avatarConfig = object.avatarConfig !== void 0 && object.avatarConfig !== null ? BlockConfig_Avatar.fromPartial(object.avatarConfig) : void 0;
    message.fullsnooConfig = object.fullsnooConfig !== void 0 && object.fullsnooConfig !== null ? BlockConfig_FullSnoo.fromPartial(object.fullsnooConfig) : void 0;
    message.animationConfig = object.animationConfig !== void 0 && object.animationConfig !== null ? BlockConfig_Animation.fromPartial(object.animationConfig) : void 0;
    message.webviewConfig = object.webviewConfig !== void 0 && object.webviewConfig !== null ? BlockConfig_WebView.fromPartial(object.webviewConfig) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig", BlockConfig);
function createBaseBlockConfig_Root() {
  return { children: [] };
}
var BlockConfig_Root = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Root",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    for (const v of message.children) {
      Block.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Root();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.children.push(Block.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { children: Array.isArray(object?.children) ? object.children.map((e) => Block.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.children) {
      obj.children = message.children.map((e) => e ? Block.toJSON(e) : void 0);
    } else {
      obj.children = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Root();
    message.children = object.children?.map((e) => Block.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Root", BlockConfig_Root);
function createBaseBlockConfig_Stack() {
  return {
    direction: 0,
    children: [],
    reverse: void 0,
    alignment: void 0,
    padding: void 0,
    gap: void 0,
    border: void 0,
    cornerRadius: void 0,
    backgroundColor: void 0
  };
}
var BlockConfig_Stack = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Stack",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.direction !== 0) {
      writer.uint32(8).int32(message.direction);
    }
    for (const v of message.children) {
      Block.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.reverse !== void 0) {
      writer.uint32(24).bool(message.reverse);
    }
    if (message.alignment !== void 0) {
      BlockAlignment.encode(message.alignment, writer.uint32(34).fork()).ldelim();
    }
    if (message.padding !== void 0) {
      writer.uint32(40).int32(message.padding);
    }
    if (message.gap !== void 0) {
      writer.uint32(48).int32(message.gap);
    }
    if (message.border !== void 0) {
      BlockBorder.encode(message.border, writer.uint32(58).fork()).ldelim();
    }
    if (message.cornerRadius !== void 0) {
      writer.uint32(64).int32(message.cornerRadius);
    }
    if (message.backgroundColor !== void 0) {
      writer.uint32(74).string(message.backgroundColor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Stack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.direction = reader.int32();
          break;
        case 2:
          message.children.push(Block.decode(reader, reader.uint32()));
          break;
        case 3:
          message.reverse = reader.bool();
          break;
        case 4:
          message.alignment = BlockAlignment.decode(reader, reader.uint32());
          break;
        case 5:
          message.padding = reader.int32();
          break;
        case 6:
          message.gap = reader.int32();
          break;
        case 7:
          message.border = BlockBorder.decode(reader, reader.uint32());
          break;
        case 8:
          message.cornerRadius = reader.int32();
          break;
        case 9:
          message.backgroundColor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      direction: isSet102(object.direction) ? blockStackDirectionFromJSON(object.direction) : 0,
      children: Array.isArray(object?.children) ? object.children.map((e) => Block.fromJSON(e)) : [],
      reverse: isSet102(object.reverse) ? Boolean(object.reverse) : void 0,
      alignment: isSet102(object.alignment) ? BlockAlignment.fromJSON(object.alignment) : void 0,
      padding: isSet102(object.padding) ? blockPaddingFromJSON(object.padding) : void 0,
      gap: isSet102(object.gap) ? blockGapFromJSON(object.gap) : void 0,
      border: isSet102(object.border) ? BlockBorder.fromJSON(object.border) : void 0,
      cornerRadius: isSet102(object.cornerRadius) ? blockRadiusFromJSON(object.cornerRadius) : void 0,
      backgroundColor: isSet102(object.backgroundColor) ? String(object.backgroundColor) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.direction !== void 0 && (obj.direction = blockStackDirectionToJSON(message.direction));
    if (message.children) {
      obj.children = message.children.map((e) => e ? Block.toJSON(e) : void 0);
    } else {
      obj.children = [];
    }
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    message.alignment !== void 0 && (obj.alignment = message.alignment ? BlockAlignment.toJSON(message.alignment) : void 0);
    message.padding !== void 0 && (obj.padding = message.padding !== void 0 ? blockPaddingToJSON(message.padding) : void 0);
    message.gap !== void 0 && (obj.gap = message.gap !== void 0 ? blockGapToJSON(message.gap) : void 0);
    message.border !== void 0 && (obj.border = message.border ? BlockBorder.toJSON(message.border) : void 0);
    message.cornerRadius !== void 0 && (obj.cornerRadius = message.cornerRadius !== void 0 ? blockRadiusToJSON(message.cornerRadius) : void 0);
    message.backgroundColor !== void 0 && (obj.backgroundColor = message.backgroundColor);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Stack();
    message.direction = object.direction ?? 0;
    message.children = object.children?.map((e) => Block.fromPartial(e)) || [];
    message.reverse = object.reverse ?? void 0;
    message.alignment = object.alignment !== void 0 && object.alignment !== null ? BlockAlignment.fromPartial(object.alignment) : void 0;
    message.padding = object.padding ?? void 0;
    message.gap = object.gap ?? void 0;
    message.border = object.border !== void 0 && object.border !== null ? BlockBorder.fromPartial(object.border) : void 0;
    message.cornerRadius = object.cornerRadius ?? void 0;
    message.backgroundColor = object.backgroundColor ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Stack", BlockConfig_Stack);
function createBaseBlockConfig_Text() {
  return {
    text: "",
    size: void 0,
    weight: void 0,
    color: void 0,
    alignment: void 0,
    outline: void 0,
    style: void 0
  };
}
var BlockConfig_Text = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Text",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.size !== void 0) {
      writer.uint32(16).int32(message.size);
    }
    if (message.weight !== void 0) {
      writer.uint32(24).int32(message.weight);
    }
    if (message.color !== void 0) {
      writer.uint32(34).string(message.color);
    }
    if (message.alignment !== void 0) {
      BlockAlignment.encode(message.alignment, writer.uint32(42).fork()).ldelim();
    }
    if (message.outline !== void 0) {
      writer.uint32(48).int32(message.outline);
    }
    if (message.style !== void 0) {
      writer.uint32(56).int32(message.style);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Text();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.text = reader.string();
          break;
        case 2:
          message.size = reader.int32();
          break;
        case 3:
          message.weight = reader.int32();
          break;
        case 4:
          message.color = reader.string();
          break;
        case 5:
          message.alignment = BlockAlignment.decode(reader, reader.uint32());
          break;
        case 6:
          message.outline = reader.int32();
          break;
        case 7:
          message.style = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet102(object.text) ? String(object.text) : "",
      size: isSet102(object.size) ? blockTextSizeFromJSON(object.size) : void 0,
      weight: isSet102(object.weight) ? blockTextWeightFromJSON(object.weight) : void 0,
      color: isSet102(object.color) ? String(object.color) : void 0,
      alignment: isSet102(object.alignment) ? BlockAlignment.fromJSON(object.alignment) : void 0,
      outline: isSet102(object.outline) ? blockTextOutlineFromJSON(object.outline) : void 0,
      style: isSet102(object.style) ? blockTextStyleFromJSON(object.style) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.text !== void 0 && (obj.text = message.text);
    message.size !== void 0 && (obj.size = message.size !== void 0 ? blockTextSizeToJSON(message.size) : void 0);
    message.weight !== void 0 && (obj.weight = message.weight !== void 0 ? blockTextWeightToJSON(message.weight) : void 0);
    message.color !== void 0 && (obj.color = message.color);
    message.alignment !== void 0 && (obj.alignment = message.alignment ? BlockAlignment.toJSON(message.alignment) : void 0);
    message.outline !== void 0 && (obj.outline = message.outline !== void 0 ? blockTextOutlineToJSON(message.outline) : void 0);
    message.style !== void 0 && (obj.style = message.style !== void 0 ? blockTextStyleToJSON(message.style) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Text();
    message.text = object.text ?? "";
    message.size = object.size ?? void 0;
    message.weight = object.weight ?? void 0;
    message.color = object.color ?? void 0;
    message.alignment = object.alignment !== void 0 && object.alignment !== null ? BlockAlignment.fromPartial(object.alignment) : void 0;
    message.outline = object.outline ?? void 0;
    message.style = object.style ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Text", BlockConfig_Text);
function createBaseBlockConfig_Button() {
  return {
    text: void 0,
    icon: void 0,
    buttonSize: void 0,
    buttonAppearance: void 0,
    textColor: void 0,
    backgroundColor: void 0,
    disabled: void 0
  };
}
var BlockConfig_Button = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Button",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.text !== void 0) {
      writer.uint32(10).string(message.text);
    }
    if (message.icon !== void 0) {
      writer.uint32(18).string(message.icon);
    }
    if (message.buttonSize !== void 0) {
      writer.uint32(24).int32(message.buttonSize);
    }
    if (message.buttonAppearance !== void 0) {
      writer.uint32(32).int32(message.buttonAppearance);
    }
    if (message.textColor !== void 0) {
      writer.uint32(42).string(message.textColor);
    }
    if (message.backgroundColor !== void 0) {
      writer.uint32(50).string(message.backgroundColor);
    }
    if (message.disabled !== void 0) {
      writer.uint32(56).bool(message.disabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Button();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.text = reader.string();
          break;
        case 2:
          message.icon = reader.string();
          break;
        case 3:
          message.buttonSize = reader.int32();
          break;
        case 4:
          message.buttonAppearance = reader.int32();
          break;
        case 5:
          message.textColor = reader.string();
          break;
        case 6:
          message.backgroundColor = reader.string();
          break;
        case 7:
          message.disabled = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet102(object.text) ? String(object.text) : void 0,
      icon: isSet102(object.icon) ? String(object.icon) : void 0,
      buttonSize: isSet102(object.buttonSize) ? blockButtonSizeFromJSON(object.buttonSize) : void 0,
      buttonAppearance: isSet102(object.buttonAppearance) ? blockButtonAppearanceFromJSON(object.buttonAppearance) : void 0,
      textColor: isSet102(object.textColor) ? String(object.textColor) : void 0,
      backgroundColor: isSet102(object.backgroundColor) ? String(object.backgroundColor) : void 0,
      disabled: isSet102(object.disabled) ? Boolean(object.disabled) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.text !== void 0 && (obj.text = message.text);
    message.icon !== void 0 && (obj.icon = message.icon);
    message.buttonSize !== void 0 && (obj.buttonSize = message.buttonSize !== void 0 ? blockButtonSizeToJSON(message.buttonSize) : void 0);
    message.buttonAppearance !== void 0 && (obj.buttonAppearance = message.buttonAppearance !== void 0 ? blockButtonAppearanceToJSON(message.buttonAppearance) : void 0);
    message.textColor !== void 0 && (obj.textColor = message.textColor);
    message.backgroundColor !== void 0 && (obj.backgroundColor = message.backgroundColor);
    message.disabled !== void 0 && (obj.disabled = message.disabled);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Button();
    message.text = object.text ?? void 0;
    message.icon = object.icon ?? void 0;
    message.buttonSize = object.buttonSize ?? void 0;
    message.buttonAppearance = object.buttonAppearance ?? void 0;
    message.textColor = object.textColor ?? void 0;
    message.backgroundColor = object.backgroundColor ?? void 0;
    message.disabled = object.disabled ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Button", BlockConfig_Button);
function createBaseBlockConfig_Image() {
  return { url: "", width: 0, height: 0, description: void 0, resizeMode: void 0 };
}
var BlockConfig_Image = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Image",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.description !== void 0) {
      writer.uint32(34).string(message.description);
    }
    if (message.resizeMode !== void 0) {
      writer.uint32(40).int32(message.resizeMode);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Image();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.url = reader.string();
          break;
        case 2:
          message.width = reader.int32();
          break;
        case 3:
          message.height = reader.int32();
          break;
        case 4:
          message.description = reader.string();
          break;
        case 5:
          message.resizeMode = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet102(object.url) ? String(object.url) : "",
      width: isSet102(object.width) ? Number(object.width) : 0,
      height: isSet102(object.height) ? Number(object.height) : 0,
      description: isSet102(object.description) ? String(object.description) : void 0,
      resizeMode: isSet102(object.resizeMode) ? blockImageResizeModeFromJSON(object.resizeMode) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    message.width !== void 0 && (obj.width = Math.round(message.width));
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.description !== void 0 && (obj.description = message.description);
    message.resizeMode !== void 0 && (obj.resizeMode = message.resizeMode !== void 0 ? blockImageResizeModeToJSON(message.resizeMode) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Image();
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.description = object.description ?? void 0;
    message.resizeMode = object.resizeMode ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Image", BlockConfig_Image);
function createBaseBlockConfig_Spacer() {
  return { size: void 0 };
}
var BlockConfig_Spacer = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Spacer",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.size !== void 0) {
      writer.uint32(8).int32(message.size);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Spacer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.size = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { size: isSet102(object.size) ? blockSpacerSizeFromJSON(object.size) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.size !== void 0 && (obj.size = message.size !== void 0 ? blockSpacerSizeToJSON(message.size) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Spacer();
    message.size = object.size ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Spacer", BlockConfig_Spacer);
function createBaseBlockConfig_Icon() {
  return { icon: "", color: void 0, size: void 0 };
}
var BlockConfig_Icon = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Icon",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.icon !== "") {
      writer.uint32(10).string(message.icon);
    }
    if (message.color !== void 0) {
      writer.uint32(18).string(message.color);
    }
    if (message.size !== void 0) {
      writer.uint32(24).int32(message.size);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Icon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.icon = reader.string();
          break;
        case 2:
          message.color = reader.string();
          break;
        case 3:
          message.size = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      icon: isSet102(object.icon) ? String(object.icon) : "",
      color: isSet102(object.color) ? String(object.color) : void 0,
      size: isSet102(object.size) ? blockIconSizeFromJSON(object.size) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.icon !== void 0 && (obj.icon = message.icon);
    message.color !== void 0 && (obj.color = message.color);
    message.size !== void 0 && (obj.size = message.size !== void 0 ? blockIconSizeToJSON(message.size) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Icon();
    message.icon = object.icon ?? "";
    message.color = object.color ?? void 0;
    message.size = object.size ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Icon", BlockConfig_Icon);
function createBaseBlockConfig_Avatar() {
  return { thingId: "", facing: void 0, size: void 0, background: void 0 };
}
var BlockConfig_Avatar = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Avatar",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.thingId !== "") {
      writer.uint32(10).string(message.thingId);
    }
    if (message.facing !== void 0) {
      writer.uint32(16).int32(message.facing);
    }
    if (message.size !== void 0) {
      writer.uint32(24).int32(message.size);
    }
    if (message.background !== void 0) {
      writer.uint32(32).int32(message.background);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Avatar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.thingId = reader.string();
          break;
        case 2:
          message.facing = reader.int32();
          break;
        case 3:
          message.size = reader.int32();
          break;
        case 4:
          message.background = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      thingId: isSet102(object.thingId) ? String(object.thingId) : "",
      facing: isSet102(object.facing) ? blockAvatarFacingFromJSON(object.facing) : void 0,
      size: isSet102(object.size) ? blockAvatarSizeFromJSON(object.size) : void 0,
      background: isSet102(object.background) ? blockAvatarBackgroundFromJSON(object.background) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.thingId !== void 0 && (obj.thingId = message.thingId);
    message.facing !== void 0 && (obj.facing = message.facing !== void 0 ? blockAvatarFacingToJSON(message.facing) : void 0);
    message.size !== void 0 && (obj.size = message.size !== void 0 ? blockAvatarSizeToJSON(message.size) : void 0);
    message.background !== void 0 && (obj.background = message.background !== void 0 ? blockAvatarBackgroundToJSON(message.background) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Avatar();
    message.thingId = object.thingId ?? "";
    message.facing = object.facing ?? void 0;
    message.size = object.size ?? void 0;
    message.background = object.background ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Avatar", BlockConfig_Avatar);
function createBaseBlockConfig_FullSnoo() {
  return { userId: "", facing: void 0, size: void 0 };
}
var BlockConfig_FullSnoo = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.FullSnoo",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.facing !== void 0) {
      writer.uint32(16).int32(message.facing);
    }
    if (message.size !== void 0) {
      writer.uint32(24).int32(message.size);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_FullSnoo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.userId = reader.string();
          break;
        case 2:
          message.facing = reader.int32();
          break;
        case 3:
          message.size = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      userId: isSet102(object.userId) ? String(object.userId) : "",
      facing: isSet102(object.facing) ? blockAvatarFacingFromJSON(object.facing) : void 0,
      size: isSet102(object.size) ? blockFullSnooSizeFromJSON(object.size) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.userId !== void 0 && (obj.userId = message.userId);
    message.facing !== void 0 && (obj.facing = message.facing !== void 0 ? blockAvatarFacingToJSON(message.facing) : void 0);
    message.size !== void 0 && (obj.size = message.size !== void 0 ? blockFullSnooSizeToJSON(message.size) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_FullSnoo();
    message.userId = object.userId ?? "";
    message.facing = object.facing ?? void 0;
    message.size = object.size ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.FullSnoo", BlockConfig_FullSnoo);
function createBaseBlockConfig_Animation() {
  return {
    url: "",
    width: 0,
    height: 0,
    type: 0,
    loop: void 0,
    loopMode: void 0,
    autoplay: void 0,
    speed: void 0,
    direction: void 0
  };
}
var BlockConfig_Animation = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.Animation",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.loop !== void 0) {
      writer.uint32(40).bool(message.loop);
    }
    if (message.loopMode !== void 0) {
      writer.uint32(48).int32(message.loopMode);
    }
    if (message.autoplay !== void 0) {
      writer.uint32(56).bool(message.autoplay);
    }
    if (message.speed !== void 0) {
      writer.uint32(69).float(message.speed);
    }
    if (message.direction !== void 0) {
      writer.uint32(72).int32(message.direction);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_Animation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.url = reader.string();
          break;
        case 2:
          message.width = reader.int32();
          break;
        case 3:
          message.height = reader.int32();
          break;
        case 4:
          message.type = reader.int32();
          break;
        case 5:
          message.loop = reader.bool();
          break;
        case 6:
          message.loopMode = reader.int32();
          break;
        case 7:
          message.autoplay = reader.bool();
          break;
        case 8:
          message.speed = reader.float();
          break;
        case 9:
          message.direction = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet102(object.url) ? String(object.url) : "",
      width: isSet102(object.width) ? Number(object.width) : 0,
      height: isSet102(object.height) ? Number(object.height) : 0,
      type: isSet102(object.type) ? blockAnimationTypeFromJSON(object.type) : 0,
      loop: isSet102(object.loop) ? Boolean(object.loop) : void 0,
      loopMode: isSet102(object.loopMode) ? blockAnimationLoopModeFromJSON(object.loopMode) : void 0,
      autoplay: isSet102(object.autoplay) ? Boolean(object.autoplay) : void 0,
      speed: isSet102(object.speed) ? Number(object.speed) : void 0,
      direction: isSet102(object.direction) ? blockAnimationDirectionFromJSON(object.direction) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    message.width !== void 0 && (obj.width = Math.round(message.width));
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.type !== void 0 && (obj.type = blockAnimationTypeToJSON(message.type));
    message.loop !== void 0 && (obj.loop = message.loop);
    message.loopMode !== void 0 && (obj.loopMode = message.loopMode !== void 0 ? blockAnimationLoopModeToJSON(message.loopMode) : void 0);
    message.autoplay !== void 0 && (obj.autoplay = message.autoplay);
    message.speed !== void 0 && (obj.speed = message.speed);
    message.direction !== void 0 && (obj.direction = message.direction !== void 0 ? blockAnimationDirectionToJSON(message.direction) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_Animation();
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.type = object.type ?? 0;
    message.loop = object.loop ?? void 0;
    message.loopMode = object.loopMode ?? void 0;
    message.autoplay = object.autoplay ?? void 0;
    message.speed = object.speed ?? void 0;
    message.direction = object.direction ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.Animation", BlockConfig_Animation);
function createBaseBlockConfig_WebView() {
  return { url: "" };
}
var BlockConfig_WebView = {
  $type: "devvit.ui.block_kit.v1beta.BlockConfig.WebView",
  encode(message, writer = import_minimal121.default.Writer.create()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal121.default.Reader ? input : new import_minimal121.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfig_WebView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.url = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { url: isSet102(object.url) ? String(object.url) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockConfig_WebView();
    message.url = object.url ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockConfig.WebView", BlockConfig_WebView);
function isSet102(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/ui/block_kit/v1beta/rendering.js
function createBaseBlockRenderRequest() {
  return { type: 0, id: void 0, data: void 0 };
}
var BlockRenderRequest = {
  $type: "devvit.ui.block_kit.v1beta.BlockRenderRequest",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== void 0) {
      writer.uint32(18).string(message.id);
    }
    if (message.data !== void 0) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : new import_minimal122.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockRenderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet103(object.type) ? blockRenderEventTypeFromJSON(object.type) : 0,
      id: isSet103(object.id) ? String(object.id) : void 0,
      data: isObject22(object.data) ? object.data : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = blockRenderEventTypeToJSON(message.type));
    message.id !== void 0 && (obj.id = message.id);
    message.data !== void 0 && (obj.data = message.data);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockRenderRequest();
    message.type = object.type ?? 0;
    message.id = object.id ?? void 0;
    message.data = object.data ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockRenderRequest", BlockRenderRequest);
function createBaseBlockRenderResponse() {
  return { ui: void 0 };
}
var BlockRenderResponse = {
  $type: "devvit.ui.block_kit.v1beta.BlockRenderResponse",
  encode(message, writer = import_minimal122.default.Writer.create()) {
    if (message.ui !== void 0) {
      Block.encode(message.ui, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal122.default.Reader ? input : new import_minimal122.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockRenderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ui = Block.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { ui: isSet103(object.ui) ? Block.fromJSON(object.ui) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.ui !== void 0 && (obj.ui = message.ui ? Block.toJSON(message.ui) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBlockRenderResponse();
    message.ui = object.ui !== void 0 && object.ui !== null ? Block.fromPartial(object.ui) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockRenderResponse", BlockRenderResponse);
function isObject22(value) {
  return typeof value === "object" && value !== null;
}
function isSet103(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/custom_post/v1alpha/custom_post.js
function createBaseRenderPostRequest() {
  return { state: void 0, blocks: void 0 };
}
var RenderPostRequest = {
  $type: "devvit.reddit.custom_post.v1alpha.RenderPostRequest",
  encode(message, writer = import_minimal123.default.Writer.create()) {
    if (message.state !== void 0) {
      Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
    }
    if (message.blocks !== void 0) {
      BlockRenderRequest.encode(message.blocks, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal123.default.Reader ? input : new import_minimal123.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRenderPostRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        case 2:
          message.blocks = BlockRenderRequest.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      state: isObject23(object.state) ? object.state : void 0,
      blocks: isSet104(object.blocks) ? BlockRenderRequest.fromJSON(object.blocks) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.state !== void 0 && (obj.state = message.state);
    message.blocks !== void 0 && (obj.blocks = message.blocks ? BlockRenderRequest.toJSON(message.blocks) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRenderPostRequest();
    message.state = object.state ?? void 0;
    message.blocks = object.blocks !== void 0 && object.blocks !== null ? BlockRenderRequest.fromPartial(object.blocks) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.custom_post.v1alpha.RenderPostRequest", RenderPostRequest);
function createBaseRenderPostResponse() {
  return { state: void 0, effects: [], blocks: void 0 };
}
var RenderPostResponse = {
  $type: "devvit.reddit.custom_post.v1alpha.RenderPostResponse",
  encode(message, writer = import_minimal123.default.Writer.create()) {
    if (message.state !== void 0) {
      Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.effects) {
      Effect.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.blocks !== void 0) {
      BlockRenderResponse.encode(message.blocks, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal123.default.Reader ? input : new import_minimal123.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRenderPostResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        case 2:
          message.effects.push(Effect.decode(reader, reader.uint32()));
          break;
        case 4:
          message.blocks = BlockRenderResponse.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      state: isObject23(object.state) ? object.state : void 0,
      effects: Array.isArray(object?.effects) ? object.effects.map((e) => Effect.fromJSON(e)) : [],
      blocks: isSet104(object.blocks) ? BlockRenderResponse.fromJSON(object.blocks) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.state !== void 0 && (obj.state = message.state);
    if (message.effects) {
      obj.effects = message.effects.map((e) => e ? Effect.toJSON(e) : void 0);
    } else {
      obj.effects = [];
    }
    message.blocks !== void 0 && (obj.blocks = message.blocks ? BlockRenderResponse.toJSON(message.blocks) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseRenderPostResponse();
    message.state = object.state ?? void 0;
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    message.blocks = object.blocks !== void 0 && object.blocks !== null ? BlockRenderResponse.fromPartial(object.blocks) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.custom_post.v1alpha.RenderPostResponse", RenderPostResponse);
var CustomPostDefinition = {
  name: "CustomPost",
  fullName: "devvit.reddit.custom_post.v1alpha.CustomPost",
  methods: {
    /** Render a custom post. */
    renderPost: {
      name: "RenderPost",
      requestType: RenderPostRequest,
      requestStream: false,
      responseType: RenderPostResponse,
      responseStream: false,
      options: {}
    }
  }
};
function isObject23(value) {
  return typeof value === "object" && value !== null;
}
function isSet104(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/reddit/post_guidance/v1alpha/post_guidance.js
var import_minimal124 = __toESM(require_minimal2(), 1);
var DiscussionType;
(function(DiscussionType2) {
  DiscussionType2[DiscussionType2["NULL_VALUE"] = 0] = "NULL_VALUE";
  DiscussionType2[DiscussionType2["CHAT"] = 1] = "CHAT";
  DiscussionType2[DiscussionType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DiscussionType || (DiscussionType = {}));
function discussionTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "NULL_VALUE":
      return DiscussionType.NULL_VALUE;
    case 1:
    case "CHAT":
      return DiscussionType.CHAT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DiscussionType.UNRECOGNIZED;
  }
}
function discussionTypeToJSON(object) {
  switch (object) {
    case DiscussionType.NULL_VALUE:
      return 0;
    case DiscussionType.CHAT:
      return 1;
    case DiscussionType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var PostType;
(function(PostType2) {
  PostType2[PostType2["UNKNOWN"] = 0] = "UNKNOWN";
  PostType2[PostType2["LINK"] = 1] = "LINK";
  PostType2[PostType2["TEXT"] = 2] = "TEXT";
  PostType2[PostType2["LINK_TEXT"] = 3] = "LINK_TEXT";
  PostType2[PostType2["MEDIA_UPLOAD"] = 4] = "MEDIA_UPLOAD";
  PostType2[PostType2["POLL"] = 5] = "POLL";
  PostType2[PostType2["CROSSPOST"] = 6] = "CROSSPOST";
  PostType2[PostType2["GALLERY"] = 7] = "GALLERY";
  PostType2[PostType2["IMAGE"] = 9] = "IMAGE";
  PostType2[PostType2["VIDEO"] = 10] = "VIDEO";
  PostType2[PostType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PostType || (PostType = {}));
function postTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return PostType.UNKNOWN;
    case 1:
    case "LINK":
      return PostType.LINK;
    case 2:
    case "TEXT":
      return PostType.TEXT;
    case 3:
    case "LINK_TEXT":
      return PostType.LINK_TEXT;
    case 4:
    case "MEDIA_UPLOAD":
      return PostType.MEDIA_UPLOAD;
    case 5:
    case "POLL":
      return PostType.POLL;
    case 6:
    case "CROSSPOST":
      return PostType.CROSSPOST;
    case 7:
    case "GALLERY":
      return PostType.GALLERY;
    case 9:
    case "IMAGE":
      return PostType.IMAGE;
    case 10:
    case "VIDEO":
      return PostType.VIDEO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PostType.UNRECOGNIZED;
  }
}
function postTypeToJSON(object) {
  switch (object) {
    case PostType.UNKNOWN:
      return 0;
    case PostType.LINK:
      return 1;
    case PostType.TEXT:
      return 2;
    case PostType.LINK_TEXT:
      return 3;
    case PostType.MEDIA_UPLOAD:
      return 4;
    case PostType.POLL:
      return 5;
    case PostType.CROSSPOST:
      return 6;
    case PostType.GALLERY:
      return 7;
    case PostType.IMAGE:
      return 9;
    case PostType.VIDEO:
      return 10;
    case PostType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var MediaType;
(function(MediaType2) {
  MediaType2[MediaType2["MEDIA_UNKNOWN"] = 0] = "MEDIA_UNKNOWN";
  MediaType2[MediaType2["MEDIA_IMAGE"] = 1] = "MEDIA_IMAGE";
  MediaType2[MediaType2["MEDIA_VIDEO"] = 2] = "MEDIA_VIDEO";
  MediaType2[MediaType2["MEDIA_VIDEOGIF"] = 3] = "MEDIA_VIDEOGIF";
  MediaType2[MediaType2["MEDIA_STREAMING"] = 4] = "MEDIA_STREAMING";
  MediaType2[MediaType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MediaType || (MediaType = {}));
function mediaTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "MEDIA_UNKNOWN":
      return MediaType.MEDIA_UNKNOWN;
    case 1:
    case "MEDIA_IMAGE":
      return MediaType.MEDIA_IMAGE;
    case 2:
    case "MEDIA_VIDEO":
      return MediaType.MEDIA_VIDEO;
    case 3:
    case "MEDIA_VIDEOGIF":
      return MediaType.MEDIA_VIDEOGIF;
    case 4:
    case "MEDIA_STREAMING":
      return MediaType.MEDIA_STREAMING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MediaType.UNRECOGNIZED;
  }
}
function mediaTypeToJSON(object) {
  switch (object) {
    case MediaType.MEDIA_UNKNOWN:
      return 0;
    case MediaType.MEDIA_IMAGE:
      return 1;
    case MediaType.MEDIA_VIDEO:
      return 2;
    case MediaType.MEDIA_VIDEOGIF:
      return 3;
    case MediaType.MEDIA_STREAMING:
      return 4;
    case MediaType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBasePostContent() {
  return {
    url: void 0,
    body: void 0,
    isRtjson: void 0,
    crosspostLinkId: void 0,
    mediaType: 0,
    isUserUpload: void 0,
    galleryItems: []
  };
}
var PostContent = {
  $type: "devvit.reddit.post_guidance.v1alpha.PostContent",
  encode(message, writer = import_minimal124.default.Writer.create()) {
    if (message.url !== void 0) {
      StringValue.encode({ value: message.url }, writer.uint32(10).fork()).ldelim();
    }
    if (message.body !== void 0) {
      StringValue.encode({ value: message.body }, writer.uint32(18).fork()).ldelim();
    }
    if (message.isRtjson !== void 0) {
      BoolValue.encode({ value: message.isRtjson }, writer.uint32(26).fork()).ldelim();
    }
    if (message.crosspostLinkId !== void 0) {
      StringValue.encode({ value: message.crosspostLinkId }, writer.uint32(34).fork()).ldelim();
    }
    if (message.mediaType !== 0) {
      writer.uint32(40).int32(message.mediaType);
    }
    if (message.isUserUpload !== void 0) {
      BoolValue.encode({ value: message.isUserUpload }, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.galleryItems) {
      GalleryItem.encode(v, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal124.default.Reader ? input : new import_minimal124.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.body = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.isRtjson = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.crosspostLinkId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.mediaType = reader.int32();
          break;
        case 6:
          message.isUserUpload = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.galleryItems.push(GalleryItem.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet105(object.url) ? String(object.url) : void 0,
      body: isSet105(object.body) ? String(object.body) : void 0,
      isRtjson: isSet105(object.isRtjson) ? Boolean(object.isRtjson) : void 0,
      crosspostLinkId: isSet105(object.crosspostLinkId) ? String(object.crosspostLinkId) : void 0,
      mediaType: isSet105(object.mediaType) ? mediaTypeFromJSON(object.mediaType) : 0,
      isUserUpload: isSet105(object.isUserUpload) ? Boolean(object.isUserUpload) : void 0,
      galleryItems: Array.isArray(object?.galleryItems) ? object.galleryItems.map((e) => GalleryItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    message.body !== void 0 && (obj.body = message.body);
    message.isRtjson !== void 0 && (obj.isRtjson = message.isRtjson);
    message.crosspostLinkId !== void 0 && (obj.crosspostLinkId = message.crosspostLinkId);
    message.mediaType !== void 0 && (obj.mediaType = mediaTypeToJSON(message.mediaType));
    message.isUserUpload !== void 0 && (obj.isUserUpload = message.isUserUpload);
    if (message.galleryItems) {
      obj.galleryItems = message.galleryItems.map((e) => e ? GalleryItem.toJSON(e) : void 0);
    } else {
      obj.galleryItems = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBasePostContent();
    message.url = object.url ?? void 0;
    message.body = object.body ?? void 0;
    message.isRtjson = object.isRtjson ?? void 0;
    message.crosspostLinkId = object.crosspostLinkId ?? void 0;
    message.mediaType = object.mediaType ?? 0;
    message.isUserUpload = object.isUserUpload ?? void 0;
    message.galleryItems = object.galleryItems?.map((e) => GalleryItem.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.PostContent", PostContent);
function createBasePostMetadata() {
  return {
    title: void 0,
    subredditId: void 0,
    userId: void 0,
    postType: 0,
    isLocked: void 0,
    isNsfw: void 0,
    isOriginalContent: void 0,
    isReceivingReplies: void 0,
    isSpoiler: void 0,
    isUnlisted: void 0,
    flairId: void 0,
    flairText: void 0,
    eventStart: void 0,
    eventEnd: void 0,
    discussionType: 0,
    collectionId: void 0,
    ip: void 0,
    isPromoted: void 0
  };
}
var PostMetadata = {
  $type: "devvit.reddit.post_guidance.v1alpha.PostMetadata",
  encode(message, writer = import_minimal124.default.Writer.create()) {
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(10).fork()).ldelim();
    }
    if (message.subredditId !== void 0) {
      StringValue.encode({ value: message.subredditId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.userId !== void 0) {
      StringValue.encode({ value: message.userId }, writer.uint32(26).fork()).ldelim();
    }
    if (message.postType !== 0) {
      writer.uint32(32).int32(message.postType);
    }
    if (message.isLocked !== void 0) {
      BoolValue.encode({ value: message.isLocked }, writer.uint32(42).fork()).ldelim();
    }
    if (message.isNsfw !== void 0) {
      BoolValue.encode({ value: message.isNsfw }, writer.uint32(50).fork()).ldelim();
    }
    if (message.isOriginalContent !== void 0) {
      BoolValue.encode({ value: message.isOriginalContent }, writer.uint32(58).fork()).ldelim();
    }
    if (message.isReceivingReplies !== void 0) {
      BoolValue.encode({ value: message.isReceivingReplies }, writer.uint32(66).fork()).ldelim();
    }
    if (message.isSpoiler !== void 0) {
      BoolValue.encode({ value: message.isSpoiler }, writer.uint32(74).fork()).ldelim();
    }
    if (message.isUnlisted !== void 0) {
      BoolValue.encode({ value: message.isUnlisted }, writer.uint32(82).fork()).ldelim();
    }
    if (message.flairId !== void 0) {
      StringValue.encode({ value: message.flairId }, writer.uint32(90).fork()).ldelim();
    }
    if (message.flairText !== void 0) {
      StringValue.encode({ value: message.flairText }, writer.uint32(98).fork()).ldelim();
    }
    if (message.eventStart !== void 0) {
      Int64Value.encode({ value: message.eventStart }, writer.uint32(106).fork()).ldelim();
    }
    if (message.eventEnd !== void 0) {
      Int64Value.encode({ value: message.eventEnd }, writer.uint32(114).fork()).ldelim();
    }
    if (message.discussionType !== 0) {
      writer.uint32(120).int32(message.discussionType);
    }
    if (message.collectionId !== void 0) {
      StringValue.encode({ value: message.collectionId }, writer.uint32(130).fork()).ldelim();
    }
    if (message.ip !== void 0) {
      StringValue.encode({ value: message.ip }, writer.uint32(138).fork()).ldelim();
    }
    if (message.isPromoted !== void 0) {
      BoolValue.encode({ value: message.isPromoted }, writer.uint32(146).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal124.default.Reader ? input : new import_minimal124.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePostMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.subredditId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.userId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.postType = reader.int32();
          break;
        case 5:
          message.isLocked = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.isNsfw = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.isOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.isReceivingReplies = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.isSpoiler = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.isUnlisted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 11:
          message.flairId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 12:
          message.flairText = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 13:
          message.eventStart = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 14:
          message.eventEnd = Int64Value.decode(reader, reader.uint32()).value;
          break;
        case 15:
          message.discussionType = reader.int32();
          break;
        case 16:
          message.collectionId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 17:
          message.ip = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 18:
          message.isPromoted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet105(object.title) ? String(object.title) : void 0,
      subredditId: isSet105(object.subredditId) ? String(object.subredditId) : void 0,
      userId: isSet105(object.userId) ? String(object.userId) : void 0,
      postType: isSet105(object.postType) ? postTypeFromJSON(object.postType) : 0,
      isLocked: isSet105(object.isLocked) ? Boolean(object.isLocked) : void 0,
      isNsfw: isSet105(object.isNsfw) ? Boolean(object.isNsfw) : void 0,
      isOriginalContent: isSet105(object.isOriginalContent) ? Boolean(object.isOriginalContent) : void 0,
      isReceivingReplies: isSet105(object.isReceivingReplies) ? Boolean(object.isReceivingReplies) : void 0,
      isSpoiler: isSet105(object.isSpoiler) ? Boolean(object.isSpoiler) : void 0,
      isUnlisted: isSet105(object.isUnlisted) ? Boolean(object.isUnlisted) : void 0,
      flairId: isSet105(object.flairId) ? String(object.flairId) : void 0,
      flairText: isSet105(object.flairText) ? String(object.flairText) : void 0,
      eventStart: isSet105(object.eventStart) ? Number(object.eventStart) : void 0,
      eventEnd: isSet105(object.eventEnd) ? Number(object.eventEnd) : void 0,
      discussionType: isSet105(object.discussionType) ? discussionTypeFromJSON(object.discussionType) : 0,
      collectionId: isSet105(object.collectionId) ? String(object.collectionId) : void 0,
      ip: isSet105(object.ip) ? String(object.ip) : void 0,
      isPromoted: isSet105(object.isPromoted) ? Boolean(object.isPromoted) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.subredditId !== void 0 && (obj.subredditId = message.subredditId);
    message.userId !== void 0 && (obj.userId = message.userId);
    message.postType !== void 0 && (obj.postType = postTypeToJSON(message.postType));
    message.isLocked !== void 0 && (obj.isLocked = message.isLocked);
    message.isNsfw !== void 0 && (obj.isNsfw = message.isNsfw);
    message.isOriginalContent !== void 0 && (obj.isOriginalContent = message.isOriginalContent);
    message.isReceivingReplies !== void 0 && (obj.isReceivingReplies = message.isReceivingReplies);
    message.isSpoiler !== void 0 && (obj.isSpoiler = message.isSpoiler);
    message.isUnlisted !== void 0 && (obj.isUnlisted = message.isUnlisted);
    message.flairId !== void 0 && (obj.flairId = message.flairId);
    message.flairText !== void 0 && (obj.flairText = message.flairText);
    message.eventStart !== void 0 && (obj.eventStart = message.eventStart);
    message.eventEnd !== void 0 && (obj.eventEnd = message.eventEnd);
    message.discussionType !== void 0 && (obj.discussionType = discussionTypeToJSON(message.discussionType));
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.ip !== void 0 && (obj.ip = message.ip);
    message.isPromoted !== void 0 && (obj.isPromoted = message.isPromoted);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePostMetadata();
    message.title = object.title ?? void 0;
    message.subredditId = object.subredditId ?? void 0;
    message.userId = object.userId ?? void 0;
    message.postType = object.postType ?? 0;
    message.isLocked = object.isLocked ?? void 0;
    message.isNsfw = object.isNsfw ?? void 0;
    message.isOriginalContent = object.isOriginalContent ?? void 0;
    message.isReceivingReplies = object.isReceivingReplies ?? void 0;
    message.isSpoiler = object.isSpoiler ?? void 0;
    message.isUnlisted = object.isUnlisted ?? void 0;
    message.flairId = object.flairId ?? void 0;
    message.flairText = object.flairText ?? void 0;
    message.eventStart = object.eventStart ?? void 0;
    message.eventEnd = object.eventEnd ?? void 0;
    message.discussionType = object.discussionType ?? 0;
    message.collectionId = object.collectionId ?? void 0;
    message.ip = object.ip ?? void 0;
    message.isPromoted = object.isPromoted ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.PostMetadata", PostMetadata);
function createBaseGalleryItem() {
  return {
    id: void 0,
    mediaId: void 0,
    caption: void 0,
    outboundUrl: void 0,
    isDeleted: void 0,
    callToAction: void 0,
    displayUrl: void 0,
    product: void 0
  };
}
var GalleryItem = {
  $type: "devvit.reddit.post_guidance.v1alpha.GalleryItem",
  encode(message, writer = import_minimal124.default.Writer.create()) {
    if (message.id !== void 0) {
      StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
    }
    if (message.mediaId !== void 0) {
      StringValue.encode({ value: message.mediaId }, writer.uint32(18).fork()).ldelim();
    }
    if (message.caption !== void 0) {
      StringValue.encode({ value: message.caption }, writer.uint32(26).fork()).ldelim();
    }
    if (message.outboundUrl !== void 0) {
      StringValue.encode({ value: message.outboundUrl }, writer.uint32(34).fork()).ldelim();
    }
    if (message.isDeleted !== void 0) {
      BoolValue.encode({ value: message.isDeleted }, writer.uint32(42).fork()).ldelim();
    }
    if (message.callToAction !== void 0) {
      StringValue.encode({ value: message.callToAction }, writer.uint32(50).fork()).ldelim();
    }
    if (message.displayUrl !== void 0) {
      StringValue.encode({ value: message.displayUrl }, writer.uint32(58).fork()).ldelim();
    }
    if (message.product !== void 0) {
      Product.encode(message.product, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal124.default.Reader ? input : new import_minimal124.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGalleryItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.mediaId = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.caption = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.outboundUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.isDeleted = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.callToAction = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 7:
          message.displayUrl = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.product = Product.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet105(object.id) ? String(object.id) : void 0,
      mediaId: isSet105(object.mediaId) ? String(object.mediaId) : void 0,
      caption: isSet105(object.caption) ? String(object.caption) : void 0,
      outboundUrl: isSet105(object.outboundUrl) ? String(object.outboundUrl) : void 0,
      isDeleted: isSet105(object.isDeleted) ? Boolean(object.isDeleted) : void 0,
      callToAction: isSet105(object.callToAction) ? String(object.callToAction) : void 0,
      displayUrl: isSet105(object.displayUrl) ? String(object.displayUrl) : void 0,
      product: isSet105(object.product) ? Product.fromJSON(object.product) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.mediaId !== void 0 && (obj.mediaId = message.mediaId);
    message.caption !== void 0 && (obj.caption = message.caption);
    message.outboundUrl !== void 0 && (obj.outboundUrl = message.outboundUrl);
    message.isDeleted !== void 0 && (obj.isDeleted = message.isDeleted);
    message.callToAction !== void 0 && (obj.callToAction = message.callToAction);
    message.displayUrl !== void 0 && (obj.displayUrl = message.displayUrl);
    message.product !== void 0 && (obj.product = message.product ? Product.toJSON(message.product) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGalleryItem();
    message.id = object.id ?? void 0;
    message.mediaId = object.mediaId ?? void 0;
    message.caption = object.caption ?? void 0;
    message.outboundUrl = object.outboundUrl ?? void 0;
    message.isDeleted = object.isDeleted ?? void 0;
    message.callToAction = object.callToAction ?? void 0;
    message.displayUrl = object.displayUrl ?? void 0;
    message.product = object.product !== void 0 && object.product !== null ? Product.fromPartial(object.product) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.GalleryItem", GalleryItem);
function createBaseProduct() {
  return { title: void 0, price: void 0, description: void 0 };
}
var Product = {
  $type: "devvit.reddit.post_guidance.v1alpha.Product",
  encode(message, writer = import_minimal124.default.Writer.create()) {
    if (message.title !== void 0) {
      StringValue.encode({ value: message.title }, writer.uint32(10).fork()).ldelim();
    }
    if (message.price !== void 0) {
      StringValue.encode({ value: message.price }, writer.uint32(18).fork()).ldelim();
    }
    if (message.description !== void 0) {
      StringValue.encode({ value: message.description }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal124.default.Reader ? input : new import_minimal124.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.price = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet105(object.title) ? String(object.title) : void 0,
      price: isSet105(object.price) ? String(object.price) : void 0,
      description: isSet105(object.description) ? String(object.description) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.title !== void 0 && (obj.title = message.title);
    message.price !== void 0 && (obj.price = message.price);
    message.description !== void 0 && (obj.description = message.description);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseProduct();
    message.title = object.title ?? void 0;
    message.price = object.price ?? void 0;
    message.description = object.description ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.Product", Product);
function createBaseValidatePostRequirementsRequest() {
  return { postContent: void 0, postMetadata: void 0 };
}
var ValidatePostRequirementsRequest = {
  $type: "devvit.reddit.post_guidance.v1alpha.ValidatePostRequirementsRequest",
  encode(message, writer = import_minimal124.default.Writer.create()) {
    if (message.postContent !== void 0) {
      PostContent.encode(message.postContent, writer.uint32(10).fork()).ldelim();
    }
    if (message.postMetadata !== void 0) {
      PostMetadata.encode(message.postMetadata, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal124.default.Reader ? input : new import_minimal124.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidatePostRequirementsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.postContent = PostContent.decode(reader, reader.uint32());
          break;
        case 2:
          message.postMetadata = PostMetadata.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      postContent: isSet105(object.postContent) ? PostContent.fromJSON(object.postContent) : void 0,
      postMetadata: isSet105(object.postMetadata) ? PostMetadata.fromJSON(object.postMetadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.postContent !== void 0 && (obj.postContent = message.postContent ? PostContent.toJSON(message.postContent) : void 0);
    message.postMetadata !== void 0 && (obj.postMetadata = message.postMetadata ? PostMetadata.toJSON(message.postMetadata) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseValidatePostRequirementsRequest();
    message.postContent = object.postContent !== void 0 && object.postContent !== null ? PostContent.fromPartial(object.postContent) : void 0;
    message.postMetadata = object.postMetadata !== void 0 && object.postMetadata !== null ? PostMetadata.fromPartial(object.postMetadata) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.ValidatePostRequirementsRequest", ValidatePostRequirementsRequest);
function createBaseValidationError() {
  return { reason: void 0, field: void 0, shortName: void 0 };
}
var ValidationError = {
  $type: "devvit.reddit.post_guidance.v1alpha.ValidationError",
  encode(message, writer = import_minimal124.default.Writer.create()) {
    if (message.reason !== void 0) {
      StringValue.encode({ value: message.reason }, writer.uint32(10).fork()).ldelim();
    }
    if (message.field !== void 0) {
      StringValue.encode({ value: message.field }, writer.uint32(18).fork()).ldelim();
    }
    if (message.shortName !== void 0) {
      StringValue.encode({ value: message.shortName }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal124.default.Reader ? input : new import_minimal124.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.reason = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.field = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.shortName = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      reason: isSet105(object.reason) ? String(object.reason) : void 0,
      field: isSet105(object.field) ? String(object.field) : void 0,
      shortName: isSet105(object.shortName) ? String(object.shortName) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.reason !== void 0 && (obj.reason = message.reason);
    message.field !== void 0 && (obj.field = message.field);
    message.shortName !== void 0 && (obj.shortName = message.shortName);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseValidationError();
    message.reason = object.reason ?? void 0;
    message.field = object.field ?? void 0;
    message.shortName = object.shortName ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.ValidationError", ValidationError);
function createBaseValidatePostRequirementsResponse() {
  return { errors: [] };
}
var ValidatePostRequirementsResponse = {
  $type: "devvit.reddit.post_guidance.v1alpha.ValidatePostRequirementsResponse",
  encode(message, writer = import_minimal124.default.Writer.create()) {
    for (const v of message.errors) {
      ValidationError.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal124.default.Reader ? input : new import_minimal124.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidatePostRequirementsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.errors.push(ValidationError.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { errors: Array.isArray(object?.errors) ? object.errors.map((e) => ValidationError.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.errors) {
      obj.errors = message.errors.map((e) => e ? ValidationError.toJSON(e) : void 0);
    } else {
      obj.errors = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseValidatePostRequirementsResponse();
    message.errors = object.errors?.map((e) => ValidationError.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.reddit.post_guidance.v1alpha.ValidatePostRequirementsResponse", ValidatePostRequirementsResponse);
function isSet105(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/runtime/actor/bootstrap.js
var import_minimal125 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/runtime/actor/echo.js
var import_minimal126 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/runtime/actor/runtime.js
var import_minimal127 = __toESM(require_minimal2(), 1);
function createBaseWorkerQuery() {
  return { hostname: "" };
}
var WorkerQuery = {
  $type: "devvit.runtime.actor.WorkerQuery",
  encode(message, writer = import_minimal127.default.Writer.create()) {
    if (message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal127.default.Reader ? input : new import_minimal127.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWorkerQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hostname = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { hostname: isSet106(object.hostname) ? String(object.hostname) : "" };
  },
  toJSON(message) {
    const obj = {};
    message.hostname !== void 0 && (obj.hostname = message.hostname);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseWorkerQuery();
    message.hostname = object.hostname ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.actor.WorkerQuery", WorkerQuery);
function isSet106(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/runtime/actor/supervisor.js
var import_minimal129 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/runtime/envelope.js
var import_minimal128 = __toESM(require_minimal2(), 1);
function createBaseEnvelope() {
  return {
    id: "",
    src: "",
    dst: "",
    method: "",
    streamId: "",
    traceId: "",
    success: false,
    message: void 0,
    request: false,
    complete: false,
    metadata: {}
  };
}
var Envelope = {
  $type: "devvit.runtime.Envelope",
  encode(message, writer = import_minimal128.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(90).string(message.id);
    }
    if (message.src !== "") {
      writer.uint32(10).string(message.src);
    }
    if (message.dst !== "") {
      writer.uint32(18).string(message.dst);
    }
    if (message.method !== "") {
      writer.uint32(26).string(message.method);
    }
    if (message.streamId !== "") {
      writer.uint32(34).string(message.streamId);
    }
    if (message.traceId !== "") {
      writer.uint32(82).string(message.traceId);
    }
    if (message.success === true) {
      writer.uint32(40).bool(message.success);
    }
    if (message.message !== void 0) {
      Value.encode(Value.wrap(message.message), writer.uint32(50).fork()).ldelim();
    }
    if (message.request === true) {
      writer.uint32(56).bool(message.request);
    }
    if (message.complete === true) {
      writer.uint32(64).bool(message.complete);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Envelope_MetadataEntry.encode({ key, value }, writer.uint32(74).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal128.default.Reader ? input : new import_minimal128.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11:
          message.id = reader.string();
          break;
        case 1:
          message.src = reader.string();
          break;
        case 2:
          message.dst = reader.string();
          break;
        case 3:
          message.method = reader.string();
          break;
        case 4:
          message.streamId = reader.string();
          break;
        case 10:
          message.traceId = reader.string();
          break;
        case 5:
          message.success = reader.bool();
          break;
        case 6:
          message.message = Value.unwrap(Value.decode(reader, reader.uint32()));
          break;
        case 7:
          message.request = reader.bool();
          break;
        case 8:
          message.complete = reader.bool();
          break;
        case 9:
          const entry9 = Envelope_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== void 0) {
            message.metadata[entry9.key] = entry9.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet107(object.id) ? String(object.id) : "",
      src: isSet107(object.src) ? String(object.src) : "",
      dst: isSet107(object.dst) ? String(object.dst) : "",
      method: isSet107(object.method) ? String(object.method) : "",
      streamId: isSet107(object.streamId) ? String(object.streamId) : "",
      traceId: isSet107(object.traceId) ? String(object.traceId) : "",
      success: isSet107(object.success) ? Boolean(object.success) : false,
      message: isSet107(object?.message) ? object.message : void 0,
      request: isSet107(object.request) ? Boolean(object.request) : false,
      complete: isSet107(object.complete) ? Boolean(object.complete) : false,
      metadata: isObject24(object.metadata) ? Object.entries(object.metadata).reduce((acc, [key, value]) => {
        acc[key] = Strings.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.src !== void 0 && (obj.src = message.src);
    message.dst !== void 0 && (obj.dst = message.dst);
    message.method !== void 0 && (obj.method = message.method);
    message.streamId !== void 0 && (obj.streamId = message.streamId);
    message.traceId !== void 0 && (obj.traceId = message.traceId);
    message.success !== void 0 && (obj.success = message.success);
    message.message !== void 0 && (obj.message = message.message);
    message.request !== void 0 && (obj.request = message.request);
    message.complete !== void 0 && (obj.complete = message.complete);
    obj.metadata = {};
    if (message.metadata) {
      Object.entries(message.metadata).forEach(([k, v]) => {
        obj.metadata[k] = Strings.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEnvelope();
    message.id = object.id ?? "";
    message.src = object.src ?? "";
    message.dst = object.dst ?? "";
    message.method = object.method ?? "";
    message.streamId = object.streamId ?? "";
    message.traceId = object.traceId ?? "";
    message.success = object.success ?? false;
    message.message = object.message ?? void 0;
    message.request = object.request ?? false;
    message.complete = object.complete ?? false;
    message.metadata = Object.entries(object.metadata ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = Strings.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.Envelope", Envelope);
function createBaseEnvelope_MetadataEntry() {
  return { key: "", value: void 0 };
}
var Envelope_MetadataEntry = {
  $type: "devvit.runtime.Envelope.MetadataEntry",
  encode(message, writer = import_minimal128.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Strings.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal128.default.Reader ? input : new import_minimal128.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvelope_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Strings.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet107(object.key) ? String(object.key) : "",
      value: isSet107(object.value) ? Strings.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value ? Strings.toJSON(message.value) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEnvelope_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? Strings.fromPartial(object.value) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.Envelope.MetadataEntry", Envelope_MetadataEntry);
function isObject24(value) {
  return typeof value === "object" && value !== null;
}
function isSet107(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/runtime/actor/supervisor.js
function createBaseUnloadRequest() {
  return { force: false, hostname: "" };
}
var UnloadRequest = {
  $type: "devvit.runtime.actor.UnloadRequest",
  encode(message, writer = import_minimal129.default.Writer.create()) {
    if (message.force === true) {
      writer.uint32(8).bool(message.force);
    }
    if (message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal129.default.Reader ? input : new import_minimal129.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnloadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.force = reader.bool();
          break;
        case 2:
          message.hostname = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      force: isSet108(object.force) ? Boolean(object.force) : false,
      hostname: isSet108(object.hostname) ? String(object.hostname) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.force !== void 0 && (obj.force = message.force);
    message.hostname !== void 0 && (obj.hostname = message.hostname);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUnloadRequest();
    message.force = object.force ?? false;
    message.hostname = object.hostname ?? "";
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.actor.UnloadRequest", UnloadRequest);
var SupervisorDefinition = {
  name: "Supervisor",
  fullName: "devvit.runtime.actor.Supervisor",
  methods: {
    /**
     * Transform an incoming envelope.
     *
     * Because the input and outputs are Envelopes, they are actually Envelopes
     * wrapped in Envelopes. That is, Envelope.message is an Envelope. The outer
     * Envelope.success flag indicates filter status.
     */
    filter: {
      name: "Filter",
      requestType: Envelope,
      requestStream: false,
      responseType: Envelope,
      responseStream: false,
      options: {}
    },
    /** Unpacks and loads each bundled Actor into their own Workers */
    load: {
      name: "Load",
      requestType: LinkedBundle,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** Unloads the actor at the provided URI, and unloads dependencies if needed */
    unload: {
      name: "Unload",
      requestType: UnloadRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    }
  }
};
function isSet108(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/runtime/actor/v1alpha/health.js
var import_minimal130 = __toESM(require_minimal2(), 1);
function createBaseHealthStatus() {
  return { start: void 0, end: void 0 };
}
var HealthStatus = {
  $type: "devvit.runtime.actor.v1alpha.HealthStatus",
  encode(message, writer = import_minimal130.default.Writer.create()) {
    if (message.start !== void 0) {
      Timestamp.encode(toTimestamp13(message.start), writer.uint32(10).fork()).ldelim();
    }
    if (message.end !== void 0) {
      Timestamp.encode(toTimestamp13(message.end), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal130.default.Reader ? input : new import_minimal130.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHealthStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.start = fromTimestamp13(Timestamp.decode(reader, reader.uint32()));
          break;
        case 2:
          message.end = fromTimestamp13(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      start: isSet109(object.start) ? fromJsonTimestamp13(object.start) : void 0,
      end: isSet109(object.end) ? fromJsonTimestamp13(object.end) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.start !== void 0 && (obj.start = message.start.toISOString());
    message.end !== void 0 && (obj.end = message.end.toISOString());
    return obj;
  },
  fromPartial(object) {
    const message = createBaseHealthStatus();
    message.start = object.start ?? void 0;
    message.end = object.end ?? void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.runtime.actor.v1alpha.HealthStatus", HealthStatus);
function toTimestamp13(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp13(t) {
  let millis = t.seconds * 1e3;
  millis += t.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp13(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp13(Timestamp.fromJSON(o));
  }
}
function isSet109(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/devvit/service/bundle_service.js
var import_minimal131 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/service/envelope_service.js
var import_minimal132 = __toESM(require_minimal2(), 1);

// ../protos/dist/types/devvit/ui/events/v1alpha/event.js
var import_minimal133 = __toESM(require_minimal2(), 1);
function createBaseUIEvent() {
  return { realtimeEvent: void 0, formSubmitted: void 0, toastAction: void 0 };
}
var UIEvent = {
  $type: "devvit.ui.events.v1alpha.UIEvent",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.realtimeEvent !== void 0) {
      RealtimeSubscriptionEvent.encode(message.realtimeEvent, writer.uint32(18).fork()).ldelim();
    }
    if (message.formSubmitted !== void 0) {
      FormSubmittedEvent.encode(message.formSubmitted, writer.uint32(26).fork()).ldelim();
    }
    if (message.toastAction !== void 0) {
      ToastActionEvent.encode(message.toastAction, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : new import_minimal133.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUIEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.realtimeEvent = RealtimeSubscriptionEvent.decode(reader, reader.uint32());
          break;
        case 3:
          message.formSubmitted = FormSubmittedEvent.decode(reader, reader.uint32());
          break;
        case 4:
          message.toastAction = ToastActionEvent.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      realtimeEvent: isSet110(object.realtimeEvent) ? RealtimeSubscriptionEvent.fromJSON(object.realtimeEvent) : void 0,
      formSubmitted: isSet110(object.formSubmitted) ? FormSubmittedEvent.fromJSON(object.formSubmitted) : void 0,
      toastAction: isSet110(object.toastAction) ? ToastActionEvent.fromJSON(object.toastAction) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.realtimeEvent !== void 0 && (obj.realtimeEvent = message.realtimeEvent ? RealtimeSubscriptionEvent.toJSON(message.realtimeEvent) : void 0);
    message.formSubmitted !== void 0 && (obj.formSubmitted = message.formSubmitted ? FormSubmittedEvent.toJSON(message.formSubmitted) : void 0);
    message.toastAction !== void 0 && (obj.toastAction = message.toastAction ? ToastActionEvent.toJSON(message.toastAction) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUIEvent();
    message.realtimeEvent = object.realtimeEvent !== void 0 && object.realtimeEvent !== null ? RealtimeSubscriptionEvent.fromPartial(object.realtimeEvent) : void 0;
    message.formSubmitted = object.formSubmitted !== void 0 && object.formSubmitted !== null ? FormSubmittedEvent.fromPartial(object.formSubmitted) : void 0;
    message.toastAction = object.toastAction !== void 0 && object.toastAction !== null ? ToastActionEvent.fromPartial(object.toastAction) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.events.v1alpha.UIEvent", UIEvent);
function createBaseHandleUIEventRequest() {
  return { state: void 0, event: void 0 };
}
var HandleUIEventRequest = {
  $type: "devvit.ui.events.v1alpha.HandleUIEventRequest",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.state !== void 0) {
      Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
    }
    if (message.event !== void 0) {
      UIEvent.encode(message.event, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : new import_minimal133.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHandleUIEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        case 2:
          message.event = UIEvent.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      state: isObject25(object.state) ? object.state : void 0,
      event: isSet110(object.event) ? UIEvent.fromJSON(object.event) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.state !== void 0 && (obj.state = message.state);
    message.event !== void 0 && (obj.event = message.event ? UIEvent.toJSON(message.event) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseHandleUIEventRequest();
    message.state = object.state ?? void 0;
    message.event = object.event !== void 0 && object.event !== null ? UIEvent.fromPartial(object.event) : void 0;
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.events.v1alpha.HandleUIEventRequest", HandleUIEventRequest);
function createBaseHandleUIEventResponse() {
  return { state: void 0, effects: [] };
}
var HandleUIEventResponse = {
  $type: "devvit.ui.events.v1alpha.HandleUIEventResponse",
  encode(message, writer = import_minimal133.default.Writer.create()) {
    if (message.state !== void 0) {
      Struct.encode(Struct.wrap(message.state), writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.effects) {
      Effect.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal133.default.Reader ? input : new import_minimal133.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHandleUIEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          break;
        case 2:
          message.effects.push(Effect.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      state: isObject25(object.state) ? object.state : void 0,
      effects: Array.isArray(object?.effects) ? object.effects.map((e) => Effect.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.state !== void 0 && (obj.state = message.state);
    if (message.effects) {
      obj.effects = message.effects.map((e) => e ? Effect.toJSON(e) : void 0);
    } else {
      obj.effects = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseHandleUIEventResponse();
    message.state = object.state ?? void 0;
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("devvit.ui.events.v1alpha.HandleUIEventResponse", HandleUIEventResponse);
function isObject25(value) {
  return typeof value === "object" && value !== null;
}
function isSet110(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/types/google/protobuf/descriptor.js
var import_long11 = __toESM(require_long(), 1);
var import_minimal134 = __toESM(require_minimal2(), 1);
var FieldDescriptorProto_Type;
(function(FieldDescriptorProto_Type2) {
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_DOUBLE"] = 1] = "TYPE_DOUBLE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_FLOAT"] = 2] = "TYPE_FLOAT";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_INT64"] = 3] = "TYPE_INT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_UINT64"] = 4] = "TYPE_UINT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_INT32"] = 5] = "TYPE_INT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_FIXED64"] = 6] = "TYPE_FIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_FIXED32"] = 7] = "TYPE_FIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_BOOL"] = 8] = "TYPE_BOOL";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_STRING"] = 9] = "TYPE_STRING";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_GROUP"] = 10] = "TYPE_GROUP";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_MESSAGE"] = 11] = "TYPE_MESSAGE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_BYTES"] = 12] = "TYPE_BYTES";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_UINT32"] = 13] = "TYPE_UINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_ENUM"] = 14] = "TYPE_ENUM";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_SFIXED32"] = 15] = "TYPE_SFIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_SFIXED64"] = 16] = "TYPE_SFIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_SINT32"] = 17] = "TYPE_SINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["TYPE_SINT64"] = 18] = "TYPE_SINT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldDescriptorProto_Type || (FieldDescriptorProto_Type = {}));
function fieldDescriptorProto_TypeFromJSON(object) {
  switch (object) {
    case 1:
    case "TYPE_DOUBLE":
      return FieldDescriptorProto_Type.TYPE_DOUBLE;
    case 2:
    case "TYPE_FLOAT":
      return FieldDescriptorProto_Type.TYPE_FLOAT;
    case 3:
    case "TYPE_INT64":
      return FieldDescriptorProto_Type.TYPE_INT64;
    case 4:
    case "TYPE_UINT64":
      return FieldDescriptorProto_Type.TYPE_UINT64;
    case 5:
    case "TYPE_INT32":
      return FieldDescriptorProto_Type.TYPE_INT32;
    case 6:
    case "TYPE_FIXED64":
      return FieldDescriptorProto_Type.TYPE_FIXED64;
    case 7:
    case "TYPE_FIXED32":
      return FieldDescriptorProto_Type.TYPE_FIXED32;
    case 8:
    case "TYPE_BOOL":
      return FieldDescriptorProto_Type.TYPE_BOOL;
    case 9:
    case "TYPE_STRING":
      return FieldDescriptorProto_Type.TYPE_STRING;
    case 10:
    case "TYPE_GROUP":
      return FieldDescriptorProto_Type.TYPE_GROUP;
    case 11:
    case "TYPE_MESSAGE":
      return FieldDescriptorProto_Type.TYPE_MESSAGE;
    case 12:
    case "TYPE_BYTES":
      return FieldDescriptorProto_Type.TYPE_BYTES;
    case 13:
    case "TYPE_UINT32":
      return FieldDescriptorProto_Type.TYPE_UINT32;
    case 14:
    case "TYPE_ENUM":
      return FieldDescriptorProto_Type.TYPE_ENUM;
    case 15:
    case "TYPE_SFIXED32":
      return FieldDescriptorProto_Type.TYPE_SFIXED32;
    case 16:
    case "TYPE_SFIXED64":
      return FieldDescriptorProto_Type.TYPE_SFIXED64;
    case 17:
    case "TYPE_SINT32":
      return FieldDescriptorProto_Type.TYPE_SINT32;
    case 18:
    case "TYPE_SINT64":
      return FieldDescriptorProto_Type.TYPE_SINT64;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldDescriptorProto_Type.UNRECOGNIZED;
  }
}
function fieldDescriptorProto_TypeToJSON(object) {
  switch (object) {
    case FieldDescriptorProto_Type.TYPE_DOUBLE:
      return 1;
    case FieldDescriptorProto_Type.TYPE_FLOAT:
      return 2;
    case FieldDescriptorProto_Type.TYPE_INT64:
      return 3;
    case FieldDescriptorProto_Type.TYPE_UINT64:
      return 4;
    case FieldDescriptorProto_Type.TYPE_INT32:
      return 5;
    case FieldDescriptorProto_Type.TYPE_FIXED64:
      return 6;
    case FieldDescriptorProto_Type.TYPE_FIXED32:
      return 7;
    case FieldDescriptorProto_Type.TYPE_BOOL:
      return 8;
    case FieldDescriptorProto_Type.TYPE_STRING:
      return 9;
    case FieldDescriptorProto_Type.TYPE_GROUP:
      return 10;
    case FieldDescriptorProto_Type.TYPE_MESSAGE:
      return 11;
    case FieldDescriptorProto_Type.TYPE_BYTES:
      return 12;
    case FieldDescriptorProto_Type.TYPE_UINT32:
      return 13;
    case FieldDescriptorProto_Type.TYPE_ENUM:
      return 14;
    case FieldDescriptorProto_Type.TYPE_SFIXED32:
      return 15;
    case FieldDescriptorProto_Type.TYPE_SFIXED64:
      return 16;
    case FieldDescriptorProto_Type.TYPE_SINT32:
      return 17;
    case FieldDescriptorProto_Type.TYPE_SINT64:
      return 18;
    case FieldDescriptorProto_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FieldDescriptorProto_Label;
(function(FieldDescriptorProto_Label2) {
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["LABEL_OPTIONAL"] = 1] = "LABEL_OPTIONAL";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["LABEL_REQUIRED"] = 2] = "LABEL_REQUIRED";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["LABEL_REPEATED"] = 3] = "LABEL_REPEATED";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldDescriptorProto_Label || (FieldDescriptorProto_Label = {}));
function fieldDescriptorProto_LabelFromJSON(object) {
  switch (object) {
    case 1:
    case "LABEL_OPTIONAL":
      return FieldDescriptorProto_Label.LABEL_OPTIONAL;
    case 2:
    case "LABEL_REQUIRED":
      return FieldDescriptorProto_Label.LABEL_REQUIRED;
    case 3:
    case "LABEL_REPEATED":
      return FieldDescriptorProto_Label.LABEL_REPEATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldDescriptorProto_Label.UNRECOGNIZED;
  }
}
function fieldDescriptorProto_LabelToJSON(object) {
  switch (object) {
    case FieldDescriptorProto_Label.LABEL_OPTIONAL:
      return 1;
    case FieldDescriptorProto_Label.LABEL_REQUIRED:
      return 2;
    case FieldDescriptorProto_Label.LABEL_REPEATED:
      return 3;
    case FieldDescriptorProto_Label.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FileOptions_OptimizeMode;
(function(FileOptions_OptimizeMode2) {
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["SPEED"] = 1] = "SPEED";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["CODE_SIZE"] = 2] = "CODE_SIZE";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["LITE_RUNTIME"] = 3] = "LITE_RUNTIME";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FileOptions_OptimizeMode || (FileOptions_OptimizeMode = {}));
function fileOptions_OptimizeModeFromJSON(object) {
  switch (object) {
    case 1:
    case "SPEED":
      return FileOptions_OptimizeMode.SPEED;
    case 2:
    case "CODE_SIZE":
      return FileOptions_OptimizeMode.CODE_SIZE;
    case 3:
    case "LITE_RUNTIME":
      return FileOptions_OptimizeMode.LITE_RUNTIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileOptions_OptimizeMode.UNRECOGNIZED;
  }
}
function fileOptions_OptimizeModeToJSON(object) {
  switch (object) {
    case FileOptions_OptimizeMode.SPEED:
      return 1;
    case FileOptions_OptimizeMode.CODE_SIZE:
      return 2;
    case FileOptions_OptimizeMode.LITE_RUNTIME:
      return 3;
    case FileOptions_OptimizeMode.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FieldOptions_CType;
(function(FieldOptions_CType2) {
  FieldOptions_CType2[FieldOptions_CType2["STRING"] = 0] = "STRING";
  FieldOptions_CType2[FieldOptions_CType2["CORD"] = 1] = "CORD";
  FieldOptions_CType2[FieldOptions_CType2["STRING_PIECE"] = 2] = "STRING_PIECE";
  FieldOptions_CType2[FieldOptions_CType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldOptions_CType || (FieldOptions_CType = {}));
function fieldOptions_CTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "STRING":
      return FieldOptions_CType.STRING;
    case 1:
    case "CORD":
      return FieldOptions_CType.CORD;
    case 2:
    case "STRING_PIECE":
      return FieldOptions_CType.STRING_PIECE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldOptions_CType.UNRECOGNIZED;
  }
}
function fieldOptions_CTypeToJSON(object) {
  switch (object) {
    case FieldOptions_CType.STRING:
      return 0;
    case FieldOptions_CType.CORD:
      return 1;
    case FieldOptions_CType.STRING_PIECE:
      return 2;
    case FieldOptions_CType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FieldOptions_JSType;
(function(FieldOptions_JSType2) {
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NORMAL"] = 0] = "JS_NORMAL";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_STRING"] = 1] = "JS_STRING";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NUMBER"] = 2] = "JS_NUMBER";
  FieldOptions_JSType2[FieldOptions_JSType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldOptions_JSType || (FieldOptions_JSType = {}));
function fieldOptions_JSTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "JS_NORMAL":
      return FieldOptions_JSType.JS_NORMAL;
    case 1:
    case "JS_STRING":
      return FieldOptions_JSType.JS_STRING;
    case 2:
    case "JS_NUMBER":
      return FieldOptions_JSType.JS_NUMBER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldOptions_JSType.UNRECOGNIZED;
  }
}
function fieldOptions_JSTypeToJSON(object) {
  switch (object) {
    case FieldOptions_JSType.JS_NORMAL:
      return 0;
    case FieldOptions_JSType.JS_STRING:
      return 1;
    case FieldOptions_JSType.JS_NUMBER:
      return 2;
    case FieldOptions_JSType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FieldOptions_OptionRetention;
(function(FieldOptions_OptionRetention2) {
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_UNKNOWN"] = 0] = "RETENTION_UNKNOWN";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_RUNTIME"] = 1] = "RETENTION_RUNTIME";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_SOURCE"] = 2] = "RETENTION_SOURCE";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldOptions_OptionRetention || (FieldOptions_OptionRetention = {}));
function fieldOptions_OptionRetentionFromJSON(object) {
  switch (object) {
    case 0:
    case "RETENTION_UNKNOWN":
      return FieldOptions_OptionRetention.RETENTION_UNKNOWN;
    case 1:
    case "RETENTION_RUNTIME":
      return FieldOptions_OptionRetention.RETENTION_RUNTIME;
    case 2:
    case "RETENTION_SOURCE":
      return FieldOptions_OptionRetention.RETENTION_SOURCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldOptions_OptionRetention.UNRECOGNIZED;
  }
}
function fieldOptions_OptionRetentionToJSON(object) {
  switch (object) {
    case FieldOptions_OptionRetention.RETENTION_UNKNOWN:
      return 0;
    case FieldOptions_OptionRetention.RETENTION_RUNTIME:
      return 1;
    case FieldOptions_OptionRetention.RETENTION_SOURCE:
      return 2;
    case FieldOptions_OptionRetention.UNRECOGNIZED:
    default:
      return -1;
  }
}
var FieldOptions_OptionTargetType;
(function(FieldOptions_OptionTargetType2) {
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_UNKNOWN"] = 0] = "TARGET_TYPE_UNKNOWN";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FILE"] = 1] = "TARGET_TYPE_FILE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_EXTENSION_RANGE"] = 2] = "TARGET_TYPE_EXTENSION_RANGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_MESSAGE"] = 3] = "TARGET_TYPE_MESSAGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FIELD"] = 4] = "TARGET_TYPE_FIELD";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ONEOF"] = 5] = "TARGET_TYPE_ONEOF";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM"] = 6] = "TARGET_TYPE_ENUM";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM_ENTRY"] = 7] = "TARGET_TYPE_ENUM_ENTRY";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_SERVICE"] = 8] = "TARGET_TYPE_SERVICE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_METHOD"] = 9] = "TARGET_TYPE_METHOD";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FieldOptions_OptionTargetType || (FieldOptions_OptionTargetType = {}));
function fieldOptions_OptionTargetTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "TARGET_TYPE_UNKNOWN":
      return FieldOptions_OptionTargetType.TARGET_TYPE_UNKNOWN;
    case 1:
    case "TARGET_TYPE_FILE":
      return FieldOptions_OptionTargetType.TARGET_TYPE_FILE;
    case 2:
    case "TARGET_TYPE_EXTENSION_RANGE":
      return FieldOptions_OptionTargetType.TARGET_TYPE_EXTENSION_RANGE;
    case 3:
    case "TARGET_TYPE_MESSAGE":
      return FieldOptions_OptionTargetType.TARGET_TYPE_MESSAGE;
    case 4:
    case "TARGET_TYPE_FIELD":
      return FieldOptions_OptionTargetType.TARGET_TYPE_FIELD;
    case 5:
    case "TARGET_TYPE_ONEOF":
      return FieldOptions_OptionTargetType.TARGET_TYPE_ONEOF;
    case 6:
    case "TARGET_TYPE_ENUM":
      return FieldOptions_OptionTargetType.TARGET_TYPE_ENUM;
    case 7:
    case "TARGET_TYPE_ENUM_ENTRY":
      return FieldOptions_OptionTargetType.TARGET_TYPE_ENUM_ENTRY;
    case 8:
    case "TARGET_TYPE_SERVICE":
      return FieldOptions_OptionTargetType.TARGET_TYPE_SERVICE;
    case 9:
    case "TARGET_TYPE_METHOD":
      return FieldOptions_OptionTargetType.TARGET_TYPE_METHOD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldOptions_OptionTargetType.UNRECOGNIZED;
  }
}
function fieldOptions_OptionTargetTypeToJSON(object) {
  switch (object) {
    case FieldOptions_OptionTargetType.TARGET_TYPE_UNKNOWN:
      return 0;
    case FieldOptions_OptionTargetType.TARGET_TYPE_FILE:
      return 1;
    case FieldOptions_OptionTargetType.TARGET_TYPE_EXTENSION_RANGE:
      return 2;
    case FieldOptions_OptionTargetType.TARGET_TYPE_MESSAGE:
      return 3;
    case FieldOptions_OptionTargetType.TARGET_TYPE_FIELD:
      return 4;
    case FieldOptions_OptionTargetType.TARGET_TYPE_ONEOF:
      return 5;
    case FieldOptions_OptionTargetType.TARGET_TYPE_ENUM:
      return 6;
    case FieldOptions_OptionTargetType.TARGET_TYPE_ENUM_ENTRY:
      return 7;
    case FieldOptions_OptionTargetType.TARGET_TYPE_SERVICE:
      return 8;
    case FieldOptions_OptionTargetType.TARGET_TYPE_METHOD:
      return 9;
    case FieldOptions_OptionTargetType.UNRECOGNIZED:
    default:
      return -1;
  }
}
var MethodOptions_IdempotencyLevel;
(function(MethodOptions_IdempotencyLevel2) {
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = 0] = "IDEMPOTENCY_UNKNOWN";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["NO_SIDE_EFFECTS"] = 1] = "NO_SIDE_EFFECTS";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENT"] = 2] = "IDEMPOTENT";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MethodOptions_IdempotencyLevel || (MethodOptions_IdempotencyLevel = {}));
function methodOptions_IdempotencyLevelFromJSON(object) {
  switch (object) {
    case 0:
    case "IDEMPOTENCY_UNKNOWN":
      return MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN;
    case 1:
    case "NO_SIDE_EFFECTS":
      return MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS;
    case 2:
    case "IDEMPOTENT":
      return MethodOptions_IdempotencyLevel.IDEMPOTENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MethodOptions_IdempotencyLevel.UNRECOGNIZED;
  }
}
function methodOptions_IdempotencyLevelToJSON(object) {
  switch (object) {
    case MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN:
      return 0;
    case MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS:
      return 1;
    case MethodOptions_IdempotencyLevel.IDEMPOTENT:
      return 2;
    case MethodOptions_IdempotencyLevel.UNRECOGNIZED:
    default:
      return -1;
  }
}
var GeneratedCodeInfo_Annotation_Semantic;
(function(GeneratedCodeInfo_Annotation_Semantic2) {
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["NONE"] = 0] = "NONE";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["SET"] = 1] = "SET";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["ALIAS"] = 2] = "ALIAS";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(GeneratedCodeInfo_Annotation_Semantic || (GeneratedCodeInfo_Annotation_Semantic = {}));
function generatedCodeInfo_Annotation_SemanticFromJSON(object) {
  switch (object) {
    case 0:
    case "NONE":
      return GeneratedCodeInfo_Annotation_Semantic.NONE;
    case 1:
    case "SET":
      return GeneratedCodeInfo_Annotation_Semantic.SET;
    case 2:
    case "ALIAS":
      return GeneratedCodeInfo_Annotation_Semantic.ALIAS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GeneratedCodeInfo_Annotation_Semantic.UNRECOGNIZED;
  }
}
function generatedCodeInfo_Annotation_SemanticToJSON(object) {
  switch (object) {
    case GeneratedCodeInfo_Annotation_Semantic.NONE:
      return 0;
    case GeneratedCodeInfo_Annotation_Semantic.SET:
      return 1;
    case GeneratedCodeInfo_Annotation_Semantic.ALIAS:
      return 2;
    case GeneratedCodeInfo_Annotation_Semantic.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseFileDescriptorSet() {
  return { file: [] };
}
var FileDescriptorSet = {
  $type: "google.protobuf.FileDescriptorSet",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    for (const v of message.file) {
      FileDescriptorProto.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileDescriptorSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.file.push(FileDescriptorProto.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { file: Array.isArray(object?.file) ? object.file.map((e) => FileDescriptorProto.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.file) {
      obj.file = message.file.map((e) => e ? FileDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.file = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFileDescriptorSet();
    message.file = object.file?.map((e) => FileDescriptorProto.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.FileDescriptorSet", FileDescriptorSet);
function createBaseFileDescriptorProto() {
  return {
    name: "",
    package: "",
    dependency: [],
    publicDependency: [],
    weakDependency: [],
    messageType: [],
    enumType: [],
    service: [],
    extension: [],
    options: void 0,
    sourceCodeInfo: void 0,
    syntax: "",
    edition: ""
  };
}
var FileDescriptorProto = {
  $type: "google.protobuf.FileDescriptorProto",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.package !== "") {
      writer.uint32(18).string(message.package);
    }
    for (const v of message.dependency) {
      writer.uint32(26).string(v);
    }
    writer.uint32(82).fork();
    for (const v of message.publicDependency) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(90).fork();
    for (const v of message.weakDependency) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.messageType) {
      DescriptorProto.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.enumType) {
      EnumDescriptorProto.encode(v, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.service) {
      ServiceDescriptorProto.encode(v, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.extension) {
      FieldDescriptorProto.encode(v, writer.uint32(58).fork()).ldelim();
    }
    if (message.options !== void 0) {
      FileOptions.encode(message.options, writer.uint32(66).fork()).ldelim();
    }
    if (message.sourceCodeInfo !== void 0) {
      SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(74).fork()).ldelim();
    }
    if (message.syntax !== "") {
      writer.uint32(98).string(message.syntax);
    }
    if (message.edition !== "") {
      writer.uint32(106).string(message.edition);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.package = reader.string();
          break;
        case 3:
          message.dependency.push(reader.string());
          break;
        case 10:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.publicDependency.push(reader.int32());
            }
          } else {
            message.publicDependency.push(reader.int32());
          }
          break;
        case 11:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.weakDependency.push(reader.int32());
            }
          } else {
            message.weakDependency.push(reader.int32());
          }
          break;
        case 4:
          message.messageType.push(DescriptorProto.decode(reader, reader.uint32()));
          break;
        case 5:
          message.enumType.push(EnumDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 6:
          message.service.push(ServiceDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 7:
          message.extension.push(FieldDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 8:
          message.options = FileOptions.decode(reader, reader.uint32());
          break;
        case 9:
          message.sourceCodeInfo = SourceCodeInfo.decode(reader, reader.uint32());
          break;
        case 12:
          message.syntax = reader.string();
          break;
        case 13:
          message.edition = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet111(object.name) ? String(object.name) : "",
      package: isSet111(object.package) ? String(object.package) : "",
      dependency: Array.isArray(object?.dependency) ? object.dependency.map((e) => String(e)) : [],
      publicDependency: Array.isArray(object?.publicDependency) ? object.publicDependency.map((e) => Number(e)) : [],
      weakDependency: Array.isArray(object?.weakDependency) ? object.weakDependency.map((e) => Number(e)) : [],
      messageType: Array.isArray(object?.messageType) ? object.messageType.map((e) => DescriptorProto.fromJSON(e)) : [],
      enumType: Array.isArray(object?.enumType) ? object.enumType.map((e) => EnumDescriptorProto.fromJSON(e)) : [],
      service: Array.isArray(object?.service) ? object.service.map((e) => ServiceDescriptorProto.fromJSON(e)) : [],
      extension: Array.isArray(object?.extension) ? object.extension.map((e) => FieldDescriptorProto.fromJSON(e)) : [],
      options: isSet111(object.options) ? FileOptions.fromJSON(object.options) : void 0,
      sourceCodeInfo: isSet111(object.sourceCodeInfo) ? SourceCodeInfo.fromJSON(object.sourceCodeInfo) : void 0,
      syntax: isSet111(object.syntax) ? String(object.syntax) : "",
      edition: isSet111(object.edition) ? String(object.edition) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.package !== void 0 && (obj.package = message.package);
    if (message.dependency) {
      obj.dependency = message.dependency.map((e) => e);
    } else {
      obj.dependency = [];
    }
    if (message.publicDependency) {
      obj.publicDependency = message.publicDependency.map((e) => Math.round(e));
    } else {
      obj.publicDependency = [];
    }
    if (message.weakDependency) {
      obj.weakDependency = message.weakDependency.map((e) => Math.round(e));
    } else {
      obj.weakDependency = [];
    }
    if (message.messageType) {
      obj.messageType = message.messageType.map((e) => e ? DescriptorProto.toJSON(e) : void 0);
    } else {
      obj.messageType = [];
    }
    if (message.enumType) {
      obj.enumType = message.enumType.map((e) => e ? EnumDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.enumType = [];
    }
    if (message.service) {
      obj.service = message.service.map((e) => e ? ServiceDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.service = [];
    }
    if (message.extension) {
      obj.extension = message.extension.map((e) => e ? FieldDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.extension = [];
    }
    message.options !== void 0 && (obj.options = message.options ? FileOptions.toJSON(message.options) : void 0);
    message.sourceCodeInfo !== void 0 && (obj.sourceCodeInfo = message.sourceCodeInfo ? SourceCodeInfo.toJSON(message.sourceCodeInfo) : void 0);
    message.syntax !== void 0 && (obj.syntax = message.syntax);
    message.edition !== void 0 && (obj.edition = message.edition);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFileDescriptorProto();
    message.name = object.name ?? "";
    message.package = object.package ?? "";
    message.dependency = object.dependency?.map((e) => e) || [];
    message.publicDependency = object.publicDependency?.map((e) => e) || [];
    message.weakDependency = object.weakDependency?.map((e) => e) || [];
    message.messageType = object.messageType?.map((e) => DescriptorProto.fromPartial(e)) || [];
    message.enumType = object.enumType?.map((e) => EnumDescriptorProto.fromPartial(e)) || [];
    message.service = object.service?.map((e) => ServiceDescriptorProto.fromPartial(e)) || [];
    message.extension = object.extension?.map((e) => FieldDescriptorProto.fromPartial(e)) || [];
    message.options = object.options !== void 0 && object.options !== null ? FileOptions.fromPartial(object.options) : void 0;
    message.sourceCodeInfo = object.sourceCodeInfo !== void 0 && object.sourceCodeInfo !== null ? SourceCodeInfo.fromPartial(object.sourceCodeInfo) : void 0;
    message.syntax = object.syntax ?? "";
    message.edition = object.edition ?? "";
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.FileDescriptorProto", FileDescriptorProto);
function createBaseDescriptorProto() {
  return {
    name: "",
    field: [],
    extension: [],
    nestedType: [],
    enumType: [],
    extensionRange: [],
    oneofDecl: [],
    options: void 0,
    reservedRange: [],
    reservedName: []
  };
}
var DescriptorProto = {
  $type: "google.protobuf.DescriptorProto",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.field) {
      FieldDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.extension) {
      FieldDescriptorProto.encode(v, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.nestedType) {
      DescriptorProto.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.enumType) {
      EnumDescriptorProto.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.extensionRange) {
      DescriptorProto_ExtensionRange.encode(v, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.oneofDecl) {
      OneofDescriptorProto.encode(v, writer.uint32(66).fork()).ldelim();
    }
    if (message.options !== void 0) {
      MessageOptions.encode(message.options, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.reservedRange) {
      DescriptorProto_ReservedRange.encode(v, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.reservedName) {
      writer.uint32(82).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.field.push(FieldDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 6:
          message.extension.push(FieldDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 3:
          message.nestedType.push(DescriptorProto.decode(reader, reader.uint32()));
          break;
        case 4:
          message.enumType.push(EnumDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 5:
          message.extensionRange.push(DescriptorProto_ExtensionRange.decode(reader, reader.uint32()));
          break;
        case 8:
          message.oneofDecl.push(OneofDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 7:
          message.options = MessageOptions.decode(reader, reader.uint32());
          break;
        case 9:
          message.reservedRange.push(DescriptorProto_ReservedRange.decode(reader, reader.uint32()));
          break;
        case 10:
          message.reservedName.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet111(object.name) ? String(object.name) : "",
      field: Array.isArray(object?.field) ? object.field.map((e) => FieldDescriptorProto.fromJSON(e)) : [],
      extension: Array.isArray(object?.extension) ? object.extension.map((e) => FieldDescriptorProto.fromJSON(e)) : [],
      nestedType: Array.isArray(object?.nestedType) ? object.nestedType.map((e) => DescriptorProto.fromJSON(e)) : [],
      enumType: Array.isArray(object?.enumType) ? object.enumType.map((e) => EnumDescriptorProto.fromJSON(e)) : [],
      extensionRange: Array.isArray(object?.extensionRange) ? object.extensionRange.map((e) => DescriptorProto_ExtensionRange.fromJSON(e)) : [],
      oneofDecl: Array.isArray(object?.oneofDecl) ? object.oneofDecl.map((e) => OneofDescriptorProto.fromJSON(e)) : [],
      options: isSet111(object.options) ? MessageOptions.fromJSON(object.options) : void 0,
      reservedRange: Array.isArray(object?.reservedRange) ? object.reservedRange.map((e) => DescriptorProto_ReservedRange.fromJSON(e)) : [],
      reservedName: Array.isArray(object?.reservedName) ? object.reservedName.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    if (message.field) {
      obj.field = message.field.map((e) => e ? FieldDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.field = [];
    }
    if (message.extension) {
      obj.extension = message.extension.map((e) => e ? FieldDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.extension = [];
    }
    if (message.nestedType) {
      obj.nestedType = message.nestedType.map((e) => e ? DescriptorProto.toJSON(e) : void 0);
    } else {
      obj.nestedType = [];
    }
    if (message.enumType) {
      obj.enumType = message.enumType.map((e) => e ? EnumDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.enumType = [];
    }
    if (message.extensionRange) {
      obj.extensionRange = message.extensionRange.map((e) => e ? DescriptorProto_ExtensionRange.toJSON(e) : void 0);
    } else {
      obj.extensionRange = [];
    }
    if (message.oneofDecl) {
      obj.oneofDecl = message.oneofDecl.map((e) => e ? OneofDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.oneofDecl = [];
    }
    message.options !== void 0 && (obj.options = message.options ? MessageOptions.toJSON(message.options) : void 0);
    if (message.reservedRange) {
      obj.reservedRange = message.reservedRange.map((e) => e ? DescriptorProto_ReservedRange.toJSON(e) : void 0);
    } else {
      obj.reservedRange = [];
    }
    if (message.reservedName) {
      obj.reservedName = message.reservedName.map((e) => e);
    } else {
      obj.reservedName = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDescriptorProto();
    message.name = object.name ?? "";
    message.field = object.field?.map((e) => FieldDescriptorProto.fromPartial(e)) || [];
    message.extension = object.extension?.map((e) => FieldDescriptorProto.fromPartial(e)) || [];
    message.nestedType = object.nestedType?.map((e) => DescriptorProto.fromPartial(e)) || [];
    message.enumType = object.enumType?.map((e) => EnumDescriptorProto.fromPartial(e)) || [];
    message.extensionRange = object.extensionRange?.map((e) => DescriptorProto_ExtensionRange.fromPartial(e)) || [];
    message.oneofDecl = object.oneofDecl?.map((e) => OneofDescriptorProto.fromPartial(e)) || [];
    message.options = object.options !== void 0 && object.options !== null ? MessageOptions.fromPartial(object.options) : void 0;
    message.reservedRange = object.reservedRange?.map((e) => DescriptorProto_ReservedRange.fromPartial(e)) || [];
    message.reservedName = object.reservedName?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.DescriptorProto", DescriptorProto);
function createBaseDescriptorProto_ExtensionRange() {
  return { start: 0, end: 0, options: void 0 };
}
var DescriptorProto_ExtensionRange = {
  $type: "google.protobuf.DescriptorProto.ExtensionRange",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    if (message.options !== void 0) {
      ExtensionRangeOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDescriptorProto_ExtensionRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.start = reader.int32();
          break;
        case 2:
          message.end = reader.int32();
          break;
        case 3:
          message.options = ExtensionRangeOptions.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      start: isSet111(object.start) ? Number(object.start) : 0,
      end: isSet111(object.end) ? Number(object.end) : 0,
      options: isSet111(object.options) ? ExtensionRangeOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.start !== void 0 && (obj.start = Math.round(message.start));
    message.end !== void 0 && (obj.end = Math.round(message.end));
    message.options !== void 0 && (obj.options = message.options ? ExtensionRangeOptions.toJSON(message.options) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDescriptorProto_ExtensionRange();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    message.options = object.options !== void 0 && object.options !== null ? ExtensionRangeOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.DescriptorProto.ExtensionRange", DescriptorProto_ExtensionRange);
function createBaseDescriptorProto_ReservedRange() {
  return { start: 0, end: 0 };
}
var DescriptorProto_ReservedRange = {
  $type: "google.protobuf.DescriptorProto.ReservedRange",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDescriptorProto_ReservedRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.start = reader.int32();
          break;
        case 2:
          message.end = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { start: isSet111(object.start) ? Number(object.start) : 0, end: isSet111(object.end) ? Number(object.end) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.start !== void 0 && (obj.start = Math.round(message.start));
    message.end !== void 0 && (obj.end = Math.round(message.end));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDescriptorProto_ReservedRange();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.DescriptorProto.ReservedRange", DescriptorProto_ReservedRange);
function createBaseExtensionRangeOptions() {
  return { uninterpretedOption: [] };
}
var ExtensionRangeOptions = {
  $type: "google.protobuf.ExtensionRangeOptions",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExtensionRangeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      uninterpretedOption: Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseExtensionRangeOptions();
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.ExtensionRangeOptions", ExtensionRangeOptions);
function createBaseFieldDescriptorProto() {
  return {
    name: "",
    number: 0,
    label: 1,
    type: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    options: void 0,
    proto3Optional: false
  };
}
var FieldDescriptorProto = {
  $type: "google.protobuf.FieldDescriptorProto",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.number !== 0) {
      writer.uint32(24).int32(message.number);
    }
    if (message.label !== 1) {
      writer.uint32(32).int32(message.label);
    }
    if (message.type !== 1) {
      writer.uint32(40).int32(message.type);
    }
    if (message.typeName !== "") {
      writer.uint32(50).string(message.typeName);
    }
    if (message.extendee !== "") {
      writer.uint32(18).string(message.extendee);
    }
    if (message.defaultValue !== "") {
      writer.uint32(58).string(message.defaultValue);
    }
    if (message.oneofIndex !== 0) {
      writer.uint32(72).int32(message.oneofIndex);
    }
    if (message.jsonName !== "") {
      writer.uint32(82).string(message.jsonName);
    }
    if (message.options !== void 0) {
      FieldOptions.encode(message.options, writer.uint32(66).fork()).ldelim();
    }
    if (message.proto3Optional === true) {
      writer.uint32(136).bool(message.proto3Optional);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 3:
          message.number = reader.int32();
          break;
        case 4:
          message.label = reader.int32();
          break;
        case 5:
          message.type = reader.int32();
          break;
        case 6:
          message.typeName = reader.string();
          break;
        case 2:
          message.extendee = reader.string();
          break;
        case 7:
          message.defaultValue = reader.string();
          break;
        case 9:
          message.oneofIndex = reader.int32();
          break;
        case 10:
          message.jsonName = reader.string();
          break;
        case 8:
          message.options = FieldOptions.decode(reader, reader.uint32());
          break;
        case 17:
          message.proto3Optional = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet111(object.name) ? String(object.name) : "",
      number: isSet111(object.number) ? Number(object.number) : 0,
      label: isSet111(object.label) ? fieldDescriptorProto_LabelFromJSON(object.label) : 1,
      type: isSet111(object.type) ? fieldDescriptorProto_TypeFromJSON(object.type) : 1,
      typeName: isSet111(object.typeName) ? String(object.typeName) : "",
      extendee: isSet111(object.extendee) ? String(object.extendee) : "",
      defaultValue: isSet111(object.defaultValue) ? String(object.defaultValue) : "",
      oneofIndex: isSet111(object.oneofIndex) ? Number(object.oneofIndex) : 0,
      jsonName: isSet111(object.jsonName) ? String(object.jsonName) : "",
      options: isSet111(object.options) ? FieldOptions.fromJSON(object.options) : void 0,
      proto3Optional: isSet111(object.proto3Optional) ? Boolean(object.proto3Optional) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.number !== void 0 && (obj.number = Math.round(message.number));
    message.label !== void 0 && (obj.label = fieldDescriptorProto_LabelToJSON(message.label));
    message.type !== void 0 && (obj.type = fieldDescriptorProto_TypeToJSON(message.type));
    message.typeName !== void 0 && (obj.typeName = message.typeName);
    message.extendee !== void 0 && (obj.extendee = message.extendee);
    message.defaultValue !== void 0 && (obj.defaultValue = message.defaultValue);
    message.oneofIndex !== void 0 && (obj.oneofIndex = Math.round(message.oneofIndex));
    message.jsonName !== void 0 && (obj.jsonName = message.jsonName);
    message.options !== void 0 && (obj.options = message.options ? FieldOptions.toJSON(message.options) : void 0);
    message.proto3Optional !== void 0 && (obj.proto3Optional = message.proto3Optional);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFieldDescriptorProto();
    message.name = object.name ?? "";
    message.number = object.number ?? 0;
    message.label = object.label ?? 1;
    message.type = object.type ?? 1;
    message.typeName = object.typeName ?? "";
    message.extendee = object.extendee ?? "";
    message.defaultValue = object.defaultValue ?? "";
    message.oneofIndex = object.oneofIndex ?? 0;
    message.jsonName = object.jsonName ?? "";
    message.options = object.options !== void 0 && object.options !== null ? FieldOptions.fromPartial(object.options) : void 0;
    message.proto3Optional = object.proto3Optional ?? false;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.FieldDescriptorProto", FieldDescriptorProto);
function createBaseOneofDescriptorProto() {
  return { name: "", options: void 0 };
}
var OneofDescriptorProto = {
  $type: "google.protobuf.OneofDescriptorProto",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.options !== void 0) {
      OneofOptions.encode(message.options, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOneofDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.options = OneofOptions.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet111(object.name) ? String(object.name) : "",
      options: isSet111(object.options) ? OneofOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.options !== void 0 && (obj.options = message.options ? OneofOptions.toJSON(message.options) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseOneofDescriptorProto();
    message.name = object.name ?? "";
    message.options = object.options !== void 0 && object.options !== null ? OneofOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.OneofDescriptorProto", OneofDescriptorProto);
function createBaseEnumDescriptorProto() {
  return { name: "", value: [], options: void 0, reservedRange: [], reservedName: [] };
}
var EnumDescriptorProto = {
  $type: "google.protobuf.EnumDescriptorProto",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.value) {
      EnumValueDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.options !== void 0) {
      EnumOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.reservedRange) {
      EnumDescriptorProto_EnumReservedRange.encode(v, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.reservedName) {
      writer.uint32(42).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.value.push(EnumValueDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 3:
          message.options = EnumOptions.decode(reader, reader.uint32());
          break;
        case 4:
          message.reservedRange.push(EnumDescriptorProto_EnumReservedRange.decode(reader, reader.uint32()));
          break;
        case 5:
          message.reservedName.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet111(object.name) ? String(object.name) : "",
      value: Array.isArray(object?.value) ? object.value.map((e) => EnumValueDescriptorProto.fromJSON(e)) : [],
      options: isSet111(object.options) ? EnumOptions.fromJSON(object.options) : void 0,
      reservedRange: Array.isArray(object?.reservedRange) ? object.reservedRange.map((e) => EnumDescriptorProto_EnumReservedRange.fromJSON(e)) : [],
      reservedName: Array.isArray(object?.reservedName) ? object.reservedName.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    if (message.value) {
      obj.value = message.value.map((e) => e ? EnumValueDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.value = [];
    }
    message.options !== void 0 && (obj.options = message.options ? EnumOptions.toJSON(message.options) : void 0);
    if (message.reservedRange) {
      obj.reservedRange = message.reservedRange.map((e) => e ? EnumDescriptorProto_EnumReservedRange.toJSON(e) : void 0);
    } else {
      obj.reservedRange = [];
    }
    if (message.reservedName) {
      obj.reservedName = message.reservedName.map((e) => e);
    } else {
      obj.reservedName = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEnumDescriptorProto();
    message.name = object.name ?? "";
    message.value = object.value?.map((e) => EnumValueDescriptorProto.fromPartial(e)) || [];
    message.options = object.options !== void 0 && object.options !== null ? EnumOptions.fromPartial(object.options) : void 0;
    message.reservedRange = object.reservedRange?.map((e) => EnumDescriptorProto_EnumReservedRange.fromPartial(e)) || [];
    message.reservedName = object.reservedName?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.EnumDescriptorProto", EnumDescriptorProto);
function createBaseEnumDescriptorProto_EnumReservedRange() {
  return { start: 0, end: 0 };
}
var EnumDescriptorProto_EnumReservedRange = {
  $type: "google.protobuf.EnumDescriptorProto.EnumReservedRange",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumDescriptorProto_EnumReservedRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.start = reader.int32();
          break;
        case 2:
          message.end = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return { start: isSet111(object.start) ? Number(object.start) : 0, end: isSet111(object.end) ? Number(object.end) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.start !== void 0 && (obj.start = Math.round(message.start));
    message.end !== void 0 && (obj.end = Math.round(message.end));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEnumDescriptorProto_EnumReservedRange();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.EnumDescriptorProto.EnumReservedRange", EnumDescriptorProto_EnumReservedRange);
function createBaseEnumValueDescriptorProto() {
  return { name: "", number: 0, options: void 0 };
}
var EnumValueDescriptorProto = {
  $type: "google.protobuf.EnumValueDescriptorProto",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.number !== 0) {
      writer.uint32(16).int32(message.number);
    }
    if (message.options !== void 0) {
      EnumValueOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumValueDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.number = reader.int32();
          break;
        case 3:
          message.options = EnumValueOptions.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet111(object.name) ? String(object.name) : "",
      number: isSet111(object.number) ? Number(object.number) : 0,
      options: isSet111(object.options) ? EnumValueOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.number !== void 0 && (obj.number = Math.round(message.number));
    message.options !== void 0 && (obj.options = message.options ? EnumValueOptions.toJSON(message.options) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEnumValueDescriptorProto();
    message.name = object.name ?? "";
    message.number = object.number ?? 0;
    message.options = object.options !== void 0 && object.options !== null ? EnumValueOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.EnumValueDescriptorProto", EnumValueDescriptorProto);
function createBaseServiceDescriptorProto() {
  return { name: "", method: [], options: void 0 };
}
var ServiceDescriptorProto = {
  $type: "google.protobuf.ServiceDescriptorProto",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.method) {
      MethodDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.options !== void 0) {
      ServiceOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseServiceDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.method.push(MethodDescriptorProto.decode(reader, reader.uint32()));
          break;
        case 3:
          message.options = ServiceOptions.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet111(object.name) ? String(object.name) : "",
      method: Array.isArray(object?.method) ? object.method.map((e) => MethodDescriptorProto.fromJSON(e)) : [],
      options: isSet111(object.options) ? ServiceOptions.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    if (message.method) {
      obj.method = message.method.map((e) => e ? MethodDescriptorProto.toJSON(e) : void 0);
    } else {
      obj.method = [];
    }
    message.options !== void 0 && (obj.options = message.options ? ServiceOptions.toJSON(message.options) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseServiceDescriptorProto();
    message.name = object.name ?? "";
    message.method = object.method?.map((e) => MethodDescriptorProto.fromPartial(e)) || [];
    message.options = object.options !== void 0 && object.options !== null ? ServiceOptions.fromPartial(object.options) : void 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.ServiceDescriptorProto", ServiceDescriptorProto);
function createBaseMethodDescriptorProto() {
  return {
    name: "",
    inputType: "",
    outputType: "",
    options: void 0,
    clientStreaming: false,
    serverStreaming: false
  };
}
var MethodDescriptorProto = {
  $type: "google.protobuf.MethodDescriptorProto",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.inputType !== "") {
      writer.uint32(18).string(message.inputType);
    }
    if (message.outputType !== "") {
      writer.uint32(26).string(message.outputType);
    }
    if (message.options !== void 0) {
      MethodOptions.encode(message.options, writer.uint32(34).fork()).ldelim();
    }
    if (message.clientStreaming === true) {
      writer.uint32(40).bool(message.clientStreaming);
    }
    if (message.serverStreaming === true) {
      writer.uint32(48).bool(message.serverStreaming);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMethodDescriptorProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.inputType = reader.string();
          break;
        case 3:
          message.outputType = reader.string();
          break;
        case 4:
          message.options = MethodOptions.decode(reader, reader.uint32());
          break;
        case 5:
          message.clientStreaming = reader.bool();
          break;
        case 6:
          message.serverStreaming = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet111(object.name) ? String(object.name) : "",
      inputType: isSet111(object.inputType) ? String(object.inputType) : "",
      outputType: isSet111(object.outputType) ? String(object.outputType) : "",
      options: isSet111(object.options) ? MethodOptions.fromJSON(object.options) : void 0,
      clientStreaming: isSet111(object.clientStreaming) ? Boolean(object.clientStreaming) : false,
      serverStreaming: isSet111(object.serverStreaming) ? Boolean(object.serverStreaming) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.inputType !== void 0 && (obj.inputType = message.inputType);
    message.outputType !== void 0 && (obj.outputType = message.outputType);
    message.options !== void 0 && (obj.options = message.options ? MethodOptions.toJSON(message.options) : void 0);
    message.clientStreaming !== void 0 && (obj.clientStreaming = message.clientStreaming);
    message.serverStreaming !== void 0 && (obj.serverStreaming = message.serverStreaming);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMethodDescriptorProto();
    message.name = object.name ?? "";
    message.inputType = object.inputType ?? "";
    message.outputType = object.outputType ?? "";
    message.options = object.options !== void 0 && object.options !== null ? MethodOptions.fromPartial(object.options) : void 0;
    message.clientStreaming = object.clientStreaming ?? false;
    message.serverStreaming = object.serverStreaming ?? false;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.MethodDescriptorProto", MethodDescriptorProto);
function createBaseFileOptions() {
  return {
    javaPackage: "",
    javaOuterClassname: "",
    javaMultipleFiles: false,
    javaGenerateEqualsAndHash: false,
    javaStringCheckUtf8: false,
    optimizeFor: 1,
    goPackage: "",
    ccGenericServices: false,
    javaGenericServices: false,
    pyGenericServices: false,
    phpGenericServices: false,
    deprecated: false,
    ccEnableArenas: false,
    objcClassPrefix: "",
    csharpNamespace: "",
    swiftPrefix: "",
    phpClassPrefix: "",
    phpNamespace: "",
    phpMetadataNamespace: "",
    rubyPackage: "",
    uninterpretedOption: []
  };
}
var FileOptions = {
  $type: "google.protobuf.FileOptions",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.javaPackage !== "") {
      writer.uint32(10).string(message.javaPackage);
    }
    if (message.javaOuterClassname !== "") {
      writer.uint32(66).string(message.javaOuterClassname);
    }
    if (message.javaMultipleFiles === true) {
      writer.uint32(80).bool(message.javaMultipleFiles);
    }
    if (message.javaGenerateEqualsAndHash === true) {
      writer.uint32(160).bool(message.javaGenerateEqualsAndHash);
    }
    if (message.javaStringCheckUtf8 === true) {
      writer.uint32(216).bool(message.javaStringCheckUtf8);
    }
    if (message.optimizeFor !== 1) {
      writer.uint32(72).int32(message.optimizeFor);
    }
    if (message.goPackage !== "") {
      writer.uint32(90).string(message.goPackage);
    }
    if (message.ccGenericServices === true) {
      writer.uint32(128).bool(message.ccGenericServices);
    }
    if (message.javaGenericServices === true) {
      writer.uint32(136).bool(message.javaGenericServices);
    }
    if (message.pyGenericServices === true) {
      writer.uint32(144).bool(message.pyGenericServices);
    }
    if (message.phpGenericServices === true) {
      writer.uint32(336).bool(message.phpGenericServices);
    }
    if (message.deprecated === true) {
      writer.uint32(184).bool(message.deprecated);
    }
    if (message.ccEnableArenas === true) {
      writer.uint32(248).bool(message.ccEnableArenas);
    }
    if (message.objcClassPrefix !== "") {
      writer.uint32(290).string(message.objcClassPrefix);
    }
    if (message.csharpNamespace !== "") {
      writer.uint32(298).string(message.csharpNamespace);
    }
    if (message.swiftPrefix !== "") {
      writer.uint32(314).string(message.swiftPrefix);
    }
    if (message.phpClassPrefix !== "") {
      writer.uint32(322).string(message.phpClassPrefix);
    }
    if (message.phpNamespace !== "") {
      writer.uint32(330).string(message.phpNamespace);
    }
    if (message.phpMetadataNamespace !== "") {
      writer.uint32(354).string(message.phpMetadataNamespace);
    }
    if (message.rubyPackage !== "") {
      writer.uint32(362).string(message.rubyPackage);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.javaPackage = reader.string();
          break;
        case 8:
          message.javaOuterClassname = reader.string();
          break;
        case 10:
          message.javaMultipleFiles = reader.bool();
          break;
        case 20:
          message.javaGenerateEqualsAndHash = reader.bool();
          break;
        case 27:
          message.javaStringCheckUtf8 = reader.bool();
          break;
        case 9:
          message.optimizeFor = reader.int32();
          break;
        case 11:
          message.goPackage = reader.string();
          break;
        case 16:
          message.ccGenericServices = reader.bool();
          break;
        case 17:
          message.javaGenericServices = reader.bool();
          break;
        case 18:
          message.pyGenericServices = reader.bool();
          break;
        case 42:
          message.phpGenericServices = reader.bool();
          break;
        case 23:
          message.deprecated = reader.bool();
          break;
        case 31:
          message.ccEnableArenas = reader.bool();
          break;
        case 36:
          message.objcClassPrefix = reader.string();
          break;
        case 37:
          message.csharpNamespace = reader.string();
          break;
        case 39:
          message.swiftPrefix = reader.string();
          break;
        case 40:
          message.phpClassPrefix = reader.string();
          break;
        case 41:
          message.phpNamespace = reader.string();
          break;
        case 44:
          message.phpMetadataNamespace = reader.string();
          break;
        case 45:
          message.rubyPackage = reader.string();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      javaPackage: isSet111(object.javaPackage) ? String(object.javaPackage) : "",
      javaOuterClassname: isSet111(object.javaOuterClassname) ? String(object.javaOuterClassname) : "",
      javaMultipleFiles: isSet111(object.javaMultipleFiles) ? Boolean(object.javaMultipleFiles) : false,
      javaGenerateEqualsAndHash: isSet111(object.javaGenerateEqualsAndHash) ? Boolean(object.javaGenerateEqualsAndHash) : false,
      javaStringCheckUtf8: isSet111(object.javaStringCheckUtf8) ? Boolean(object.javaStringCheckUtf8) : false,
      optimizeFor: isSet111(object.optimizeFor) ? fileOptions_OptimizeModeFromJSON(object.optimizeFor) : 1,
      goPackage: isSet111(object.goPackage) ? String(object.goPackage) : "",
      ccGenericServices: isSet111(object.ccGenericServices) ? Boolean(object.ccGenericServices) : false,
      javaGenericServices: isSet111(object.javaGenericServices) ? Boolean(object.javaGenericServices) : false,
      pyGenericServices: isSet111(object.pyGenericServices) ? Boolean(object.pyGenericServices) : false,
      phpGenericServices: isSet111(object.phpGenericServices) ? Boolean(object.phpGenericServices) : false,
      deprecated: isSet111(object.deprecated) ? Boolean(object.deprecated) : false,
      ccEnableArenas: isSet111(object.ccEnableArenas) ? Boolean(object.ccEnableArenas) : false,
      objcClassPrefix: isSet111(object.objcClassPrefix) ? String(object.objcClassPrefix) : "",
      csharpNamespace: isSet111(object.csharpNamespace) ? String(object.csharpNamespace) : "",
      swiftPrefix: isSet111(object.swiftPrefix) ? String(object.swiftPrefix) : "",
      phpClassPrefix: isSet111(object.phpClassPrefix) ? String(object.phpClassPrefix) : "",
      phpNamespace: isSet111(object.phpNamespace) ? String(object.phpNamespace) : "",
      phpMetadataNamespace: isSet111(object.phpMetadataNamespace) ? String(object.phpMetadataNamespace) : "",
      rubyPackage: isSet111(object.rubyPackage) ? String(object.rubyPackage) : "",
      uninterpretedOption: Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.javaPackage !== void 0 && (obj.javaPackage = message.javaPackage);
    message.javaOuterClassname !== void 0 && (obj.javaOuterClassname = message.javaOuterClassname);
    message.javaMultipleFiles !== void 0 && (obj.javaMultipleFiles = message.javaMultipleFiles);
    message.javaGenerateEqualsAndHash !== void 0 && (obj.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash);
    message.javaStringCheckUtf8 !== void 0 && (obj.javaStringCheckUtf8 = message.javaStringCheckUtf8);
    message.optimizeFor !== void 0 && (obj.optimizeFor = fileOptions_OptimizeModeToJSON(message.optimizeFor));
    message.goPackage !== void 0 && (obj.goPackage = message.goPackage);
    message.ccGenericServices !== void 0 && (obj.ccGenericServices = message.ccGenericServices);
    message.javaGenericServices !== void 0 && (obj.javaGenericServices = message.javaGenericServices);
    message.pyGenericServices !== void 0 && (obj.pyGenericServices = message.pyGenericServices);
    message.phpGenericServices !== void 0 && (obj.phpGenericServices = message.phpGenericServices);
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    message.ccEnableArenas !== void 0 && (obj.ccEnableArenas = message.ccEnableArenas);
    message.objcClassPrefix !== void 0 && (obj.objcClassPrefix = message.objcClassPrefix);
    message.csharpNamespace !== void 0 && (obj.csharpNamespace = message.csharpNamespace);
    message.swiftPrefix !== void 0 && (obj.swiftPrefix = message.swiftPrefix);
    message.phpClassPrefix !== void 0 && (obj.phpClassPrefix = message.phpClassPrefix);
    message.phpNamespace !== void 0 && (obj.phpNamespace = message.phpNamespace);
    message.phpMetadataNamespace !== void 0 && (obj.phpMetadataNamespace = message.phpMetadataNamespace);
    message.rubyPackage !== void 0 && (obj.rubyPackage = message.rubyPackage);
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFileOptions();
    message.javaPackage = object.javaPackage ?? "";
    message.javaOuterClassname = object.javaOuterClassname ?? "";
    message.javaMultipleFiles = object.javaMultipleFiles ?? false;
    message.javaGenerateEqualsAndHash = object.javaGenerateEqualsAndHash ?? false;
    message.javaStringCheckUtf8 = object.javaStringCheckUtf8 ?? false;
    message.optimizeFor = object.optimizeFor ?? 1;
    message.goPackage = object.goPackage ?? "";
    message.ccGenericServices = object.ccGenericServices ?? false;
    message.javaGenericServices = object.javaGenericServices ?? false;
    message.pyGenericServices = object.pyGenericServices ?? false;
    message.phpGenericServices = object.phpGenericServices ?? false;
    message.deprecated = object.deprecated ?? false;
    message.ccEnableArenas = object.ccEnableArenas ?? false;
    message.objcClassPrefix = object.objcClassPrefix ?? "";
    message.csharpNamespace = object.csharpNamespace ?? "";
    message.swiftPrefix = object.swiftPrefix ?? "";
    message.phpClassPrefix = object.phpClassPrefix ?? "";
    message.phpNamespace = object.phpNamespace ?? "";
    message.phpMetadataNamespace = object.phpMetadataNamespace ?? "";
    message.rubyPackage = object.rubyPackage ?? "";
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.FileOptions", FileOptions);
function createBaseMessageOptions() {
  return {
    messageSetWireFormat: false,
    noStandardDescriptorAccessor: false,
    deprecated: false,
    mapEntry: false,
    deprecatedLegacyJsonFieldConflicts: false,
    uninterpretedOption: []
  };
}
var MessageOptions = {
  $type: "google.protobuf.MessageOptions",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.messageSetWireFormat === true) {
      writer.uint32(8).bool(message.messageSetWireFormat);
    }
    if (message.noStandardDescriptorAccessor === true) {
      writer.uint32(16).bool(message.noStandardDescriptorAccessor);
    }
    if (message.deprecated === true) {
      writer.uint32(24).bool(message.deprecated);
    }
    if (message.mapEntry === true) {
      writer.uint32(56).bool(message.mapEntry);
    }
    if (message.deprecatedLegacyJsonFieldConflicts === true) {
      writer.uint32(88).bool(message.deprecatedLegacyJsonFieldConflicts);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.messageSetWireFormat = reader.bool();
          break;
        case 2:
          message.noStandardDescriptorAccessor = reader.bool();
          break;
        case 3:
          message.deprecated = reader.bool();
          break;
        case 7:
          message.mapEntry = reader.bool();
          break;
        case 11:
          message.deprecatedLegacyJsonFieldConflicts = reader.bool();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      messageSetWireFormat: isSet111(object.messageSetWireFormat) ? Boolean(object.messageSetWireFormat) : false,
      noStandardDescriptorAccessor: isSet111(object.noStandardDescriptorAccessor) ? Boolean(object.noStandardDescriptorAccessor) : false,
      deprecated: isSet111(object.deprecated) ? Boolean(object.deprecated) : false,
      mapEntry: isSet111(object.mapEntry) ? Boolean(object.mapEntry) : false,
      deprecatedLegacyJsonFieldConflicts: isSet111(object.deprecatedLegacyJsonFieldConflicts) ? Boolean(object.deprecatedLegacyJsonFieldConflicts) : false,
      uninterpretedOption: Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.messageSetWireFormat !== void 0 && (obj.messageSetWireFormat = message.messageSetWireFormat);
    message.noStandardDescriptorAccessor !== void 0 && (obj.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor);
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    message.mapEntry !== void 0 && (obj.mapEntry = message.mapEntry);
    message.deprecatedLegacyJsonFieldConflicts !== void 0 && (obj.deprecatedLegacyJsonFieldConflicts = message.deprecatedLegacyJsonFieldConflicts);
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMessageOptions();
    message.messageSetWireFormat = object.messageSetWireFormat ?? false;
    message.noStandardDescriptorAccessor = object.noStandardDescriptorAccessor ?? false;
    message.deprecated = object.deprecated ?? false;
    message.mapEntry = object.mapEntry ?? false;
    message.deprecatedLegacyJsonFieldConflicts = object.deprecatedLegacyJsonFieldConflicts ?? false;
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.MessageOptions", MessageOptions);
function createBaseFieldOptions() {
  return {
    ctype: 0,
    packed: false,
    jstype: 0,
    lazy: false,
    unverifiedLazy: false,
    deprecated: false,
    weak: false,
    debugRedact: false,
    retention: 0,
    target: 0,
    uninterpretedOption: []
  };
}
var FieldOptions = {
  $type: "google.protobuf.FieldOptions",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.ctype !== 0) {
      writer.uint32(8).int32(message.ctype);
    }
    if (message.packed === true) {
      writer.uint32(16).bool(message.packed);
    }
    if (message.jstype !== 0) {
      writer.uint32(48).int32(message.jstype);
    }
    if (message.lazy === true) {
      writer.uint32(40).bool(message.lazy);
    }
    if (message.unverifiedLazy === true) {
      writer.uint32(120).bool(message.unverifiedLazy);
    }
    if (message.deprecated === true) {
      writer.uint32(24).bool(message.deprecated);
    }
    if (message.weak === true) {
      writer.uint32(80).bool(message.weak);
    }
    if (message.debugRedact === true) {
      writer.uint32(128).bool(message.debugRedact);
    }
    if (message.retention !== 0) {
      writer.uint32(136).int32(message.retention);
    }
    if (message.target !== 0) {
      writer.uint32(144).int32(message.target);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFieldOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ctype = reader.int32();
          break;
        case 2:
          message.packed = reader.bool();
          break;
        case 6:
          message.jstype = reader.int32();
          break;
        case 5:
          message.lazy = reader.bool();
          break;
        case 15:
          message.unverifiedLazy = reader.bool();
          break;
        case 3:
          message.deprecated = reader.bool();
          break;
        case 10:
          message.weak = reader.bool();
          break;
        case 16:
          message.debugRedact = reader.bool();
          break;
        case 17:
          message.retention = reader.int32();
          break;
        case 18:
          message.target = reader.int32();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      ctype: isSet111(object.ctype) ? fieldOptions_CTypeFromJSON(object.ctype) : 0,
      packed: isSet111(object.packed) ? Boolean(object.packed) : false,
      jstype: isSet111(object.jstype) ? fieldOptions_JSTypeFromJSON(object.jstype) : 0,
      lazy: isSet111(object.lazy) ? Boolean(object.lazy) : false,
      unverifiedLazy: isSet111(object.unverifiedLazy) ? Boolean(object.unverifiedLazy) : false,
      deprecated: isSet111(object.deprecated) ? Boolean(object.deprecated) : false,
      weak: isSet111(object.weak) ? Boolean(object.weak) : false,
      debugRedact: isSet111(object.debugRedact) ? Boolean(object.debugRedact) : false,
      retention: isSet111(object.retention) ? fieldOptions_OptionRetentionFromJSON(object.retention) : 0,
      target: isSet111(object.target) ? fieldOptions_OptionTargetTypeFromJSON(object.target) : 0,
      uninterpretedOption: Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.ctype !== void 0 && (obj.ctype = fieldOptions_CTypeToJSON(message.ctype));
    message.packed !== void 0 && (obj.packed = message.packed);
    message.jstype !== void 0 && (obj.jstype = fieldOptions_JSTypeToJSON(message.jstype));
    message.lazy !== void 0 && (obj.lazy = message.lazy);
    message.unverifiedLazy !== void 0 && (obj.unverifiedLazy = message.unverifiedLazy);
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    message.weak !== void 0 && (obj.weak = message.weak);
    message.debugRedact !== void 0 && (obj.debugRedact = message.debugRedact);
    message.retention !== void 0 && (obj.retention = fieldOptions_OptionRetentionToJSON(message.retention));
    message.target !== void 0 && (obj.target = fieldOptions_OptionTargetTypeToJSON(message.target));
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFieldOptions();
    message.ctype = object.ctype ?? 0;
    message.packed = object.packed ?? false;
    message.jstype = object.jstype ?? 0;
    message.lazy = object.lazy ?? false;
    message.unverifiedLazy = object.unverifiedLazy ?? false;
    message.deprecated = object.deprecated ?? false;
    message.weak = object.weak ?? false;
    message.debugRedact = object.debugRedact ?? false;
    message.retention = object.retention ?? 0;
    message.target = object.target ?? 0;
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.FieldOptions", FieldOptions);
function createBaseOneofOptions() {
  return { uninterpretedOption: [] };
}
var OneofOptions = {
  $type: "google.protobuf.OneofOptions",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOneofOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      uninterpretedOption: Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseOneofOptions();
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.OneofOptions", OneofOptions);
function createBaseEnumOptions() {
  return { allowAlias: false, deprecated: false, deprecatedLegacyJsonFieldConflicts: false, uninterpretedOption: [] };
}
var EnumOptions = {
  $type: "google.protobuf.EnumOptions",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.allowAlias === true) {
      writer.uint32(16).bool(message.allowAlias);
    }
    if (message.deprecated === true) {
      writer.uint32(24).bool(message.deprecated);
    }
    if (message.deprecatedLegacyJsonFieldConflicts === true) {
      writer.uint32(48).bool(message.deprecatedLegacyJsonFieldConflicts);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.allowAlias = reader.bool();
          break;
        case 3:
          message.deprecated = reader.bool();
          break;
        case 6:
          message.deprecatedLegacyJsonFieldConflicts = reader.bool();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      allowAlias: isSet111(object.allowAlias) ? Boolean(object.allowAlias) : false,
      deprecated: isSet111(object.deprecated) ? Boolean(object.deprecated) : false,
      deprecatedLegacyJsonFieldConflicts: isSet111(object.deprecatedLegacyJsonFieldConflicts) ? Boolean(object.deprecatedLegacyJsonFieldConflicts) : false,
      uninterpretedOption: Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.allowAlias !== void 0 && (obj.allowAlias = message.allowAlias);
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    message.deprecatedLegacyJsonFieldConflicts !== void 0 && (obj.deprecatedLegacyJsonFieldConflicts = message.deprecatedLegacyJsonFieldConflicts);
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEnumOptions();
    message.allowAlias = object.allowAlias ?? false;
    message.deprecated = object.deprecated ?? false;
    message.deprecatedLegacyJsonFieldConflicts = object.deprecatedLegacyJsonFieldConflicts ?? false;
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.EnumOptions", EnumOptions);
function createBaseEnumValueOptions() {
  return { deprecated: false, uninterpretedOption: [] };
}
var EnumValueOptions = {
  $type: "google.protobuf.EnumValueOptions",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.deprecated === true) {
      writer.uint32(8).bool(message.deprecated);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnumValueOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.deprecated = reader.bool();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      deprecated: isSet111(object.deprecated) ? Boolean(object.deprecated) : false,
      uninterpretedOption: Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEnumValueOptions();
    message.deprecated = object.deprecated ?? false;
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.EnumValueOptions", EnumValueOptions);
function createBaseServiceOptions() {
  return { deprecated: false, uninterpretedOption: [] };
}
var ServiceOptions = {
  $type: "google.protobuf.ServiceOptions",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.deprecated === true) {
      writer.uint32(264).bool(message.deprecated);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseServiceOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 33:
          message.deprecated = reader.bool();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      deprecated: isSet111(object.deprecated) ? Boolean(object.deprecated) : false,
      uninterpretedOption: Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseServiceOptions();
    message.deprecated = object.deprecated ?? false;
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.ServiceOptions", ServiceOptions);
function createBaseMethodOptions() {
  return { deprecated: false, idempotencyLevel: 0, uninterpretedOption: [] };
}
var MethodOptions = {
  $type: "google.protobuf.MethodOptions",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.deprecated === true) {
      writer.uint32(264).bool(message.deprecated);
    }
    if (message.idempotencyLevel !== 0) {
      writer.uint32(272).int32(message.idempotencyLevel);
    }
    for (const v of message.uninterpretedOption) {
      UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMethodOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 33:
          message.deprecated = reader.bool();
          break;
        case 34:
          message.idempotencyLevel = reader.int32();
          break;
        case 999:
          message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      deprecated: isSet111(object.deprecated) ? Boolean(object.deprecated) : false,
      idempotencyLevel: isSet111(object.idempotencyLevel) ? methodOptions_IdempotencyLevelFromJSON(object.idempotencyLevel) : 0,
      uninterpretedOption: Array.isArray(object?.uninterpretedOption) ? object.uninterpretedOption.map((e) => UninterpretedOption.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.deprecated !== void 0 && (obj.deprecated = message.deprecated);
    message.idempotencyLevel !== void 0 && (obj.idempotencyLevel = methodOptions_IdempotencyLevelToJSON(message.idempotencyLevel));
    if (message.uninterpretedOption) {
      obj.uninterpretedOption = message.uninterpretedOption.map((e) => e ? UninterpretedOption.toJSON(e) : void 0);
    } else {
      obj.uninterpretedOption = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMethodOptions();
    message.deprecated = object.deprecated ?? false;
    message.idempotencyLevel = object.idempotencyLevel ?? 0;
    message.uninterpretedOption = object.uninterpretedOption?.map((e) => UninterpretedOption.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.MethodOptions", MethodOptions);
function createBaseUninterpretedOption() {
  return {
    name: [],
    identifierValue: "",
    positiveIntValue: 0,
    negativeIntValue: 0,
    doubleValue: 0,
    stringValue: new Uint8Array(),
    aggregateValue: ""
  };
}
var UninterpretedOption = {
  $type: "google.protobuf.UninterpretedOption",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    for (const v of message.name) {
      UninterpretedOption_NamePart.encode(v, writer.uint32(18).fork()).ldelim();
    }
    if (message.identifierValue !== "") {
      writer.uint32(26).string(message.identifierValue);
    }
    if (message.positiveIntValue !== 0) {
      writer.uint32(32).uint64(message.positiveIntValue);
    }
    if (message.negativeIntValue !== 0) {
      writer.uint32(40).int64(message.negativeIntValue);
    }
    if (message.doubleValue !== 0) {
      writer.uint32(49).double(message.doubleValue);
    }
    if (message.stringValue.length !== 0) {
      writer.uint32(58).bytes(message.stringValue);
    }
    if (message.aggregateValue !== "") {
      writer.uint32(66).string(message.aggregateValue);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUninterpretedOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.name.push(UninterpretedOption_NamePart.decode(reader, reader.uint32()));
          break;
        case 3:
          message.identifierValue = reader.string();
          break;
        case 4:
          message.positiveIntValue = longToNumber11(reader.uint64());
          break;
        case 5:
          message.negativeIntValue = longToNumber11(reader.int64());
          break;
        case 6:
          message.doubleValue = reader.double();
          break;
        case 7:
          message.stringValue = reader.bytes();
          break;
        case 8:
          message.aggregateValue = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: Array.isArray(object?.name) ? object.name.map((e) => UninterpretedOption_NamePart.fromJSON(e)) : [],
      identifierValue: isSet111(object.identifierValue) ? String(object.identifierValue) : "",
      positiveIntValue: isSet111(object.positiveIntValue) ? Number(object.positiveIntValue) : 0,
      negativeIntValue: isSet111(object.negativeIntValue) ? Number(object.negativeIntValue) : 0,
      doubleValue: isSet111(object.doubleValue) ? Number(object.doubleValue) : 0,
      stringValue: isSet111(object.stringValue) ? bytesFromBase645(object.stringValue) : new Uint8Array(),
      aggregateValue: isSet111(object.aggregateValue) ? String(object.aggregateValue) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name) {
      obj.name = message.name.map((e) => e ? UninterpretedOption_NamePart.toJSON(e) : void 0);
    } else {
      obj.name = [];
    }
    message.identifierValue !== void 0 && (obj.identifierValue = message.identifierValue);
    message.positiveIntValue !== void 0 && (obj.positiveIntValue = Math.round(message.positiveIntValue));
    message.negativeIntValue !== void 0 && (obj.negativeIntValue = Math.round(message.negativeIntValue));
    message.doubleValue !== void 0 && (obj.doubleValue = message.doubleValue);
    message.stringValue !== void 0 && (obj.stringValue = base64FromBytes5(message.stringValue !== void 0 ? message.stringValue : new Uint8Array()));
    message.aggregateValue !== void 0 && (obj.aggregateValue = message.aggregateValue);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUninterpretedOption();
    message.name = object.name?.map((e) => UninterpretedOption_NamePart.fromPartial(e)) || [];
    message.identifierValue = object.identifierValue ?? "";
    message.positiveIntValue = object.positiveIntValue ?? 0;
    message.negativeIntValue = object.negativeIntValue ?? 0;
    message.doubleValue = object.doubleValue ?? 0;
    message.stringValue = object.stringValue ?? new Uint8Array();
    message.aggregateValue = object.aggregateValue ?? "";
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.UninterpretedOption", UninterpretedOption);
function createBaseUninterpretedOption_NamePart() {
  return { namePart: "", isExtension: false };
}
var UninterpretedOption_NamePart = {
  $type: "google.protobuf.UninterpretedOption.NamePart",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    if (message.namePart !== "") {
      writer.uint32(10).string(message.namePart);
    }
    if (message.isExtension === true) {
      writer.uint32(16).bool(message.isExtension);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUninterpretedOption_NamePart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.namePart = reader.string();
          break;
        case 2:
          message.isExtension = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      namePart: isSet111(object.namePart) ? String(object.namePart) : "",
      isExtension: isSet111(object.isExtension) ? Boolean(object.isExtension) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.namePart !== void 0 && (obj.namePart = message.namePart);
    message.isExtension !== void 0 && (obj.isExtension = message.isExtension);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseUninterpretedOption_NamePart();
    message.namePart = object.namePart ?? "";
    message.isExtension = object.isExtension ?? false;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.UninterpretedOption.NamePart", UninterpretedOption_NamePart);
function createBaseSourceCodeInfo() {
  return { location: [] };
}
var SourceCodeInfo = {
  $type: "google.protobuf.SourceCodeInfo",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    for (const v of message.location) {
      SourceCodeInfo_Location.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSourceCodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.location.push(SourceCodeInfo_Location.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      location: Array.isArray(object?.location) ? object.location.map((e) => SourceCodeInfo_Location.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.location) {
      obj.location = message.location.map((e) => e ? SourceCodeInfo_Location.toJSON(e) : void 0);
    } else {
      obj.location = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSourceCodeInfo();
    message.location = object.location?.map((e) => SourceCodeInfo_Location.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.SourceCodeInfo", SourceCodeInfo);
function createBaseSourceCodeInfo_Location() {
  return { path: [], span: [], leadingComments: "", trailingComments: "", leadingDetachedComments: [] };
}
var SourceCodeInfo_Location = {
  $type: "google.protobuf.SourceCodeInfo.Location",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v of message.path) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.span) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.leadingComments !== "") {
      writer.uint32(26).string(message.leadingComments);
    }
    if (message.trailingComments !== "") {
      writer.uint32(34).string(message.trailingComments);
    }
    for (const v of message.leadingDetachedComments) {
      writer.uint32(50).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSourceCodeInfo_Location();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.path.push(reader.int32());
            }
          } else {
            message.path.push(reader.int32());
          }
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.span.push(reader.int32());
            }
          } else {
            message.span.push(reader.int32());
          }
          break;
        case 3:
          message.leadingComments = reader.string();
          break;
        case 4:
          message.trailingComments = reader.string();
          break;
        case 6:
          message.leadingDetachedComments.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: Array.isArray(object?.path) ? object.path.map((e) => Number(e)) : [],
      span: Array.isArray(object?.span) ? object.span.map((e) => Number(e)) : [],
      leadingComments: isSet111(object.leadingComments) ? String(object.leadingComments) : "",
      trailingComments: isSet111(object.trailingComments) ? String(object.trailingComments) : "",
      leadingDetachedComments: Array.isArray(object?.leadingDetachedComments) ? object.leadingDetachedComments.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path) {
      obj.path = message.path.map((e) => Math.round(e));
    } else {
      obj.path = [];
    }
    if (message.span) {
      obj.span = message.span.map((e) => Math.round(e));
    } else {
      obj.span = [];
    }
    message.leadingComments !== void 0 && (obj.leadingComments = message.leadingComments);
    message.trailingComments !== void 0 && (obj.trailingComments = message.trailingComments);
    if (message.leadingDetachedComments) {
      obj.leadingDetachedComments = message.leadingDetachedComments.map((e) => e);
    } else {
      obj.leadingDetachedComments = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSourceCodeInfo_Location();
    message.path = object.path?.map((e) => e) || [];
    message.span = object.span?.map((e) => e) || [];
    message.leadingComments = object.leadingComments ?? "";
    message.trailingComments = object.trailingComments ?? "";
    message.leadingDetachedComments = object.leadingDetachedComments?.map((e) => e) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.SourceCodeInfo.Location", SourceCodeInfo_Location);
function createBaseGeneratedCodeInfo() {
  return { annotation: [] };
}
var GeneratedCodeInfo = {
  $type: "google.protobuf.GeneratedCodeInfo",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    for (const v of message.annotation) {
      GeneratedCodeInfo_Annotation.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeneratedCodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.annotation.push(GeneratedCodeInfo_Annotation.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      annotation: Array.isArray(object?.annotation) ? object.annotation.map((e) => GeneratedCodeInfo_Annotation.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.annotation) {
      obj.annotation = message.annotation.map((e) => e ? GeneratedCodeInfo_Annotation.toJSON(e) : void 0);
    } else {
      obj.annotation = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGeneratedCodeInfo();
    message.annotation = object.annotation?.map((e) => GeneratedCodeInfo_Annotation.fromPartial(e)) || [];
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.GeneratedCodeInfo", GeneratedCodeInfo);
function createBaseGeneratedCodeInfo_Annotation() {
  return { path: [], sourceFile: "", begin: 0, end: 0, semantic: 0 };
}
var GeneratedCodeInfo_Annotation = {
  $type: "google.protobuf.GeneratedCodeInfo.Annotation",
  encode(message, writer = import_minimal134.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v of message.path) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.sourceFile !== "") {
      writer.uint32(18).string(message.sourceFile);
    }
    if (message.begin !== 0) {
      writer.uint32(24).int32(message.begin);
    }
    if (message.end !== 0) {
      writer.uint32(32).int32(message.end);
    }
    if (message.semantic !== 0) {
      writer.uint32(40).int32(message.semantic);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal134.default.Reader ? input : new import_minimal134.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeneratedCodeInfo_Annotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.path.push(reader.int32());
            }
          } else {
            message.path.push(reader.int32());
          }
          break;
        case 2:
          message.sourceFile = reader.string();
          break;
        case 3:
          message.begin = reader.int32();
          break;
        case 4:
          message.end = reader.int32();
          break;
        case 5:
          message.semantic = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: Array.isArray(object?.path) ? object.path.map((e) => Number(e)) : [],
      sourceFile: isSet111(object.sourceFile) ? String(object.sourceFile) : "",
      begin: isSet111(object.begin) ? Number(object.begin) : 0,
      end: isSet111(object.end) ? Number(object.end) : 0,
      semantic: isSet111(object.semantic) ? generatedCodeInfo_Annotation_SemanticFromJSON(object.semantic) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path) {
      obj.path = message.path.map((e) => Math.round(e));
    } else {
      obj.path = [];
    }
    message.sourceFile !== void 0 && (obj.sourceFile = message.sourceFile);
    message.begin !== void 0 && (obj.begin = Math.round(message.begin));
    message.end !== void 0 && (obj.end = Math.round(message.end));
    message.semantic !== void 0 && (obj.semantic = generatedCodeInfo_Annotation_SemanticToJSON(message.semantic));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGeneratedCodeInfo_Annotation();
    message.path = object.path?.map((e) => e) || [];
    message.sourceFile = object.sourceFile ?? "";
    message.begin = object.begin ?? 0;
    message.end = object.end ?? 0;
    message.semantic = object.semantic ?? 0;
    return message;
  }
};
messageTypeRegistry.set("google.protobuf.GeneratedCodeInfo.Annotation", GeneratedCodeInfo_Annotation);
var globalThis14 = (() => {
  if (typeof globalThis14 !== "undefined") {
    return globalThis14;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase645(b64) {
  if (globalThis14.Buffer) {
    return Uint8Array.from(globalThis14.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis14.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes5(arr) {
  if (globalThis14.Buffer) {
    return globalThis14.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return globalThis14.btoa(bin.join(""));
  }
}
function longToNumber11(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis14.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal134.default.util.Long !== import_long11.default) {
  import_minimal134.default.util.Long = import_long11.default;
  import_minimal134.default.configure();
}
function isSet111(value) {
  return value !== null && value !== void 0;
}

// ../protos/dist/lib/Types.js
var Definition = {
  toSerializable(definition) {
    if (isSerializableServiceDefinition(definition))
      return definition;
    return SerializableServiceDefinition.fromPartial({
      name: definition.name,
      fullName: definition.fullName,
      methods: Object.values(definition.methods).map((method) => {
        return SerializableMethodDefinition.fromPartial({
          fullName: "/" + definition.fullName + "/" + method.name,
          name: method.name,
          requestStream: method.requestStream,
          requestType: method.requestType.$type,
          responseStream: method.responseStream,
          responseType: method.responseType.$type
        });
      })
    });
  },
  fromSerializable(def) {
    const methods = {};
    Object.values(def.methods).forEach((method) => {
      const reqType = messageTypeRegistry.get(method.requestType);
      const rspType = messageTypeRegistry.get(method.responseType);
      if (!reqType) {
        throw new Error(`Request type ${method.requestType} not found`);
      }
      if (!rspType) {
        throw new Error(`Response type ${method.responseType} not found`);
      }
      const name = method.name[0].toLocaleLowerCase() + method.name.slice(1);
      methods[name] = {
        name: method.name,
        requestType: reqType,
        requestStream: method.requestStream,
        responseType: rspType,
        responseStream: method.responseStream
      };
    });
    return {
      fullName: def.fullName,
      name: def.name,
      methods
    };
  }
};
function isSerializableServiceDefinition(definition) {
  return Array.isArray(definition.methods);
}

// src/lib/fetch.polyfill.ts
var httpPlugin;
function getHttpPlugin() {
  if (httpPlugin !== void 0) {
    return httpPlugin;
  }
  const config2 = globalThis?.devvit?.config;
  if (!config2?.uses?.(HTTPDefinition)) {
    throw new Error("To use fetch, you must have Devvit.use(Devvit.Types.HTTP) in your actor!");
  }
  const handler = config2?.use?.(HTTPDefinition, {}) ?? null;
  if (handler === null) {
    throw new Error("fetch polyfill failed to initialize HTTPPlugin");
  }
  return handler;
}
var _headers;
var _Headers = class {
  constructor(init) {
    __privateAdd(this, _headers, /* @__PURE__ */ new Map());
    if (init instanceof _Headers) {
      __privateSet(this, _headers, new Map(Object.entries(__privateGet(init, _headers))));
    } else if (typeof init === "object") {
      const h = Array.isArray(init) ? init : Object.entries(init);
      for (const [name, val] of h) {
        this.set(name, val);
      }
    }
  }
  entries() {
    return __privateGet(this, _headers).entries();
  }
  append(name, val) {
    const current = this.get(name) ?? "";
    this.set(name, `${current},${val}`);
  }
  set(name, val) {
    __privateGet(this, _headers).set(name.toLowerCase(), val);
  }
  get(name) {
    return __privateGet(this, _headers).get(name.toLowerCase()) ?? null;
  }
  delete(name) {
    __privateGet(this, _headers).delete(name.toLowerCase());
  }
  has(name) {
    return this.get(name) !== null;
  }
  forEach(cb, thisArg) {
    __privateGet(this, _headers).forEach((val, name) => {
      cb.call(thisArg, val, name, this);
    });
  }
  keys() {
    return __privateGet(this, _headers).keys();
  }
  values() {
    return __privateGet(this, _headers).values();
  }
};
var Headers = _Headers;
_headers = new WeakMap();
var _options, _url, _bodyUsed;
var Request = class {
  constructor(input, options) {
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _url, void 0);
    __privateAdd(this, _bodyUsed, false);
    if (typeof input == "string") {
      __privateSet(this, _url, input);
      __privateSet(this, _options, options ?? {});
    } else {
      __privateSet(this, _url, __privateGet(input, _url));
      __privateSet(this, _options, { ...__privateGet(input, _options), ...options ?? {} });
    }
    this.headers = new Headers(__privateGet(this, _options).headers);
  }
  get url() {
    return __privateGet(this, _url);
  }
  get method() {
    return __privateGet(this, _options).method ?? "GET";
  }
  // TODO: make this return ReadableStream, but that's a lot more to polyfill...
  get body() {
    throw new Error("Request.body is not implemented");
  }
  // NON-STANDARD way of getting the body as an ArrayBuffer to Avoid ReadableStreams
  getBodyAsArrayBuffer() {
    __privateSet(this, _bodyUsed, true);
    const body = __privateGet(this, _options).body;
    if (typeof body === "string") {
      return new TextEncoder().encode(body);
    } else if (body instanceof ArrayBuffer) {
      return body;
    } else if (typeof body === "object" && "buffer" in body && body.buffer instanceof ArrayBuffer) {
      return body.buffer;
    } else if (typeof body === "undefined") {
      return new ArrayBuffer(0);
    } else {
      throw new Error(
        "Request.body must be a TypedArray, DataView, ArrayBuffer, string, or undefined"
      );
    }
  }
  get bodyUsed() {
    return __privateGet(this, _bodyUsed);
  }
  get mode() {
    return "cors";
  }
  get cache() {
    return "no-cache";
  }
  get credentials() {
    return "omit";
  }
  get destination() {
    return "";
  }
  get integrity() {
    return "";
  }
  // this is expermiental
  get priority() {
    return "auto";
  }
  get redirect() {
    return "follow";
  }
  get referrer() {
    return "";
  }
  get referrerPolicy() {
    return "";
  }
};
_options = new WeakMap();
_url = new WeakMap();
_bodyUsed = new WeakMap();
var _pluginResponse, _headers2, _bodyUsed2, _resultMethodUnimplemented, resultMethodUnimplemented_fn;
var _Response = class {
  constructor(unsupportedFileOrBlob) {
    __privateAdd(this, _resultMethodUnimplemented);
    __privateAdd(this, _pluginResponse, void 0);
    __privateAdd(this, _headers2, void 0);
    __privateAdd(this, _bodyUsed2, false);
    if (unsupportedFileOrBlob !== void 0) {
      throw new Error("Response does not support construction from File or Blob");
    }
  }
  clone() {
    if (__privateGet(this, _pluginResponse) == null) {
      return new _Response();
    }
    return _Response.fromPluginResponse(__privateGet(this, _pluginResponse));
  }
  async arrayBuffer() {
    if (__privateGet(this, _pluginResponse) == null) {
      return new ArrayBuffer(0);
    }
    return __privateGet(this, _pluginResponse).body.buffer;
  }
  async text() {
    __privateSet(this, _bodyUsed2, true);
    const body = await this.arrayBuffer();
    return new TextDecoder().decode(body);
  }
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  get headers() {
    if (__privateGet(this, _headers2) != null) {
      return __privateGet(this, _headers2);
    }
    __privateSet(this, _headers2, new Headers(__privateGet(this, _pluginResponse)?.headers));
    return __privateGet(this, _headers2);
  }
  get bodyUsed() {
    return __privateGet(this, _bodyUsed2);
  }
  get status() {
    return __privateGet(this, _pluginResponse)?.status ?? 200;
  }
  get statusText() {
    throw new Error("Response.statusText() is not implemented, please use Response.status()");
  }
  get ok() {
    return 200 <= this.status && this.status < 300;
  }
  get redirected() {
    return false;
  }
  get type() {
    return "cors";
  }
  get url() {
    return __privateGet(this, _pluginResponse)?.url ?? "";
  }
  get body() {
    return __privateMethod(this, _resultMethodUnimplemented, resultMethodUnimplemented_fn).call(this, "body");
  }
  get blob() {
    return __privateMethod(this, _resultMethodUnimplemented, resultMethodUnimplemented_fn).call(this, "blob()");
  }
  formData() {
    __privateMethod(this, _resultMethodUnimplemented, resultMethodUnimplemented_fn).call(this, "formData()");
  }
  static error() {
    return _Response.fromPluginResponse({
      url: "",
      body: new Uint8Array(0),
      status: 0,
      headers: {}
    });
  }
  static redirect(url, status = 0) {
    return _Response.fromPluginResponse({
      url,
      status,
      body: new Uint8Array(0),
      headers: {}
    });
  }
  /**
   * This method allows us to construct a Response from a PluginResponse,
   * but this should not be considered part of the public api
   */
  static fromPluginResponse(pr) {
    const resp = new _Response();
    __privateSet(resp, _pluginResponse, pr);
    return resp;
  }
};
var Response2 = _Response;
_pluginResponse = new WeakMap();
_headers2 = new WeakMap();
_bodyUsed2 = new WeakMap();
_resultMethodUnimplemented = new WeakSet();
resultMethodUnimplemented_fn = function(method) {
  throw new Error(
    `Response.${method} is not implemented! Please use Response.text() or Response.json().`
  );
};
async function fetch(request, options) {
  const fetchPlugin = getHttpPlugin();
  if (typeof request === "string" || options !== void 0) {
    request = new Request(request, options);
  }
  const pluginResponse = await fetchPlugin.Fetch({
    url: request.url,
    data: {
      method: request.method,
      headers: Object.fromEntries([...request.headers.entries()]),
      body: new Uint8Array(request.getBodyAsArrayBuffer())
    }
  });
  return Response2.fromPluginResponse(pluginResponse);
}
var globalExports = {
  fetch,
  Request,
  Response: Response2,
  Headers
};
var global2 = globalThis;
Object.assign(global2, globalExports);

// ../shared-types/dist/NonNull.js
function assertNonNull(val, msg) {
  if (val == null)
    throw Error(msg ?? "Expected nonnullish value.");
}
function NonNull(val, msg) {
  assertNonNull(val, msg);
  return val;
}

// src/lib/HostnameUtil.ts
var LOCAL_HOSTNAME = "local";
var SUPERVISOR_CNAME = "supervisor";
function resolvePluginHostname(name, namespace) {
  return childHostname(name, Hostname.getPluginNamespace(namespace));
}
function resolveSystemHostname(name, namespace) {
  return childHostname(name, Hostname.getSystemNamespace(namespace));
}
function resolvePluginDefinitionHostname(definition, namespace) {
  return resolvePluginHostname(definition.name, namespace);
}
function childHostname(name, namespace) {
  if (namespace.hostname == null)
    throw Error("Unbound namespace.");
  return `${name}.${namespace.hostname}`.toLocaleLowerCase();
}
function parentHostname(hostnameOrNamespace) {
  const hostname = typeof hostnameOrNamespace === "string" ? hostnameOrNamespace : hostnameOrNamespace.hostname;
  if (hostname == null)
    throw Error("Unbound namespace.");
  return hostname.split(".").slice(1).join(".").toLocaleLowerCase();
}
function isDescendantHostname(lhs, rhs) {
  const suffix = `.${rhs}`;
  return lhs === rhs || lhs.length > suffix.length && lhs.endsWith(suffix);
}
var Hostname;
((Hostname2) => {
  function getChild(hostname) {
    return hostname.split(".")[0];
  }
  Hostname2.getChild = getChild;
  function getRoot(hostname) {
    return NonNull(hostname.split(".").at(-1));
  }
  Hostname2.getRoot = getRoot;
  function getPluginNamespace(namespace) {
    return { hostname: childHostname("plugins", namespace) };
  }
  Hostname2.getPluginNamespace = getPluginNamespace;
  function getSystemNamespace(namespace) {
    return { hostname: childHostname("system", namespace) };
  }
  Hostname2.getSystemNamespace = getSystemNamespace;
  function isPlugin(hostname, namespace) {
    return isDescendantHostname(hostname, NonNull(getPluginNamespace(namespace).hostname));
  }
  Hostname2.isPlugin = isPlugin;
  function isSystem(hostname, namespace) {
    return isDescendantHostname(hostname, NonNull(getSystemNamespace(namespace).hostname));
  }
  Hostname2.isSystem = isSystem;
})(Hostname || (Hostname = {}));

// ../shared-types/dist/debugConfig.js
var isProd = false;
var prod = {
  flushNodeLogs: false,
  logAllEnvelopes: false,
  addDebugUtilsToEnv: false,
  assertEnvelopesPostable: false
};
var debug = {
  flushNodeLogs: true,
  // This environment may only be applied at compilation or only at runtime. For
  // build-only packaging, you must build the code for the environment you want.
  // Be mindful of build caching too. shared-types is a leaf dependency that may
  // not be rebuilt automatically when building another package.
  logAllEnvelopes: typeof process !== "undefined" && false,
  // to-do: add logFilteredEnvelopes.
  addDebugUtilsToEnv: true,
  assertEnvelopesPostable: true
};
var DEBUG_CONFIG = isProd ? prod : debug;

// ../shared-types/dist/PlatformUtil.js
function isWorker() {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope || // Go doesn't polyfill WorkerGlobalScope, but it doesn't execute non-worker code
  // so we know any code it executes is within a worker.
  isPlatformGo();
}
function isPlatformGo() {
  return globalThis.devvit?.compute?.platform === "go";
}
function isPlatformWeb() {
  return !isPlatformGo() && !isPlatformNode();
}
function isPlatformNode() {
  return typeof process !== "undefined" && process.release?.name === "node";
}
function isHeadless() {
  return typeof window === "undefined" || isPlatformGo() || isPlatformNode();
}
function isNativeWorker() {
  return isWorker() && isPlatformGo();
}

// ../shared-types/dist/StringUtil.js
var StringUtil;
(function(StringUtil2) {
  function ellipsize(str, limit) {
    return str.length <= limit ? str : `${str.slice(0, limit - 1)}\u2026`;
  }
  StringUtil2.ellipsize = ellipsize;
  function capitalize(str) {
    if (str[0] == null)
      return str;
    return `${str[0].toLocaleUpperCase()}${str.slice(1)}`;
  }
  StringUtil2.capitalize = capitalize;
  function isBlank(str) {
    return str == null || /^\s*$/.test(str);
  }
  StringUtil2.isBlank = isBlank;
  function caughtToString(val) {
    return val instanceof Error ? `${val.stack || val.message || val.name}` : String(val);
  }
  StringUtil2.caughtToString = caughtToString;
})(StringUtil || (StringUtil = {}));

// src/common/envelope/dispatcher/CentralDispatcher.ts
var import_lru_cache = __toESM(require_lru_cache(), 1);

// ../../node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// ../../node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// ../../node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// ../../node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/lib/Header.ts
var Header = Object.freeze({
  Actor: "devvit-actor",
  App: "devvit-app",
  AppUser: "devvit-app-user",
  Caller: "devvit-caller",
  CallerPortID: "devvit-caller-port-id",
  Canary: "devvit-canary",
  Installation: "devvit-installation",
  ModPermissions: "devvit-mod-permissions",
  R2Auth: "devvit-sec-authorization",
  R2Host: "devvit-r2-host",
  RemoteHostname: "devvit-remote-hostname",
  StreamID: "devvit-stream-id",
  Subreddit: "devvit-subreddit",
  TraceID: "devvit-trace-id",
  User: "devvit-user",
  Version: "devvit-version",
  SettingsUri: "devvit-sec-settings-uri"
});
function isSystemHeader(header) {
  return header.startsWith("devvit-");
}
var allowlistedReadHeaders = Object.freeze([
  Header.AppUser,
  Header.Caller,
  Header.Canary,
  Header.ModPermissions,
  // Warning: this exposes settings URIs across apps.
  Header.SettingsUri,
  Header.StreamID,
  Header.Subreddit,
  Header.TraceID,
  Header.User
]);
function filterHeadersForDestination(namespace, metadata, destination) {
  if (isTrustedLocation(namespace, destination))
    return { ...metadata };
  const allowedEntries = Object.entries(metadata).filter(
    ([header]) => allowlistedReadHeaders.includes(header) || !isSystemHeader(header)
  );
  return Object.fromEntries(allowedEntries);
}
function isTrustedLocation(namespace, location) {
  return (
    // Allow runtime plugin clients, Studio, and test clients to send whatever
    // headers they wish. An actor trusts all Envelopes manufactured in its
    // own thread.
    location === namespace.hostname || Hostname.isPlugin(location, namespace) || Hostname.isSystem(location, namespace)
  );
}

// ../shared-types/dist/Immutable.js
function Immutable(val) {
  if (val == null || typeof val != "object")
    return val;
  for (const subVal of Object.values(val))
    Immutable(subVal);
  return Object.freeze(val);
}

// ../shared-types/dist/findUncloneable.js
var supportedObjectTypes = Immutable(new Set([
  Boolean,
  String,
  Date,
  // to-do: Blob,
  // to-do: File,
  // to-do: FileList,
  ArrayBuffer,
  DataView,
  // to-do: ImageBitmap,
  // to-do: ImageData,
  Array,
  Object,
  Map,
  Set,
  // TypedArray
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  BigInt64Array,
  BigUint64Array,
  // Errors
  // to-do: DOMException
  Error,
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError
].map((type) => type.prototype)));
function findUncloneable(path, dat) {
  if (dat == null)
    return [];
  if (typeof dat === "bigint")
    return [];
  if (typeof dat === "boolean")
    return [];
  if (typeof dat === "function")
    return [path, dat];
  if (typeof dat === "number")
    return [];
  if (typeof dat === "string")
    return [];
  if (typeof dat === "symbol")
    return [path, dat];
  if (dat instanceof RegExp)
    return [path, dat];
  const obj = dat;
  const proto = Object.getPrototypeOf(obj);
  if (obj instanceof Object && proto != null && !isSupportedObjectType(proto))
    return [path, dat];
  for (const [key, val] of Object.entries(obj)) {
    const descendant = findUncloneable(`${path}.${key}`, val);
    if (descendant.length > 0)
      return descendant;
  }
  return [];
}
function isSupportedObjectType(proto) {
  return supportedObjectTypes.has(proto);
}

// src/common/envelope/EnvelopeUtil.ts
function assertEnvelopePostable(envelope) {
  const [path, val] = findUncloneable("envelope", envelope);
  if (path != null)
    throw Error(
      `Envelope is not postable. See value at ${path}: ${String(val)}. This is likely an error in your messaging code or \`assertEnvelopePostable()\`. Only Protobuf generated messages and native Errors can be sent. Please verify you are using \`fromPartial()\` to generate request / response messages and only throwing Error itself, not subclasses.`
    );
}
function envelopeAsError(envelope) {
  if (envelope.message instanceof Error)
    return envelope.message;
  return new Error(envelope.message?.toString().replace(/^Error: /, "") ?? "<unknown>");
}
function getFromMetadata(key, metadata) {
  return metadata?.[key]?.values[0];
}
function extractMetadataTraceID(metadata) {
  return getFromMetadata(Header.TraceID, metadata);
}
function envelopeMethod(def, name) {
  const method = def.methods[name];
  return `/${def.fullName}/${method?.name ?? name}`;
}
function envelopeMethodToName(envelope) {
  const name = NonNull(envelope.method.split("/").at(-1));
  return name[0].toLocaleLowerCase() + name.slice(1);
}
function requestMessageToJSON(message, method) {
  if (message == null)
    return message;
  return method.requestType.toJSON(message);
}
function responseMessageToJSON(message, method) {
  if (!message)
    return message;
  return method.responseType.toJSON(message);
}
function requestMessageFromJSON(envelope, method) {
  if (!envelope.success || !envelope.message)
    return envelope.message;
  return method.requestType.fromJSON(envelope.message);
}
function responseMessageFromJSON(envelope, method) {
  if (!envelope.success || !envelope.message)
    return envelope.message;
  return method.responseType.fromJSON(envelope.message);
}
function sendEnvelopeMessageToStream(envelope, stream) {
  if (envelope.success) {
    if (envelope.complete) {
      if (envelope.message) {
        stream.next(envelope.message);
      }
      stream.complete();
    } else {
      stream.next(envelope.message);
    }
  } else {
    stream.error(envelope.message);
    stream.complete();
  }
}
var EnvelopeUtil;
((EnvelopeUtil2) => {
  function toLogString(envelope) {
    const path = envelope.request ? `${envelope.src} \u2192 ${envelope.dst}` : `${envelope.dst} \u2190 ${envelope.src}`;
    const streamIDOctet = envelope.streamId.split("-")[0];
    const method = StringUtil.capitalize(envelopeMethodToName(envelope));
    return `${path}@${streamIDOctet}/${method}`;
  }
  EnvelopeUtil2.toLogString = toLogString;
})(EnvelopeUtil || (EnvelopeUtil = {}));

// src/lib/loggers/Log.ts
var NAME = typeof self !== "undefined" && self.name || globalThis.location?.hostname || v4_default();
var LogLevel = Object.freeze({
  /**
   * Verbose logs are useful for tracing but usually a hindrance for others not
   * working where the log is placed. Keep our logs clean and add with care.
   *
   * These logs are disabled by default but can be enabled.
   */
  VERBOSE: 0,
  /**
   * Informational logs should be used to mark significant non-erroneous events.
   * Little information is significant.
   *
   * These logs are enabled by default in development builds but disabled in
   * production.
   */
  INFO: 1,
  /**
   * Debug logs should never be committed.
   *
   * These logs are always enabled in development builds but disabled in
   * production.
   */
  DEBUG: 2,
  /**
   * Warnings should be reported as long as they do not contain sensitive data.
   *
   * These logs are always enabled.
   */
  WARN: 3,
  /**
   * Errors should always be reported as long as they do not contain sensitive
   * data.
   *
   * These logs are always enabled.
   */
  ERROR: 4,
  SILENT: 10
});
var LEVEL = LogLevel.VERBOSE;
var LEVEL_PREFIX = Object.freeze({
  [LogLevel.VERBOSE]: "V",
  [LogLevel.INFO]: "I",
  [LogLevel.DEBUG]: "D",
  [LogLevel.WARN]: "W",
  [LogLevel.ERROR]: "E",
  [LogLevel.SILENT]: ""
});
var defaultEnvelopeLoggerConfig = {
  // When debugging local changes, abbreviating lengthy strings is helpful. For
  // unexpected errors in non-debug, it may be harmful.
  abbreviateStrings: !isProd,
  showClientAddress: true,
  showServerAddress: true,
  // We expect browser devtools to be able to compact messages nicely
  // even if they're huge. That's not the case on the server and, in the
  // browser, including messages impedes log aggregation so let's not display
  // them by default there.
  showAllRequestMessages: false,
  showAllResponseMessages: false,
  showAllErrorMessages: true,
  showAllSuccessMessages: false,
  showMetadata: LEVEL <= LogLevel.VERBOSE,
  // If we're in a browser and _not_ in a worker, then we have a much nicer
  // console.log() which allows clicking through the various fields in the
  // DevTools console. Everybody else must stringify.
  stringifyObjects: isHeadless(),
  point: ""
};
function prefix(level, config2 = {}) {
  config2 = { ...defaultEnvelopeLoggerConfig, ...config2 };
  return `${LEVEL_PREFIX[level]}[${config2.abbreviateStrings ? abbreviateName() : NAME}]`;
}
var nodeDebugConsole = Object.freeze({
  async debug(...args) {
    console.debug(...args);
    await flush(process.stdout);
  },
  async info(...args) {
    console.info(...args);
    await flush(process.stdout);
  },
  async log(...args) {
    console.log(...args);
    await flush(process.stdout);
  },
  async warn(...args) {
    console.warn(...args);
    await flush(process.stderr);
  },
  async error(...args) {
    console.error(...args);
    await flush(process.stderr);
  }
});
var voidConsole = Object.freeze({
  debug() {
  },
  info() {
  },
  log() {
  },
  warn() {
  },
  error() {
  }
});
var logger = DEBUG_CONFIG.flushNodeLogs && isPlatformNode() ? nodeDebugConsole : console;
var Log = {
  // These Log APIs are logical. The verbose implementation uses console.debug()
  // because it corresponds to the verbose logging level in Chromium. Similarly,
  // debug uses log as a default.
  verbose: LEVEL > LogLevel.VERBOSE ? () => {
  } : (...args) => logger.debug(prefix(LogLevel.VERBOSE), ...args),
  info: LEVEL > LogLevel.INFO ? () => {
  } : (...args) => logger.info(prefix(LogLevel.INFO), ...args),
  debug: LEVEL > LogLevel.DEBUG ? () => {
  } : (...args) => logger.log(prefix(LogLevel.DEBUG), ...args),
  warn: LEVEL > LogLevel.WARN ? () => {
  } : (...args) => logger.warn(prefix(LogLevel.WARN), ...args),
  error: LEVEL > LogLevel.ERROR ? () => {
  } : (...args) => logger.error(prefix(LogLevel.ERROR), ...args),
  /**
   * Update the base envelope config for all invocations of `Log.envelope()`
   */
  setDefaultConfig(config2) {
    Object.assign(defaultEnvelopeLoggerConfig, config2);
  },
  /**
   * Dump the contents of an envelope to the debug logs.
   *
   * Accepts a logger config partial, which will be mixed with the default logger config
   */
  envelope(envelope, config2 = {}) {
    config2 = { ...defaultEnvelopeLoggerConfig, ...config2 };
    if (isProd)
      return;
    const errSym = envelope.success ? "" : "\u{1F5D9}";
    let streamId = envelope.streamId;
    if (config2.abbreviateStrings)
      streamId = abbreviateUUID(streamId);
    let msg = "";
    if (envelope.request && config2.showAllRequestMessages || !envelope.request && config2.showAllResponseMessages || envelope.success && config2.showAllSuccessMessages || !envelope.success && config2.showAllErrorMessages) {
      msg = envelope.message || envelope;
    }
    if (msg !== "" && config2.stringifyObjects) {
      msg = JSON.stringify(msg);
      if (config2.abbreviateStrings)
        msg = `[msg (${msg.length}) ${StringUtil.ellipsize(msg, 80)}]`;
    }
    let path;
    if (envelope.request)
      path = [envelope.src, "\u2192", envelope.dst];
    else
      path = [envelope.dst, "\u2190", envelope.src];
    if (!config2.showClientAddress)
      path[0] = "Client";
    if (!config2.showServerAddress)
      path[2] = "Server";
    if (config2.abbreviateStrings) {
      path[0] = abbreviateClientHostname(path[0]);
    }
    const method = config2.abbreviateStrings ? envelopeMethodToName(envelope) : envelope.method;
    const requestResponse = `${path.join(" ")}@${streamId}/${method}`;
    let metadata = envelope.metadata;
    if (config2.stringifyObjects)
      metadata = stringifyMetadata(metadata);
    const logs = [
      `${errSym}${config2.point ? `${config2.point} ` : ""}${requestResponse}`
    ];
    if (msg)
      logs.push(msg);
    if (config2.showMetadata)
      logs.push(metadata);
    Log.debug(...logs);
  },
  setLogger(console2) {
    logger = console2;
  }
};
function abbreviateClientHostname(hostname) {
  const uuid = extractHostnameUUID(Hostname.getChild(hostname))[0];
  if (uuid == null)
    return hostname;
  const uuidAbbreviated = abbreviateUUID(uuid);
  const dispatcher2 = Hostname.getChild(parentHostname(hostname));
  return `${uuidAbbreviated}.${dispatcher2}`;
}
function abbreviateName() {
  if (isUUID(NAME))
    return abbreviateUUID(NAME);
  return NAME;
}
function abbreviateUUID(uuid) {
  return uuid.split("-")[0];
}
function extractHostnameUUID(hostname) {
  return hostname.match(/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i) ?? [];
}
function isUUID(str) {
  return /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i.test(str);
}
function stringifyMetadata(metadata) {
  const entries = Object.entries(metadata ?? {});
  if (entries.length == 0)
    return "";
  const entriesStr = entries.map(([header, { values }]) => `${header}: "${values.join(", ")}"`).join(", ");
  return `[meta ${entriesStr}]`;
}
async function flush(stream) {
  await new Promise((resolve) => stream.write("", resolve));
}

// src/common/envelope/IDFactory.ts
var IDLength = 36;
function isIDish(str) {
  return str != null && str.length === IDLength;
}

// src/common/envelope/dispatcher/CentralDispatcher.ts
var _clients, _recipientsByHostname, _supervisor, _streamsByID, _bind2, bind_fn, _dispatchFiltered, dispatchFiltered_fn, _dispatchFilteredRequest, dispatchFilteredRequest_fn, _dispatchFilteredResponse, dispatchFilteredResponse_fn, _dispatchError404, dispatchError404_fn, _evictStreamIfComplete, evictStreamIfComplete_fn, _getSupervisorHostname, getSupervisorHostname_fn, _isFiltered, isFiltered_fn, _isLocalClient, isLocalClient_fn, _isSourceDispatcherOrSupervisor, isSourceDispatcherOrSupervisor_fn, _isWorker, isWorker_fn, _logEnvelope, logEnvelope_fn, _newClientCloseRequestError499, newClientCloseRequestError499_fn, _newFilterError500, newFilterError500_fn, _newStreamEvictionError503, newStreamEvictionError503_fn, _newServiceUnavailableError503, newServiceUnavailableError503_fn, _onStreamEvicting, onStreamEvicting_fn, _postAsync, postAsync_fn, _unbind, unbind_fn;
var CentralDispatcher = class {
  constructor(hostname) {
    __privateAdd(this, _bind2);
    __privateAdd(this, _dispatchFiltered);
    __privateAdd(this, _dispatchFilteredRequest);
    __privateAdd(this, _dispatchFilteredResponse);
    __privateAdd(this, _dispatchError404);
    __privateAdd(this, _evictStreamIfComplete);
    __privateAdd(this, _getSupervisorHostname);
    __privateAdd(this, _isFiltered);
    __privateAdd(this, _isLocalClient);
    __privateAdd(this, _isSourceDispatcherOrSupervisor);
    /** True if executing within a worker. */
    __privateAdd(this, _isWorker);
    __privateAdd(this, _logEnvelope);
    __privateAdd(this, _newClientCloseRequestError499);
    __privateAdd(this, _newFilterError500);
    __privateAdd(this, _newStreamEvictionError503);
    __privateAdd(this, _newServiceUnavailableError503);
    /**
     * Called when a stream is about to be evicted. Do not modify the LRU.
     */
    __privateAdd(this, _onStreamEvicting);
    __privateAdd(this, _postAsync);
    __privateAdd(this, _unbind);
    /**
     * Clients local to the dispatcher. Local clients have the same hostname as
     * the dispatcher and do not appear in #recipientsByHostname which does not
     * permit duplicates.
     */
    __privateAdd(this, _clients, /* @__PURE__ */ new Set());
    /**
     * All known recipients by hostname excluding local clients. Local clients
     * have the same hostname as the dispatcher. The primary worker server also
     * has the same hostname as the dispatcher (eg, supervisor.system.local) but
     * the runtime actor does not (eg, runtime.system.local).
     */
    __privateAdd(this, _recipientsByHostname, {});
    /** Nullish when in a worker, nonnullish in runtime. */
    __privateAdd(this, _supervisor, void 0);
    /**
     * *Response* recipients by stream ID. Never route a request by stream ID.
     * Requests should always be routed by hostname.
     *
     * The recipients may be local clients or external recipients.
     *
     * to-do: never evict local clients.
     */
    __privateAdd(this, _streamsByID, void 0);
    this.hostname = hostname;
    __privateSet(this, _streamsByID, new import_lru_cache.default({ max: 8192, dispose: __privateMethod(this, _onStreamEvicting, onStreamEvicting_fn).bind(this) }));
  }
  /**
   * All known recipients by hostname excluding local clients. Only meant to be
   * used in a debug mode REPL.
   */
  get debugRecipientsByHostname() {
    return DEBUG_CONFIG.addDebugUtilsToEnv ? __privateGet(this, _recipientsByHostname) : void 0;
  }
  /** Local clients. Only meant to be used in a debug mode REPL. */
  get debugClients() {
    return DEBUG_CONFIG.addDebugUtilsToEnv ? __privateGet(this, _clients) : void 0;
  }
  onBind(recipient) {
    __privateMethod(this, _bind2, bind_fn).call(this, recipient);
  }
  onUnbind(other) {
    if (other.hostname == null)
      throw Error("Cannot unbind from unbound dispatcher.");
    __privateMethod(this, _unbind, unbind_fn).call(this, other);
  }
  bind(recipient) {
    if (!__privateMethod(this, _isLocalClient, isLocalClient_fn).call(this, recipient) && this.isBound(recipient))
      throw Error(`Recipient at ${recipient.hostname} already bound.`);
    recipient.onBind(this);
    __privateMethod(this, _bind2, bind_fn).call(this, recipient);
  }
  /** For runtimes only, bind a supervisor client. */
  bindSupervisor(supervisor) {
    __privateSet(this, _supervisor, supervisor);
  }
  isBound(recipient) {
    return __privateGet(this, _clients).has(recipient) || recipient.hostname != null && recipient.hostname in __privateGet(this, _recipientsByHostname);
  }
  unbind(recipient) {
    if (!this.isBound(recipient))
      return;
    __privateMethod(this, _unbind, unbind_fn).call(this, recipient);
    recipient.onUnbind(this);
  }
  async release(recipient) {
    this.unbind(recipient);
    await recipient.dispose();
  }
  post(caller, envelope) {
    if (!isIDish(envelope.id))
      throw Error(`Missing or invalid ID in envelope ${EnvelopeUtil.toLogString(envelope)}.`);
    __privateMethod(this, _postAsync, postAsync_fn).call(this, caller, envelope);
  }
  async dispose() {
    for (const recipient of __privateGet(this, _clients))
      await this.release(recipient);
    for (const recipient of Object.values(__privateGet(this, _recipientsByHostname)))
      await this.release(recipient);
    __privateSet(this, _supervisor, void 0);
  }
};
_clients = new WeakMap();
_recipientsByHostname = new WeakMap();
_supervisor = new WeakMap();
_streamsByID = new WeakMap();
_bind2 = new WeakSet();
bind_fn = function(recipient) {
  assertNonNull(recipient.hostname, "Recipient missing hostname.");
  if (__privateMethod(this, _isLocalClient, isLocalClient_fn).call(this, recipient)) {
    __privateGet(this, _clients).add(recipient);
    return;
  }
  if (recipient.hostname in __privateGet(this, _recipientsByHostname) && __privateGet(this, _recipientsByHostname)[recipient.hostname] !== recipient)
    throw Error(`Server hostname ${recipient.hostname} already bound.`);
  __privateGet(this, _recipientsByHostname)[recipient.hostname] = recipient;
};
_dispatchFiltered = new WeakSet();
dispatchFiltered_fn = function(caller, envelope) {
  __privateMethod(this, _logEnvelope, logEnvelope_fn).call(this, envelope);
  if (envelope.request)
    __privateMethod(this, _dispatchFilteredRequest, dispatchFilteredRequest_fn).call(this, caller, envelope);
  else
    __privateMethod(this, _dispatchFilteredResponse, dispatchFilteredResponse_fn).call(this, caller, envelope);
  __privateMethod(this, _evictStreamIfComplete, evictStreamIfComplete_fn).call(this, envelope);
};
_dispatchFilteredRequest = new WeakSet();
dispatchFilteredRequest_fn = function(caller, envelope) {
  if (!envelope.request)
    throw Error("Expected request envelope.");
  if (!this.isBound(caller))
    throw Error(`Caller ${caller.hostname} must be bound to dispatcher.`);
  const stream = __privateGet(this, _streamsByID).get(envelope.streamId);
  if (stream == null)
    __privateGet(this, _streamsByID).set(envelope.streamId, { requester: caller, request: envelope });
  else if (stream.requester !== caller)
    throw Error(
      `Client recipient ${envelope.src} with request to ${envelope.dst} changed on open stream ${envelope.streamId}.`
    );
  let dst = envelope.dst;
  let searching = true;
  while (searching) {
    const recipient = __privateGet(this, _recipientsByHostname)[dst];
    if (recipient != null) {
      try {
        recipient.post(caller, envelope);
      } catch (err) {
        Log.error(
          `Failed to post request ${EnvelopeUtil.toLogString(
            envelope
          )}: ${StringUtil.caughtToString(err)}`
        );
        if (!isDispatcherErrorEnvelope(envelope))
          __privateMethod(this, _dispatchFiltered, dispatchFiltered_fn).call(this, this, __privateMethod(this, _newServiceUnavailableError503, newServiceUnavailableError503_fn).call(this, envelope));
      }
      return;
    }
    searching = dst.length > 0;
    dst = parentHostname(dst);
  }
  if (!isDispatcherErrorEnvelope(envelope))
    __privateMethod(this, _dispatchError404, dispatchError404_fn).call(this, envelope);
};
_dispatchFilteredResponse = new WeakSet();
dispatchFilteredResponse_fn = function(caller, envelope) {
  if (envelope.request)
    throw Error("Expected response envelope.");
  const stream = __privateGet(this, _streamsByID).get(envelope.streamId);
  if (stream != null) {
    try {
      stream.requester.post(caller, envelope);
    } catch (err) {
      Log.error(
        `Failed to post response ${EnvelopeUtil.toLogString(
          envelope
        )}: ${StringUtil.caughtToString(err)}`
      );
      if (!isDispatcherErrorEnvelope(envelope))
        __privateMethod(this, _dispatchFiltered, dispatchFiltered_fn).call(this, this, __privateMethod(this, _newClientCloseRequestError499, newClientCloseRequestError499_fn).call(this, envelope));
    }
  } else if (!isDispatcherErrorEnvelope(envelope))
    __privateMethod(this, _dispatchError404, dispatchError404_fn).call(this, envelope);
};
_dispatchError404 = new WeakSet();
dispatchError404_fn = function(envelope) {
  const recipients = Object.keys(__privateGet(this, _recipientsByHostname)).sort((lhs, rhs) => lhs.localeCompare(rhs)).join(", ");
  Log.info(
    `Posting 404: ${this.hostname} cannot post envelope from ${envelope.src} for ${envelope.dst} with stream ID ${envelope.streamId}; recipients are ${recipients}.`
  );
  const destination = envelope.src;
  __privateMethod(this, _dispatchFiltered, dispatchFiltered_fn).call(this, this, Envelope.fromPartial({
    id: v4_default(),
    complete: true,
    dst: destination,
    message: Error(`404 ${envelope.dst} not found.`),
    metadata: filterHeadersForDestination(this, envelope.metadata, destination),
    method: envelope.method,
    request: false,
    src: envelope.dst,
    streamId: envelope.streamId,
    success: false,
    traceId: envelope.traceId
  }));
};
_evictStreamIfComplete = new WeakSet();
evictStreamIfComplete_fn = function(envelope) {
  if (envelope.complete && !envelope.request)
    __privateGet(this, _streamsByID).delete(envelope.streamId);
};
_getSupervisorHostname = new WeakSet();
getSupervisorHostname_fn = function() {
  return resolveSystemHostname(SUPERVISOR_CNAME, { hostname: Hostname.getRoot(this.hostname) });
};
_isFiltered = new WeakSet();
isFiltered_fn = function(caller, envelope) {
  return __privateMethod(this, _isWorker, isWorker_fn).call(this) || __privateMethod(this, _isSourceDispatcherOrSupervisor, isSourceDispatcherOrSupervisor_fn).call(this, caller, envelope);
};
_isLocalClient = new WeakSet();
isLocalClient_fn = function(recipient) {
  return recipient.type === "client";
};
_isSourceDispatcherOrSupervisor = new WeakSet();
isSourceDispatcherOrSupervisor_fn = function(caller, envelope) {
  return (
    // From CentralDispatcher to the supervisor.
    caller === __privateGet(this, _supervisor) || // Already filtered by or from the supervisor.
    envelope.src === __privateMethod(this, _getSupervisorHostname, getSupervisorHostname_fn).call(this)
  );
};
_isWorker = new WeakSet();
isWorker_fn = function() {
  return __privateGet(this, _supervisor) == null;
};
_logEnvelope = new WeakSet();
logEnvelope_fn = function(envelope) {
  const isCommonRuntime = !isWorker() && (isPlatformWeb() || isPlatformNode());
  const filterEnvelope = envelope.method === envelopeMethod(SupervisorDefinition, "filter");
  if (DEBUG_CONFIG.logAllEnvelopes && // Only log from the common runtime's global dispatcher and native
  // workers. Native runtimes _only_ execute TypeScript in workers. There's
  // no common runtime and the supervisor pretty much only filters so each
  // user worker must log itself.
  (isCommonRuntime || isNativeWorker()) && // Remove filterEnvelope to log envelope filter request/responses from the
  // runtime to the supervisor and back. This is super noisy and usually
  // interferes with debugging.
  !filterEnvelope)
    Log.envelope(envelope);
};
_newClientCloseRequestError499 = new WeakSet();
newClientCloseRequestError499_fn = function(envelope) {
  const destination = envelope.src;
  return Envelope.fromPartial({
    id: v4_default(),
    complete: true,
    dst: destination,
    message: Error("499 client unavailable."),
    metadata: filterHeadersForDestination(this, envelope.metadata, destination),
    method: envelope.method,
    src: envelope.dst,
    streamId: envelope.streamId,
    traceId: envelope.traceId
  });
};
_newFilterError500 = new WeakSet();
newFilterError500_fn = function(envelope, error) {
  Log.error(StringUtil.caughtToString(error));
  const destination = envelope.src;
  return Envelope.fromPartial({
    id: v4_default(),
    complete: true,
    dst: destination,
    message: Error(
      "500 filter error.",
      // @ts-expect-error
      { cause: error }
    ),
    metadata: filterHeadersForDestination(this, envelope.metadata, destination),
    method: envelope.method,
    request: false,
    src: envelope.dst,
    streamId: envelope.streamId,
    success: false,
    traceId: envelope.traceId
  });
};
_newStreamEvictionError503 = new WeakSet();
newStreamEvictionError503_fn = function(envelope) {
  const destination = envelope.src;
  return Envelope.fromPartial({
    id: v4_default(),
    complete: true,
    dst: destination,
    message: Error("503 stream closed by dispatcher due to envelope stream overflow."),
    metadata: filterHeadersForDestination(this, envelope.metadata, destination),
    method: envelope.method,
    src: envelope.dst,
    streamId: envelope.streamId,
    traceId: envelope.traceId
  });
};
_newServiceUnavailableError503 = new WeakSet();
newServiceUnavailableError503_fn = function(envelope) {
  const destination = envelope.src;
  return Envelope.fromPartial({
    id: v4_default(),
    complete: true,
    dst: destination,
    message: Error("503 service unavailable."),
    metadata: filterHeadersForDestination(this, envelope.metadata, destination),
    method: envelope.method,
    src: envelope.dst,
    streamId: envelope.streamId,
    traceId: envelope.traceId
  });
};
_onStreamEvicting = new WeakSet();
onStreamEvicting_fn = function(stream, streamID, reason) {
  if (reason === "delete")
    return;
  if (__privateGet(this, _clients).has(stream.requester))
    Log.error(
      `Envelope stream overflow. Evicting least recently used stream ${streamID} to local client at ${stream.requester.hostname}.`
    );
  else
    Log.warn(
      `Envelope stream overflow. Evicting least recently used stream ${streamID} associated with recipient at ${stream.requester.hostname}.`
    );
  const envelope = __privateMethod(this, _newStreamEvictionError503, newStreamEvictionError503_fn).call(this, stream.request);
  __privateMethod(this, _logEnvelope, logEnvelope_fn).call(this, envelope);
  try {
    stream.requester.post(this, envelope);
  } catch (err) {
    Log.warn(
      `Failed to post stream eviction error ${EnvelopeUtil.toLogString(
        envelope
      )}. Giving up: ${StringUtil.caughtToString(err)}`
    );
  }
};
_postAsync = new WeakSet();
postAsync_fn = async function(caller, envelope) {
  if (DEBUG_CONFIG.assertEnvelopesPostable)
    assertEnvelopePostable(envelope);
  if (!__privateMethod(this, _isFiltered, isFiltered_fn).call(this, caller, envelope)) {
    assertNonNull(__privateGet(this, _supervisor), "Expected the supervisor to be set.");
    try {
      envelope = await __privateGet(this, _supervisor).Filter(envelope);
    } catch (err) {
      if (isDispatcherErrorEnvelope(envelope)) {
        Log.info(
          `A dispatch error occurred but the attempted envelope already contained a dispatcher error. Giving up: ${StringUtil.caughtToString(err)}`
        );
        __privateMethod(this, _evictStreamIfComplete, evictStreamIfComplete_fn).call(this, envelope);
        return;
      }
      Log.error(
        `Failed to filter envelope ${EnvelopeUtil.toLogString(
          envelope
        )}: ${StringUtil.caughtToString(err)}`
      );
      envelope = __privateMethod(this, _newFilterError500, newFilterError500_fn).call(this, envelope, err);
      __privateMethod(this, _logEnvelope, logEnvelope_fn).call(this, envelope);
      try {
        caller.post(caller, envelope);
      } catch (err2) {
        Log.error(
          `Failed to post envelope filter error ${EnvelopeUtil.toLogString(
            envelope
          )}. Giving up: ${StringUtil.caughtToString(err2)}.`
        );
      }
      __privateMethod(this, _evictStreamIfComplete, evictStreamIfComplete_fn).call(this, envelope);
      return;
    }
  }
  __privateMethod(this, _dispatchFiltered, dispatchFiltered_fn).call(this, caller, envelope);
};
_unbind = new WeakSet();
unbind_fn = function(recipient) {
  if (!this.isBound(recipient))
    return;
  assertNonNull(recipient.hostname, "Recipient missing hostname.");
  if (__privateMethod(this, _isLocalClient, isLocalClient_fn).call(this, recipient))
    __privateGet(this, _clients).delete(recipient);
  else
    delete __privateGet(this, _recipientsByHostname)[recipient.hostname];
};
CentralDispatcher.UNRESOLVED_HOSTNAMES = "";
function isDispatcherErrorEnvelope(envelope) {
  return envelope.message instanceof Error && envelope.complete === true && /^\d\d\d/.test(envelope.message.message) && envelope.request == false && envelope.success == false;
}

// src/common/envelope/PortEnvelopeRecipient.ts
var _port, _dispatcher;
var PortEnvelopeRecipient = class {
  constructor(hostname, port) {
    __privateAdd(this, _port, void 0);
    __privateAdd(this, _dispatcher, void 0);
    this.hostname = hostname;
    __privateSet(this, _port, port);
  }
  post(_caller, envelope) {
    __privateGet(this, _port).postMessage(envelope);
  }
  dispose() {
    __privateGet(this, _port).terminate?.();
    return Promise.resolve();
  }
  onBind(dispatcher2) {
    __privateSet(this, _dispatcher, dispatcher2);
    __privateGet(this, _port).onmessage = (event) => this.onMessage(event);
  }
  onUnbind(_dispatcher4) {
    __privateSet(this, _dispatcher, void 0);
    __privateGet(this, _port).onmessage = null;
  }
  onMessage(event) {
    if (__privateGet(this, _dispatcher) == null)
      throw Error("No dispatcher bound.");
    const envelope = event.data;
    if (!isDescendantHostname(envelope.src, this.hostname) && this.hostname !== CentralDispatcher.UNRESOLVED_HOSTNAMES) {
      throw new Error(`invalid src: ${envelope.src}, expected ${this.hostname}`);
    }
    __privateGet(this, _dispatcher).post(this, envelope);
  }
};
_port = new WeakMap();
_dispatcher = new WeakMap();

// src/common/envelope/dispatcher/WorkerDispatcher.ts
var WorkerDispatcher = class extends CentralDispatcher {
  bindToWorkerPort(port) {
    this.bind(new PortEnvelopeRecipient(CentralDispatcher.UNRESOLVED_HOSTNAMES, port));
  }
  bindSupervisor() {
    throw Error("Workers should not attempt to filter on the supervisor.");
  }
};

// ../../node_modules/rxjs/dist/esm5/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || isFunction(obj.lift) && isFunction(obj.subscribe));
}

// src/plugins/logger/ConsoleLogger.ts
var defaultConsole = Log;
var voidConsole2 = Object.freeze({
  debug() {
  },
  error() {
  },
  info() {
  },
  verbose() {
  },
  warn() {
  }
});
var levelBySeverity = Object.freeze({
  [Severity.DEBUG]: "debug",
  [Severity.ERROR]: "error",
  [Severity.INFO]: "info",
  [Severity.UNRECOGNIZED]: "info",
  [Severity.VERBOSE]: "verbose",
  [Severity.WARN]: "warn"
});
var _logger;
var ConsoleLogger = class {
  constructor(logger2 = defaultConsole) {
    __privateAdd(this, _logger, void 0);
    __privateSet(this, _logger, logger2);
  }
  async Error(log) {
    const origin = [
      log.lineNumber == null ? void 0 : `line ${log.lineNumber}`,
      log.columnNumber == null ? void 0 : `column ${log.columnNumber}`,
      log.fileName == null ? void 0 : `file ${log.fileName}`
    ].filter(Boolean).join(", ");
    const str = [`${log.name}; ${log.message}`, origin, log.stack].filter(Boolean).join("\n");
    __privateGet(this, _logger).error(str);
    return {};
  }
  async Event() {
    return {};
  }
  async Log(log) {
    const level = levelBySeverity[log.severity];
    __privateGet(this, _logger)[level](log.message);
    return {};
  }
};
_logger = new WeakMap();

// src/lib/loggers/SystemLogger.ts
var SystemLogTag = Object.freeze({
  /** A script lifecycle event such as loaded or unloaded. */
  ScriptLifecycle: "ScriptLifecycle",
  /**
   * A script threw an unhandled error when processing a request or response.
   */
  ScriptMessageError: "ScriptMessageError",
  /**
   * A script received a message. The message may be a request or a response.
   */
  ScriptMessageReceived: "ScriptMessageReceived",
  /** A script sent a message.  The message may be a request or a response. */
  ScriptMessageSent: "ScriptMessageSent",
  /**
   * A log recorded by Compute. This may occur in any environment (web, Node.js,
   * worker, Go, etc). All SystemLog-recorded logs are expected to have this
   * tag.
   */
  System: "System"
});
var VoidSystemLogger = class {
  constructor() {
    this.bind = () => {
    };
    this.debug = async () => {
    };
    this.error = async () => {
    };
    this.event = async () => {
    };
    this.info = async () => {
    };
    this.message = async () => {
    };
    this.unbind = async () => {
    };
    this.verbose = async () => {
    };
    this.warn = async () => {
    };
  }
};
var _logger2, _tags, _log, log_fn;
var DefaultSystemLogger = class {
  constructor(...tags) {
    __privateAdd(this, _log);
    /**
     * The underlying Logger client initialized to console output. ConsoleLogger
     * itself is a plugin usually provided to a runtime. However, we're using it
     * like a plain JavaScript object because that's all it is without an
     * EnvelopeServer wrapping it.
     *
     * It's preferable to never actually use the ConsoleLogger implementation
     * since those likely won't be recorded.
     */
    __privateAdd(this, _logger2, new ConsoleLogger());
    __privateAdd(this, _tags, void 0);
    __privateSet(this, _tags, [SystemLogTag.System, ...tags]);
  }
  bind(dispatcher2, namespace = getSystemLoggerWorkerNamespace()) {
    const hostname = resolvePluginDefinitionHostname(LoggerDefinition, namespace);
    const client = EnvelopeClientBuilder.build(hostname, [LoggerDefinition]);
    dispatcher2.bind(client);
    __privateSet(this, _logger2, client);
  }
  async error(errOrMessage, metadata, tags) {
    const errMessage = {
      name: errOrMessage instanceof Error ? errOrMessage.name : "Error",
      message: StringUtil.caughtToString(errOrMessage),
      tags: filterDuplicates([...__privateGet(this, _tags), ...tags ?? []]),
      // Default to now.
      timestamp: /* @__PURE__ */ new Date()
    };
    await __privateGet(this, _logger2).Error(errMessage, metadata);
  }
  async event(type, labels, data, metadata) {
    await __privateGet(this, _logger2).Event(
      { type, labels: labels ?? {}, data: data ?? {}, timestamp: /* @__PURE__ */ new Date() },
      metadata
    );
  }
  info(message, metadata, tags) {
    return __privateMethod(this, _log, log_fn).call(this, message, Severity.INFO, metadata, tags);
  }
  message(envelope, tagOrError) {
    if (isMessageSystemLogTag(tagOrError))
      return this.verbose(EnvelopeUtil.toLogString(envelope), envelope.metadata, [tagOrError]);
    return this.error(tagOrError, envelope.metadata, [SystemLogTag.ScriptMessageError]);
  }
  async unbind(dispatcher2) {
    if (!(__privateGet(this, _logger2) instanceof ConsoleLogger)) {
      await dispatcher2.release(__privateGet(this, _logger2));
    }
    __privateSet(this, _logger2, new ConsoleLogger());
  }
  verbose(message, metadata, tags) {
    return __privateMethod(this, _log, log_fn).call(this, message, Severity.VERBOSE, metadata, tags);
  }
  warn(message, metadata, tags) {
    return __privateMethod(this, _log, log_fn).call(this, message, Severity.WARN, metadata, tags);
  }
};
_logger2 = new WeakMap();
_tags = new WeakMap();
_log = new WeakSet();
log_fn = async function(message, severity, metadata, tags) {
  const logMessage = {
    message,
    severity,
    tags: filterDuplicates([...__privateGet(this, _tags), ...tags ?? []]),
    timestamp: /* @__PURE__ */ new Date()
  };
  await __privateGet(this, _logger2).Log(logMessage, metadata);
};
function filterDuplicates(array) {
  return [...new Set(array)];
}
function getSystemLoggerWorkerNamespace() {
  if (isPlatformWeb())
    return { hostname: LOCAL_HOSTNAME };
  return { hostname: Hostname.getRoot(self.name) };
}
function isMessageSystemLogTag(val) {
  return val === "ScriptMessageReceived" || val === "ScriptMessageSent";
}

// src/common/envelope/EnvelopeClientBuilder.ts
var EnvelopeClientBuilder = class {
  static build(serverHostname, knows, logger2 = new VoidSystemLogger(), idFactory = v4_default) {
    return new EnvelopeClient(serverHostname, knows, idFactory, logger2);
  }
};
var _idFactory, _dispatcher2, _callbacksByStreamID, _logger3, _createAsyncMethod, createAsyncMethod_fn, _createSourceHandler, createSourceHandler_fn, _createSinkHandler, createSinkHandler_fn, _createPipeHandler, createPipeHandler_fn, _emitRequestStreamAsEnvelopes, emitRequestStreamAsEnvelopes_fn, _postDispatcher, postDispatcher_fn;
var EnvelopeClient = class {
  constructor(serverHostname, knows, idFactory, logger2) {
    __privateAdd(this, _createAsyncMethod);
    // I emit a stream of values.  This is like a tail.
    __privateAdd(this, _createSourceHandler);
    // I expect a stream of values.  This might produce e.g. the sum of the input stream.
    __privateAdd(this, _createSinkHandler);
    __privateAdd(this, _createPipeHandler);
    __privateAdd(this, _emitRequestStreamAsEnvelopes);
    __privateAdd(this, _postDispatcher);
    this.type = "client";
    __privateAdd(this, _idFactory, void 0);
    __privateAdd(this, _dispatcher2, void 0);
    __privateAdd(this, _callbacksByStreamID, {});
    __privateAdd(this, _logger3, void 0);
    this.serverHostname = serverHostname;
    this.id = idFactory();
    __privateSet(this, _idFactory, idFactory);
    __privateSet(this, _logger3, logger2);
    for (const definition of knows) {
      for (const method of Object.values(definition.methods)) {
        if (method.requestStream && method.responseStream) {
          this[method.name] = __privateMethod(this, _createPipeHandler, createPipeHandler_fn).call(this, definition, method).bind(this);
        } else if (method.requestStream && !method.responseStream) {
          this[method.name] = __privateMethod(this, _createSinkHandler, createSinkHandler_fn).call(this, definition, method).bind(this);
        } else if (!method.requestStream && method.responseStream) {
          this[method.name] = __privateMethod(this, _createSourceHandler, createSourceHandler_fn).call(this, definition, method).bind(this);
        } else if (!method.requestStream && !method.responseStream) {
          this[method.name] = __privateMethod(this, _createAsyncMethod, createAsyncMethod_fn).call(this, definition, method).bind(this);
        } else {
          throw new Error(
            `Unsupported "${definition.name}" client method request / response definition.`
          );
        }
      }
    }
  }
  /**
   * Client hostnames always match their dispatcher. This is not a property
   * unique to clients.
   *
   * |                         |                        |                         |                                                                    |
   * | ----------------------- | ---------------------- | ----------------------- | ------------------------------------------------------------------ |
   * | Client                  | Server                 | Dispatcher              | Description                                                        |
   * | local                   | inspector.plugins.node | local                   | One of the local runtime's clients to a remote server's inspector. |
   * | local                   | logger.plugins.local   | local                   | One of the local runtime's clients to a local logger.              |
   * | node                    | supervisor.system.node | node                    | One of the Node.js runtime's clients to the local supervisor.      |
   * | supervisor.system.local | runtime.system.local   | supervisor.system.local | One of the supervisor's clients to the local runtime.              |
   *
   * When issuing requests, this is the Envelope.src. When receiving responses,
   * this is the nondistinct Envelope.dst. The client's dispatcher is expected
   * resolve by stream ID since the hostname is not unique among its clients.
   */
  get hostname() {
    return __privateGet(this, _dispatcher2)?.hostname;
  }
  async onBind(dispatcher2) {
    if (__privateGet(this, _dispatcher2) != null)
      throw Error(`Dispatcher: "${__privateGet(this, _dispatcher2).hostname}" already bound.`);
    __privateSet(this, _dispatcher2, dispatcher2);
  }
  async onUnbind(_dispatcher4) {
    __privateSet(this, _dispatcher2, void 0);
  }
  // Called by dispatcher only, to send responses to the client.
  post(_caller, envelope) {
    __privateGet(this, _logger3).message(envelope, SystemLogTag.ScriptMessageReceived);
    if (__privateGet(this, _callbacksByStreamID)[envelope.streamId] == null)
      throw Error(
        `Missing callbacks for stream ID "${envelope.streamId}" for envelope to ${envelope.dst} from ${envelope.src}.`
      );
    if (envelope.request)
      throw Error("Clients cannot be posted request Envelopes.");
    __privateGet(this, _callbacksByStreamID)[envelope.streamId](envelope);
    if (envelope.complete) {
      delete __privateGet(this, _callbacksByStreamID)[envelope.streamId];
    }
  }
  async dispose() {
    await __privateGet(this, _dispatcher2)?.release(this);
  }
};
_idFactory = new WeakMap();
_dispatcher2 = new WeakMap();
_callbacksByStreamID = new WeakMap();
_logger3 = new WeakMap();
_createAsyncMethod = new WeakSet();
createAsyncMethod_fn = function(definition, method) {
  return (message, metadata) => {
    const streamID = __privateGet(this, _idFactory).call(this);
    const traceID = extractMetadataTraceID(metadata) || __privateGet(this, _idFactory).call(this);
    return new Promise((resolve, reject) => {
      __privateGet(this, _callbacksByStreamID)[streamID] = (envelope) => {
        if (envelope.success) {
          resolve(responseMessageFromJSON(envelope, method));
        } else {
          reject(envelopeAsError(envelope));
        }
      };
      __privateMethod(this, _postDispatcher, postDispatcher_fn).call(this, {
        complete: true,
        message: requestMessageToJSON(message, method),
        metadata,
        method: envelopeMethod(definition, method.name),
        request: true,
        streamId: streamID,
        success: true,
        traceId: traceID
      });
    });
  };
};
_createSourceHandler = new WeakSet();
createSourceHandler_fn = function(definition, method) {
  return (message, metadata) => {
    const streamID = __privateGet(this, _idFactory).call(this);
    const traceID = extractMetadataTraceID(metadata) || __privateGet(this, _idFactory).call(this);
    return new Observable((subscriber) => {
      if (__privateGet(this, _callbacksByStreamID)[streamID]) {
        throw new Error("Multiple subscribers to a source is not supported");
      }
      __privateGet(this, _callbacksByStreamID)[streamID] = (envelope) => {
        envelope.message = responseMessageFromJSON(envelope, method);
        sendEnvelopeMessageToStream(envelope, subscriber);
      };
      __privateMethod(this, _postDispatcher, postDispatcher_fn).call(this, {
        complete: true,
        message: requestMessageToJSON(message, method),
        metadata,
        method: envelopeMethod(definition, method.name),
        request: true,
        streamId: streamID,
        success: true,
        traceId: traceID
      });
    });
  };
};
_createSinkHandler = new WeakSet();
createSinkHandler_fn = function(definition, method) {
  return (messages, metadata) => {
    const streamID = __privateGet(this, _idFactory).call(this);
    const traceID = extractMetadataTraceID(metadata) || __privateGet(this, _idFactory).call(this);
    const response = new Promise((resolve, reject) => {
      __privateGet(this, _callbacksByStreamID)[streamID] = (envelope) => {
        if (envelope.success) {
          resolve(responseMessageFromJSON(envelope, method));
        } else {
          reject(envelopeAsError(envelope));
        }
      };
    });
    __privateMethod(this, _emitRequestStreamAsEnvelopes, emitRequestStreamAsEnvelopes_fn).call(this, definition, method, streamID, traceID, messages, metadata);
    return response;
  };
};
_createPipeHandler = new WeakSet();
createPipeHandler_fn = function(definition, method) {
  return (messages, metadata) => {
    const streamID = __privateGet(this, _idFactory).call(this);
    const traceID = extractMetadataTraceID(metadata) || __privateGet(this, _idFactory).call(this);
    return new Observable((subscriber) => {
      __privateGet(this, _callbacksByStreamID)[streamID] = (envelope) => {
        envelope.message = responseMessageFromJSON(envelope, method);
        sendEnvelopeMessageToStream(envelope, subscriber);
      };
      __privateMethod(this, _emitRequestStreamAsEnvelopes, emitRequestStreamAsEnvelopes_fn).call(this, definition, method, streamID, traceID, messages, metadata);
    });
  };
};
_emitRequestStreamAsEnvelopes = new WeakSet();
emitRequestStreamAsEnvelopes_fn = function(definition, method, streamID, traceID, reqStream, metadata) {
  const envelope = {
    metadata,
    method: envelopeMethod(definition, method.name),
    request: true,
    streamId: streamID,
    traceId: traceID
  };
  reqStream.subscribe({
    next: (message) => __privateMethod(this, _postDispatcher, postDispatcher_fn).call(this, {
      ...envelope,
      complete: false,
      message: requestMessageToJSON(message, method),
      success: true
    }),
    error: (error) => __privateMethod(this, _postDispatcher, postDispatcher_fn).call(this, { ...envelope, complete: true, message: error, success: false }),
    complete: () => __privateMethod(this, _postDispatcher, postDispatcher_fn).call(this, { ...envelope, complete: true, message: void 0, success: true })
  });
};
_postDispatcher = new WeakSet();
postDispatcher_fn = function(partialEnvelope) {
  const envelope = Envelope.fromPartial({
    ...partialEnvelope,
    dst: this.serverHostname,
    id: __privateGet(this, _idFactory).call(this),
    src: this.hostname
  });
  __privateGet(this, _logger3).message(envelope, SystemLogTag.ScriptMessageSent);
  if (__privateGet(this, _dispatcher2) == null)
    throw Error("No dispatcher bound to client:" + this.hostname);
  __privateGet(this, _dispatcher2).post(this, envelope);
};

// src/common/envelope/EnvelopeServerBuilder.ts
var EnvelopeServerBuilder = class {
  static build(name, provides, actor, logger2 = new VoidSystemLogger(), idFactory = v4_default) {
    return new EnvelopeServer(name, provides, actor, idFactory, logger2);
  }
};
var _dispatcher3, _requestStreamsById, _responseStreamsById, _actor, _id, _idFactory2, _methodsByName, _logger4, _handleAsync, handleAsync_fn, _handleSource, handleSource_fn, _handleSink, handleSink_fn, _handlePipe, handlePipe_fn, _emitResponseStreamAsEnvelopes, emitResponseStreamAsEnvelopes_fn, _postDispatcher2, postDispatcher_fn2;
var EnvelopeServer = class {
  constructor(hostname, provides, actor, idFactory, logger2) {
    __privateAdd(this, _handleAsync);
    /** You could implement `tail foo.text` with this. */
    __privateAdd(this, _handleSource);
    /** Accepts many request messages, returns a single response. i.e `tail foo > sink`. */
    __privateAdd(this, _handleSink);
    /** `echo foo|tail`. this is the pipe between echo and tail. */
    __privateAdd(this, _handlePipe);
    __privateAdd(this, _emitResponseStreamAsEnvelopes);
    __privateAdd(this, _postDispatcher2);
    __privateAdd(this, _dispatcher3, void 0);
    __privateAdd(this, _requestStreamsById, {});
    __privateAdd(this, _responseStreamsById, {});
    __privateAdd(this, _actor, void 0);
    __privateAdd(this, _id, void 0);
    __privateAdd(this, _idFactory2, void 0);
    __privateAdd(this, _methodsByName, /* @__PURE__ */ Object.create(null));
    __privateAdd(this, _logger4, void 0);
    if (actor == null)
      throw Error(
        "EnvelopeServer requires a nonnullish actor to forward requests to and await responses from."
      );
    this.hostname = hostname;
    __privateSet(this, _actor, actor);
    __privateSet(this, _id, idFactory());
    __privateSet(this, _idFactory2, idFactory);
    __privateSet(this, _logger4, logger2);
    for (const definition of provides) {
      for (const method of Object.values(definition.methods)) {
        __privateGet(this, _methodsByName)[envelopeMethod(definition, method.name)] = method;
      }
    }
  }
  onBind(dispatcher2) {
    if (!dispatcher2.hostname || !isDescendantHostname(this.hostname, dispatcher2.hostname)) {
      throw new Error(
        `Server's hostname (${this.hostname}) must match or be under *.[dispatcher-hostname] (${dispatcher2.hostname}).`
      );
    }
    __privateSet(this, _dispatcher3, dispatcher2);
  }
  onUnbind(_dispatcher4) {
    __privateSet(this, _dispatcher3, void 0);
  }
  // Should only be called by the dispatcher
  post(_caller, envelope) {
    __privateGet(this, _logger4).message(envelope, SystemLogTag.ScriptMessageReceived);
    const definition = __privateGet(this, _methodsByName)[envelope.method];
    if (!definition) {
      throw new Error(`Service definition does not provide method "${envelope.method}".`);
    }
    const method = __privateGet(this, _actor)[definition.name]?.bind(__privateGet(this, _actor));
    if (method == null)
      throw Error(`Service does not implement "${definition.name}" method.`);
    if (definition.requestStream && definition.responseStream) {
      __privateMethod(this, _handlePipe, handlePipe_fn).call(this, method, envelope, definition);
    } else if (definition.requestStream && !definition.responseStream) {
      __privateMethod(this, _handleSink, handleSink_fn).call(this, method, envelope, definition);
    } else if (!definition.requestStream && definition.responseStream) {
      __privateMethod(this, _handleSource, handleSource_fn).call(this, method, envelope, definition);
    } else if (!definition.requestStream && !definition.responseStream) {
      __privateMethod(this, _handleAsync, handleAsync_fn).call(this, method, envelope, definition);
    } else {
      throw new Error(
        `Unsupported "${definition.name}" service method request / response definition.`
      );
    }
  }
  // todo: should this call this.#actor.dispose?.();
  async dispose() {
    for (const streamId of Object.keys(__privateGet(this, _responseStreamsById))) {
      __privateGet(this, _responseStreamsById)[streamId].unsubscribe();
    }
    for (const streamId of Object.keys(__privateGet(this, _requestStreamsById))) {
      __privateGet(this, _requestStreamsById)[streamId].error(new Error("EnvelopeServer is going away"));
    }
  }
};
_dispatcher3 = new WeakMap();
_requestStreamsById = new WeakMap();
_responseStreamsById = new WeakMap();
_actor = new WeakMap();
_id = new WeakMap();
_idFactory2 = new WeakMap();
_methodsByName = new WeakMap();
_logger4 = new WeakMap();
_handleAsync = new WeakSet();
handleAsync_fn = async function(method, req, definition) {
  const envelope = {
    complete: true,
    dst: req.src,
    metadata: req.metadata,
    method: req.method,
    request: false,
    src: req.dst,
    streamId: req.streamId,
    traceId: req.traceId
  };
  const promisedMessage = method(requestMessageFromJSON(req, definition), req.metadata);
  assertPromise(promisedMessage);
  try {
    const message = await promisedMessage;
    __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, {
      ...envelope,
      message: responseMessageToJSON(message, definition),
      success: true
    });
  } catch (err) {
    await __privateGet(this, _logger4).message(req, err);
    __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, { ...envelope, message: StringUtil.caughtToString(err) });
  }
};
_handleSource = new WeakSet();
handleSource_fn = function(method, req, definition) {
  if (!req.request || !req.success) {
    Log.warn(
      `Received response (${!req.request}) or erroneous envelope (${!req.success}). Closing stream ${req.streamId}.`
    );
    __privateGet(this, _responseStreamsById)[req.streamId]?.unsubscribe();
    delete __privateGet(this, _responseStreamsById)[req.streamId];
    return;
  }
  const responseStream = method(requestMessageFromJSON(req, definition), req.metadata);
  assertObservable(responseStream);
  __privateMethod(this, _emitResponseStreamAsEnvelopes, emitResponseStreamAsEnvelopes_fn).call(this, responseStream, req, definition);
};
_handleSink = new WeakSet();
handleSink_fn = async function(method, req, definition) {
  let requestStream = __privateGet(this, _requestStreamsById)[req.streamId];
  if (requestStream) {
    req.message = requestMessageFromJSON(req, definition);
    sendEnvelopeMessageToStream(req, requestStream);
  } else {
    __privateGet(this, _requestStreamsById)[req.streamId] = requestStream = new ReplaySubject(1);
    req.message = requestMessageFromJSON(req, definition);
    sendEnvelopeMessageToStream(req, requestStream);
    const envelope = {
      complete: true,
      dst: req.src,
      metadata: req.metadata,
      method: req.method,
      request: false,
      src: req.dst,
      streamId: req.streamId,
      traceId: req.traceId
    };
    const promisedMessage = method(requestStream, req.metadata);
    assertPromise(promisedMessage);
    try {
      const message = await promisedMessage;
      __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, {
        ...envelope,
        message: responseMessageToJSON(message, definition),
        success: true
      });
    } catch (err) {
      await __privateGet(this, _logger4).message(req, err);
      __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, {
        ...envelope,
        message: StringUtil.caughtToString(err),
        success: false
      });
    }
  }
};
_handlePipe = new WeakSet();
handlePipe_fn = function(method, req, definition) {
  let requestStream = __privateGet(this, _requestStreamsById)[req.streamId];
  if (requestStream) {
    req.message = requestMessageFromJSON(req, definition);
    sendEnvelopeMessageToStream(req, requestStream);
  } else {
    __privateGet(this, _requestStreamsById)[req.streamId] = requestStream = new ReplaySubject(1);
    req.message = requestMessageFromJSON(req, definition);
    sendEnvelopeMessageToStream(req, requestStream);
    const responseStream = method(requestStream, req.metadata);
    assertObservable(responseStream);
    __privateMethod(this, _emitResponseStreamAsEnvelopes, emitResponseStreamAsEnvelopes_fn).call(this, responseStream, req, definition);
  }
};
_emitResponseStreamAsEnvelopes = new WeakSet();
emitResponseStreamAsEnvelopes_fn = function(stream, req, definition) {
  const envelope = {
    dst: req.src,
    metadata: req.metadata,
    method: req.method,
    request: false,
    src: req.dst,
    streamId: req.streamId,
    traceId: req.traceId
  };
  if (__privateGet(this, _responseStreamsById)[req.streamId]) {
    console.warn("Already had a stream id for", req.streamId);
  }
  __privateGet(this, _responseStreamsById)[req.streamId] = stream.pipe(
    // Filter errors with something supporting async, then rethrow.
    catchError(async (err) => {
      await __privateGet(this, _logger4).message(req, err);
      throw err;
    })
  ).subscribe({
    next: (message) => __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, {
      ...envelope,
      complete: false,
      message: responseMessageToJSON(message, definition),
      success: true
    }),
    error: (err) => __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, { ...envelope, complete: true, message: err, success: false }),
    complete: () => __privateMethod(this, _postDispatcher2, postDispatcher_fn2).call(this, { ...envelope, complete: true, message: void 0, success: true })
  });
};
_postDispatcher2 = new WeakSet();
postDispatcher_fn2 = function(partialEnvelope) {
  if (!__privateGet(this, _dispatcher3))
    throw Error("No dispatcher bound to server: " + this.hostname + " - " + __privateGet(this, _id));
  const envelope = Envelope.fromPartial({ ...partialEnvelope, id: __privateGet(this, _idFactory2).call(this) });
  __privateGet(this, _logger4).message(envelope, SystemLogTag.ScriptMessageSent);
  __privateGet(this, _dispatcher3).post(this, envelope);
};
function assertPromise(val) {
  const keys = ["catch", "then"];
  if (val == null || typeof val !== "object" || keys.some((key) => !(key in val)))
    throw Error("Expected Promise.");
}
function assertObservable(val) {
  if (!isObservable(val))
    throw Error("Expected Observable.");
}

// src/plugins/redditapi/apiMappings.ts
var RedditAPIMappings = {
  /* ----------------------- LISTINGS ---------------------*/
  Best: {
    method: "get",
    path: "/best.json?after={after}&before={before}&count={count}&limit={limit}&show={show}"
  },
  ById: {
    method: "get",
    path: "/by_id/{postIds}.json"
  },
  Comments: {
    method: "get",
    path: "/comments/{article}.json?comment={comment}&context={context}&depth={depth}&limit={limit}&showedits={showedits}&sort={sort}&threaded={threaded}&truncate={truncate}"
  },
  Duplicates: {
    method: "get",
    path: "/duplicates/{article}.json?before={before}&after={after}&limit={limit}&sort={sort}&sr={sr}&count={count}&crossposts_only={crosspostsOnly}&show={show}"
  },
  Hot: {
    method: "get",
    path: "{/r/subreddit}/hot.json?after={after}&before={before}&count={count}&limit={limit}&show={show}&g={g}"
  },
  New: {
    method: "get",
    path: "{/r/subreddit}/new.json?after={after}&before={before}&count={count}&limit={limit}&show={show}"
  },
  Rising: {
    method: "get",
    path: "{/r/subreddit}/rising.json?after={after}&before={before}&count={count}&limit={limit}&show={show}"
  },
  Sort: {
    method: "get",
    path: "{/r/subreddit}/{sort}.json?after={after}&before={before}&limit={limit}&count={count}&show={show}&t={t}"
  },
  /* ----------------------- PRIVATE MESSAGES ---------------------*/
  Block: {
    method: "post",
    path: "/api/block",
    body: "*form"
  },
  CollapseMessage: {
    method: "post",
    path: "/api/collapse_message.json",
    body: "*"
  },
  Compose: {
    method: "post",
    path: "/api/compose",
    body: "*form.snake"
  },
  DelMsg: {
    method: "post",
    path: "/api/del_msg.json",
    body: "*",
    enforceJson: true
  },
  ReadAllMessages: {
    method: "post",
    path: "/api/read_all_messages.json",
    body: "*"
  },
  ReadMessage: {
    method: "post",
    path: "/api/read_message.json",
    body: "*"
  },
  UnblockSubreddit: {
    method: "post",
    path: "/api/unblock_subreddit.json",
    body: "*"
  },
  UncollapseMessage: {
    method: "post",
    path: "/api/uncollapse_message.json",
    body: "*"
  },
  UnreadMessage: {
    method: "post",
    path: "/api/unread_message.json",
    body: "*"
  },
  MessageWhere: {
    method: "get",
    path: "/message/{where}.json?mark={mark}&mid={mid}&after={after}&before={before}&count={count}&limit={limit}&show={show}"
  },
  /* ----------------------- LINKS & COMMENTS ---------------------*/
  Comment: {
    method: "post",
    path: "/api/comment",
    body: "*form.snake",
    enforceJson: true
  },
  Del: {
    method: "post",
    path: "/api/del",
    body: "*form"
  },
  EditUserText: {
    method: "post",
    path: "/api/editusertext",
    body: "*form.snake",
    enforceJson: true
  },
  EventPostTime: {
    method: "post",
    path: "/api/event_post_time",
    body: "*form.snake"
  },
  FollowPost: {
    method: "post",
    path: "/api/follow_post",
    body: "*form.snake"
  },
  Hide: {
    method: "post",
    path: "/api/hide",
    body: "*form.snake"
  },
  Info: {
    method: "get",
    path: "/api/info.json?sr_name={subreddits}&id={thingIds}&url={url}"
  },
  Lock: {
    method: "post",
    path: "/api/lock",
    body: "*form.snake"
  },
  MarkNSFW: {
    method: "post",
    path: "/api/marknsfw",
    body: "*form.snake"
  },
  MoreChildren: {
    method: "get",
    path: "/api/morechildren?children={children}&depth={depth}&id={id}&limit_children={limitChildren}&link_id={linkId}&sort={sort}&api_type=json"
  },
  Report: {
    method: "post",
    path: "/api/report",
    body: "*form.snake",
    enforceJson: true
  },
  ReportAward: {
    method: "post",
    path: "/api/report_award",
    body: "*form.snake"
  },
  Save: {
    method: "post",
    path: "/api/save",
    body: "*form.snake"
  },
  SavedCategories: {
    method: "get",
    path: "/api/saved_categories"
  },
  SendReplies: {
    method: "post",
    path: "/api/sendreplies",
    body: "*form.snake"
  },
  SetContestMode: {
    method: "post",
    path: "/api/set_contest_mode",
    body: "*form.snake",
    enforceJson: true
  },
  SetSubredditSticky: {
    method: "post",
    path: "/api/set_subreddit_sticky",
    body: "*form.snake",
    enforceJson: true
  },
  SetSuggestedSort: {
    method: "post",
    path: "/api/set_suggested_sort",
    body: "*form.snake",
    enforceJson: true
  },
  Spoiler: {
    method: "post",
    path: "/api/spoiler",
    body: "*form.snake"
  },
  StoreVisits: {
    method: "post",
    path: "/api/store_visits",
    body: "*form.snake"
  },
  Submit: {
    method: "post",
    path: "/api/submit",
    body: "*form.snake",
    enforceJson: true
  },
  Unhide: {
    method: "post",
    path: "/api/unhide",
    body: "*form.snake"
  },
  Unlock: {
    method: "post",
    path: "/api/unlock",
    body: "*form.snake"
  },
  UnmarkNSFW: {
    method: "post",
    path: "/api/unmarknsfw",
    body: "*form.snake"
  },
  Unsave: {
    method: "post",
    path: "/api/unsave",
    body: "*form.snake"
  },
  Unspoiler: {
    method: "post",
    path: "/api/unspoiler",
    body: "*form.snake"
  },
  Vote: {
    method: "post",
    path: "/api/vote",
    body: "*form.snake"
  },
  /* ----------------------- MODERATION ---------------------*/
  AboutLog: {
    method: "get",
    path: "/r/{subreddit}/about/log?after={after}&before={before}&count={count}&limit={limit}&show={show}&mod={mod}&type={type}"
  },
  AboutLocation: {
    method: "get",
    path: "/r/{subreddit}/about/{location}?after={after}&before={before}&count={count}&limit={limit}&show={show}&only={only}"
  },
  AcceptModeratorInvite: {
    method: "post",
    path: "/r/{subreddit}/api/accept_moderator_invite"
  },
  Approve: {
    method: "post",
    path: "/api/approve",
    body: "*form"
  },
  Distinguish: {
    method: "post",
    path: "/api/distinguish",
    body: "*form.snake",
    enforceJson: true
  },
  IgnoreReports: {
    method: "post",
    path: "/api/ignore_reports",
    body: "*form"
  },
  LeaveContributor: {
    method: "post",
    path: "/api/leavecontributor",
    body: "*form"
  },
  LeaveModerator: {
    method: "post",
    path: "/api/leavemoderator",
    body: "*form"
  },
  MuteMessageAuthor: {
    method: "post",
    path: "/api/mute_message_author",
    body: "*form"
  },
  Remove: {
    method: "post",
    path: "/api/remove",
    body: "*form"
  },
  ShowComment: {
    method: "post",
    path: "/api/show_comment",
    body: "*form"
  },
  SnoozeReports: {
    method: "post",
    path: "/api/snooze_reports",
    body: "*form"
  },
  UnignoreReports: {
    method: "post",
    path: "/api/unignore_reports",
    body: "*form"
  },
  UnmuteMessageAuthor: {
    method: "post",
    path: "/api/unmute_message_author",
    body: "*form"
  },
  UnsnoozeReports: {
    method: "post",
    path: "/api/unsnooze_reports",
    body: "*form"
  },
  UpdateCrowdControlLevel: {
    method: "post",
    path: "/api/update_crowd_control_level",
    body: "*form"
  },
  Stylesheet: {
    method: "get",
    path: "/r/{subreddit}/stylesheet"
  },
  /* ----------------------- FLAIR ---------------------*/
  ClearFlairTemplates: {
    method: "post",
    path: "/r/{subreddit}/api/clearflairtemplates",
    body: "*form.snake",
    enforceJson: true
  },
  DeleteFlair: {
    method: "post",
    path: "/r/{subreddit}/api/deleteflair",
    body: "*form"
  },
  DeleteFlairTemplate: {
    method: "post",
    path: "/r/{subreddit}/api/deleteflairtemplate",
    body: "*form.snake",
    enforceJson: true
  },
  Flair: {
    method: "post",
    path: "/r/{subreddit}/api/flair",
    body: "*form.snake",
    enforceJson: true
  },
  FlairTemplateOrder: {
    method: "patch",
    path: "/r/{subreddit}/api/flair_template_order?flair_type={flairType}&subreddit={subreddit}",
    body: "*"
  },
  FlairConfig: {
    method: "post",
    path: "/r/{subreddit}/api/flairconfig",
    body: "*form.snake",
    enforceJson: true
  },
  FlairCsv: {
    method: "post",
    path: "/r/{subreddit}/api/flaircsv?flair_csv={flairCsv}"
  },
  FlairList: {
    method: "get",
    path: "/r/{subreddit}/api/flairlist.json?after={after}&before={before}&count={count}&limit={limit}&name={name}&show={show}"
  },
  FlairSelector: {
    method: "post",
    path: "/r/{subreddit}/api/flairselector?name={name}&link={link}&is_newlink={isNewlink}"
  },
  FlairTemplate: {
    method: "post",
    path: "/r/{subreddit}/api/flairtemplate_v2",
    body: "*form.snake",
    enforceJson: true
  },
  LinkFlair: {
    method: "get",
    path: "/r/{subreddit}/api/link_flair_v2"
  },
  SelectFlair: {
    method: "post",
    path: "/r/{subreddit}/api/selectflair",
    body: "*form.snake",
    enforceJson: true
  },
  SetFlairEnabled: {
    method: "post",
    path: "/r/{subreddit}/api/setflairenabled",
    body: "*form.snake",
    enforceJson: true
  },
  UserFlair: {
    method: "get",
    path: "/r/{subreddit}/api/user_flair_v2"
  },
  /* ----------------------- NEWMODMAIL ---------------------*/
  BulkReadConversations: {
    method: "post",
    path: "/api/mod/conversations/bulk/read",
    body: "*form"
  },
  GetConversations: {
    method: "get",
    path: "/api/mod/conversations?after={after}&entity={entity}&limit={limit}&sort={sort}&state={state}"
  },
  CreateConversation: {
    method: "post",
    path: "/api/mod/conversations",
    body: "*form"
  },
  GetConversation: {
    method: "get",
    path: "/api/mod/conversations/{conversationId}?markRead={markRead}"
  },
  CreateConversationMessage: {
    method: "post",
    path: "/api/mod/conversations/{conversationId}",
    body: "*form"
  },
  ApproveConversation: {
    method: "post",
    path: "/api/mod/conversations/{conversationId}/approve"
  },
  ArchiveConversation: {
    method: "post",
    path: "/api/mod/conversations/{conversationId}/archive"
  },
  DisapproveConversation: {
    method: "post",
    path: "/api/mod/conversations/{conversationId}/disapprove"
  },
  UnhighlightConversation: {
    method: "delete",
    path: "/api/mod/conversations/{conversationId}/highlight"
  },
  HighlightConversation: {
    method: "post",
    path: "/api/mod/conversations/{conversationId}/highlight"
  },
  MuteConversation: {
    method: "post",
    path: "/api/mod/conversations/{conversationId}/mute",
    body: "*form"
  },
  TempBan: {
    method: "post",
    path: "/api/mod/conversations/{conversationId}/temp_ban",
    body: "*"
  },
  UnarchiveConversation: {
    method: "post",
    path: "/api/mod/conversations/{conversationId}/unarchive"
  },
  Unban: {
    method: "post",
    path: "/api/mod/conversations/{conversationId}/unban"
  },
  UnmuteConversation: {
    method: "post",
    path: "/api/mod/conversations/{conversationId}/unmute"
  },
  UserConversations: {
    method: "get",
    path: "/api/mod/conversations/{conversationId}/user"
  },
  Read: {
    method: "post",
    path: "/api/mod/conversations/read",
    body: "*form"
  },
  Subreddits: {
    method: "get",
    path: "/api/mod/conversations/subreddits"
  },
  Unread: {
    method: "post",
    path: "/api/mod/conversations/unread",
    body: "*form"
  },
  UnreadCount: {
    method: "get",
    path: "/api/mod/conversations/unread/count"
  },
  /* ----------------------- ModNote ---------------------*/
  DeleteNotes: {
    method: "delete",
    path: "/api/mod/notes?note_id={noteId}&subreddit={subreddit}&user={user}"
  },
  GetNotes: {
    method: "get",
    path: "/api/mod/notes?before={before}&filter={filter}&limit={limit}&subreddit={subreddit}&user={user}"
  },
  PostNotes: {
    method: "post",
    path: "/api/mod/notes",
    body: "*form.snake"
  },
  PostRemovalNote: {
    method: "post",
    path: "/api/v1/modactions/removal_reasons",
    body: "*.snake"
  },
  RecentNotes: {
    method: "get",
    path: "/api/mod/notes/recent?subreddits={subreddits}&users={users}"
  },
  /* -------------------------- USERS -----------------------*/
  BlockUser: {
    method: "post",
    path: "/api/block_user",
    body: "*form.snake",
    enforceJson: true
  },
  Friend: {
    method: "post",
    path: "/r/{subreddit}/api/friend",
    body: "*form.snake",
    enforceJson: true
  },
  ReportUser: {
    method: "post",
    path: "/api/report_user",
    body: "*form.snake"
  },
  SetPermissions: {
    method: "post",
    path: "/r/{subreddit}/api/setpermissions",
    body: "*form.snake",
    enforceJson: true
  },
  Unfriend: {
    method: "post",
    path: "/r/{subreddit}/api/unfriend",
    body: "*form.snake"
  },
  UserDataByAccountIds: {
    method: "get",
    path: "/api/user_data_by_account_ids?ids={ids}"
  },
  UsernameAvailable: {
    method: "get",
    path: "/api/username_available?user={user}"
  },
  UnfriendUser: {
    method: "delete",
    path: "/api/v1/me/friends/{username}?id={id}"
  },
  GetFriendInformation: {
    method: "get",
    path: "/api/v1/me/friends/{username}?id={id}"
  },
  UpdateFriendRelationship: {
    method: "put",
    path: "/api/v1/me/friends/{name}",
    body: "*"
  },
  UserTrophies: {
    method: "get",
    path: "/api/v1/user/{username}/trophies?id={id}"
  },
  UserAbout: {
    method: "get",
    path: "/user/{username}/about"
  },
  UserWhere: {
    method: "get",
    path: "/user/{username}/{where}?context={context}&show={show}&sort={sort}&t={t}&type={type}&after={after}&before={before}&count={count}&limit={limit}"
  },
  /* ----------------------- SUBREDDITS ---------------------*/
  AboutWhere: {
    method: "get",
    path: "/r/{subreddit}/about/{where}?after={after}&before={before}&count={count}&limit={limit}&show={show}&user={user}"
  },
  DeleteSrBanner: {
    method: "post",
    path: "/r/{subreddit}/api/delete_sr_banner"
  },
  DeleteSrHeader: {
    method: "post",
    path: "/r/{subreddit}/api/delete_sr_header"
  },
  DeleteSrIcon: {
    method: "post",
    path: "/r/{subreddit}/api/delete_sr_icon"
  },
  DeleteSrImg: {
    method: "post",
    path: "/r/{subreddit}/api/delete_sr_img",
    body: "*form.snake",
    enforceJson: true
  },
  SearchRedditNames: {
    method: "post",
    path: "/api/search_reddit_names",
    body: "*form.snake"
  },
  SearchSubreddits: {
    method: "post",
    path: "/api/search_subreddits",
    body: "*form.snake"
  },
  SiteAdmin: {
    method: "post",
    path: "/api/site_admin",
    body: "*form.snake",
    enforceJson: true
  },
  SubmitText: {
    method: "get",
    path: "/r/{subreddit}/api/submit_text"
  },
  SubredditAutocomplete: {
    method: "get",
    path: "/api/subreddit_autocomplete_v2?include_over_18={includeOver18}&include_profiles={includeProfiles}&limit={limit}&query={query}&search_query_id={searchQueryId}&typeahead_active={typeaheadActive}"
  },
  SubredditStylesheet: {
    method: "post",
    path: "/r/{subreddit}/api/subreddit_stylesheet",
    body: "*form.snake",
    enforceJson: true
  },
  Subscribe: {
    method: "post",
    path: "/api/subscribe",
    body: "*form.snake"
  },
  UploadSrImg: {
    method: "post",
    path: "/r/{subreddit}/api/upload_sr_img",
    body: "*form.snake"
  },
  SubredditPostRequirements: {
    method: "get",
    path: "/api/v1/{subreddit}/post_requirements"
  },
  SubredditAbout: {
    method: "get",
    path: "/r/{subreddit}/about"
  },
  SubredditAboutEdit: {
    method: "get",
    path: "/r/{subreddit}/about/edit?created={created}&location={location}"
  },
  SubredditAboutRules: {
    method: "get",
    path: "/r/{subreddit}/about/rules"
  },
  SubredditAboutTraffic: {
    method: "get",
    path: "/r/{subreddit}/about/traffic"
  },
  Sidebar: {
    method: "get",
    path: "/r/{subreddit}/sidebar"
  },
  Sticky: {
    method: "get",
    path: "/r/{subreddit}/sticky?num={num}"
  },
  SubredditsMineWhere: {
    method: "get",
    path: "/subreddits/mine/{where}?after={after}&before={before}&count={count}&limit={limit}&show={show}"
  },
  SubredditsSearch: {
    method: "get",
    path: "/subreddits/search?after={after}&before={before}&count={count}&limit={limit}&q={q}&search_query_id={searchQueryId}&show={show}&show_users={showUsers}&sort={sort}&typeahead_active={typeaheadActive}"
  },
  SubredditsWhere: {
    method: "get",
    path: "/subreddits/{where}?after={after}&before={before}&count={count}&limit={limit}&show={show}"
  },
  UsersSearch: {
    method: "get",
    path: "/users/search?after={after}&before={before}&count={count}&limit={limit}&q={q}&search_query_id={searchQueryId}&show={show}&sort={sort}&typeahead_active={typeaheadActive}"
  },
  UsersWhere: {
    method: "get",
    path: "/users/{where}?after={after}&before={before}&count={count}&limit={limit}&show={show}"
  },
  /* ----------------------- WIDGETS ---------------------*/
  AddWidget: {
    method: "post",
    path: "/r/{subreddit}/api/widget",
    body: "*"
  },
  DeleteWidget: {
    method: "delete",
    path: "/r/{subreddit}/api/widget/{id}"
  },
  UpdateWidget: {
    method: "put",
    path: "/r/{subreddit}/api/widget/{id}",
    body: "*"
  },
  UploadImageForWidget: {
    method: "post",
    path: "/r/{subreddit}/api/widget_image_upload_s3",
    body: "*form"
  },
  ReorderWidgets: {
    method: "patch",
    path: "/r/{subreddit}/api/widget_order/section",
    body: "*"
  },
  GetWidgets: {
    method: "get",
    path: "/r/{subreddit}/api/widgets"
  },
  /* ----------------------- WIKI ---------------------*/
  GetWikiPages: {
    method: "get",
    path: "/r/{subreddit}/wiki/pages"
  },
  GetWikiPage: {
    method: "get",
    path: "/r/{subreddit}/wiki/{page}"
  },
  EditWikiPage: {
    method: "post",
    path: "/r/{subreddit}/api/wiki/edit",
    body: "*form.snake"
  },
  HideWikiPage: {
    method: "post",
    path: "/r/{subreddit}/api/wiki/hide",
    body: "*form.snake"
  },
  RevertWikiPage: {
    method: "post",
    path: "/r/{subreddit}/api/wiki/revert",
    body: "*form.snake"
  },
  GetWikiPageRevisions: {
    method: "get",
    path: "/r/{subreddit}/wiki/revisions/{page}?after={after}&before={before}&count={count}&limit={limit}&show={show}&sr_detail={srDetail}"
  },
  GetWikiRevisions: {
    method: "get",
    path: "/r/{subreddit}/wiki/revisions?after={after}&before={before}&count={count}&limit={limit}&show={show}&sr_detail={srDetail}"
  },
  GetWikiPageSettings: {
    method: "get",
    path: "/r/{subreddit}/wiki/settings/{page}"
  },
  UpdateWikiPageSettings: {
    method: "post",
    path: "/r/{subreddit}/wiki/settings/{page}",
    body: "*form"
  },
  AllowEditor: {
    method: "post",
    path: "/r/{subreddit}/api/wiki/alloweditor/{act}",
    body: "*form.snake"
  }
};

// ../shared-types/dist/isObject.js
function isObject26(val) {
  return val != null && !Array.isArray(val) && typeof val === "object";
}

// src/plugins/redditapi/errors.ts
function findAndThrowRedditAPIError(status, body) {
  if (isJsonArrayError(body))
    throw new Error(formatJsonArrayError(body));
  if (isStatusMessageInBodyError(body))
    throw new Error(formatStatusMessageInBodyError(body));
  if (isBadRequestError(body))
    throw new Error(formatBadRequestError(body));
  if (status === 404) {
    throw new Error("404 Not Found");
  }
  if (status === 403) {
    throw new Error("403 Forbidden");
  }
  if (status === 500) {
    throw new Error("500 Internal Server Error");
  }
  if (status >= 400) {
    throw new Error(`HTTP ${status}`);
  }
}
function isStatusMessageInBodyError(body) {
  return isObject26(body) && "error" in body;
}
function formatStatusMessageInBodyError(body) {
  let err = body.error.toString();
  if (body.message) {
    err += ` ${body.message}`;
  }
  if (body.reason) {
    err += `: ${body.reason}`;
  }
  return err;
}
function isJsonArrayError(body) {
  return isObject26(body) && isObject26(body.json) && Array.isArray(body.json.errors) && body.json.errors.length > 0;
}
function formatJsonArrayError(body) {
  let err = "Errors:";
  for (let i = 0; i < body.json.errors.length; i++) {
    if (Array.isArray(body.json.errors[i])) {
      err += `
${body.json.errors[i].join(": ")}`;
    } else {
      err += `
${body.json.errors[i]}`;
    }
  }
  return err;
}
function isBadRequestError(body) {
  return isObject26(body) && "explanation" in body;
}
function formatBadRequestError(body) {
  let err = `Bad request: ${body.explanation}`;
  if (body.fields.length > 0) {
    err += `
Error in field${body.fields.length !== 1 ? "s" : ""}: ${body.fields.join(", ")}`;
  }
  return err;
}

// src/plugins/redditapi/snakeToCamel.ts
var snakeToCamel = (str) => str.replace(/([a-z])_([a-z0-9])/g, (_, p1, p2) => p1 + p2.toUpperCase());
function deepSnakeToCamel(obj, ignoreKeys = []) {
  if (Array.isArray(obj)) {
    return obj.map((e) => isObject26(e) ? deepSnakeToCamel(e, ignoreKeys) : e);
  } else if (isObject26(obj)) {
    const result = {};
    for (const [key, val] of Object.entries(obj)) {
      const ignoreKeyTransformation = ignoreKeys.some((regex) => regex.test(key));
      const newKey = ignoreKeyTransformation ? key : snakeToCamel(key);
      result[newKey] = deepSnakeToCamel(val, ignoreKeys);
    }
    return result;
  } else {
    return obj;
  }
}

// src/plugins/redditapi/RedditAPI.ts
var camelToSnake = (str) => str.replace(/[A-Z]|(?<=[a-zA-Z])[\d]/g, (l) => `_${l.toLocaleLowerCase()}`);
var _httpClient, _mapArgsToUrl, mapArgsToUrl_fn, _getBaseUrl, getBaseUrl_fn, _getHeaders, getHeaders_fn, _getBodyParams, getBodyParams_fn, _getFetchRequest, getFetchRequest_fn;
var RedditAPI = class {
  constructor(httpClient2) {
    // Maps request properties to a URL, replacing tokens surrounded by {}
    __privateAdd(this, _mapArgsToUrl);
    __privateAdd(this, _getBaseUrl);
    __privateAdd(this, _getHeaders);
    // TODO: remove use of any below
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    __privateAdd(this, _getBodyParams);
    __privateAdd(this, _getFetchRequest);
    __privateAdd(this, _httpClient, void 0);
    __privateSet(this, _httpClient, httpClient2);
  }
  _decodeAndValidateResponseJSON(response, ignoreKeys = []) {
    if (response.status == 204) {
      return {};
    }
    const body = JSON.parse(new TextDecoder().decode(response.body));
    findAndThrowRedditAPIError(response.status, body);
    return deepSnakeToCamel(body, ignoreKeys);
  }
  _fetch(methodName, obj, metadata) {
    return __privateGet(this, _httpClient).Fetch(__privateMethod(this, _getFetchRequest, getFetchRequest_fn).call(this, methodName, obj, metadata), metadata);
  }
};
_httpClient = new WeakMap();
_mapArgsToUrl = new WeakSet();
mapArgsToUrl_fn = function(url, obj) {
  return `${Object.entries(obj).reduce((p, c) => {
    const pattern = RegExp(`{([^}]+)?${c[0]}([^{]+)?}`);
    const value = (c[1] ?? null) !== null ? `$1${c[1]}$2` : "";
    return p.replace(pattern, value);
  }, url)}${url.indexOf("?") > 0 ? "&" : "?"}raw_json=1`;
};
_getBaseUrl = new WeakSet();
getBaseUrl_fn = function(metadata) {
  const r2Host = getFromMetadata(Header.R2Host, metadata);
  if (r2Host) {
    return `https://${r2Host}`;
  }
  throw new Error("unable to locate base url for reddit api");
};
_getHeaders = new WeakSet();
getHeaders_fn = function(mapping, metadata) {
  const authToken = getFromMetadata(Header.R2Auth, metadata);
  if (!authToken) {
    throw new Error("Must include auth header when calling the reddit api");
  }
  const headers = {};
  if (authToken) {
    headers["Authorization"] = `Bearer ${authToken}`;
  }
  switch (mapping.body) {
    case "*":
    case "*.snake":
      headers["Content-Type"] = "application/json";
      break;
    case "*form":
    case "*form.snake":
      headers["Content-Type"] = "application/x-www-form-urlencoded";
  }
  return headers;
};
_getBodyParams = new WeakSet();
getBodyParams_fn = function(mapping, obj) {
  const { body: bodyType, enforceJson } = mapping;
  let body = "";
  const bodyObj = enforceJson ? enforceJsonOnBody(obj) : obj;
  switch (bodyType) {
    case "*": {
      body = JSON.stringify(bodyObj);
      break;
    }
    case "*.snake": {
      const tempBody = {};
      for (const key in bodyObj) {
        if (bodyObj[key] !== void 0) {
          tempBody[camelToSnake(key)] = bodyObj[key];
        }
      }
      body = JSON.stringify(tempBody);
      break;
    }
    case "*form": {
      body = bodyToFormData(bodyObj);
      break;
    }
    case "*form.snake": {
      const tempBody = {};
      for (const key in bodyObj) {
        if (bodyObj[key] !== void 0) {
          tempBody[camelToSnake(key)] = bodyObj[key];
        }
      }
      body = bodyToFormData(tempBody);
      break;
    }
  }
  return new TextEncoder().encode(body);
};
_getFetchRequest = new WeakSet();
getFetchRequest_fn = function(methodName, obj, metadata) {
  const mapping = RedditAPIMappings[methodName];
  const url = __privateMethod(this, _mapArgsToUrl, mapArgsToUrl_fn).call(this, `${__privateMethod(this, _getBaseUrl, getBaseUrl_fn).call(this, metadata)}${mapping.path}`, obj);
  return FetchRequest.fromPartial({
    url,
    data: {
      body: __privateMethod(this, _getBodyParams, getBodyParams_fn).call(this, mapping, obj),
      headers: __privateMethod(this, _getHeaders, getHeaders_fn).call(this, mapping, metadata),
      method: mapping.method
    }
  });
};
function bodyToFormData(obj) {
  return Object.entries(obj).map(([k, v]) => {
    return isObject26(v) ? `${k}=${encodeURIComponent(JSON.stringify(v))}` : `${k}=${encodeURIComponent(v)}`;
  }).join("&");
}
function enforceJsonOnBody(obj) {
  return {
    ...obj,
    api_type: "json"
  };
}

// src/plugins/redditapi/Flair.ts
var Flair = class extends RedditAPI {
  async ClearFlairTemplates(request, metadata) {
    const response = await this._fetch("ClearFlairTemplates", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async DeleteFlair(request, metadata) {
    const response = await this._fetch("DeleteFlair", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async DeleteFlairTemplate(request, metadata) {
    const response = await this._fetch("DeleteFlairTemplate", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Flair(request, metadata) {
    const response = await this._fetch("Flair", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async FlairTemplateOrder(request, metadata) {
    const response = await this._fetch("FlairTemplateOrder", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async FlairConfig(request, metadata) {
    const response = await this._fetch("FlairConfig", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async FlairCsv(request, metadata) {
    const response = await this._fetch("FlairCsv", request, metadata);
    return FlairCsvResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async FlairList(request, metadata) {
    const response = await this._fetch("FlairList", request, metadata);
    return FlairListResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async FlairSelector(request, metadata) {
    const response = await this._fetch("FlairSelector", request, metadata);
    return FlairSelectorResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async FlairTemplate(request, metadata) {
    const response = await this._fetch("FlairTemplate", request, metadata);
    return FlairObject.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async LinkFlair(request, metadata) {
    const response = await this._fetch("LinkFlair", request, metadata);
    return FlairArray.fromJSON({ flair: this._decodeAndValidateResponseJSON(response) });
  }
  async SelectFlair(request, metadata) {
    const response = await this._fetch("SelectFlair", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SetFlairEnabled(request, metadata) {
    const response = await this._fetch("SetFlairEnabled", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UserFlair(request, metadata) {
    const response = await this._fetch("UserFlair", request, metadata);
    return FlairArray.fromJSON({ flair: this._decodeAndValidateResponseJSON(response) });
  }
};

// ../shared-types/dist/tid.js
var T_PREFIX;
(function(T_PREFIX2) {
  T_PREFIX2["COMMENT"] = "t1_";
  T_PREFIX2["ACCOUNT"] = "t2_";
  T_PREFIX2["LINK"] = "t3_";
  T_PREFIX2["MESSAGE"] = "t4_";
  T_PREFIX2["SUBREDDIT"] = "t5_";
})(T_PREFIX || (T_PREFIX = {}));
function isT1ID(id) {
  return id.startsWith(T_PREFIX.COMMENT);
}
function isCommentId(id) {
  return isT1ID(id);
}

// src/plugins/redditapi/LinksAndComments.ts
var import_base64_js = __toESM(require_base64_js(), 1);
var customPostTemplate = (encodedBundle, encodedCached) => `# DX_Bundle:

    ${encodedBundle}

# DX_Config:

    EhYKB3ZlcnNpb24SCwgCGQAAAAAAAPA/

# DX_Cached:

    ${encodedCached}

`;
var LinksAndComments = class extends RedditAPI {
  async Comment(request, metadata) {
    const response = await this._fetch("Comment", request, metadata);
    let body = JSON.parse(new TextDecoder().decode(response.body));
    findAndThrowRedditAPIError(response.status, body);
    if (!body.json && request.richtextJson && isCommentId(body.name)) {
      body = {
        json: {
          errors: [],
          data: {
            things: [
              {
                kind: "t1",
                data: body
              }
            ]
          }
        }
      };
    }
    return JsonWrappedComment.fromJSON(deepSnakeToCamel(body));
  }
  async Del(request, metadata) {
    await this._fetch("Del", request, metadata);
    return Empty.fromPartial({});
  }
  async EditUserText(request, metadata) {
    const response = await this._fetch("EditUserText", request, metadata);
    return JsonWrappedComment.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async FollowPost(request, metadata) {
    await this._fetch("FollowPost", request, metadata);
    return Empty.fromPartial({});
  }
  async Hide(request, metadata) {
    await this._fetch("Hide", request, metadata);
    return Empty.fromPartial({});
  }
  async Info(request, metadata) {
    const response = await this._fetch("Info", request, metadata);
    return Listing.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Lock(request, metadata) {
    await this._fetch("Lock", request, metadata);
    return Empty.fromPartial({});
  }
  async MarkNSFW(request, metadata) {
    await this._fetch("MarkNSFW", request, metadata);
    return Empty.fromPartial({});
  }
  async MoreChildren(request, metadata) {
    const response = await this._fetch("MoreChildren", request, metadata);
    return JsonWrappedComment.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Report(request, metadata) {
    const response = await this._fetch("Report", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async ReportAward(request, metadata) {
    await this._fetch("ReportAward", request, metadata);
    return Empty.fromPartial({});
  }
  async Save(request, metadata) {
    await this._fetch("Save", request, metadata);
    return Empty.fromPartial({});
  }
  async SendReplies(request, metadata) {
    await this._fetch("SendReplies", request, metadata);
    return Empty.fromPartial({});
  }
  async SetContestMode(request, metadata) {
    const response = await this._fetch("SetContestMode", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SetSubredditSticky(request, metadata) {
    const response = await this._fetch("SetSubredditSticky", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SetSuggestedSort(request, metadata) {
    const response = await this._fetch("SetSuggestedSort", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Spoiler(request, metadata) {
    await this._fetch("Spoiler", request, metadata);
    return Empty.fromPartial({});
  }
  async Submit(request, metadata) {
    if (request.kind === "custom") {
      return this.SubmitCustomPost(request, metadata);
    }
    const response = await this._fetch("Submit", request, metadata);
    return SubmitResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SubmitCustomPost(request, metadata) {
    const hostname = getFromMetadata(Header.RemoteHostname, metadata);
    assertNonNull(hostname, "Remote hostname is missing");
    const bundle = LinkedBundle.fromPartial({
      hostname,
      provides: [Definition.toSerializable(CustomPostDefinition)]
    });
    assertNonNull(request.text, "Custom post blocks is missing");
    const encodedBundle = (0, import_base64_js.fromByteArray)(LinkedBundle.encode(bundle).finish());
    const encodedCached = request.text;
    request.text = customPostTemplate(encodedBundle, encodedCached);
    request.kind = "self";
    const response = await this._fetch("Submit", request, metadata);
    return SubmitResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Unhide(request, metadata) {
    await this._fetch("Unhide", request, metadata);
    return Empty.fromPartial({});
  }
  async Unlock(request, metadata) {
    await this._fetch("Unlock", request, metadata);
    return Empty.fromPartial({});
  }
  async UnmarkNSFW(request, metadata) {
    await this._fetch("UnmarkNSFW", request, metadata);
    return Empty.fromPartial({});
  }
  async Unsave(request, metadata) {
    await this._fetch("Unsave", request, metadata);
    return Empty.fromPartial({});
  }
  async Unspoiler(request, metadata) {
    await this._fetch("Unspoiler", request, metadata);
    return Empty.fromPartial({});
  }
  async Vote(request, metadata) {
    await this._fetch("Vote", request, metadata);
    return Empty.fromPartial({});
  }
};

// src/plugins/redditapi/Listings.ts
var Listings = class extends RedditAPI {
  async Best(request, metadata) {
    const response = await this._fetch("Best", request, metadata);
    return Listing.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async ById(request, metadata) {
    const response = await this._fetch("ById", request, metadata);
    return Listing.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Comments(request, metadata) {
    const response = await this._fetch("Comments", request, metadata);
    const body = JSON.parse(new TextDecoder().decode(response.body));
    findAndThrowRedditAPIError(response.status, body);
    if (Array.isArray(body) && body[1] != null) {
      body[1] = fixCommentReplies(body[1]);
    }
    return ListingResponse.fromJSON({
      listings: deepSnakeToCamel(body)
    });
  }
  async Duplicates(request, metadata) {
    const response = await this._fetch("Duplicates", request, metadata);
    return ListingResponse.fromJSON({
      listings: this._decodeAndValidateResponseJSON(response)
    });
  }
  async Hot(request, metadata) {
    const response = await this._fetch("Hot", request, metadata);
    return Listing.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async New(request, metadata) {
    const response = await this._fetch("New", request, metadata);
    return Listing.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Rising(request, metadata) {
    const response = await this._fetch("Rising", request, metadata);
    return Listing.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Sort(request, metadata) {
    const response = await this._fetch("Sort", request, metadata);
    return Listing.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
};
function fixCommentReplies(listing) {
  if (!listing.data?.children) {
    return listing;
  }
  const newListing = Object.assign({}, listing);
  for (const wrappedComment of newListing.data.children) {
    const comment = wrappedComment.data;
    if (comment?.replies) {
      comment.reply_list = fixCommentReplies(comment.replies);
      ;
      delete comment.replies;
    }
  }
  return newListing;
}

// src/plugins/redditapi/Moderation.ts
var Moderation = class extends RedditAPI {
  async AboutLog(request, metadata) {
    const response = await this._fetch("AboutLog", request, metadata);
    return AboutLogResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async AboutLocation(request, metadata) {
    const response = await this._fetch("AboutLocation", request, metadata);
    return Listing.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async AcceptModeratorInvite(request, metadata) {
    const response = await this._fetch("AcceptModeratorInvite", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Approve(request, metadata) {
    await this._fetch("Approve", request, metadata);
    return Empty.fromPartial({});
  }
  async Distinguish(request, metadata) {
    const response = await this._fetch("Distinguish", request, metadata);
    return JsonRedditObjects.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async IgnoreReports(request, metadata) {
    await this._fetch("IgnoreReports", request, metadata);
    return Empty.fromPartial({});
  }
  async LeaveContributor(request, metadata) {
    await this._fetch("LeaveContributor", request, metadata);
    return Empty.fromPartial({});
  }
  async LeaveModerator(request, metadata) {
    await this._fetch("LeaveModerator", request, metadata);
    return Empty.fromPartial({});
  }
  async MuteMessageAuthor(request, metadata) {
    await this._fetch("MuteMessageAuthor", request, metadata);
    return Empty.fromPartial({});
  }
  async Remove(request, metadata) {
    await this._fetch("Remove", request, metadata);
    return Empty.fromPartial({});
  }
  async ShowComment(request, metadata) {
    await this._fetch("ShowComment", request, metadata);
    return Empty.fromPartial({});
  }
  async SnoozeReports(request, metadata) {
    await this._fetch("SnoozeReports", request, metadata);
    return Empty.fromPartial({});
  }
  async UnignoreReports(request, metadata) {
    await this._fetch("UnignoreReports", request, metadata);
    return Empty.fromPartial({});
  }
  async UnmuteMessageAuthor(request, metadata) {
    await this._fetch("UnmuteMessageAuthor", request, metadata);
    return Empty.fromPartial({});
  }
  async UnsnoozeReports(request, metadata) {
    await this._fetch("UnsnoozeReports", request, metadata);
    return Empty.fromPartial({});
  }
  async UpdateCrowdControlLevel(request, metadata) {
    await this._fetch("UpdateCrowdControlLevel", request, metadata);
    return Empty.fromPartial({});
  }
  async Stylesheet(request, metadata) {
    const response = await this._fetch("UpdateCrowdControlLevel", request, metadata);
    return StringValue.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
};

// src/plugins/redditapi/ModNote.ts
var ModNote = class extends RedditAPI {
  async DeleteNotes(request, metadata) {
    const response = await this._fetch("DeleteNotes", request, metadata);
    return DeleteNotesResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async GetNotes(request, metadata) {
    const response = await this._fetch("GetNotes", request, metadata);
    return ModNotesResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async PostNotes(request, metadata) {
    const response = await this._fetch("PostNotes", request, metadata);
    return PostModNotesResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async PostRemovalNote(request, metadata) {
    await this._fetch("PostRemovalNote", request, metadata);
    return Empty.fromPartial({});
  }
  async RecentNotes(request, metadata) {
    const response = await this._fetch("RecentNotes", request, metadata);
    return ModNotesResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
};

// src/plugins/redditapi/NewModmail.ts
var NewModmail = class extends RedditAPI {
  async BulkReadConversations(request, metadata) {
    const response = await this._fetch("BulkReadConversations", request, metadata);
    return BulkReadConversationsResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async GetConversations(request, metadata) {
    const response = await this._fetch("GetConversations", request, metadata);
    return GetConversationsResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async CreateConversation(request, metadata) {
    const response = await this._fetch("CreateConversation", request, metadata);
    return CreateConversationResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async GetConversation(request, metadata) {
    const response = await this._fetch("GetConversation", request, metadata);
    return GetConversationResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async CreateConversationMessage(request, metadata) {
    const response = await this._fetch("CreateConversationMessage", request, metadata);
    return CreateConversationMessageResponse.fromJSON(
      this._decodeAndValidateResponseJSON(response)
    );
  }
  async ApproveConversation(request, metadata) {
    const response = await this._fetch("ApproveConversation", request, metadata);
    return ApproveConversationResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async ArchiveConversation(request, metadata) {
    const response = await this._fetch("ArchiveConversation", request, metadata);
    return ArchiveConversationResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async DisapproveConversation(request, metadata) {
    const response = await this._fetch("DisapproveConversation", request, metadata);
    return ApproveConversationResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UnhighlightConversation(request, metadata) {
    const response = await this._fetch("UnhighlightConversation", request, metadata);
    return HighlightConversationResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async HighlightConversation(request, metadata) {
    const response = await this._fetch("HighlightConversation", request, metadata);
    return HighlightConversationResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async MuteConversation(request, metadata) {
    const response = await this._fetch("MuteConversation", request, metadata);
    return MuteConversationResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async TempBan(request, metadata) {
    const response = await this._fetch("TempBan", request, metadata);
    return TempBanResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UnarchiveConversation(request, metadata) {
    const response = await this._fetch("UnarchiveConversation", request, metadata);
    return ArchiveConversationResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Unban(request, metadata) {
    const response = await this._fetch("Unban", request, metadata);
    return TempBanResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UnmuteConversation(request, metadata) {
    const response = await this._fetch("UnmuteConversation", request, metadata);
    return MuteConversationResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UserConversations(request, metadata) {
    const response = await this._fetch("UserConversations", request, metadata);
    return ConversationUserData.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Read(request, metadata) {
    await this._fetch("Read", request, metadata);
    return Empty.fromPartial({});
  }
  async Subreddits(request, metadata) {
    const response = await this._fetch("Subreddits", request, metadata);
    return SubredditsResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Unread(request, metadata) {
    await this._fetch("Unread", request, metadata);
    return Empty.fromPartial({});
  }
  async UnreadCount(request, metadata) {
    const response = await this._fetch("UnreadCount", request, metadata);
    return UnreadCountResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
};

// src/plugins/redditapi/PrivateMessages.ts
var PrivateMessages = class extends RedditAPI {
  async Block(request, metadata) {
    await this._fetch("Block", request, metadata);
    return Empty.fromPartial({});
  }
  async CollapseMessage(request, metadata) {
    await this._fetch("CollapseMessage", request, metadata);
    return Empty.fromPartial({});
  }
  async Compose(request, metadata) {
    await this._fetch("Compose", request, metadata);
    return Empty.fromPartial({});
  }
  async DelMsg(request, metadata) {
    await this._fetch("DelMsg", request, metadata);
    return Empty.fromPartial({});
  }
  async ReadAllMessages(request, metadata) {
    await this._fetch("ReadAllMessages", request, metadata);
    return Empty.fromPartial({});
  }
  async ReadMessage(request, metadata) {
    await this._fetch("ReadMessage", request, metadata);
    return Empty.fromPartial({});
  }
  async UnblockSubreddit(request, metadata) {
    await this._fetch("UnblockSubreddit", request, metadata);
    return Empty.fromPartial({});
  }
  async UncollapseMessage(request, metadata) {
    await this._fetch("UncollapseMessage", request, metadata);
    return Empty.fromPartial({});
  }
  async UnreadMessage(request, metadata) {
    await this._fetch("UnreadMessage", request, metadata);
    return Empty.fromPartial({});
  }
  async MessageWhere(request, metadata) {
    const response = await this._fetch("MessageWhere", request, metadata);
    return Listing.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
};

// src/plugins/redditapi/Subreddits.ts
var Subreddits = class extends RedditAPI {
  async AboutWhere(request, metadata) {
    const response = await this._fetch("AboutWhere", request, metadata);
    const body = JSON.parse(new TextDecoder().decode(response.body));
    findAndThrowRedditAPIError(response.status, body);
    if (body.data != null) {
      body.data.children = body.data.children.map((child) => ({
        kind: "t2",
        data: child
      }));
    }
    return Listing.fromJSON(deepSnakeToCamel(body));
  }
  async DeleteSrBanner(request, metadata) {
    const response = await this._fetch("DeleteSrBanner", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async DeleteSrHeader(request, metadata) {
    const response = await this._fetch("DeleteSrHeader", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async DeleteSrIcon(request, metadata) {
    const response = await this._fetch("DeleteSrIcon", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async DeleteSrImg(request, metadata) {
    const response = await this._fetch("DeleteSrImg", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SearchRedditNames(request, metadata) {
    const response = await this._fetch("SearchRedditNames", request, metadata);
    return SearchRedditNamesResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SearchSubreddits(request, metadata) {
    const response = await this._fetch("SearchSubreddits", request, metadata);
    return SearchSubredditsResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SiteAdmin(request, metadata) {
    const response = await this._fetch("SiteAdmin", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SubmitText(request, metadata) {
    const response = await this._fetch("SubmitText", request, metadata);
    return SubmitTextResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SubredditAutocomplete(request, metadata) {
    const response = await this._fetch("SubredditAutocomplete", request, metadata);
    return SubredditAutocompleteResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SubredditStylesheet(request, metadata) {
    const response = await this._fetch("SubredditStylesheet", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Subscribe(request, metadata) {
    await this._fetch("Subscribe", request, metadata);
    return Empty.fromJSON({});
  }
  async UploadSrImg(request, metadata) {
    const response = await this._fetch("UploadSrImg", request, metadata);
    return UploadSrImgResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SubredditPostRequirements(request, metadata) {
    const response = await this._fetch("SubredditPostRequirements", request, metadata);
    return SubredditPostRequirementsResponse.fromJSON(
      this._decodeAndValidateResponseJSON(response)
    );
  }
  async SubredditAbout(request, metadata) {
    const response = await this._fetch("SubredditAbout", request, metadata);
    return SubredditAboutResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SubredditAboutEdit(request, metadata) {
    const response = await this._fetch("SubredditAboutEdit", request, metadata);
    return SubredditAboutEditResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SubredditAboutRules(request, metadata) {
    const response = await this._fetch("SubredditAboutRules", request, metadata);
    return SubredditAboutRulesResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SubredditAboutTraffic(request, metadata) {
    const response = await this._fetch("SubredditAboutTraffic", request, metadata);
    return SubredditAboutTrafficResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Sidebar(request, metadata) {
    const response = await this._fetch("Sidebar", request, metadata);
    return StringValue.fromJSON({ value: new TextDecoder().decode(response.body) });
  }
  async Sticky(request, metadata) {
    const response = await this._fetch("Sticky", request, metadata);
    return StickyResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SubredditsMineWhere(request, metadata) {
    const response = await this._fetch("SubredditsMineWhere", request, metadata);
    return Listing.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async SubredditsSearch(request, metadata) {
    const response = await this._fetch("SubredditsSearch", request, metadata);
    const body = JSON.parse(new TextDecoder().decode(response.body));
    findAndThrowRedditAPIError(response.status, body);
    const children = body?.data?.children || [];
    for (const child of children) {
      if (child.kind === "t5") {
        if (!body.data.children_subreddits) {
          body.data.children_subreddits = [];
        }
        body.data.children_subreddits.push(child);
      } else if (child.kind === "t2") {
        if (!body.data.children_accounts) {
          body.data.children_accounts = [];
        }
        body.data.children_accounts.push(child);
      }
    }
    delete body?.data?.children;
    return SubredditsSearchResponse.fromJSON(body);
  }
  async SubredditsWhere(request, metadata) {
    const response = await this._fetch("SubredditsWhere", request, metadata);
    return SubredditsSearchResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UsersSearch(request, metadata) {
    const response = await this._fetch("UsersSearch", request, metadata);
    return UserSearchResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UsersWhere(request, metadata) {
    const response = await this._fetch("UsersWhere", request, metadata);
    return SubredditsSearchResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
};

// src/plugins/redditapi/Users.ts
var Users = class extends RedditAPI {
  async BlockUser(request, metadata) {
    const response = await this._fetch("BlockUser", request, metadata);
    return BlockUserResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Friend(request, metadata) {
    const response = await this._fetch("Friend", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async ReportUser(request, metadata) {
    await this._fetch("ReportUser", request, metadata);
    return Empty.fromJSON({});
  }
  async SetPermissions(request, metadata) {
    const response = await this._fetch("SetPermissions", request, metadata);
    return JsonStatus.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async Unfriend(request, metadata) {
    await this._fetch("Unfriend", request, metadata);
    return Empty.fromJSON({});
  }
  async UserDataByAccountIds(request, metadata) {
    const response = await this._fetch("UserDataByAccountIds", request, metadata);
    return UserDataByAccountIdsResponse.fromJSON({
      users: this._decodeAndValidateResponseJSON(response)
    });
  }
  async UsernameAvailable(request, metadata) {
    const response = await this._fetch("UsernameAvailable", request, metadata);
    return BoolValue.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UnfriendUser(request, metadata) {
    await this._fetch("UnfriendUser", request, metadata);
    return Empty.fromJSON({});
  }
  async GetFriendInformation(request, metadata) {
    const response = await this._fetch("GetFriendInformation", request, metadata);
    return GeneralFriendResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UpdateFriendRelationship(request, metadata) {
    const response = await this._fetch("UpdateFriendRelationship", request, metadata);
    return GeneralFriendResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UserTrophies(request, metadata) {
    const response = await this._fetch("UserTrophies", request, metadata);
    return UserTrophiesResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UserAbout(request, metadata) {
    const response = await this._fetch("UserAbout", request, metadata);
    return UserAboutResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UserWhere(request, metadata) {
    const response = await this._fetch("UserWhere", request, metadata);
    return Listing.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
};

// src/plugins/redditapi/Widgets.ts
var Widgets = class extends RedditAPI {
  async AddButtonWidget(request, metadata) {
    const response = await this._fetch(
      "AddWidget",
      {
        kind: "button",
        ...request
      },
      metadata
    );
    return ButtonWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async AddImageWidget(request, metadata) {
    const response = await this._fetch(
      "AddWidget",
      {
        kind: "image",
        ...request
      },
      metadata
    );
    return ImageWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async AddCalendarWidget(request, metadata) {
    const response = await this._fetch(
      "AddWidget",
      {
        kind: "calendar",
        ...request
      },
      metadata
    );
    return CalendarWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async AddTextAreaWidget(request, metadata) {
    const response = await this._fetch(
      "AddWidget",
      {
        kind: "textarea",
        ...request
      },
      metadata
    );
    return TextAreaWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async AddCommunityListWidget(request, metadata) {
    const response = await this._fetch(
      "AddWidget",
      {
        kind: "community-list",
        ...request
      },
      metadata
    );
    return CommunityListWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async AddPostFlairWidget(request, metadata) {
    const response = await this._fetch(
      "AddWidget",
      {
        kind: "post-flair",
        ...request
      },
      metadata
    );
    return PostFlairWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async AddCustomWidget(request, metadata) {
    const response = await this._fetch(
      "AddWidget",
      {
        kind: "custom",
        ...request
      },
      metadata
    );
    return CustomWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async DeleteWidget(request, metadata) {
    await this._fetch("DeleteWidget", request, metadata);
    return Empty.fromJSON({});
  }
  async UpdateButtonWidget(request, metadata) {
    const response = await this._fetch(
      "UpdateWidget",
      {
        kind: "button",
        ...request
      },
      metadata
    );
    return ButtonWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UpdateImageWidget(request, metadata) {
    const response = await this._fetch(
      "UpdateWidget",
      {
        kind: "image",
        ...request
      },
      metadata
    );
    return ImageWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UpdateCalendarWidget(request, metadata) {
    const response = await this._fetch(
      "UpdateWidget",
      {
        kind: "calendar",
        ...request
      },
      metadata
    );
    return CalendarWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UpdateTextAreaWidget(request, metadata) {
    const response = await this._fetch(
      "UpdateWidget",
      {
        kind: "textarea",
        ...request
      },
      metadata
    );
    return TextAreaWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UpdateCommunityListWidget(request, metadata) {
    const response = await this._fetch(
      "UpdateWidget",
      {
        kind: "community-list",
        ...request
      },
      metadata
    );
    return UpdateCommunityListWidgetResponse.fromJSON(
      this._decodeAndValidateResponseJSON(response)
    );
  }
  async UpdatePostFlairWidget(request, metadata) {
    const response = await this._fetch(
      "UpdateWidget",
      {
        kind: "post-flair",
        ...request
      },
      metadata
    );
    return PostFlairWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UpdateCustomWidget(request, metadata) {
    const response = await this._fetch(
      "UpdateWidget",
      {
        kind: "custom",
        ...request
      },
      metadata
    );
    return CustomWidget.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async OrderWidgets(request, metadata) {
    await this._fetch("ReorderWidgets", request, metadata);
    return Empty.fromJSON({});
  }
  async GetWidgetImageUploadLease(request, metadata) {
    const response = await this._fetch("UploadImageForWidget", request, metadata);
    return GetWidgetImageUploadLeaseResponse.fromJSON(
      this._decodeAndValidateResponseJSON(response)
    );
  }
  async GetWidgets(request, metadata) {
    const response = await this._fetch("GetWidgets", request, metadata);
    return GetWidgetsResponse.fromJSON(this._decodeAndValidateResponseJSON(response, [/^widget_/]));
  }
};

// src/plugins/redditapi/Wiki.ts
var Wiki = class extends RedditAPI {
  async GetWikiPages(request, metadata) {
    const response = await this._fetch("GetWikiPages", request, metadata);
    return GetWikiPagesResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async GetWikiPage(request, metadata) {
    const response = await this._fetch("GetWikiPage", request, metadata);
    return GetWikiPageResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async EditWikiPage(request, metadata) {
    await this._fetch("EditWikiPage", request, metadata);
    return Empty.fromPartial({});
  }
  async HideWikiPageRevision(request, metadata) {
    const response = await this._fetch("HideWikiPage", request, metadata);
    return HideWikiPageRevisionResponse.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async GetWikiPageRevisions(request, metadata) {
    const repsonse = await this._fetch("GetWikiPageRevisions", request, metadata);
    return WikiPageRevisionListing.fromJSON(this._decodeAndValidateResponseJSON(repsonse));
  }
  async GetWikiRevisions(request, metadata) {
    const response = await this._fetch("GetWikiRevisions", request, metadata);
    return WikiPageRevisionListing.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async RevertWikiPage(request, metadata) {
    await this._fetch("RevertWikiPage", request, metadata);
    return Empty.fromPartial({});
  }
  async GetWikiPageSettings(request, metadata) {
    const response = await this._fetch("GetWikiPageSettings", request, metadata);
    return WikiPageSettings.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async UpdateWikiPageSettings(request, metadata) {
    const response = await this._fetch("UpdateWikiPageSettings", request, metadata);
    return WikiPageSettings.fromJSON(this._decodeAndValidateResponseJSON(response));
  }
  async AllowEditor(request, metadata) {
    await this._fetch("AllowEditor", request, metadata);
    return Empty.fromPartial({});
  }
};

// src/workers/system/RedditAPI.ts
var dispatcher = new WorkerDispatcher(self.name);
dispatcher.bindToWorkerPort(self);
var apiCategories = [
  {
    cname: "listings",
    constructor: Listings,
    definition: ListingsDefinition
  },
  {
    cname: "modnote",
    constructor: ModNote,
    definition: ModNoteDefinition
  },
  {
    cname: "newmodmail",
    constructor: NewModmail,
    definition: NewModmailDefinition
  },
  {
    cname: "flair",
    constructor: Flair,
    definition: FlairDefinition
  },
  {
    cname: "linksandcomments",
    constructor: LinksAndComments,
    definition: LinksAndCommentsDefinition
  },
  {
    cname: "moderation",
    constructor: Moderation,
    definition: ModerationDefinition
  },
  {
    cname: "privatemessages",
    constructor: PrivateMessages,
    definition: PrivateMessagesDefinition
  },
  {
    cname: "subreddits",
    constructor: Subreddits,
    definition: SubredditsDefinition
  },
  {
    cname: "users",
    constructor: Users,
    definition: UsersDefinition
  },
  {
    cname: "widgets",
    constructor: Widgets,
    definition: WidgetsDefinition
  },
  {
    cname: "wiki",
    constructor: Wiki,
    definition: WikiDefinition
  }
];
var httpClient = getHttpClient();
for (const cat of apiCategories) {
  const hostname = childHostname(cat.cname, { hostname: dispatcher.hostname });
  const client = new cat.constructor(httpClient);
  const server = EnvelopeServerBuilder.build(hostname, [cat.definition], client);
  dispatcher.bind(server);
}
Log.verbose(`${self.name} ready.`);
function getHttpClient() {
  const rootHostname = self.name.split(".").at(-1);
  const client = EnvelopeClientBuilder.build(
    resolvePluginHostname("http", { hostname: rootHostname }),
    [HTTPDefinition]
  );
  dispatcher.bind(client);
  return client;
}
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=worker.redditapi.cjs.map
