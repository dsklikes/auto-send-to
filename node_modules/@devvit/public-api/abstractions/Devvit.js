/**
 * GENERATED FILE - DO NOT EDIT
 * See generateDevvitShim.js.
 */
var _a, _Devvit_provides, _Devvit_uses, _Devvit_provideHandlers, _Devvit_apiClients, _Devvit_provide, _Devvit_contextActions, _Devvit_registerContextActions, _Devvit_schedulerHandlers, _Devvit_registerSchedulerHandlers, _Devvit_settingsFormFields;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import * as types from '@devvit/protos';
import { Definition, Empty, HandlerResult, } from '@devvit/protos';
import { Actor } from '@devvit/runtimes/api/Actor.js';
import { convertContextActionsToProtos, executeContextActionHandler, getContextActionId, } from '../context-actions/utilities.js';
import { executeSchedulerHandler } from '../scheduler/utilities.js';
import { getSettingsValues, transformFormFields } from '../settings/utilities.js';
/**
 * Provides a binding between a SerializableServiceDefinition and its interface to allow automatic
 * casting with the generic use
 */
class BoundType {
    constructor(ssd) {
        this.ssd = ssd;
    }
}
const redditApiDefinitionNames = Object.freeze([
    'Flair',
    'LinksAndComments',
    'Listings',
    'Moderation',
    'ModNote',
    'NewModmail',
    'PrivateMessages',
    'Subreddits',
    'Users',
    'Widgets',
    'Wiki',
]);
function bind(ssd) {
    return new BoundType(ssd);
}
/**
 * Devvit's non-class-based API for Bundle programs. Bundles are expected to
 * reexport their Devvit singleton. Config state is retained statically so that
 * when a Bundle exports their static instance of Devvit, its constructor can
 * populate the passed in Config with that static state.
 *
 * For the class API, see Actor.
 */
export class Devvit extends Actor {
    // {{TRIGGER_DOC_COMMENT}}
    static addTrigger(config) {
        if ('events' in config) {
            // Disable use of any. This is a tricky overload to write w/out any
            // eslint-disable @typescript-eslint/no-explicit-any
            for (const eventType of config.events) {
                this.addTrigger({
                    event: eventType,
                    handler: (event, meta) => config.handler({
                        type: eventType,
                        event,
                    }, meta),
                });
            }
            // eslint-enable @typescript-eslint/no-explicit-any
            return this;
        }
        const wrapHandler = (fn) => async (arg, meta) => {
            let result = await fn(arg, meta);
            return result ?? HandlerResult.fromPartial({});
        };
        switch (config.event) {
            case Devvit.Trigger.PostSubmit:
                Devvit.onPostSubmit(wrapHandler(config.handler));
                break;
            case Devvit.Trigger.PostUpdate:
                Devvit.onPostUpdate(wrapHandler(config.handler));
                break;
            case Devvit.Trigger.PostReport:
                Devvit.onPostReport(wrapHandler(config.handler));
                break;
            case Devvit.Trigger.CommentSubmit:
                Devvit.onCommentSubmit(wrapHandler(config.handler));
                break;
            case Devvit.Trigger.CommentUpdate:
                Devvit.onCommentUpdate(wrapHandler(config.handler));
                break;
            case Devvit.Trigger.CommentReport:
                Devvit.onCommentReport(wrapHandler(config.handler));
                break;
            case Devvit.Trigger.SubredditSubscribe:
                Devvit.onSubredditSubscribe(wrapHandler(config.handler));
                break;
            case Devvit.Trigger.AppInstall:
                Devvit.onAppInstall(wrapHandler(config.handler));
                break;
            case Devvit.Trigger.AppUpgrade:
                Devvit.onAppUpgrade(wrapHandler(config.handler));
                break;
        }
        return Devvit;
    }
    static use(type, opts) {
        return Devvit._use(Definition.fromSerializable(type.ssd), opts);
    }
    static getApiClient(type) {
        const definition = Definition.fromSerializable(type.ssd);
        const client = __classPrivateFieldGet(this, _a, "f", _Devvit_apiClients)[definition.fullName];
        if (!client) {
            throw new Error(`${definition.name} client has not been initialized. Make sure to call \`Devvit.use\` at the top of your main.ts file.`);
        }
        return client;
    }
    // OnPostSubmit
    static onPostSubmit(cb) {
        Devvit._extend(types.OnPostSubmitDefinition, '/devvit.actor.automation.v1alpha.OnPostSubmit/OnPostSubmit', cb);
    }
    // OnPostUpdate
    static onPostUpdate(cb) {
        Devvit._extend(types.OnPostUpdateDefinition, '/devvit.actor.automation.v1alpha.OnPostUpdate/OnPostUpdate', cb);
    }
    // OnPostReport
    static onPostReport(cb) {
        Devvit._extend(types.OnPostReportDefinition, '/devvit.actor.automation.v1alpha.OnPostReport/OnPostReport', cb);
    }
    // OnCommentSubmit
    static onCommentSubmit(cb) {
        Devvit._extend(types.OnCommentSubmitDefinition, '/devvit.actor.automation.v1alpha.OnCommentSubmit/OnCommentSubmit', cb);
    }
    // OnCommentUpdate
    static onCommentUpdate(cb) {
        Devvit._extend(types.OnCommentUpdateDefinition, '/devvit.actor.automation.v1alpha.OnCommentUpdate/OnCommentUpdate', cb);
    }
    // OnCommentReport
    static onCommentReport(cb) {
        Devvit._extend(types.OnCommentReportDefinition, '/devvit.actor.automation.v1alpha.OnCommentReport/OnCommentReport', cb);
    }
    // OnSubredditSubscribe
    static onSubredditSubscribe(cb) {
        Devvit._extend(types.OnSubredditSubscribeDefinition, '/devvit.actor.automation.v1alpha.OnSubredditSubscribe/OnSubredditSubscribe', cb);
    }
    // OnAppInstall
    static onAppInstall(cb) {
        Devvit._extend(types.OnAppInstallDefinition, '/devvit.actor.automation.v1alpha.OnAppInstall/OnAppInstall', cb);
    }
    // OnAppUpgrade
    static onAppUpgrade(cb) {
        Devvit._extend(types.OnAppUpgradeDefinition, '/devvit.actor.automation.v1alpha.OnAppUpgrade/OnAppUpgrade', cb);
    }
    static addAction(contextAction) {
        __classPrivateFieldGet(this, _a, "f", _Devvit_contextActions).set(getContextActionId(contextAction, __classPrivateFieldGet(this, _a, "f", _Devvit_contextActions).size), contextAction);
        __classPrivateFieldGet(this, _a, "m", _Devvit_registerContextActions).call(this);
        return Devvit;
    }
    static addActions(contextActions) {
        for (const contextAction of contextActions) {
            this.addAction(contextAction);
        }
        return Devvit;
    }
    static addSchedulerHandler(schedulerHandler) {
        __classPrivateFieldGet(Devvit, _a, "f", _Devvit_schedulerHandlers).set(schedulerHandler.type, schedulerHandler);
        __classPrivateFieldGet(Devvit, _a, "m", _Devvit_registerSchedulerHandlers).call(Devvit);
        return Devvit;
    }
    /**
     * Add fields to the app installation settings. These fields will appear in the subreddit app settings page
     * in the Developer Portal.
     *
     * @param {SettingsFormField[]} settings - The form fields to add to the app installation settings.
     *
     * @example
     * ```ts
     * import { Devvit } from '@devvit/public-api';
     *
     * Devvit.addSettings([
     *   {
     *     type: 'string',
     *     name: 'apiKey',
     *     label: 'API Key',
     *     required: true
     *   },
     *   {
     *     type: 'boolean',
     *     name: 'enabled',
     *     label: 'Feature Enabled',
     *     required: true
     *   },
     * ]);
     * ```
     */
    static addSettings(settings) {
        __classPrivateFieldSet(this, _a, settings, "f", _Devvit_settingsFormFields);
        this.use(this.Types.Settings);
        const fields = transformFormFields(__classPrivateFieldGet(this, _a, "f", _Devvit_settingsFormFields));
        this.InstallationSettings.onGetSettingsFields(async () => {
            if (!__classPrivateFieldGet(this, _a, "f", _Devvit_settingsFormFields)) {
                throw new Error('Installation settings is not defined.');
            }
            return types.GetFieldsResponse.fromPartial({
                fields: {
                    fields,
                },
            });
        });
        const flattendFields = __classPrivateFieldGet(this, _a, "f", _Devvit_settingsFormFields).flatMap((field) => {
            if (field.type === 'group') {
                return field.fields;
            }
            return field;
        });
        this.InstallationSettings.onValidateForm(async (req, metadata) => {
            if (!__classPrivateFieldGet(this, _a, "f", _Devvit_settingsFormFields)) {
                throw new Error('Installation settings is not defined.');
            }
            const response = types.ValidateFormResponse.fromPartial({
                success: true,
                errors: {},
            });
            const formValues = getSettingsValues(req.fieldValues);
            await Promise.all(flattendFields.map(async (field) => {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const fieldName = field.name;
                if (fieldName && field.type !== 'group' && field.onValidate) {
                    const value = formValues[fieldName];
                    const validator = field.onValidate;
                    const error = await validator({
                        isEditing: req.editing,
                        value,
                    }, metadata);
                    if (error) {
                        response.success = false;
                        response.errors[fieldName] = error;
                    }
                }
            }));
            return response;
        });
    }
    /** @internal */
    static _reset() {
        __classPrivateFieldSet(this, _a, new Set(), "f", _Devvit_provides);
        __classPrivateFieldSet(this, _a, {}, "f", _Devvit_uses);
        __classPrivateFieldSet(this, _a, {}, "f", _Devvit_provideHandlers);
        __classPrivateFieldSet(this, _a, new Map(), "f", _Devvit_contextActions);
        Object.keys(Devvit.prototype).forEach((key) => delete Devvit.prototype[key]);
    }
    /** @internal */
    static _extend(d, m, cb) {
        __classPrivateFieldGet(Devvit, _a, "m", _Devvit_provide).call(Devvit, d);
        __classPrivateFieldGet(Devvit, _a, "f", _Devvit_provideHandlers)[m] = cb;
    }
    /** @internal */
    static _use(d, opts) {
        __classPrivateFieldGet(this, _a, "f", _Devvit_uses)[d.fullName] = {
            def: d,
            options: opts ?? {},
            handler: undefined,
        };
        const wrapped = {};
        for (const method of Object.values(d.methods)) {
            wrapped[method.name] = (args, metadata) => __classPrivateFieldGet(this, _a, "f", _Devvit_uses)[d.fullName].handler?.[method.name]?.(method.requestType?.fromPartial(args ?? {}), metadata);
        }
        __classPrivateFieldGet(this, _a, "f", _Devvit_apiClients)[d.fullName] = wrapped;
        return wrapped;
    }
    constructor(cfg) {
        super(cfg);
        for (const fullName in __classPrivateFieldGet(Devvit, _a, "f", _Devvit_uses)) {
            const use = __classPrivateFieldGet(Devvit, _a, "f", _Devvit_uses)[fullName];
            use.handler = cfg.use(use.def, use.options);
        }
        for (const provide of __classPrivateFieldGet(Devvit, _a, "f", _Devvit_provides))
            cfg.provides(provide);
    }
}
_a = Devvit, _Devvit_provide = function _Devvit_provide(def) {
    if (!__classPrivateFieldGet(this, _a, "f", _Devvit_provides).has(def)) {
        __classPrivateFieldGet(this, _a, "f", _Devvit_provides).add(def);
        for (const key in def.methods) {
            const name = def.methods[key].name;
            Devvit.prototype[name] = async (args, metadata) => {
                const handler = __classPrivateFieldGet(this, _a, "f", _Devvit_provideHandlers)[`/${def.fullName}/${name}`];
                if (handler) {
                    if (def.methods[key].responseType.$type !== Empty.$type) {
                        return def.methods[key].responseType?.fromPartial((await handler(args, metadata)) ?? Empty.fromPartial({}));
                    }
                    else {
                        await handler(args, metadata);
                    }
                }
                return def.methods[key].responseType?.fromPartial({});
            };
        }
    }
}, _Devvit_registerContextActions = function _Devvit_registerContextActions() {
    if (__classPrivateFieldGet(Devvit, _a, "f", _Devvit_contextActions).size > 0) {
        Devvit.ContextAction.onGetActions(async () => {
            return convertContextActionsToProtos(Array.from(__classPrivateFieldGet(Devvit, _a, "f", _Devvit_contextActions).values()));
        });
        Devvit.ContextAction.onAction(async (req, metadata) => {
            const contextAction = __classPrivateFieldGet(Devvit, _a, "f", _Devvit_contextActions).get(req.actionId);
            if (!contextAction) {
                throw new Error('could not find context action handler');
            }
            const response = await executeContextActionHandler(contextAction, req, metadata);
            return {
                ...response,
                effects: [],
            };
        });
    }
}, _Devvit_registerSchedulerHandlers = function _Devvit_registerSchedulerHandlers() {
    if (__classPrivateFieldGet(Devvit, _a, "f", _Devvit_schedulerHandlers).size > 0) {
        Devvit.SchedulerHandler.onHandleScheduledAction(async (req, metadata) => {
            const handler = __classPrivateFieldGet(Devvit, _a, "f", _Devvit_schedulerHandlers).get(req.type);
            if (!handler) {
                throw new Error('could not find handler for scheduled action');
            }
            return executeSchedulerHandler(handler, req, metadata);
        });
    }
};
_Devvit_provides = { value: new Set() };
_Devvit_uses = { value: {} };
/** Methods can be asynchronous. */
_Devvit_provideHandlers = { value: {} };
_Devvit_apiClients = { value: {} };
Devvit.Types = Object.freeze({
    HTTP: bind(Definition.toSerializable(types.HTTPDefinition)),
    Logger: bind(Definition.toSerializable(types.LoggerDefinition)),
    Scheduler: bind(Definition.toSerializable(types.SchedulerDefinition)),
    Settings: bind(Definition.toSerializable(types.SettingsDefinition)),
    Timer: bind(Definition.toSerializable(types.TimerDefinition)),
    ContextAction: bind(Definition.toSerializable(types.ContextActionDefinition)),
    KVStore: bind(Definition.toSerializable(types.KVStoreDefinition)),
    InstallationSettings: bind(Definition.toSerializable(types.InstallationSettingsDefinition)),
    InstanceSettings: bind(Definition.toSerializable(types.InstanceSettingsDefinition)),
    SchedulerHandler: bind(Definition.toSerializable(types.SchedulerHandlerDefinition)),
    UserConfigurable: bind(Definition.toSerializable(types.UserConfigurableDefinition)),
    OnPostSubmit: bind(Definition.toSerializable(types.OnPostSubmitDefinition)),
    OnPostUpdate: bind(Definition.toSerializable(types.OnPostUpdateDefinition)),
    OnPostReport: bind(Definition.toSerializable(types.OnPostReportDefinition)),
    OnCommentSubmit: bind(Definition.toSerializable(types.OnCommentSubmitDefinition)),
    OnCommentUpdate: bind(Definition.toSerializable(types.OnCommentUpdateDefinition)),
    OnCommentReport: bind(Definition.toSerializable(types.OnCommentReportDefinition)),
    OnSubredditSubscribe: bind(Definition.toSerializable(types.OnSubredditSubscribeDefinition)),
    OnAppInstall: bind(Definition.toSerializable(types.OnAppInstallDefinition)),
    OnAppUpgrade: bind(Definition.toSerializable(types.OnAppUpgradeDefinition)),
    RedditAPI: {
        Flair: bind(Definition.toSerializable(types.FlairDefinition)),
        LinksAndComments: bind(Definition.toSerializable(types.LinksAndCommentsDefinition)),
        Listings: bind(Definition.toSerializable(types.ListingsDefinition)),
        Moderation: bind(Definition.toSerializable(types.ModerationDefinition)),
        ModNote: bind(Definition.toSerializable(types.ModNoteDefinition)),
        NewModmail: bind(Definition.toSerializable(types.NewModmailDefinition)),
        PrivateMessages: bind(Definition.toSerializable(types.PrivateMessagesDefinition)),
        Subreddits: bind(Definition.toSerializable(types.SubredditsDefinition)),
        Users: bind(Definition.toSerializable(types.UsersDefinition)),
        Widgets: bind(Definition.toSerializable(types.WidgetsDefinition)),
        Wiki: bind(Definition.toSerializable(types.WikiDefinition)),
    },
});
// ContextAction
Devvit.ContextAction = {
    onGetActions(cb) {
        Devvit._extend(types.ContextActionDefinition, '/devvit.actor.reddit.ContextAction/GetActions', cb);
    },
    onAction(cb) {
        Devvit._extend(types.ContextActionDefinition, '/devvit.actor.reddit.ContextAction/OnAction', cb);
    },
};
// KVStore
Devvit.KVStore = {
    onPut(cb) {
        Devvit._extend(types.KVStoreDefinition, '/devvit.plugin.kvstore.KVStore/Put', cb);
    },
    onGet(cb) {
        Devvit._extend(types.KVStoreDefinition, '/devvit.plugin.kvstore.KVStore/Get', cb);
    },
    onDel(cb) {
        Devvit._extend(types.KVStoreDefinition, '/devvit.plugin.kvstore.KVStore/Del', cb);
    },
    onList(cb) {
        Devvit._extend(types.KVStoreDefinition, '/devvit.plugin.kvstore.KVStore/List', cb);
    },
};
// InstallationSettings
Devvit.InstallationSettings = {
    onGetSettingsFields(cb) {
        Devvit._extend(types.InstallationSettingsDefinition, '/devvit.actor.settings.v1alpha.InstallationSettings/GetSettingsFields', cb);
    },
    onValidateForm(cb) {
        Devvit._extend(types.InstallationSettingsDefinition, '/devvit.actor.settings.v1alpha.InstallationSettings/ValidateForm', cb);
    },
};
// InstanceSettings
Devvit.InstanceSettings = {
    onGetSettingsFields(cb) {
        Devvit._extend(types.InstanceSettingsDefinition, '/devvit.actor.settings.v1alpha.InstanceSettings/GetSettingsFields', cb);
    },
    onValidateForm(cb) {
        Devvit._extend(types.InstanceSettingsDefinition, '/devvit.actor.settings.v1alpha.InstanceSettings/ValidateForm', cb);
    },
};
// SchedulerHandler
Devvit.SchedulerHandler = {
    onHandleScheduledAction(cb) {
        Devvit._extend(types.SchedulerHandlerDefinition, '/devvit.actor.scheduler.SchedulerHandler/HandleScheduledAction', cb);
    },
};
// UserConfigurable
Devvit.UserConfigurable = {
    onRenderForm(cb) {
        Devvit._extend(types.UserConfigurableDefinition, '/devvit.actor.user_configurable.UserConfigurable/RenderForm', cb);
    },
    onHandleFormResponse(cb) {
        Devvit._extend(types.UserConfigurableDefinition, '/devvit.actor.user_configurable.UserConfigurable/HandleFormResponse', cb);
    },
};
_Devvit_contextActions = { value: new Map() };
_Devvit_schedulerHandlers = { value: new Map() };
_Devvit_settingsFormFields = { value: void 0 };
(function (Devvit) {
    /**
     * The type of a trigger
     */
    let Trigger;
    (function (Trigger) {
        Trigger["PostSubmit"] = "PostSubmit";
        Trigger["PostUpdate"] = "PostUpdate";
        Trigger["PostReport"] = "PostReport";
        Trigger["CommentSubmit"] = "CommentSubmit";
        Trigger["CommentUpdate"] = "CommentUpdate";
        Trigger["CommentReport"] = "CommentReport";
        Trigger["SubredditSubscribe"] = "SubredditSubscribe";
        Trigger["AppInstall"] = "AppInstall";
        Trigger["AppUpgrade"] = "AppUpgrade";
    })(Trigger = Devvit.Trigger || (Devvit.Trigger = {}));
})(Devvit || (Devvit = {}));
