/**
 * #attributes.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { Struct } from '../../../../google/protobuf/struct.js';
import { messageTypeRegistry } from '../../../../typeRegistry.js';
import { blockActionTypeFromJSON, blockActionTypeToJSON, blockBorderWidthFromJSON, blockBorderWidthToJSON, blockHorizontalAlignmentFromJSON, blockHorizontalAlignmentToJSON, blockVerticalAlignmentFromJSON, blockVerticalAlignmentToJSON, } from './enums.js';
function createBaseBlockAlignment() {
    return { vertical: undefined, horizontal: undefined };
}
export const BlockAlignment = {
    $type: "devvit.ui.block_kit.v1beta.BlockAlignment",
    encode(message, writer = _m0.Writer.create()) {
        if (message.vertical !== undefined) {
            writer.uint32(8).int32(message.vertical);
        }
        if (message.horizontal !== undefined) {
            writer.uint32(16).int32(message.horizontal);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockAlignment();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vertical = reader.int32();
                    break;
                case 2:
                    message.horizontal = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vertical: isSet(object.vertical) ? blockVerticalAlignmentFromJSON(object.vertical) : undefined,
            horizontal: isSet(object.horizontal) ? blockHorizontalAlignmentFromJSON(object.horizontal) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.vertical !== undefined &&
            (obj.vertical = message.vertical !== undefined ? blockVerticalAlignmentToJSON(message.vertical) : undefined);
        message.horizontal !== undefined && (obj.horizontal = message.horizontal !== undefined
            ? blockHorizontalAlignmentToJSON(message.horizontal)
            : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockAlignment();
        message.vertical = object.vertical ?? undefined;
        message.horizontal = object.horizontal ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockAlignment", BlockAlignment);
function createBaseBlockBorder() {
    return { color: undefined, width: undefined };
}
export const BlockBorder = {
    $type: "devvit.ui.block_kit.v1beta.BlockBorder",
    encode(message, writer = _m0.Writer.create()) {
        if (message.color !== undefined) {
            writer.uint32(10).string(message.color);
        }
        if (message.width !== undefined) {
            writer.uint32(16).int32(message.width);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockBorder();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.color = reader.string();
                    break;
                case 2:
                    message.width = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            color: isSet(object.color) ? String(object.color) : undefined,
            width: isSet(object.width) ? blockBorderWidthFromJSON(object.width) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.color !== undefined && (obj.color = message.color);
        message.width !== undefined &&
            (obj.width = message.width !== undefined ? blockBorderWidthToJSON(message.width) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockBorder();
        message.color = object.color ?? undefined;
        message.width = object.width ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockBorder", BlockBorder);
function createBaseBlockSize() {
    return { grow: undefined, width: undefined, height: undefined };
}
export const BlockSize = {
    $type: "devvit.ui.block_kit.v1beta.BlockSize",
    encode(message, writer = _m0.Writer.create()) {
        if (message.grow !== undefined) {
            writer.uint32(8).bool(message.grow);
        }
        if (message.width !== undefined) {
            writer.uint32(21).float(message.width);
        }
        if (message.height !== undefined) {
            writer.uint32(29).float(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockSize();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.grow = reader.bool();
                    break;
                case 2:
                    message.width = reader.float();
                    break;
                case 3:
                    message.height = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            grow: isSet(object.grow) ? Boolean(object.grow) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
            height: isSet(object.height) ? Number(object.height) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.grow !== undefined && (obj.grow = message.grow);
        message.width !== undefined && (obj.width = message.width);
        message.height !== undefined && (obj.height = message.height);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockSize();
        message.grow = object.grow ?? undefined;
        message.width = object.width ?? undefined;
        message.height = object.height ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockSize", BlockSize);
function createBaseBlockAction() {
    return { type: 0, id: "", data: undefined };
}
export const BlockAction = {
    $type: "devvit.ui.block_kit.v1beta.BlockAction",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.data !== undefined) {
            Struct.encode(Struct.wrap(message.data), writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockAction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? blockActionTypeFromJSON(object.type) : 0,
            id: isSet(object.id) ? String(object.id) : "",
            data: isObject(object.data) ? object.data : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.type !== undefined && (obj.type = blockActionTypeToJSON(message.type));
        message.id !== undefined && (obj.id = message.id);
        message.data !== undefined && (obj.data = message.data);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockAction();
        message.type = object.type ?? 0;
        message.id = object.id ?? "";
        message.data = object.data ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.ui.block_kit.v1beta.BlockAction", BlockAction);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
