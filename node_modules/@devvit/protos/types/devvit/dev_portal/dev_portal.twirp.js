import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { AppCreationRequest, AppSearchRequest, AppSearchResponse, GetAppBySlugRequest, FullAppInfo, GetAllWithOwnerRequest, GetPopularAppsRequest, AppUpdateRequest, UnpublishAppRequest, AppExistsRequest, AppExistsResponse, AppAccountExistsRequest, AppAccountExistsResponse, } from './app/app.js';
import { AppInfo, MultipleAppInfos } from './app/info/app_info.js';
import { UUID } from '../uuid.js';
import { GetAllWithInstallLocationRequest, GetAllWithInstallerRequest, InstallationCreationRequest, FullInstallationInfo, GetByAppNameAndInstallLocationRequest, MultipleInstallationsResponse, GetAllWithAppResponse, GetInstallationHistoryRequest, GetInstallationHistoryResponse, InstallationUpgradeRequest, InstallationUpdateRequest, } from './installation/installation.js';
import { Empty } from '../../google/protobuf/empty.js';
import { AppVersionCreationRequest, FullAppVersionInfo, AppSlugAndVersion, AppVersionUpdateRequest, ValidInstallLocationsResponse, } from './app_version/app_version.js';
import { AppVersionInfo } from './app_version/info/app_version_info.js';
import { CreateFeedbackRequest } from './feedback/feedback.js';
import { Value } from '../../google/protobuf/struct.js';
import { GetInstallationSettingsFormRequest, GetInstallationSettingsFormResponse, ValidateInstallationSettingsFormRequest, ValidateInstallationSettingsFormResponse, GetInstallationSettingsRequest, GetInstallationSettingsResponse, UpdateInstallationSettingsRequest, UpdateInstallationSettingsResponse, } from './installation_settings/installation_settings.js';
export var AppMethod;
(function (AppMethod) {
    AppMethod["Create"] = "Create";
    AppMethod["Search"] = "Search";
    AppMethod["GetBySlug"] = "GetBySlug";
    AppMethod["GetByUUID"] = "GetByUUID";
    AppMethod["GetAllWithLocation"] = "GetAllWithLocation";
    AppMethod["GetAllWithInstaller"] = "GetAllWithInstaller";
    AppMethod["GetAllWithOwner"] = "GetAllWithOwner";
    AppMethod["GetPopularApps"] = "GetPopularApps";
    AppMethod["Update"] = "Update";
    AppMethod["Unpublish"] = "Unpublish";
    AppMethod["Exists"] = "Exists";
    AppMethod["AppAccountExists"] = "AppAccountExists";
})(AppMethod || (AppMethod = {}));
export const AppMethodList = [
    AppMethod.Create,
    AppMethod.Search,
    AppMethod.GetBySlug,
    AppMethod.GetByUUID,
    AppMethod.GetAllWithLocation,
    AppMethod.GetAllWithInstaller,
    AppMethod.GetAllWithOwner,
    AppMethod.GetPopularApps,
    AppMethod.Update,
    AppMethod.Unpublish,
    AppMethod.Exists,
    AppMethod.AppAccountExists,
];
export function createAppServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'App',
        methodList: AppMethodList,
        matchRoute: matchAppRoute,
    });
}
function matchAppRoute(method, events) {
    switch (method) {
        case 'Create':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Create' };
                await events.onMatch(ctx);
                return handleAppCreateRequest(ctx, service, data, interceptors);
            };
        case 'Search':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Search' };
                await events.onMatch(ctx);
                return handleAppSearchRequest(ctx, service, data, interceptors);
            };
        case 'GetBySlug':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetBySlug' };
                await events.onMatch(ctx);
                return handleAppGetBySlugRequest(ctx, service, data, interceptors);
            };
        case 'GetByUUID':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetByUUID' };
                await events.onMatch(ctx);
                return handleAppGetByUUIDRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithLocation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithLocation' };
                await events.onMatch(ctx);
                return handleAppGetAllWithLocationRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithInstaller':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithInstaller' };
                await events.onMatch(ctx);
                return handleAppGetAllWithInstallerRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithOwner':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithOwner' };
                await events.onMatch(ctx);
                return handleAppGetAllWithOwnerRequest(ctx, service, data, interceptors);
            };
        case 'GetPopularApps':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetPopularApps' };
                await events.onMatch(ctx);
                return handleAppGetPopularAppsRequest(ctx, service, data, interceptors);
            };
        case 'Update':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Update' };
                await events.onMatch(ctx);
                return handleAppUpdateRequest(ctx, service, data, interceptors);
            };
        case 'Unpublish':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Unpublish' };
                await events.onMatch(ctx);
                return handleAppUnpublishRequest(ctx, service, data, interceptors);
            };
        case 'Exists':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Exists' };
                await events.onMatch(ctx);
                return handleAppExistsRequest(ctx, service, data, interceptors);
            };
        case 'AppAccountExists':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AppAccountExists' };
                await events.onMatch(ctx);
                return handleAppAppAccountExistsRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppCreateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppCreateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppCreateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppSearchRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppSearchJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppSearchProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppGetBySlugRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppGetBySlugJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppGetBySlugProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppGetByUUIDRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppGetByUUIDJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppGetByUUIDProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppGetAllWithLocationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppGetAllWithLocationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppGetAllWithLocationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppGetAllWithInstallerRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppGetAllWithInstallerJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppGetAllWithInstallerProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppGetAllWithOwnerRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppGetAllWithOwnerJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppGetAllWithOwnerProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppGetPopularAppsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppGetPopularAppsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppGetPopularAppsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppUpdateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppUpdateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppUpdateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppUnpublishRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppUnpublishJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppUnpublishProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppExistsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppExistsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppExistsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppAppAccountExistsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppAppAccountExistsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppAppAccountExistsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleAppCreateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppCreationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return JSON.stringify(AppInfo.toJSON(response));
}
async function handleAppSearchJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppSearchRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Search(ctx, inputReq);
        });
    }
    else {
        response = await service.Search(ctx, request);
    }
    return JSON.stringify(AppSearchResponse.toJSON(response));
}
async function handleAppGetBySlugJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAppBySlugRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetBySlug(ctx, inputReq);
        });
    }
    else {
        response = await service.GetBySlug(ctx, request);
    }
    return JSON.stringify(FullAppInfo.toJSON(response));
}
async function handleAppGetByUUIDJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetByUUID(ctx, inputReq);
        });
    }
    else {
        response = await service.GetByUUID(ctx, request);
    }
    return JSON.stringify(FullAppInfo.toJSON(response));
}
async function handleAppGetAllWithLocationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAllWithInstallLocationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithLocation(ctx, request);
    }
    return JSON.stringify(MultipleAppInfos.toJSON(response));
}
async function handleAppGetAllWithInstallerJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAllWithInstallerRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithInstaller(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithInstaller(ctx, request);
    }
    return JSON.stringify(MultipleAppInfos.toJSON(response));
}
async function handleAppGetAllWithOwnerJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAllWithOwnerRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithOwner(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithOwner(ctx, request);
    }
    return JSON.stringify(MultipleAppInfos.toJSON(response));
}
async function handleAppGetPopularAppsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetPopularAppsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetPopularApps(ctx, inputReq);
        });
    }
    else {
        response = await service.GetPopularApps(ctx, request);
    }
    return JSON.stringify(MultipleAppInfos.toJSON(response));
}
async function handleAppUpdateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppUpdateRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Update(ctx, inputReq);
        });
    }
    else {
        response = await service.Update(ctx, request);
    }
    return JSON.stringify(FullAppInfo.toJSON(response));
}
async function handleAppUnpublishJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UnpublishAppRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unpublish(ctx, inputReq);
        });
    }
    else {
        response = await service.Unpublish(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleAppExistsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppExistsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Exists(ctx, inputReq);
        });
    }
    else {
        response = await service.Exists(ctx, request);
    }
    return JSON.stringify(AppExistsResponse.toJSON(response));
}
async function handleAppAppAccountExistsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppAccountExistsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AppAccountExists(ctx, inputReq);
        });
    }
    else {
        response = await service.AppAccountExists(ctx, request);
    }
    return JSON.stringify(AppAccountExistsResponse.toJSON(response));
}
async function handleAppCreateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppCreationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return Buffer.from(AppInfo.encode(response).finish());
}
async function handleAppSearchProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppSearchRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Search(ctx, inputReq);
        });
    }
    else {
        response = await service.Search(ctx, request);
    }
    return Buffer.from(AppSearchResponse.encode(response).finish());
}
async function handleAppGetBySlugProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAppBySlugRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetBySlug(ctx, inputReq);
        });
    }
    else {
        response = await service.GetBySlug(ctx, request);
    }
    return Buffer.from(FullAppInfo.encode(response).finish());
}
async function handleAppGetByUUIDProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetByUUID(ctx, inputReq);
        });
    }
    else {
        response = await service.GetByUUID(ctx, request);
    }
    return Buffer.from(FullAppInfo.encode(response).finish());
}
async function handleAppGetAllWithLocationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAllWithInstallLocationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithLocation(ctx, request);
    }
    return Buffer.from(MultipleAppInfos.encode(response).finish());
}
async function handleAppGetAllWithInstallerProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAllWithInstallerRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithInstaller(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithInstaller(ctx, request);
    }
    return Buffer.from(MultipleAppInfos.encode(response).finish());
}
async function handleAppGetAllWithOwnerProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAllWithOwnerRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithOwner(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithOwner(ctx, request);
    }
    return Buffer.from(MultipleAppInfos.encode(response).finish());
}
async function handleAppGetPopularAppsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetPopularAppsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetPopularApps(ctx, inputReq);
        });
    }
    else {
        response = await service.GetPopularApps(ctx, request);
    }
    return Buffer.from(MultipleAppInfos.encode(response).finish());
}
async function handleAppUpdateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppUpdateRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Update(ctx, inputReq);
        });
    }
    else {
        response = await service.Update(ctx, request);
    }
    return Buffer.from(FullAppInfo.encode(response).finish());
}
async function handleAppUnpublishProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UnpublishAppRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unpublish(ctx, inputReq);
        });
    }
    else {
        response = await service.Unpublish(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleAppExistsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppExistsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Exists(ctx, inputReq);
        });
    }
    else {
        response = await service.Exists(ctx, request);
    }
    return Buffer.from(AppExistsResponse.encode(response).finish());
}
async function handleAppAppAccountExistsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppAccountExistsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AppAccountExists(ctx, inputReq);
        });
    }
    else {
        response = await service.AppAccountExists(ctx, request);
    }
    return Buffer.from(AppAccountExistsResponse.encode(response).finish());
}
export var AppVersionMethod;
(function (AppVersionMethod) {
    AppVersionMethod["Create"] = "Create";
    AppVersionMethod["Get"] = "Get";
    AppVersionMethod["GetBySlugAndVersionNumber"] = "GetBySlugAndVersionNumber";
    AppVersionMethod["Update"] = "Update";
    AppVersionMethod["GetValidInstallLocations"] = "GetValidInstallLocations";
})(AppVersionMethod || (AppVersionMethod = {}));
export const AppVersionMethodList = [
    AppVersionMethod.Create,
    AppVersionMethod.Get,
    AppVersionMethod.GetBySlugAndVersionNumber,
    AppVersionMethod.Update,
    AppVersionMethod.GetValidInstallLocations,
];
export function createAppVersionServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'AppVersion',
        methodList: AppVersionMethodList,
        matchRoute: matchAppVersionRoute,
    });
}
function matchAppVersionRoute(method, events) {
    switch (method) {
        case 'Create':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Create' };
                await events.onMatch(ctx);
                return handleAppVersionCreateRequest(ctx, service, data, interceptors);
            };
        case 'Get':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Get' };
                await events.onMatch(ctx);
                return handleAppVersionGetRequest(ctx, service, data, interceptors);
            };
        case 'GetBySlugAndVersionNumber':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetBySlugAndVersionNumber' };
                await events.onMatch(ctx);
                return handleAppVersionGetBySlugAndVersionNumberRequest(ctx, service, data, interceptors);
            };
        case 'Update':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Update' };
                await events.onMatch(ctx);
                return handleAppVersionUpdateRequest(ctx, service, data, interceptors);
            };
        case 'GetValidInstallLocations':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetValidInstallLocations' };
                await events.onMatch(ctx);
                return handleAppVersionGetValidInstallLocationsRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionCreateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionCreateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionCreateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionGetRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionGetJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionGetProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionGetBySlugAndVersionNumberRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionGetBySlugAndVersionNumberJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionGetBySlugAndVersionNumberProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionUpdateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionUpdateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionUpdateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAppVersionGetValidInstallLocationsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAppVersionGetValidInstallLocationsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAppVersionGetValidInstallLocationsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleAppVersionCreateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppVersionCreationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return JSON.stringify(AppVersionInfo.toJSON(response));
}
async function handleAppVersionGetJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Get(ctx, inputReq);
        });
    }
    else {
        response = await service.Get(ctx, request);
    }
    return JSON.stringify(FullAppVersionInfo.toJSON(response));
}
async function handleAppVersionGetBySlugAndVersionNumberJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppSlugAndVersion.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetBySlugAndVersionNumber(ctx, inputReq);
        });
    }
    else {
        response = await service.GetBySlugAndVersionNumber(ctx, request);
    }
    return JSON.stringify(FullAppVersionInfo.toJSON(response));
}
async function handleAppVersionUpdateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppVersionUpdateRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Update(ctx, inputReq);
        });
    }
    else {
        response = await service.Update(ctx, request);
    }
    return JSON.stringify(FullAppVersionInfo.toJSON(response));
}
async function handleAppVersionGetValidInstallLocationsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetValidInstallLocations(ctx, inputReq);
        });
    }
    else {
        response = await service.GetValidInstallLocations(ctx, request);
    }
    return JSON.stringify(ValidInstallLocationsResponse.toJSON(response));
}
async function handleAppVersionCreateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppVersionCreationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return Buffer.from(AppVersionInfo.encode(response).finish());
}
async function handleAppVersionGetProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Get(ctx, inputReq);
        });
    }
    else {
        response = await service.Get(ctx, request);
    }
    return Buffer.from(FullAppVersionInfo.encode(response).finish());
}
async function handleAppVersionGetBySlugAndVersionNumberProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppSlugAndVersion.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetBySlugAndVersionNumber(ctx, inputReq);
        });
    }
    else {
        response = await service.GetBySlugAndVersionNumber(ctx, request);
    }
    return Buffer.from(FullAppVersionInfo.encode(response).finish());
}
async function handleAppVersionUpdateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppVersionUpdateRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Update(ctx, inputReq);
        });
    }
    else {
        response = await service.Update(ctx, request);
    }
    return Buffer.from(FullAppVersionInfo.encode(response).finish());
}
async function handleAppVersionGetValidInstallLocationsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetValidInstallLocations(ctx, inputReq);
        });
    }
    else {
        response = await service.GetValidInstallLocations(ctx, request);
    }
    return Buffer.from(ValidInstallLocationsResponse.encode(response).finish());
}
export var InstallationsMethod;
(function (InstallationsMethod) {
    InstallationsMethod["Create"] = "Create";
    InstallationsMethod["GetByUUID"] = "GetByUUID";
    InstallationsMethod["GetByAppNameAndInstallLocation"] = "GetByAppNameAndInstallLocation";
    InstallationsMethod["GetAllWithInstallLocation"] = "GetAllWithInstallLocation";
    InstallationsMethod["GetAllWithInstaller"] = "GetAllWithInstaller";
    InstallationsMethod["GetAllWithVersionUUID"] = "GetAllWithVersionUUID";
    InstallationsMethod["GetAllWithApp"] = "GetAllWithApp";
    InstallationsMethod["GetInstallationHistory"] = "GetInstallationHistory";
    InstallationsMethod["Upgrade"] = "Upgrade";
    InstallationsMethod["Update"] = "Update";
    InstallationsMethod["Remove"] = "Remove";
})(InstallationsMethod || (InstallationsMethod = {}));
export const InstallationsMethodList = [
    InstallationsMethod.Create,
    InstallationsMethod.GetByUUID,
    InstallationsMethod.GetByAppNameAndInstallLocation,
    InstallationsMethod.GetAllWithInstallLocation,
    InstallationsMethod.GetAllWithInstaller,
    InstallationsMethod.GetAllWithVersionUUID,
    InstallationsMethod.GetAllWithApp,
    InstallationsMethod.GetInstallationHistory,
    InstallationsMethod.Upgrade,
    InstallationsMethod.Update,
    InstallationsMethod.Remove,
];
export function createInstallationsServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'Installations',
        methodList: InstallationsMethodList,
        matchRoute: matchInstallationsRoute,
    });
}
function matchInstallationsRoute(method, events) {
    switch (method) {
        case 'Create':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Create' };
                await events.onMatch(ctx);
                return handleInstallationsCreateRequest(ctx, service, data, interceptors);
            };
        case 'GetByUUID':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetByUUID' };
                await events.onMatch(ctx);
                return handleInstallationsGetByUUIDRequest(ctx, service, data, interceptors);
            };
        case 'GetByAppNameAndInstallLocation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetByAppNameAndInstallLocation' };
                await events.onMatch(ctx);
                return handleInstallationsGetByAppNameAndInstallLocationRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithInstallLocation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithInstallLocation' };
                await events.onMatch(ctx);
                return handleInstallationsGetAllWithInstallLocationRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithInstaller':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithInstaller' };
                await events.onMatch(ctx);
                return handleInstallationsGetAllWithInstallerRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithVersionUUID':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithVersionUUID' };
                await events.onMatch(ctx);
                return handleInstallationsGetAllWithVersionUUIDRequest(ctx, service, data, interceptors);
            };
        case 'GetAllWithApp':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAllWithApp' };
                await events.onMatch(ctx);
                return handleInstallationsGetAllWithAppRequest(ctx, service, data, interceptors);
            };
        case 'GetInstallationHistory':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetInstallationHistory' };
                await events.onMatch(ctx);
                return handleInstallationsGetInstallationHistoryRequest(ctx, service, data, interceptors);
            };
        case 'Upgrade':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Upgrade' };
                await events.onMatch(ctx);
                return handleInstallationsUpgradeRequest(ctx, service, data, interceptors);
            };
        case 'Update':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Update' };
                await events.onMatch(ctx);
                return handleInstallationsUpdateRequest(ctx, service, data, interceptors);
            };
        case 'Remove':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Remove' };
                await events.onMatch(ctx);
                return handleInstallationsRemoveRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsCreateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsCreateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsCreateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetByUUIDRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetByUUIDJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetByUUIDProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetByAppNameAndInstallLocationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetByAppNameAndInstallLocationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetByAppNameAndInstallLocationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetAllWithInstallLocationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetAllWithInstallLocationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetAllWithInstallLocationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetAllWithInstallerRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetAllWithInstallerJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetAllWithInstallerProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetAllWithVersionUUIDRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetAllWithVersionUUIDJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetAllWithVersionUUIDProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetAllWithAppRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetAllWithAppJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetAllWithAppProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsGetInstallationHistoryRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsGetInstallationHistoryJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsGetInstallationHistoryProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsUpgradeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsUpgradeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsUpgradeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsUpdateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsUpdateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsUpdateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleInstallationsRemoveRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleInstallationsRemoveJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleInstallationsRemoveProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleInstallationsCreateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationCreationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return JSON.stringify(FullInstallationInfo.toJSON(response));
}
async function handleInstallationsGetByUUIDJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetByUUID(ctx, inputReq);
        });
    }
    else {
        response = await service.GetByUUID(ctx, request);
    }
    return JSON.stringify(FullInstallationInfo.toJSON(response));
}
async function handleInstallationsGetByAppNameAndInstallLocationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetByAppNameAndInstallLocationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetByAppNameAndInstallLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetByAppNameAndInstallLocation(ctx, request);
    }
    return JSON.stringify(FullInstallationInfo.toJSON(response));
}
async function handleInstallationsGetAllWithInstallLocationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAllWithInstallLocationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithInstallLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithInstallLocation(ctx, request);
    }
    return JSON.stringify(MultipleInstallationsResponse.toJSON(response));
}
async function handleInstallationsGetAllWithInstallerJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAllWithInstallerRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithInstaller(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithInstaller(ctx, request);
    }
    return JSON.stringify(MultipleInstallationsResponse.toJSON(response));
}
async function handleInstallationsGetAllWithVersionUUIDJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithVersionUUID(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithVersionUUID(ctx, request);
    }
    return JSON.stringify(MultipleInstallationsResponse.toJSON(response));
}
async function handleInstallationsGetAllWithAppJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithApp(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithApp(ctx, request);
    }
    return JSON.stringify(GetAllWithAppResponse.toJSON(response));
}
async function handleInstallationsGetInstallationHistoryJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetInstallationHistoryRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetInstallationHistory(ctx, inputReq);
        });
    }
    else {
        response = await service.GetInstallationHistory(ctx, request);
    }
    return JSON.stringify(GetInstallationHistoryResponse.toJSON(response));
}
async function handleInstallationsUpgradeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationUpgradeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Upgrade(ctx, inputReq);
        });
    }
    else {
        response = await service.Upgrade(ctx, request);
    }
    return JSON.stringify(FullInstallationInfo.toJSON(response));
}
async function handleInstallationsUpdateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationUpdateRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Update(ctx, inputReq);
        });
    }
    else {
        response = await service.Update(ctx, request);
    }
    return JSON.stringify(FullInstallationInfo.toJSON(response));
}
async function handleInstallationsRemoveJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UUID.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Remove(ctx, inputReq);
        });
    }
    else {
        response = await service.Remove(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleInstallationsCreateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationCreationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return Buffer.from(FullInstallationInfo.encode(response).finish());
}
async function handleInstallationsGetByUUIDProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetByUUID(ctx, inputReq);
        });
    }
    else {
        response = await service.GetByUUID(ctx, request);
    }
    return Buffer.from(FullInstallationInfo.encode(response).finish());
}
async function handleInstallationsGetByAppNameAndInstallLocationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetByAppNameAndInstallLocationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetByAppNameAndInstallLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetByAppNameAndInstallLocation(ctx, request);
    }
    return Buffer.from(FullInstallationInfo.encode(response).finish());
}
async function handleInstallationsGetAllWithInstallLocationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAllWithInstallLocationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithInstallLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithInstallLocation(ctx, request);
    }
    return Buffer.from(MultipleInstallationsResponse.encode(response).finish());
}
async function handleInstallationsGetAllWithInstallerProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAllWithInstallerRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithInstaller(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithInstaller(ctx, request);
    }
    return Buffer.from(MultipleInstallationsResponse.encode(response).finish());
}
async function handleInstallationsGetAllWithVersionUUIDProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithVersionUUID(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithVersionUUID(ctx, request);
    }
    return Buffer.from(MultipleInstallationsResponse.encode(response).finish());
}
async function handleInstallationsGetAllWithAppProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAllWithApp(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAllWithApp(ctx, request);
    }
    return Buffer.from(GetAllWithAppResponse.encode(response).finish());
}
async function handleInstallationsGetInstallationHistoryProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetInstallationHistoryRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetInstallationHistory(ctx, inputReq);
        });
    }
    else {
        response = await service.GetInstallationHistory(ctx, request);
    }
    return Buffer.from(GetInstallationHistoryResponse.encode(response).finish());
}
async function handleInstallationsUpgradeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationUpgradeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Upgrade(ctx, inputReq);
        });
    }
    else {
        response = await service.Upgrade(ctx, request);
    }
    return Buffer.from(FullInstallationInfo.encode(response).finish());
}
async function handleInstallationsUpdateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationUpdateRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Update(ctx, inputReq);
        });
    }
    else {
        response = await service.Update(ctx, request);
    }
    return Buffer.from(FullInstallationInfo.encode(response).finish());
}
async function handleInstallationsRemoveProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UUID.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Remove(ctx, inputReq);
        });
    }
    else {
        response = await service.Remove(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
export var FeedbackMethod;
(function (FeedbackMethod) {
    FeedbackMethod["Create"] = "Create";
})(FeedbackMethod || (FeedbackMethod = {}));
export const FeedbackMethodList = [FeedbackMethod.Create];
export function createFeedbackServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'Feedback',
        methodList: FeedbackMethodList,
        matchRoute: matchFeedbackRoute,
    });
}
function matchFeedbackRoute(method, events) {
    switch (method) {
        case 'Create':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Create' };
                await events.onMatch(ctx);
                return handleFeedbackCreateRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFeedbackCreateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFeedbackCreateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFeedbackCreateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleFeedbackCreateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CreateFeedbackRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleFeedbackCreateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CreateFeedbackRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Create(ctx, inputReq);
        });
    }
    else {
        response = await service.Create(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
export var EventsMethod;
(function (EventsMethod) {
    EventsMethod["SendEvent"] = "SendEvent";
})(EventsMethod || (EventsMethod = {}));
export const EventsMethodList = [EventsMethod.SendEvent];
export function createEventsServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'Events',
        methodList: EventsMethodList,
        matchRoute: matchEventsRoute,
    });
}
function matchEventsRoute(method, events) {
    switch (method) {
        case 'SendEvent':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'SendEvent' };
                await events.onMatch(ctx);
                return handleEventsSendEventRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleEventsSendEventRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleEventsSendEventJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleEventsSendEventProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleEventsSendEventJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Value.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SendEvent(ctx, inputReq);
        });
    }
    else {
        response = await service.SendEvent(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleEventsSendEventProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Value.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SendEvent(ctx, inputReq);
        });
    }
    else {
        response = await service.SendEvent(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
export var DevPortalInstallationSettingsMethod;
(function (DevPortalInstallationSettingsMethod) {
    DevPortalInstallationSettingsMethod["GetForm"] = "GetForm";
    DevPortalInstallationSettingsMethod["ValidateForm"] = "ValidateForm";
    DevPortalInstallationSettingsMethod["GetSettings"] = "GetSettings";
    DevPortalInstallationSettingsMethod["UpdateSettings"] = "UpdateSettings";
})(DevPortalInstallationSettingsMethod || (DevPortalInstallationSettingsMethod = {}));
export const DevPortalInstallationSettingsMethodList = [
    DevPortalInstallationSettingsMethod.GetForm,
    DevPortalInstallationSettingsMethod.ValidateForm,
    DevPortalInstallationSettingsMethod.GetSettings,
    DevPortalInstallationSettingsMethod.UpdateSettings,
];
export function createDevPortalInstallationSettingsServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'DevPortalInstallationSettings',
        methodList: DevPortalInstallationSettingsMethodList,
        matchRoute: matchDevPortalInstallationSettingsRoute,
    });
}
function matchDevPortalInstallationSettingsRoute(method, events) {
    switch (method) {
        case 'GetForm':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetForm' };
                await events.onMatch(ctx);
                return handleDevPortalInstallationSettingsGetFormRequest(ctx, service, data, interceptors);
            };
        case 'ValidateForm':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ValidateForm' };
                await events.onMatch(ctx);
                return handleDevPortalInstallationSettingsValidateFormRequest(ctx, service, data, interceptors);
            };
        case 'GetSettings':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetSettings' };
                await events.onMatch(ctx);
                return handleDevPortalInstallationSettingsGetSettingsRequest(ctx, service, data, interceptors);
            };
        case 'UpdateSettings':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UpdateSettings' };
                await events.onMatch(ctx);
                return handleDevPortalInstallationSettingsUpdateSettingsRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDevPortalInstallationSettingsGetFormRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDevPortalInstallationSettingsGetFormJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDevPortalInstallationSettingsGetFormProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDevPortalInstallationSettingsValidateFormRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDevPortalInstallationSettingsValidateFormJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDevPortalInstallationSettingsValidateFormProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDevPortalInstallationSettingsGetSettingsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDevPortalInstallationSettingsGetSettingsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDevPortalInstallationSettingsGetSettingsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleDevPortalInstallationSettingsUpdateSettingsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleDevPortalInstallationSettingsUpdateSettingsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleDevPortalInstallationSettingsUpdateSettingsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleDevPortalInstallationSettingsGetFormJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetInstallationSettingsFormRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetForm(ctx, inputReq);
        });
    }
    else {
        response = await service.GetForm(ctx, request);
    }
    return JSON.stringify(GetInstallationSettingsFormResponse.toJSON(response));
}
async function handleDevPortalInstallationSettingsValidateFormJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ValidateInstallationSettingsFormRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ValidateForm(ctx, inputReq);
        });
    }
    else {
        response = await service.ValidateForm(ctx, request);
    }
    return JSON.stringify(ValidateInstallationSettingsFormResponse.toJSON(response));
}
async function handleDevPortalInstallationSettingsGetSettingsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetInstallationSettingsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetSettings(ctx, inputReq);
        });
    }
    else {
        response = await service.GetSettings(ctx, request);
    }
    return JSON.stringify(GetInstallationSettingsResponse.toJSON(response));
}
async function handleDevPortalInstallationSettingsUpdateSettingsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UpdateInstallationSettingsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateSettings(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateSettings(ctx, request);
    }
    return JSON.stringify(UpdateInstallationSettingsResponse.toJSON(response));
}
async function handleDevPortalInstallationSettingsGetFormProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetInstallationSettingsFormRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetForm(ctx, inputReq);
        });
    }
    else {
        response = await service.GetForm(ctx, request);
    }
    return Buffer.from(GetInstallationSettingsFormResponse.encode(response).finish());
}
async function handleDevPortalInstallationSettingsValidateFormProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ValidateInstallationSettingsFormRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ValidateForm(ctx, inputReq);
        });
    }
    else {
        response = await service.ValidateForm(ctx, request);
    }
    return Buffer.from(ValidateInstallationSettingsFormResponse.encode(response).finish());
}
async function handleDevPortalInstallationSettingsGetSettingsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetInstallationSettingsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetSettings(ctx, inputReq);
        });
    }
    else {
        response = await service.GetSettings(ctx, request);
    }
    return Buffer.from(GetInstallationSettingsResponse.encode(response).finish());
}
async function handleDevPortalInstallationSettingsUpdateSettingsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UpdateInstallationSettingsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateSettings(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateSettings(ctx, request);
    }
    return Buffer.from(UpdateInstallationSettingsResponse.encode(response).finish());
}
