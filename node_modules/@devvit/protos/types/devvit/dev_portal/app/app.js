/**
 * #app.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from 'protobufjs/minimal.js';
import { BoolValue, Int32Value, StringValue } from '../../../google/protobuf/wrappers.js';
import { messageTypeRegistry } from '../../../typeRegistry.js';
import { AppVersionInfo } from '../app_version/info/app_version_info.js';
import { categoriesFromJSON, categoriesToJSON } from './categories/categories.js';
import { AppInfo } from './info/app_info.js';
export var OrderBy;
(function (OrderBy) {
    OrderBy[OrderBy["DATE_CREATED"] = 0] = "DATE_CREATED";
    OrderBy[OrderBy["NAME"] = 1] = "NAME";
    OrderBy[OrderBy["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OrderBy || (OrderBy = {}));
export function orderByFromJSON(object) {
    switch (object) {
        case 0:
        case "DATE_CREATED":
            return OrderBy.DATE_CREATED;
        case 1:
        case "NAME":
            return OrderBy.NAME;
        case -1:
        case "UNRECOGNIZED":
        default:
            return OrderBy.UNRECOGNIZED;
    }
}
export function orderByToJSON(object) {
    switch (object) {
        case OrderBy.DATE_CREATED:
            return 0;
        case OrderBy.NAME:
            return 1;
        case OrderBy.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseAppSearchRequest() {
    return {
        searchTerm: undefined,
        categories: [],
        page: undefined,
        pageSize: undefined,
        orderBy: 0,
        isAscending: undefined,
    };
}
export const AppSearchRequest = {
    $type: "devvit.dev_portal.app.AppSearchRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.searchTerm !== undefined) {
            StringValue.encode({ value: message.searchTerm }, writer.uint32(10).fork()).ldelim();
        }
        writer.uint32(18).fork();
        for (const v of message.categories) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.page !== undefined) {
            Int32Value.encode({ value: message.page }, writer.uint32(26).fork()).ldelim();
        }
        if (message.pageSize !== undefined) {
            Int32Value.encode({ value: message.pageSize }, writer.uint32(34).fork()).ldelim();
        }
        if (message.orderBy !== 0) {
            writer.uint32(40).int32(message.orderBy);
        }
        if (message.isAscending !== undefined) {
            BoolValue.encode({ value: message.isAscending }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppSearchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.searchTerm = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.categories.push(reader.int32());
                        }
                    }
                    else {
                        message.categories.push(reader.int32());
                    }
                    break;
                case 3:
                    message.page = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.pageSize = Int32Value.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.orderBy = reader.int32();
                    break;
                case 6:
                    message.isAscending = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            searchTerm: isSet(object.searchTerm) ? String(object.searchTerm) : undefined,
            categories: Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
            page: isSet(object.page) ? Number(object.page) : undefined,
            pageSize: isSet(object.pageSize) ? Number(object.pageSize) : undefined,
            orderBy: isSet(object.orderBy) ? orderByFromJSON(object.orderBy) : 0,
            isAscending: isSet(object.isAscending) ? Boolean(object.isAscending) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.searchTerm !== undefined && (obj.searchTerm = message.searchTerm);
        if (message.categories) {
            obj.categories = message.categories.map((e) => categoriesToJSON(e));
        }
        else {
            obj.categories = [];
        }
        message.page !== undefined && (obj.page = message.page);
        message.pageSize !== undefined && (obj.pageSize = message.pageSize);
        message.orderBy !== undefined && (obj.orderBy = orderByToJSON(message.orderBy));
        message.isAscending !== undefined && (obj.isAscending = message.isAscending);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppSearchRequest();
        message.searchTerm = object.searchTerm ?? undefined;
        message.categories = object.categories?.map((e) => e) || [];
        message.page = object.page ?? undefined;
        message.pageSize = object.pageSize ?? undefined;
        message.orderBy = object.orderBy ?? 0;
        message.isAscending = object.isAscending ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppSearchRequest", AppSearchRequest);
function createBaseGetAppBySlugRequest() {
    return { slug: "" };
}
export const GetAppBySlugRequest = {
    $type: "devvit.dev_portal.app.GetAppBySlugRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.slug !== "") {
            writer.uint32(10).string(message.slug);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAppBySlugRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slug = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { slug: isSet(object.slug) ? String(object.slug) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.slug !== undefined && (obj.slug = message.slug);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetAppBySlugRequest();
        message.slug = object.slug ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.GetAppBySlugRequest", GetAppBySlugRequest);
function createBaseGetAllWithOwnerRequest() {
    return { owner: "" };
}
export const GetAllWithOwnerRequest = {
    $type: "devvit.dev_portal.app.GetAllWithOwnerRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.owner !== "") {
            writer.uint32(10).string(message.owner);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAllWithOwnerRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.owner = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { owner: isSet(object.owner) ? String(object.owner) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.owner !== undefined && (obj.owner = message.owner);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetAllWithOwnerRequest();
        message.owner = object.owner ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.GetAllWithOwnerRequest", GetAllWithOwnerRequest);
function createBaseAppCreationRequest() {
    return { name: "", description: "", isNsfw: false, categories: [], autogenerateName: false };
}
export const AppCreationRequest = {
    $type: "devvit.dev_portal.app.AppCreationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.isNsfw === true) {
            writer.uint32(24).bool(message.isNsfw);
        }
        writer.uint32(34).fork();
        for (const v of message.categories) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.autogenerateName === true) {
            writer.uint32(40).bool(message.autogenerateName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppCreationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.isNsfw = reader.bool();
                    break;
                case 4:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.categories.push(reader.int32());
                        }
                    }
                    else {
                        message.categories.push(reader.int32());
                    }
                    break;
                case 5:
                    message.autogenerateName = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            description: isSet(object.description) ? String(object.description) : "",
            isNsfw: isSet(object.isNsfw) ? Boolean(object.isNsfw) : false,
            categories: Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
            autogenerateName: isSet(object.autogenerateName) ? Boolean(object.autogenerateName) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.description !== undefined && (obj.description = message.description);
        message.isNsfw !== undefined && (obj.isNsfw = message.isNsfw);
        if (message.categories) {
            obj.categories = message.categories.map((e) => categoriesToJSON(e));
        }
        else {
            obj.categories = [];
        }
        message.autogenerateName !== undefined && (obj.autogenerateName = message.autogenerateName);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppCreationRequest();
        message.name = object.name ?? "";
        message.description = object.description ?? "";
        message.isNsfw = object.isNsfw ?? false;
        message.categories = object.categories?.map((e) => e) || [];
        message.autogenerateName = object.autogenerateName ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppCreationRequest", AppCreationRequest);
function createBaseGetPopularAppsRequest() {
    return { limit: 0 };
}
export const GetPopularAppsRequest = {
    $type: "devvit.dev_portal.app.GetPopularAppsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.limit !== 0) {
            writer.uint32(8).int32(message.limit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPopularAppsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.limit = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { limit: isSet(object.limit) ? Number(object.limit) : 0 };
    },
    toJSON(message) {
        const obj = {};
        message.limit !== undefined && (obj.limit = Math.round(message.limit));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseGetPopularAppsRequest();
        message.limit = object.limit ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.GetPopularAppsRequest", GetPopularAppsRequest);
function createBaseAppUpdateRequest() {
    return {
        id: "",
        slug: undefined,
        name: undefined,
        description: undefined,
        isNsfw: undefined,
        isDelisted: undefined,
        categories: [],
        termsAndConditions: undefined,
        privacyPolicy: undefined,
    };
}
export const AppUpdateRequest = {
    $type: "devvit.dev_portal.app.AppUpdateRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.slug !== undefined) {
            StringValue.encode({ value: message.slug }, writer.uint32(18).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(34).fork()).ldelim();
        }
        if (message.isNsfw !== undefined) {
            BoolValue.encode({ value: message.isNsfw }, writer.uint32(42).fork()).ldelim();
        }
        if (message.isDelisted !== undefined) {
            BoolValue.encode({ value: message.isDelisted }, writer.uint32(50).fork()).ldelim();
        }
        writer.uint32(58).fork();
        for (const v of message.categories) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.termsAndConditions !== undefined) {
            StringValue.encode({ value: message.termsAndConditions }, writer.uint32(66).fork()).ldelim();
        }
        if (message.privacyPolicy !== undefined) {
            StringValue.encode({ value: message.privacyPolicy }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppUpdateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.slug = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 3:
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 4:
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 5:
                    message.isNsfw = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 6:
                    message.isDelisted = BoolValue.decode(reader, reader.uint32()).value;
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.categories.push(reader.int32());
                        }
                    }
                    else {
                        message.categories.push(reader.int32());
                    }
                    break;
                case 8:
                    message.termsAndConditions = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 9:
                    message.privacyPolicy = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            slug: isSet(object.slug) ? String(object.slug) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            isNsfw: isSet(object.isNsfw) ? Boolean(object.isNsfw) : undefined,
            isDelisted: isSet(object.isDelisted) ? Boolean(object.isDelisted) : undefined,
            categories: Array.isArray(object?.categories) ? object.categories.map((e) => categoriesFromJSON(e)) : [],
            termsAndConditions: isSet(object.termsAndConditions) ? String(object.termsAndConditions) : undefined,
            privacyPolicy: isSet(object.privacyPolicy) ? String(object.privacyPolicy) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.slug !== undefined && (obj.slug = message.slug);
        message.name !== undefined && (obj.name = message.name);
        message.description !== undefined && (obj.description = message.description);
        message.isNsfw !== undefined && (obj.isNsfw = message.isNsfw);
        message.isDelisted !== undefined && (obj.isDelisted = message.isDelisted);
        if (message.categories) {
            obj.categories = message.categories.map((e) => categoriesToJSON(e));
        }
        else {
            obj.categories = [];
        }
        message.termsAndConditions !== undefined && (obj.termsAndConditions = message.termsAndConditions);
        message.privacyPolicy !== undefined && (obj.privacyPolicy = message.privacyPolicy);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppUpdateRequest();
        message.id = object.id ?? "";
        message.slug = object.slug ?? undefined;
        message.name = object.name ?? undefined;
        message.description = object.description ?? undefined;
        message.isNsfw = object.isNsfw ?? undefined;
        message.isDelisted = object.isDelisted ?? undefined;
        message.categories = object.categories?.map((e) => e) || [];
        message.termsAndConditions = object.termsAndConditions ?? undefined;
        message.privacyPolicy = object.privacyPolicy ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppUpdateRequest", AppUpdateRequest);
function createBaseFullAppInfo() {
    return { app: undefined, versions: [] };
}
export const FullAppInfo = {
    $type: "devvit.dev_portal.app.FullAppInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.app !== undefined) {
            AppInfo.encode(message.app, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.versions) {
            AppVersionInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFullAppInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.app = AppInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.versions.push(AppVersionInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            app: isSet(object.app) ? AppInfo.fromJSON(object.app) : undefined,
            versions: Array.isArray(object?.versions) ? object.versions.map((e) => AppVersionInfo.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.app !== undefined && (obj.app = message.app ? AppInfo.toJSON(message.app) : undefined);
        if (message.versions) {
            obj.versions = message.versions.map((e) => e ? AppVersionInfo.toJSON(e) : undefined);
        }
        else {
            obj.versions = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFullAppInfo();
        message.app = (object.app !== undefined && object.app !== null) ? AppInfo.fromPartial(object.app) : undefined;
        message.versions = object.versions?.map((e) => AppVersionInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.FullAppInfo", FullAppInfo);
function createBaseAppSearchResponse() {
    return { apps: [], totalResults: 0, pageNumber: 0, pageSize: 0 };
}
export const AppSearchResponse = {
    $type: "devvit.dev_portal.app.AppSearchResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.apps) {
            AppInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.totalResults !== 0) {
            writer.uint32(16).int32(message.totalResults);
        }
        if (message.pageNumber !== 0) {
            writer.uint32(24).int32(message.pageNumber);
        }
        if (message.pageSize !== 0) {
            writer.uint32(32).int32(message.pageSize);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppSearchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.apps.push(AppInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.totalResults = reader.int32();
                    break;
                case 3:
                    message.pageNumber = reader.int32();
                    break;
                case 4:
                    message.pageSize = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            apps: Array.isArray(object?.apps) ? object.apps.map((e) => AppInfo.fromJSON(e)) : [],
            totalResults: isSet(object.totalResults) ? Number(object.totalResults) : 0,
            pageNumber: isSet(object.pageNumber) ? Number(object.pageNumber) : 0,
            pageSize: isSet(object.pageSize) ? Number(object.pageSize) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.apps) {
            obj.apps = message.apps.map((e) => e ? AppInfo.toJSON(e) : undefined);
        }
        else {
            obj.apps = [];
        }
        message.totalResults !== undefined && (obj.totalResults = Math.round(message.totalResults));
        message.pageNumber !== undefined && (obj.pageNumber = Math.round(message.pageNumber));
        message.pageSize !== undefined && (obj.pageSize = Math.round(message.pageSize));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppSearchResponse();
        message.apps = object.apps?.map((e) => AppInfo.fromPartial(e)) || [];
        message.totalResults = object.totalResults ?? 0;
        message.pageNumber = object.pageNumber ?? 0;
        message.pageSize = object.pageSize ?? 0;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppSearchResponse", AppSearchResponse);
function createBaseUnpublishAppRequest() {
    return { slug: undefined, shouldDelist: false };
}
export const UnpublishAppRequest = {
    $type: "devvit.dev_portal.app.UnpublishAppRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.slug !== undefined) {
            StringValue.encode({ value: message.slug }, writer.uint32(10).fork()).ldelim();
        }
        if (message.shouldDelist === true) {
            writer.uint32(16).bool(message.shouldDelist);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnpublishAppRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slug = StringValue.decode(reader, reader.uint32()).value;
                    break;
                case 2:
                    message.shouldDelist = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            slug: isSet(object.slug) ? String(object.slug) : undefined,
            shouldDelist: isSet(object.shouldDelist) ? Boolean(object.shouldDelist) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.slug !== undefined && (obj.slug = message.slug);
        message.shouldDelist !== undefined && (obj.shouldDelist = message.shouldDelist);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseUnpublishAppRequest();
        message.slug = object.slug ?? undefined;
        message.shouldDelist = object.shouldDelist ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.UnpublishAppRequest", UnpublishAppRequest);
function createBaseAppExistsRequest() {
    return { slug: undefined };
}
export const AppExistsRequest = {
    $type: "devvit.dev_portal.app.AppExistsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.slug !== undefined) {
            StringValue.encode({ value: message.slug }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppExistsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slug = StringValue.decode(reader, reader.uint32()).value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { slug: isSet(object.slug) ? String(object.slug) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.slug !== undefined && (obj.slug = message.slug);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppExistsRequest();
        message.slug = object.slug ?? undefined;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppExistsRequest", AppExistsRequest);
function createBaseAppExistsResponse() {
    return { exists: false };
}
export const AppExistsResponse = {
    $type: "devvit.dev_portal.app.AppExistsResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.exists === true) {
            writer.uint32(8).bool(message.exists);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppExistsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exists = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { exists: isSet(object.exists) ? Boolean(object.exists) : false };
    },
    toJSON(message) {
        const obj = {};
        message.exists !== undefined && (obj.exists = message.exists);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppExistsResponse();
        message.exists = object.exists ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppExistsResponse", AppExistsResponse);
function createBaseAppAccountExistsRequest() {
    return { accountName: "" };
}
export const AppAccountExistsRequest = {
    $type: "devvit.dev_portal.app.AppAccountExistsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.accountName !== "") {
            writer.uint32(10).string(message.accountName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppAccountExistsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { accountName: isSet(object.accountName) ? String(object.accountName) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.accountName !== undefined && (obj.accountName = message.accountName);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppAccountExistsRequest();
        message.accountName = object.accountName ?? "";
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppAccountExistsRequest", AppAccountExistsRequest);
function createBaseAppAccountExistsResponse() {
    return { exists: false };
}
export const AppAccountExistsResponse = {
    $type: "devvit.dev_portal.app.AppAccountExistsResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.exists === true) {
            writer.uint32(8).bool(message.exists);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppAccountExistsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exists = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { exists: isSet(object.exists) ? Boolean(object.exists) : false };
    },
    toJSON(message) {
        const obj = {};
        message.exists !== undefined && (obj.exists = message.exists);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseAppAccountExistsResponse();
        message.exists = object.exists ?? false;
        return message;
    },
};
messageTypeRegistry.set("devvit.dev_portal.app.AppAccountExistsResponse", AppAccountExistsResponse);
function isSet(value) {
    return value !== null && value !== undefined;
}
